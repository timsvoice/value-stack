(function(e, a) { for(var i in a) e[i] = a[i]; }(exports, /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _schema = __webpack_require__(1);

	var _schema2 = _interopRequireDefault(_schema);

	var _graphql = __webpack_require__(4);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	module.exports.graphql = function (event, context, callback) {

		var body = event.body;
		var query = JSON.parse(body).query;

		return (0, _graphql.graphql)(_schema2.default, query).then(function (response) {

			var data = {
				statusCode: 200,
				headers: {
					"Access-Control-Allow-Origin": "*" // Required for CORS support to work
				},
				body: JSON.stringify(response)
			};

			callback(null, data);
		}).catch(function (error) {
			return callback(error);
		});
	};

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _graphqlTools = __webpack_require__(2);

	var _resolvers = __webpack_require__(88);

	var _resolvers2 = _interopRequireDefault(_resolvers);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var schema = '\n  type Player {\n    playerId: String\n    first_name: String\n    fppg: Int\n    game: String\n    injury_details: String\n    injury_indicator: String\n    last_name: String\n    opponent: String\n    played: Int\n    position: String\n    salary: Int\n    team: String\n  }\n\n  # the schema allows the following query:\n  type RootQuery {\n    players: [Player]\n  }\n\n  # we need to tell the server which types represent the root query\n  # and root mutation types. We call them RootQuery and RootMutation by convention.\n  schema {\n    query: RootQuery\n  }\n';

	var graphqlSchema = (0, _graphqlTools.makeExecutableSchema)({
	  typeDefs: schema,
	  resolvers: _resolvers2.default
	});

	exports.default = graphqlSchema;

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(3));
	__export(__webpack_require__(84));
	__export(__webpack_require__(87));
	//# sourceMappingURL=index.js.map

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	// Generates a schema for graphql-js given a shorthand schema
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	// TODO: document each function clearly in the code: what arguments it accepts
	// and what it outputs.
	// TODO: we should refactor this file, rename it to makeExecutableSchema, and move
	// a bunch of utility functions into a separate utitlities folder, one file per function.
	var graphql_1 = __webpack_require__(4);
	var lodash_1 = __webpack_require__(81);
	var graphql_2 = __webpack_require__(4);
	var graphql_3 = __webpack_require__(4);
	var deprecated_decorator_1 = __webpack_require__(83);
	// @schemaDefinition: A GraphQL type schema in shorthand
	// @resolvers: Definitions for resolvers to be merged with schema
	var SchemaError = (function (_super) {
	    __extends(SchemaError, _super);
	    function SchemaError(message) {
	        _super.call(this, message);
	        this.message = message;
	        Error.captureStackTrace(this, this.constructor);
	    }
	    return SchemaError;
	}(Error));
	exports.SchemaError = SchemaError;
	// type definitions can be a string or an array of strings.
	function _generateSchema(typeDefinitions, resolveFunctions, logger, 
	    // TODO: rename to allowUndefinedInResolve to be consistent
	    allowUndefinedInResolve, resolverValidationOptions) {
	    if (typeof resolverValidationOptions !== 'object') {
	        throw new SchemaError('Expected `resolverValidationOptions` to be an object');
	    }
	    if (!typeDefinitions) {
	        throw new SchemaError('Must provide typeDefs');
	    }
	    if (!resolveFunctions) {
	        throw new SchemaError('Must provide resolvers');
	    }
	    // TODO: check that typeDefinitions is either string or array of strings
	    var schema = buildSchemaFromTypeDefinitions(typeDefinitions);
	    addResolveFunctionsToSchema(schema, resolveFunctions);
	    assertResolveFunctionsPresent(schema, resolverValidationOptions);
	    if (!allowUndefinedInResolve) {
	        addCatchUndefinedToSchema(schema);
	    }
	    if (logger) {
	        addErrorLoggingToSchema(schema, logger);
	    }
	    return schema;
	}
	function makeExecutableSchema(_a) {
	    var typeDefs = _a.typeDefs, _b = _a.resolvers, resolvers = _b === void 0 ? {} : _b, connectors = _a.connectors, logger = _a.logger, _c = _a.allowUndefinedInResolve, allowUndefinedInResolve = _c === void 0 ? true : _c, _d = _a.resolverValidationOptions, resolverValidationOptions = _d === void 0 ? {} : _d;
	    var jsSchema = _generateSchema(typeDefs, resolvers, logger, allowUndefinedInResolve, resolverValidationOptions);
	    if (typeof resolvers['__schema'] === 'function') {
	        // TODO a bit of a hack now, better rewrite generateSchema to attach it there.
	        // not doing that now, because I'd have to rewrite a lot of tests.
	        addSchemaLevelResolveFunction(jsSchema, resolvers['__schema']);
	    }
	    if (connectors) {
	        // connectors are optional, at least for now. That means you can just import them in the resolve
	        // function if you want.
	        attachConnectorsToContext(jsSchema, connectors);
	    }
	    return jsSchema;
	}
	exports.makeExecutableSchema = makeExecutableSchema;
	function concatenateTypeDefs(typeDefinitionsAry, functionsCalled) {
	    if (functionsCalled === void 0) { functionsCalled = {}; }
	    var resolvedTypeDefinitions = [];
	    typeDefinitionsAry.forEach(function (typeDef) {
	        if (typeof typeDef === 'function') {
	            if (!(typeDef in functionsCalled)) {
	                functionsCalled[typeDef] = 1;
	                resolvedTypeDefinitions = resolvedTypeDefinitions.concat(concatenateTypeDefs(typeDef(), functionsCalled));
	            }
	        }
	        else if (typeof typeDef === 'string') {
	            resolvedTypeDefinitions.push(typeDef.trim());
	        }
	        else {
	            var type = typeof typeDef;
	            throw new SchemaError("typeDef array must contain only strings and functions, got " + type);
	        }
	    });
	    return lodash_1.uniq(resolvedTypeDefinitions.map(function (x) { return x.trim(); })).join('\n');
	}
	function buildSchemaFromTypeDefinitions(typeDefinitions) {
	    // TODO: accept only array here, otherwise interfaces get confusing.
	    var myDefinitions = typeDefinitions;
	    if (typeof myDefinitions !== 'string') {
	        if (!Array.isArray(myDefinitions)) {
	            // TODO improve error message and say what type was actually found
	            throw new SchemaError('`typeDefs` must be a string or array');
	        }
	        myDefinitions = concatenateTypeDefs(myDefinitions);
	    }
	    var astDocument = graphql_1.parse(myDefinitions);
	    var schema = graphql_2.buildASTSchema(astDocument);
	    var extensionsAst = extractExtensionDefinitions(astDocument);
	    if (extensionsAst.definitions.length > 0) {
	        schema = graphql_2.extendSchema(schema, extensionsAst);
	    }
	    return schema;
	}
	exports.buildSchemaFromTypeDefinitions = buildSchemaFromTypeDefinitions;
	function extractExtensionDefinitions(ast) {
	    var extensionDefs = ast.definitions.filter(function (def) { return def.kind === graphql_1.Kind.TYPE_EXTENSION_DEFINITION; });
	    return Object.assign({}, ast, {
	        definitions: extensionDefs,
	    });
	}
	function forEachField(schema, fn) {
	    var typeMap = schema.getTypeMap();
	    Object.keys(typeMap).forEach(function (typeName) {
	        var type = typeMap[typeName];
	        // TODO: maybe have an option to include these?
	        if (!graphql_3.getNamedType(type).name.startsWith('__') && type instanceof graphql_3.GraphQLObjectType) {
	            var fields_1 = type.getFields();
	            Object.keys(fields_1).forEach(function (fieldName) {
	                var field = fields_1[fieldName];
	                fn(field, typeName, fieldName);
	            });
	        }
	    });
	}
	exports.forEachField = forEachField;
	// takes a GraphQL-JS schema and an object of connectors, then attaches
	// the connectors to the context by wrapping each query or mutation resolve
	// function with a function that attaches connectors if they don't exist.
	// attaches connectors only once to make sure they are singletons
	var attachConnectorsToContext = deprecated_decorator_1.deprecated({
	    version: '0.7.0',
	    url: 'https://github.com/apollostack/graphql-tools/issues/140',
	}, function attachConnectorsToContext(schema, connectors) {
	    if (!schema || !(schema instanceof graphql_3.GraphQLSchema)) {
	        throw new Error('schema must be an instance of GraphQLSchema. ' +
	            'This error could be caused by installing more than one version of GraphQL-JS');
	    }
	    if (typeof connectors !== 'object') {
	        var connectorType = typeof connectors;
	        throw new Error("Expected connectors to be of type object, got " + connectorType);
	    }
	    if (Object.keys(connectors).length === 0) {
	        throw new Error('Expected connectors to not be an empty object');
	    }
	    if (Array.isArray(connectors)) {
	        throw new Error('Expected connectors to be of type object, got Array');
	    }
	    if (schema['_apolloConnectorsAttached']) {
	        throw new Error('Connectors already attached to context, cannot attach more than once');
	    }
	    schema['_apolloConnectorsAttached'] = true;
	    var attachconnectorFn = function (root, args, ctx) {
	        if (typeof ctx !== 'object') {
	            // if in any way possible, we should throw an error when the attachconnectors
	            // function is called, not when a query is executed.
	            var contextType = typeof ctx;
	            throw new Error("Cannot attach connector because context is not an object: " + contextType);
	        }
	        if (typeof ctx.connectors === 'undefined') {
	            ctx.connectors = {};
	        }
	        Object.keys(connectors).forEach(function (connectorName) {
	            var connector = connectors[connectorName];
	            if (!!connector.prototype) {
	                ctx.connectors[connectorName] = new connector(ctx);
	            }
	            else {
	                throw new Error("Connector must be a function or an class");
	            }
	        });
	        return root;
	    };
	    addSchemaLevelResolveFunction(schema, attachconnectorFn);
	});
	exports.attachConnectorsToContext = attachConnectorsToContext;
	// wraps all resolve functions of query, mutation or subscription fields
	// with the provided function to simulate a root schema level resolve funciton
	function addSchemaLevelResolveFunction(schema, fn) {
	    // TODO test that schema is a schema, fn is a function
	    var rootTypes = ([
	        schema.getQueryType(),
	        schema.getMutationType(),
	        schema.getSubscriptionType(),
	    ]).filter(function (x) { return !!x; });
	    // XXX this should run at most once per request to simulate a true root resolver
	    // for graphql-js this is an approximation that works with queries but not mutations
	    var rootResolveFn = runAtMostOncePerRequest(fn);
	    rootTypes.forEach(function (type) {
	        var fields = type.getFields();
	        Object.keys(fields).forEach(function (fieldName) {
	            fields[fieldName].resolve = wrapResolver(fields[fieldName].resolve, rootResolveFn);
	        });
	    });
	}
	exports.addSchemaLevelResolveFunction = addSchemaLevelResolveFunction;
	function getFieldsForType(type) {
	    if ((type instanceof graphql_3.GraphQLObjectType) ||
	        (type instanceof graphql_3.GraphQLInterfaceType)) {
	        return type.getFields();
	    }
	    else {
	        return undefined;
	    }
	}
	function addResolveFunctionsToSchema(schema, resolveFunctions) {
	    Object.keys(resolveFunctions).forEach(function (typeName) {
	        var type = schema.getType(typeName);
	        if (!type && typeName !== '__schema') {
	            throw new SchemaError("\"" + typeName + "\" defined in resolvers, but not in schema");
	        }
	        Object.keys(resolveFunctions[typeName]).forEach(function (fieldName) {
	            if (fieldName.startsWith('__')) {
	                // this is for isTypeOf and resolveType and all the other stuff.
	                // TODO require resolveType for unions and interfaces.
	                type[fieldName.substring(2)] = resolveFunctions[typeName][fieldName];
	                return;
	            }
	            var fields = getFieldsForType(type);
	            if (!fields) {
	                throw new SchemaError(typeName + " was defined in resolvers, but it's not an object");
	            }
	            if (!fields[fieldName]) {
	                throw new SchemaError(typeName + "." + fieldName + " defined in resolvers, but not in schema");
	            }
	            var field = fields[fieldName];
	            var fieldResolve = resolveFunctions[typeName][fieldName];
	            if (typeof fieldResolve === 'function') {
	                // for convenience. Allows shorter syntax in resolver definition file
	                setFieldProperties(field, { resolve: fieldResolve });
	            }
	            else {
	                if (typeof fieldResolve !== 'object') {
	                    throw new SchemaError("Resolver " + typeName + "." + fieldName + " must be object or function");
	                }
	                setFieldProperties(field, fieldResolve);
	            }
	        });
	    });
	}
	exports.addResolveFunctionsToSchema = addResolveFunctionsToSchema;
	function setFieldProperties(field, propertiesObj) {
	    Object.keys(propertiesObj).forEach(function (propertyName) {
	        field[propertyName] = propertiesObj[propertyName];
	    });
	}
	function assertResolveFunctionsPresent(schema, resolverValidationOptions) {
	    if (resolverValidationOptions === void 0) { resolverValidationOptions = {}; }
	    var _a = resolverValidationOptions.requireResolversForArgs, requireResolversForArgs = _a === void 0 ? false : _a, _b = resolverValidationOptions.requireResolversForNonScalar, requireResolversForNonScalar = _b === void 0 ? false : _b, _c = resolverValidationOptions.requireResolversForAllFields, requireResolversForAllFields = _c === void 0 ? false : _c;
	    if (requireResolversForAllFields && (requireResolversForArgs || requireResolversForNonScalar)) {
	        throw new TypeError('requireResolversForAllFields takes precedence over the more specific assertions. ' +
	            'Please configure either requireResolversForAllFields or requireResolversForArgs / ' +
	            'requireResolversForNonScalar, but not a combination of them.');
	    }
	    forEachField(schema, function (field, typeName, fieldName) {
	        // requires a resolve function for *every* field.
	        if (requireResolversForAllFields) {
	            expectResolveFunction(field, typeName, fieldName);
	        }
	        // requires a resolve function on every field that has arguments
	        if (requireResolversForArgs && field.args.length > 0) {
	            expectResolveFunction(field, typeName, fieldName);
	        }
	        // requires a resolve function on every field that returns a non-scalar type
	        if (requireResolversForNonScalar && !(graphql_3.getNamedType(field.type) instanceof graphql_3.GraphQLScalarType)) {
	            expectResolveFunction(field, typeName, fieldName);
	        }
	    });
	}
	exports.assertResolveFunctionsPresent = assertResolveFunctionsPresent;
	function expectResolveFunction(field, typeName, fieldName) {
	    if (!field.resolve) {
	        // tslint:disable-next-line: max-line-length
	        console.warn("Resolve function missing for \"" + typeName + "." + fieldName + "\". To disable this warning check https://github.com/apollostack/graphql-tools/issues/131");
	        return;
	    }
	    if (typeof field.resolve !== 'function') {
	        throw new SchemaError("Resolver \"" + typeName + "." + fieldName + "\" must be a function");
	    }
	}
	function addErrorLoggingToSchema(schema, logger) {
	    if (!logger) {
	        throw new Error('Must provide a logger');
	    }
	    if (typeof logger.log !== 'function') {
	        throw new Error('Logger.log must be a function');
	    }
	    forEachField(schema, function (field, typeName, fieldName) {
	        var errorHint = typeName + "." + fieldName;
	        field.resolve = decorateWithLogger(field.resolve, logger, errorHint);
	    });
	}
	exports.addErrorLoggingToSchema = addErrorLoggingToSchema;
	// XXX badly named function. this doesn't really wrap, it just chains resolvers...
	function wrapResolver(innerResolver, outerResolver) {
	    return function (obj, args, ctx, info) {
	        var root = outerResolver(obj, args, ctx, info);
	        if (innerResolver) {
	            return innerResolver(root, args, ctx, info);
	        }
	        return defaultResolveFn(root, args, ctx, info);
	    };
	}
	function chainResolvers(resolvers) {
	    return function (root, args, ctx, info) {
	        return resolvers.reduce(function (prev, curResolver) {
	            if (curResolver) {
	                return curResolver(prev, args, ctx, info);
	            }
	            return defaultResolveFn(prev, args, ctx, info);
	        }, root);
	    };
	}
	exports.chainResolvers = chainResolvers;
	/*
	 * fn: The function to decorate with the logger
	 * logger: an object instance of type Logger
	 * hint: an optional hint to add to the error's message
	 */
	function decorateWithLogger(fn, logger, hint) {
	    if (typeof fn === 'undefined') {
	        fn = defaultResolveFn;
	    }
	    return function (root, args, ctx, info) {
	        try {
	            return fn(root, args, ctx, info);
	        }
	        catch (e) {
	            // TODO: clone the error properly
	            var newE = new Error();
	            newE.stack = e.stack;
	            /* istanbul ignore else: always get the hint from addErrorLoggingToSchema */
	            if (hint) {
	                newE['originalMessage'] = e.message;
	                newE['message'] = "Error in resolver " + hint + "\n" + e.message;
	            }
	            logger.log(newE);
	            // we want to pass on the error, just in case.
	            throw e;
	        }
	    };
	}
	function addCatchUndefinedToSchema(schema) {
	    forEachField(schema, function (field, typeName, fieldName) {
	        var errorHint = typeName + "." + fieldName;
	        field.resolve = decorateToCatchUndefined(field.resolve, errorHint);
	    });
	}
	exports.addCatchUndefinedToSchema = addCatchUndefinedToSchema;
	function decorateToCatchUndefined(fn, hint) {
	    if (typeof fn === 'undefined') {
	        fn = defaultResolveFn;
	    }
	    return function (root, args, ctx, info) {
	        var result = fn(root, args, ctx, info);
	        if (typeof result === 'undefined') {
	            throw new Error("Resolve function for \"" + hint + "\" returned undefined");
	        }
	        return result;
	    };
	}
	// XXX this function only works for resolvers
	// XXX very hacky way to remember if the function
	// already ran for this request. This will only work
	// if people don't actually cache the operation.
	// if they do cache the operation, they will have to
	// manually remove the __runAtMostOnce before every request.
	function runAtMostOncePerRequest(fn) {
	    var value;
	    var randomNumber = Math.random();
	    return function (root, args, ctx, info) {
	        if (!info.operation['__runAtMostOnce']) {
	            info.operation['__runAtMostOnce'] = {};
	        }
	        if (!info.operation['__runAtMostOnce'][randomNumber]) {
	            info.operation['__runAtMostOnce'][randomNumber] = true;
	            value = fn(root, args, ctx, info);
	        }
	        return value;
	    };
	}
	/**
	 * XXX taken from graphql-js: src/execution/execute.js, because that function
	 * is not exported
	 *
	 * If a resolve function is not given, then a default resolve behavior is used
	 * which takes the property of the source object of the same name as the field
	 * and returns it as the result, or if it's a function, returns the result
	 * of calling that function.
	 */
	function defaultResolveFn(source, args, context, _a) {
	    var fieldName = _a.fieldName;
	    // ensure source is a value for which property access is acceptable.
	    if (typeof source === 'object' || typeof source === 'function') {
	        var property = source[fieldName];
	        if (typeof property === 'function') {
	            return source[fieldName](args, context);
	        }
	        return property;
	    }
	}
	//# sourceMappingURL=schemaGenerator.js.map

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _graphql = __webpack_require__(5);

	Object.defineProperty(exports, 'graphql', {
	  enumerable: true,
	  get: function get() {
	    return _graphql.graphql;
	  }
	});

	var _type = __webpack_require__(67);

	Object.defineProperty(exports, 'GraphQLSchema', {
	  enumerable: true,
	  get: function get() {
	    return _type.GraphQLSchema;
	  }
	});
	Object.defineProperty(exports, 'GraphQLScalarType', {
	  enumerable: true,
	  get: function get() {
	    return _type.GraphQLScalarType;
	  }
	});
	Object.defineProperty(exports, 'GraphQLObjectType', {
	  enumerable: true,
	  get: function get() {
	    return _type.GraphQLObjectType;
	  }
	});
	Object.defineProperty(exports, 'GraphQLInterfaceType', {
	  enumerable: true,
	  get: function get() {
	    return _type.GraphQLInterfaceType;
	  }
	});
	Object.defineProperty(exports, 'GraphQLUnionType', {
	  enumerable: true,
	  get: function get() {
	    return _type.GraphQLUnionType;
	  }
	});
	Object.defineProperty(exports, 'GraphQLEnumType', {
	  enumerable: true,
	  get: function get() {
	    return _type.GraphQLEnumType;
	  }
	});
	Object.defineProperty(exports, 'GraphQLInputObjectType', {
	  enumerable: true,
	  get: function get() {
	    return _type.GraphQLInputObjectType;
	  }
	});
	Object.defineProperty(exports, 'GraphQLList', {
	  enumerable: true,
	  get: function get() {
	    return _type.GraphQLList;
	  }
	});
	Object.defineProperty(exports, 'GraphQLNonNull', {
	  enumerable: true,
	  get: function get() {
	    return _type.GraphQLNonNull;
	  }
	});
	Object.defineProperty(exports, 'GraphQLDirective', {
	  enumerable: true,
	  get: function get() {
	    return _type.GraphQLDirective;
	  }
	});
	Object.defineProperty(exports, 'TypeKind', {
	  enumerable: true,
	  get: function get() {
	    return _type.TypeKind;
	  }
	});
	Object.defineProperty(exports, 'DirectiveLocation', {
	  enumerable: true,
	  get: function get() {
	    return _type.DirectiveLocation;
	  }
	});
	Object.defineProperty(exports, 'GraphQLInt', {
	  enumerable: true,
	  get: function get() {
	    return _type.GraphQLInt;
	  }
	});
	Object.defineProperty(exports, 'GraphQLFloat', {
	  enumerable: true,
	  get: function get() {
	    return _type.GraphQLFloat;
	  }
	});
	Object.defineProperty(exports, 'GraphQLString', {
	  enumerable: true,
	  get: function get() {
	    return _type.GraphQLString;
	  }
	});
	Object.defineProperty(exports, 'GraphQLBoolean', {
	  enumerable: true,
	  get: function get() {
	    return _type.GraphQLBoolean;
	  }
	});
	Object.defineProperty(exports, 'GraphQLID', {
	  enumerable: true,
	  get: function get() {
	    return _type.GraphQLID;
	  }
	});
	Object.defineProperty(exports, 'specifiedDirectives', {
	  enumerable: true,
	  get: function get() {
	    return _type.specifiedDirectives;
	  }
	});
	Object.defineProperty(exports, 'GraphQLIncludeDirective', {
	  enumerable: true,
	  get: function get() {
	    return _type.GraphQLIncludeDirective;
	  }
	});
	Object.defineProperty(exports, 'GraphQLSkipDirective', {
	  enumerable: true,
	  get: function get() {
	    return _type.GraphQLSkipDirective;
	  }
	});
	Object.defineProperty(exports, 'GraphQLDeprecatedDirective', {
	  enumerable: true,
	  get: function get() {
	    return _type.GraphQLDeprecatedDirective;
	  }
	});
	Object.defineProperty(exports, 'DEFAULT_DEPRECATION_REASON', {
	  enumerable: true,
	  get: function get() {
	    return _type.DEFAULT_DEPRECATION_REASON;
	  }
	});
	Object.defineProperty(exports, 'SchemaMetaFieldDef', {
	  enumerable: true,
	  get: function get() {
	    return _type.SchemaMetaFieldDef;
	  }
	});
	Object.defineProperty(exports, 'TypeMetaFieldDef', {
	  enumerable: true,
	  get: function get() {
	    return _type.TypeMetaFieldDef;
	  }
	});
	Object.defineProperty(exports, 'TypeNameMetaFieldDef', {
	  enumerable: true,
	  get: function get() {
	    return _type.TypeNameMetaFieldDef;
	  }
	});
	Object.defineProperty(exports, '__Schema', {
	  enumerable: true,
	  get: function get() {
	    return _type.__Schema;
	  }
	});
	Object.defineProperty(exports, '__Directive', {
	  enumerable: true,
	  get: function get() {
	    return _type.__Directive;
	  }
	});
	Object.defineProperty(exports, '__DirectiveLocation', {
	  enumerable: true,
	  get: function get() {
	    return _type.__DirectiveLocation;
	  }
	});
	Object.defineProperty(exports, '__Type', {
	  enumerable: true,
	  get: function get() {
	    return _type.__Type;
	  }
	});
	Object.defineProperty(exports, '__Field', {
	  enumerable: true,
	  get: function get() {
	    return _type.__Field;
	  }
	});
	Object.defineProperty(exports, '__InputValue', {
	  enumerable: true,
	  get: function get() {
	    return _type.__InputValue;
	  }
	});
	Object.defineProperty(exports, '__EnumValue', {
	  enumerable: true,
	  get: function get() {
	    return _type.__EnumValue;
	  }
	});
	Object.defineProperty(exports, '__TypeKind', {
	  enumerable: true,
	  get: function get() {
	    return _type.__TypeKind;
	  }
	});
	Object.defineProperty(exports, 'isType', {
	  enumerable: true,
	  get: function get() {
	    return _type.isType;
	  }
	});
	Object.defineProperty(exports, 'isInputType', {
	  enumerable: true,
	  get: function get() {
	    return _type.isInputType;
	  }
	});
	Object.defineProperty(exports, 'isOutputType', {
	  enumerable: true,
	  get: function get() {
	    return _type.isOutputType;
	  }
	});
	Object.defineProperty(exports, 'isLeafType', {
	  enumerable: true,
	  get: function get() {
	    return _type.isLeafType;
	  }
	});
	Object.defineProperty(exports, 'isCompositeType', {
	  enumerable: true,
	  get: function get() {
	    return _type.isCompositeType;
	  }
	});
	Object.defineProperty(exports, 'isAbstractType', {
	  enumerable: true,
	  get: function get() {
	    return _type.isAbstractType;
	  }
	});
	Object.defineProperty(exports, 'getNullableType', {
	  enumerable: true,
	  get: function get() {
	    return _type.getNullableType;
	  }
	});
	Object.defineProperty(exports, 'getNamedType', {
	  enumerable: true,
	  get: function get() {
	    return _type.getNamedType;
	  }
	});

	var _language = __webpack_require__(10);

	Object.defineProperty(exports, 'Source', {
	  enumerable: true,
	  get: function get() {
	    return _language.Source;
	  }
	});
	Object.defineProperty(exports, 'getLocation', {
	  enumerable: true,
	  get: function get() {
	    return _language.getLocation;
	  }
	});
	Object.defineProperty(exports, 'parse', {
	  enumerable: true,
	  get: function get() {
	    return _language.parse;
	  }
	});
	Object.defineProperty(exports, 'parseValue', {
	  enumerable: true,
	  get: function get() {
	    return _language.parseValue;
	  }
	});
	Object.defineProperty(exports, 'parseType', {
	  enumerable: true,
	  get: function get() {
	    return _language.parseType;
	  }
	});
	Object.defineProperty(exports, 'print', {
	  enumerable: true,
	  get: function get() {
	    return _language.print;
	  }
	});
	Object.defineProperty(exports, 'visit', {
	  enumerable: true,
	  get: function get() {
	    return _language.visit;
	  }
	});
	Object.defineProperty(exports, 'visitInParallel', {
	  enumerable: true,
	  get: function get() {
	    return _language.visitInParallel;
	  }
	});
	Object.defineProperty(exports, 'visitWithTypeInfo', {
	  enumerable: true,
	  get: function get() {
	    return _language.visitWithTypeInfo;
	  }
	});
	Object.defineProperty(exports, 'Kind', {
	  enumerable: true,
	  get: function get() {
	    return _language.Kind;
	  }
	});
	Object.defineProperty(exports, 'TokenKind', {
	  enumerable: true,
	  get: function get() {
	    return _language.TokenKind;
	  }
	});
	Object.defineProperty(exports, 'BREAK', {
	  enumerable: true,
	  get: function get() {
	    return _language.BREAK;
	  }
	});

	var _execution = __webpack_require__(68);

	Object.defineProperty(exports, 'execute', {
	  enumerable: true,
	  get: function get() {
	    return _execution.execute;
	  }
	});

	var _validation = __webpack_require__(69);

	Object.defineProperty(exports, 'validate', {
	  enumerable: true,
	  get: function get() {
	    return _validation.validate;
	  }
	});
	Object.defineProperty(exports, 'specifiedRules', {
	  enumerable: true,
	  get: function get() {
	    return _validation.specifiedRules;
	  }
	});

	var _error = __webpack_require__(8);

	Object.defineProperty(exports, 'GraphQLError', {
	  enumerable: true,
	  get: function get() {
	    return _error.GraphQLError;
	  }
	});
	Object.defineProperty(exports, 'formatError', {
	  enumerable: true,
	  get: function get() {
	    return _error.formatError;
	  }
	});

	var _utilities = __webpack_require__(70);

	Object.defineProperty(exports, 'introspectionQuery', {
	  enumerable: true,
	  get: function get() {
	    return _utilities.introspectionQuery;
	  }
	});
	Object.defineProperty(exports, 'getOperationAST', {
	  enumerable: true,
	  get: function get() {
	    return _utilities.getOperationAST;
	  }
	});
	Object.defineProperty(exports, 'buildClientSchema', {
	  enumerable: true,
	  get: function get() {
	    return _utilities.buildClientSchema;
	  }
	});
	Object.defineProperty(exports, 'buildASTSchema', {
	  enumerable: true,
	  get: function get() {
	    return _utilities.buildASTSchema;
	  }
	});
	Object.defineProperty(exports, 'buildSchema', {
	  enumerable: true,
	  get: function get() {
	    return _utilities.buildSchema;
	  }
	});
	Object.defineProperty(exports, 'extendSchema', {
	  enumerable: true,
	  get: function get() {
	    return _utilities.extendSchema;
	  }
	});
	Object.defineProperty(exports, 'printSchema', {
	  enumerable: true,
	  get: function get() {
	    return _utilities.printSchema;
	  }
	});
	Object.defineProperty(exports, 'typeFromAST', {
	  enumerable: true,
	  get: function get() {
	    return _utilities.typeFromAST;
	  }
	});
	Object.defineProperty(exports, 'valueFromAST', {
	  enumerable: true,
	  get: function get() {
	    return _utilities.valueFromAST;
	  }
	});
	Object.defineProperty(exports, 'astFromValue', {
	  enumerable: true,
	  get: function get() {
	    return _utilities.astFromValue;
	  }
	});
	Object.defineProperty(exports, 'TypeInfo', {
	  enumerable: true,
	  get: function get() {
	    return _utilities.TypeInfo;
	  }
	});
	Object.defineProperty(exports, 'isValidJSValue', {
	  enumerable: true,
	  get: function get() {
	    return _utilities.isValidJSValue;
	  }
	});
	Object.defineProperty(exports, 'isValidLiteralValue', {
	  enumerable: true,
	  get: function get() {
	    return _utilities.isValidLiteralValue;
	  }
	});
	Object.defineProperty(exports, 'concatAST', {
	  enumerable: true,
	  get: function get() {
	    return _utilities.concatAST;
	  }
	});
	Object.defineProperty(exports, 'separateOperations', {
	  enumerable: true,
	  get: function get() {
	    return _utilities.separateOperations;
	  }
	});
	Object.defineProperty(exports, 'isEqualType', {
	  enumerable: true,
	  get: function get() {
	    return _utilities.isEqualType;
	  }
	});
	Object.defineProperty(exports, 'isTypeSubTypeOf', {
	  enumerable: true,
	  get: function get() {
	    return _utilities.isTypeSubTypeOf;
	  }
	});
	Object.defineProperty(exports, 'doTypesOverlap', {
	  enumerable: true,
	  get: function get() {
	    return _utilities.doTypesOverlap;
	  }
	});
	Object.defineProperty(exports, 'assertValidName', {
	  enumerable: true,
	  get: function get() {
	    return _utilities.assertValidName;
	  }
	});
	Object.defineProperty(exports, 'findBreakingChanges', {
	  enumerable: true,
	  get: function get() {
	    return _utilities.findBreakingChanges;
	  }
	});

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.graphql = graphql;

	var _source = __webpack_require__(6);

	var _parser = __webpack_require__(7);

	var _validate = __webpack_require__(20);

	var _execute = __webpack_require__(63);

	/**
	 * This is the primary entry point function for fulfilling GraphQL operations
	 * by parsing, validating, and executing a GraphQL document along side a
	 * GraphQL schema.
	 *
	 * More sophisticated GraphQL servers, such as those which persist queries,
	 * may wish to separate the validation and execution phases to a static time
	 * tooling step, and a server runtime step.
	 *
	 * schema:
	 *    The GraphQL type system to use when validating and executing a query.
	 * requestString:
	 *    A GraphQL language formatted string representing the requested operation.
	 * rootValue:
	 *    The value provided as the first argument to resolver functions on the top
	 *    level type (e.g. the query object type).
	 * variableValues:
	 *    A mapping of variable name to runtime value to use for all variables
	 *    defined in the requestString.
	 * operationName:
	 *    The name of the operation to use if requestString contains multiple
	 *    possible operations. Can be omitted if requestString contains only
	 *    one operation.
	 */

	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	function graphql(schema, requestString, rootValue, contextValue, variableValues, operationName) {
	  return new Promise(function (resolve) {
	    var source = new _source.Source(requestString || '', 'GraphQL request');
	    var documentAST = (0, _parser.parse)(source);
	    var validationErrors = (0, _validate.validate)(schema, documentAST);
	    if (validationErrors.length > 0) {
	      resolve({ errors: validationErrors });
	    } else {
	      resolve((0, _execute.execute)(schema, documentAST, rootValue, contextValue, variableValues, operationName));
	    }
	  }).then(undefined, function (error) {
	    return { errors: [error] };
	  });
	}

	/**
	 * The result of a GraphQL parse, validation and execution.
	 *
	 * `data` is the result of a successful execution of the query.
	 * `errors` is included when any errors occurred as a non-empty array.
	 */

/***/ },
/* 6 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	/**
	 * A representation of source input to GraphQL. The name is optional,
	 * but is mostly useful for clients who store GraphQL documents in
	 * source files; for example, if the GraphQL input is in a file Foo.graphql,
	 * it might be useful for name to be "Foo.graphql".
	 */
	var Source = exports.Source = function Source(body, name) {
	  _classCallCheck(this, Source);

	  this.body = body;
	  this.name = name || 'GraphQL';
	};

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.parse = parse;
	exports.parseValue = parseValue;
	exports.parseType = parseType;
	exports.parseConstValue = parseConstValue;
	exports.parseTypeReference = parseTypeReference;
	exports.parseNamedType = parseNamedType;

	var _source = __webpack_require__(6);

	var _error = __webpack_require__(8);

	var _lexer = __webpack_require__(12);

	var _kinds = __webpack_require__(15);

	/**
	 * Given a GraphQL source, parses it into a Document.
	 * Throws GraphQLError if a syntax error is encountered.
	 */


	/**
	 * Configuration options to control parser behavior
	 */

	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	function parse(source, options) {
	  var sourceObj = typeof source === 'string' ? new _source.Source(source) : source;
	  var lexer = (0, _lexer.createLexer)(sourceObj, options || {});
	  return parseDocument(lexer);
	}

	/**
	 * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for
	 * that value.
	 * Throws GraphQLError if a syntax error is encountered.
	 *
	 * This is useful within tools that operate upon GraphQL Values directly and
	 * in isolation of complete GraphQL documents.
	 *
	 * Consider providing the results to the utility function: valueFromAST().
	 */
	function parseValue(source, options) {
	  var sourceObj = typeof source === 'string' ? new _source.Source(source) : source;
	  var lexer = (0, _lexer.createLexer)(sourceObj, options || {});
	  expect(lexer, _lexer.TokenKind.SOF);
	  var value = parseValueLiteral(lexer, false);
	  expect(lexer, _lexer.TokenKind.EOF);
	  return value;
	}

	/**
	 * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for
	 * that type.
	 * Throws GraphQLError if a syntax error is encountered.
	 *
	 * This is useful within tools that operate upon GraphQL Types directly and
	 * in isolation of complete GraphQL documents.
	 *
	 * Consider providing the results to the utility function: typeFromAST().
	 */
	function parseType(source, options) {
	  var sourceObj = typeof source === 'string' ? new _source.Source(source) : source;
	  var lexer = (0, _lexer.createLexer)(sourceObj, options || {});
	  expect(lexer, _lexer.TokenKind.SOF);
	  var type = parseTypeReference(lexer);
	  expect(lexer, _lexer.TokenKind.EOF);
	  return type;
	}

	/**
	 * Converts a name lex token into a name parse node.
	 */
	function parseName(lexer) {
	  var token = expect(lexer, _lexer.TokenKind.NAME);
	  return {
	    kind: _kinds.NAME,
	    value: token.value,
	    loc: loc(lexer, token)
	  };
	}

	// Implements the parsing rules in the Document section.

	/**
	 * Document : Definition+
	 */
	function parseDocument(lexer) {
	  var start = lexer.token;
	  expect(lexer, _lexer.TokenKind.SOF);
	  var definitions = [];
	  do {
	    definitions.push(parseDefinition(lexer));
	  } while (!skip(lexer, _lexer.TokenKind.EOF));

	  return {
	    kind: _kinds.DOCUMENT,
	    definitions: definitions,
	    loc: loc(lexer, start)
	  };
	}

	/**
	 * Definition :
	 *   - OperationDefinition
	 *   - FragmentDefinition
	 *   - TypeSystemDefinition
	 */
	function parseDefinition(lexer) {
	  if (peek(lexer, _lexer.TokenKind.BRACE_L)) {
	    return parseOperationDefinition(lexer);
	  }

	  if (peek(lexer, _lexer.TokenKind.NAME)) {
	    switch (lexer.token.value) {
	      // Note: subscription is an experimental non-spec addition.
	      case 'query':
	      case 'mutation':
	      case 'subscription':
	        return parseOperationDefinition(lexer);

	      case 'fragment':
	        return parseFragmentDefinition(lexer);

	      // Note: the Type System IDL is an experimental non-spec addition.
	      case 'schema':
	      case 'scalar':
	      case 'type':
	      case 'interface':
	      case 'union':
	      case 'enum':
	      case 'input':
	      case 'extend':
	      case 'directive':
	        return parseTypeSystemDefinition(lexer);
	    }
	  }

	  throw unexpected(lexer);
	}

	// Implements the parsing rules in the Operations section.

	/**
	 * OperationDefinition :
	 *  - SelectionSet
	 *  - OperationType Name? VariableDefinitions? Directives? SelectionSet
	 */
	function parseOperationDefinition(lexer) {
	  var start = lexer.token;
	  if (peek(lexer, _lexer.TokenKind.BRACE_L)) {
	    return {
	      kind: _kinds.OPERATION_DEFINITION,
	      operation: 'query',
	      name: null,
	      variableDefinitions: null,
	      directives: [],
	      selectionSet: parseSelectionSet(lexer),
	      loc: loc(lexer, start)
	    };
	  }
	  var operation = parseOperationType(lexer);
	  var name = void 0;
	  if (peek(lexer, _lexer.TokenKind.NAME)) {
	    name = parseName(lexer);
	  }
	  return {
	    kind: _kinds.OPERATION_DEFINITION,
	    operation: operation,
	    name: name,
	    variableDefinitions: parseVariableDefinitions(lexer),
	    directives: parseDirectives(lexer),
	    selectionSet: parseSelectionSet(lexer),
	    loc: loc(lexer, start)
	  };
	}

	/**
	 * OperationType : one of query mutation subscription
	 */
	function parseOperationType(lexer) {
	  var operationToken = expect(lexer, _lexer.TokenKind.NAME);
	  switch (operationToken.value) {
	    case 'query':
	      return 'query';
	    case 'mutation':
	      return 'mutation';
	    // Note: subscription is an experimental non-spec addition.
	    case 'subscription':
	      return 'subscription';
	  }

	  throw unexpected(lexer, operationToken);
	}

	/**
	 * VariableDefinitions : ( VariableDefinition+ )
	 */
	function parseVariableDefinitions(lexer) {
	  return peek(lexer, _lexer.TokenKind.PAREN_L) ? many(lexer, _lexer.TokenKind.PAREN_L, parseVariableDefinition, _lexer.TokenKind.PAREN_R) : [];
	}

	/**
	 * VariableDefinition : Variable : Type DefaultValue?
	 */
	function parseVariableDefinition(lexer) {
	  var start = lexer.token;
	  return {
	    kind: _kinds.VARIABLE_DEFINITION,
	    variable: parseVariable(lexer),
	    type: (expect(lexer, _lexer.TokenKind.COLON), parseTypeReference(lexer)),
	    defaultValue: skip(lexer, _lexer.TokenKind.EQUALS) ? parseValueLiteral(lexer, true) : null,
	    loc: loc(lexer, start)
	  };
	}

	/**
	 * Variable : $ Name
	 */
	function parseVariable(lexer) {
	  var start = lexer.token;
	  expect(lexer, _lexer.TokenKind.DOLLAR);
	  return {
	    kind: _kinds.VARIABLE,
	    name: parseName(lexer),
	    loc: loc(lexer, start)
	  };
	}

	/**
	 * SelectionSet : { Selection+ }
	 */
	function parseSelectionSet(lexer) {
	  var start = lexer.token;
	  return {
	    kind: _kinds.SELECTION_SET,
	    selections: many(lexer, _lexer.TokenKind.BRACE_L, parseSelection, _lexer.TokenKind.BRACE_R),
	    loc: loc(lexer, start)
	  };
	}

	/**
	 * Selection :
	 *   - Field
	 *   - FragmentSpread
	 *   - InlineFragment
	 */
	function parseSelection(lexer) {
	  return peek(lexer, _lexer.TokenKind.SPREAD) ? parseFragment(lexer) : parseField(lexer);
	}

	/**
	 * Field : Alias? Name Arguments? Directives? SelectionSet?
	 *
	 * Alias : Name :
	 */
	function parseField(lexer) {
	  var start = lexer.token;

	  var nameOrAlias = parseName(lexer);
	  var alias = void 0;
	  var name = void 0;
	  if (skip(lexer, _lexer.TokenKind.COLON)) {
	    alias = nameOrAlias;
	    name = parseName(lexer);
	  } else {
	    alias = null;
	    name = nameOrAlias;
	  }

	  return {
	    kind: _kinds.FIELD,
	    alias: alias,
	    name: name,
	    arguments: parseArguments(lexer),
	    directives: parseDirectives(lexer),
	    selectionSet: peek(lexer, _lexer.TokenKind.BRACE_L) ? parseSelectionSet(lexer) : null,
	    loc: loc(lexer, start)
	  };
	}

	/**
	 * Arguments : ( Argument+ )
	 */
	function parseArguments(lexer) {
	  return peek(lexer, _lexer.TokenKind.PAREN_L) ? many(lexer, _lexer.TokenKind.PAREN_L, parseArgument, _lexer.TokenKind.PAREN_R) : [];
	}

	/**
	 * Argument : Name : Value
	 */
	function parseArgument(lexer) {
	  var start = lexer.token;
	  return {
	    kind: _kinds.ARGUMENT,
	    name: parseName(lexer),
	    value: (expect(lexer, _lexer.TokenKind.COLON), parseValueLiteral(lexer, false)),
	    loc: loc(lexer, start)
	  };
	}

	// Implements the parsing rules in the Fragments section.

	/**
	 * Corresponds to both FragmentSpread and InlineFragment in the spec.
	 *
	 * FragmentSpread : ... FragmentName Directives?
	 *
	 * InlineFragment : ... TypeCondition? Directives? SelectionSet
	 */
	function parseFragment(lexer) {
	  var start = lexer.token;
	  expect(lexer, _lexer.TokenKind.SPREAD);
	  if (peek(lexer, _lexer.TokenKind.NAME) && lexer.token.value !== 'on') {
	    return {
	      kind: _kinds.FRAGMENT_SPREAD,
	      name: parseFragmentName(lexer),
	      directives: parseDirectives(lexer),
	      loc: loc(lexer, start)
	    };
	  }
	  var typeCondition = null;
	  if (lexer.token.value === 'on') {
	    lexer.advance();
	    typeCondition = parseNamedType(lexer);
	  }
	  return {
	    kind: _kinds.INLINE_FRAGMENT,
	    typeCondition: typeCondition,
	    directives: parseDirectives(lexer),
	    selectionSet: parseSelectionSet(lexer),
	    loc: loc(lexer, start)
	  };
	}

	/**
	 * FragmentDefinition :
	 *   - fragment FragmentName on TypeCondition Directives? SelectionSet
	 *
	 * TypeCondition : NamedType
	 */
	function parseFragmentDefinition(lexer) {
	  var start = lexer.token;
	  expectKeyword(lexer, 'fragment');
	  return {
	    kind: _kinds.FRAGMENT_DEFINITION,
	    name: parseFragmentName(lexer),
	    typeCondition: (expectKeyword(lexer, 'on'), parseNamedType(lexer)),
	    directives: parseDirectives(lexer),
	    selectionSet: parseSelectionSet(lexer),
	    loc: loc(lexer, start)
	  };
	}

	/**
	 * FragmentName : Name but not `on`
	 */
	function parseFragmentName(lexer) {
	  if (lexer.token.value === 'on') {
	    throw unexpected(lexer);
	  }
	  return parseName(lexer);
	}

	// Implements the parsing rules in the Values section.

	/**
	 * Value[Const] :
	 *   - [~Const] Variable
	 *   - IntValue
	 *   - FloatValue
	 *   - StringValue
	 *   - BooleanValue
	 *   - EnumValue
	 *   - ListValue[?Const]
	 *   - ObjectValue[?Const]
	 *
	 * BooleanValue : one of `true` `false`
	 *
	 * EnumValue : Name but not `true`, `false` or `null`
	 */
	function parseValueLiteral(lexer, isConst) {
	  var token = lexer.token;
	  switch (token.kind) {
	    case _lexer.TokenKind.BRACKET_L:
	      return parseList(lexer, isConst);
	    case _lexer.TokenKind.BRACE_L:
	      return parseObject(lexer, isConst);
	    case _lexer.TokenKind.INT:
	      lexer.advance();
	      return {
	        kind: _kinds.INT,
	        value: token.value,
	        loc: loc(lexer, token)
	      };
	    case _lexer.TokenKind.FLOAT:
	      lexer.advance();
	      return {
	        kind: _kinds.FLOAT,
	        value: token.value,
	        loc: loc(lexer, token)
	      };
	    case _lexer.TokenKind.STRING:
	      lexer.advance();
	      return {
	        kind: _kinds.STRING,
	        value: token.value,
	        loc: loc(lexer, token)
	      };
	    case _lexer.TokenKind.NAME:
	      if (token.value === 'true' || token.value === 'false') {
	        lexer.advance();
	        return {
	          kind: _kinds.BOOLEAN,
	          value: token.value === 'true',
	          loc: loc(lexer, token)
	        };
	      } else if (token.value !== 'null') {
	        lexer.advance();
	        return {
	          kind: _kinds.ENUM,
	          value: token.value,
	          loc: loc(lexer, token)
	        };
	      }
	      break;
	    case _lexer.TokenKind.DOLLAR:
	      if (!isConst) {
	        return parseVariable(lexer);
	      }
	      break;
	  }
	  throw unexpected(lexer);
	}

	function parseConstValue(lexer) {
	  return parseValueLiteral(lexer, true);
	}

	function parseValueValue(lexer) {
	  return parseValueLiteral(lexer, false);
	}

	/**
	 * ListValue[Const] :
	 *   - [ ]
	 *   - [ Value[?Const]+ ]
	 */
	function parseList(lexer, isConst) {
	  var start = lexer.token;
	  var item = isConst ? parseConstValue : parseValueValue;
	  return {
	    kind: _kinds.LIST,
	    values: any(lexer, _lexer.TokenKind.BRACKET_L, item, _lexer.TokenKind.BRACKET_R),
	    loc: loc(lexer, start)
	  };
	}

	/**
	 * ObjectValue[Const] :
	 *   - { }
	 *   - { ObjectField[?Const]+ }
	 */
	function parseObject(lexer, isConst) {
	  var start = lexer.token;
	  expect(lexer, _lexer.TokenKind.BRACE_L);
	  var fields = [];
	  while (!skip(lexer, _lexer.TokenKind.BRACE_R)) {
	    fields.push(parseObjectField(lexer, isConst));
	  }
	  return {
	    kind: _kinds.OBJECT,
	    fields: fields,
	    loc: loc(lexer, start)
	  };
	}

	/**
	 * ObjectField[Const] : Name : Value[?Const]
	 */
	function parseObjectField(lexer, isConst) {
	  var start = lexer.token;
	  return {
	    kind: _kinds.OBJECT_FIELD,
	    name: parseName(lexer),
	    value: (expect(lexer, _lexer.TokenKind.COLON), parseValueLiteral(lexer, isConst)),
	    loc: loc(lexer, start)
	  };
	}

	// Implements the parsing rules in the Directives section.

	/**
	 * Directives : Directive+
	 */
	function parseDirectives(lexer) {
	  var directives = [];
	  while (peek(lexer, _lexer.TokenKind.AT)) {
	    directives.push(parseDirective(lexer));
	  }
	  return directives;
	}

	/**
	 * Directive : @ Name Arguments?
	 */
	function parseDirective(lexer) {
	  var start = lexer.token;
	  expect(lexer, _lexer.TokenKind.AT);
	  return {
	    kind: _kinds.DIRECTIVE,
	    name: parseName(lexer),
	    arguments: parseArguments(lexer),
	    loc: loc(lexer, start)
	  };
	}

	// Implements the parsing rules in the Types section.

	/**
	 * Type :
	 *   - NamedType
	 *   - ListType
	 *   - NonNullType
	 */
	function parseTypeReference(lexer) {
	  var start = lexer.token;
	  var type = void 0;
	  if (skip(lexer, _lexer.TokenKind.BRACKET_L)) {
	    type = parseTypeReference(lexer);
	    expect(lexer, _lexer.TokenKind.BRACKET_R);
	    type = {
	      kind: _kinds.LIST_TYPE,
	      type: type,
	      loc: loc(lexer, start)
	    };
	  } else {
	    type = parseNamedType(lexer);
	  }
	  if (skip(lexer, _lexer.TokenKind.BANG)) {
	    return {
	      kind: _kinds.NON_NULL_TYPE,
	      type: type,
	      loc: loc(lexer, start)
	    };
	  }
	  return type;
	}

	/**
	 * NamedType : Name
	 */
	function parseNamedType(lexer) {
	  var start = lexer.token;
	  return {
	    kind: _kinds.NAMED_TYPE,
	    name: parseName(lexer),
	    loc: loc(lexer, start)
	  };
	}

	// Implements the parsing rules in the Type Definition section.

	/**
	 * TypeSystemDefinition :
	 *   - SchemaDefinition
	 *   - TypeDefinition
	 *   - TypeExtensionDefinition
	 *   - DirectiveDefinition
	 *
	 * TypeDefinition :
	 *   - ScalarTypeDefinition
	 *   - ObjectTypeDefinition
	 *   - InterfaceTypeDefinition
	 *   - UnionTypeDefinition
	 *   - EnumTypeDefinition
	 *   - InputObjectTypeDefinition
	 */
	function parseTypeSystemDefinition(lexer) {
	  if (peek(lexer, _lexer.TokenKind.NAME)) {
	    switch (lexer.token.value) {
	      case 'schema':
	        return parseSchemaDefinition(lexer);
	      case 'scalar':
	        return parseScalarTypeDefinition(lexer);
	      case 'type':
	        return parseObjectTypeDefinition(lexer);
	      case 'interface':
	        return parseInterfaceTypeDefinition(lexer);
	      case 'union':
	        return parseUnionTypeDefinition(lexer);
	      case 'enum':
	        return parseEnumTypeDefinition(lexer);
	      case 'input':
	        return parseInputObjectTypeDefinition(lexer);
	      case 'extend':
	        return parseTypeExtensionDefinition(lexer);
	      case 'directive':
	        return parseDirectiveDefinition(lexer);
	    }
	  }

	  throw unexpected(lexer);
	}

	/**
	 * SchemaDefinition : schema Directives? { OperationTypeDefinition+ }
	 *
	 * OperationTypeDefinition : OperationType : NamedType
	 */
	function parseSchemaDefinition(lexer) {
	  var start = lexer.token;
	  expectKeyword(lexer, 'schema');
	  var directives = parseDirectives(lexer);
	  var operationTypes = many(lexer, _lexer.TokenKind.BRACE_L, parseOperationTypeDefinition, _lexer.TokenKind.BRACE_R);
	  return {
	    kind: _kinds.SCHEMA_DEFINITION,
	    directives: directives,
	    operationTypes: operationTypes,
	    loc: loc(lexer, start)
	  };
	}

	function parseOperationTypeDefinition(lexer) {
	  var start = lexer.token;
	  var operation = parseOperationType(lexer);
	  expect(lexer, _lexer.TokenKind.COLON);
	  var type = parseNamedType(lexer);
	  return {
	    kind: _kinds.OPERATION_TYPE_DEFINITION,
	    operation: operation,
	    type: type,
	    loc: loc(lexer, start)
	  };
	}

	/**
	 * ScalarTypeDefinition : scalar Name Directives?
	 */
	function parseScalarTypeDefinition(lexer) {
	  var start = lexer.token;
	  expectKeyword(lexer, 'scalar');
	  var name = parseName(lexer);
	  var directives = parseDirectives(lexer);
	  return {
	    kind: _kinds.SCALAR_TYPE_DEFINITION,
	    name: name,
	    directives: directives,
	    loc: loc(lexer, start)
	  };
	}

	/**
	 * ObjectTypeDefinition :
	 *   - type Name ImplementsInterfaces? Directives? { FieldDefinition+ }
	 */
	function parseObjectTypeDefinition(lexer) {
	  var start = lexer.token;
	  expectKeyword(lexer, 'type');
	  var name = parseName(lexer);
	  var interfaces = parseImplementsInterfaces(lexer);
	  var directives = parseDirectives(lexer);
	  var fields = any(lexer, _lexer.TokenKind.BRACE_L, parseFieldDefinition, _lexer.TokenKind.BRACE_R);
	  return {
	    kind: _kinds.OBJECT_TYPE_DEFINITION,
	    name: name,
	    interfaces: interfaces,
	    directives: directives,
	    fields: fields,
	    loc: loc(lexer, start)
	  };
	}

	/**
	 * ImplementsInterfaces : implements NamedType+
	 */
	function parseImplementsInterfaces(lexer) {
	  var types = [];
	  if (lexer.token.value === 'implements') {
	    lexer.advance();
	    do {
	      types.push(parseNamedType(lexer));
	    } while (peek(lexer, _lexer.TokenKind.NAME));
	  }
	  return types;
	}

	/**
	 * FieldDefinition : Name ArgumentsDefinition? : Type Directives?
	 */
	function parseFieldDefinition(lexer) {
	  var start = lexer.token;
	  var name = parseName(lexer);
	  var args = parseArgumentDefs(lexer);
	  expect(lexer, _lexer.TokenKind.COLON);
	  var type = parseTypeReference(lexer);
	  var directives = parseDirectives(lexer);
	  return {
	    kind: _kinds.FIELD_DEFINITION,
	    name: name,
	    arguments: args,
	    type: type,
	    directives: directives,
	    loc: loc(lexer, start)
	  };
	}

	/**
	 * ArgumentsDefinition : ( InputValueDefinition+ )
	 */
	function parseArgumentDefs(lexer) {
	  if (!peek(lexer, _lexer.TokenKind.PAREN_L)) {
	    return [];
	  }
	  return many(lexer, _lexer.TokenKind.PAREN_L, parseInputValueDef, _lexer.TokenKind.PAREN_R);
	}

	/**
	 * InputValueDefinition : Name : Type DefaultValue? Directives?
	 */
	function parseInputValueDef(lexer) {
	  var start = lexer.token;
	  var name = parseName(lexer);
	  expect(lexer, _lexer.TokenKind.COLON);
	  var type = parseTypeReference(lexer);
	  var defaultValue = null;
	  if (skip(lexer, _lexer.TokenKind.EQUALS)) {
	    defaultValue = parseConstValue(lexer);
	  }
	  var directives = parseDirectives(lexer);
	  return {
	    kind: _kinds.INPUT_VALUE_DEFINITION,
	    name: name,
	    type: type,
	    defaultValue: defaultValue,
	    directives: directives,
	    loc: loc(lexer, start)
	  };
	}

	/**
	 * InterfaceTypeDefinition : interface Name Directives? { FieldDefinition+ }
	 */
	function parseInterfaceTypeDefinition(lexer) {
	  var start = lexer.token;
	  expectKeyword(lexer, 'interface');
	  var name = parseName(lexer);
	  var directives = parseDirectives(lexer);
	  var fields = any(lexer, _lexer.TokenKind.BRACE_L, parseFieldDefinition, _lexer.TokenKind.BRACE_R);
	  return {
	    kind: _kinds.INTERFACE_TYPE_DEFINITION,
	    name: name,
	    directives: directives,
	    fields: fields,
	    loc: loc(lexer, start)
	  };
	}

	/**
	 * UnionTypeDefinition : union Name Directives? = UnionMembers
	 */
	function parseUnionTypeDefinition(lexer) {
	  var start = lexer.token;
	  expectKeyword(lexer, 'union');
	  var name = parseName(lexer);
	  var directives = parseDirectives(lexer);
	  expect(lexer, _lexer.TokenKind.EQUALS);
	  var types = parseUnionMembers(lexer);
	  return {
	    kind: _kinds.UNION_TYPE_DEFINITION,
	    name: name,
	    directives: directives,
	    types: types,
	    loc: loc(lexer, start)
	  };
	}

	/**
	 * UnionMembers :
	 *   - NamedType
	 *   - UnionMembers | NamedType
	 */
	function parseUnionMembers(lexer) {
	  var members = [];
	  do {
	    members.push(parseNamedType(lexer));
	  } while (skip(lexer, _lexer.TokenKind.PIPE));
	  return members;
	}

	/**
	 * EnumTypeDefinition : enum Name Directives? { EnumValueDefinition+ }
	 */
	function parseEnumTypeDefinition(lexer) {
	  var start = lexer.token;
	  expectKeyword(lexer, 'enum');
	  var name = parseName(lexer);
	  var directives = parseDirectives(lexer);
	  var values = many(lexer, _lexer.TokenKind.BRACE_L, parseEnumValueDefinition, _lexer.TokenKind.BRACE_R);
	  return {
	    kind: _kinds.ENUM_TYPE_DEFINITION,
	    name: name,
	    directives: directives,
	    values: values,
	    loc: loc(lexer, start)
	  };
	}

	/**
	 * EnumValueDefinition : EnumValue Directives?
	 *
	 * EnumValue : Name
	 */
	function parseEnumValueDefinition(lexer) {
	  var start = lexer.token;
	  var name = parseName(lexer);
	  var directives = parseDirectives(lexer);
	  return {
	    kind: _kinds.ENUM_VALUE_DEFINITION,
	    name: name,
	    directives: directives,
	    loc: loc(lexer, start)
	  };
	}

	/**
	 * InputObjectTypeDefinition : input Name Directives? { InputValueDefinition+ }
	 */
	function parseInputObjectTypeDefinition(lexer) {
	  var start = lexer.token;
	  expectKeyword(lexer, 'input');
	  var name = parseName(lexer);
	  var directives = parseDirectives(lexer);
	  var fields = any(lexer, _lexer.TokenKind.BRACE_L, parseInputValueDef, _lexer.TokenKind.BRACE_R);
	  return {
	    kind: _kinds.INPUT_OBJECT_TYPE_DEFINITION,
	    name: name,
	    directives: directives,
	    fields: fields,
	    loc: loc(lexer, start)
	  };
	}

	/**
	 * TypeExtensionDefinition : extend ObjectTypeDefinition
	 */
	function parseTypeExtensionDefinition(lexer) {
	  var start = lexer.token;
	  expectKeyword(lexer, 'extend');
	  var definition = parseObjectTypeDefinition(lexer);
	  return {
	    kind: _kinds.TYPE_EXTENSION_DEFINITION,
	    definition: definition,
	    loc: loc(lexer, start)
	  };
	}

	/**
	 * DirectiveDefinition :
	 *   - directive @ Name ArgumentsDefinition? on DirectiveLocations
	 */
	function parseDirectiveDefinition(lexer) {
	  var start = lexer.token;
	  expectKeyword(lexer, 'directive');
	  expect(lexer, _lexer.TokenKind.AT);
	  var name = parseName(lexer);
	  var args = parseArgumentDefs(lexer);
	  expectKeyword(lexer, 'on');
	  var locations = parseDirectiveLocations(lexer);
	  return {
	    kind: _kinds.DIRECTIVE_DEFINITION,
	    name: name,
	    arguments: args,
	    locations: locations,
	    loc: loc(lexer, start)
	  };
	}

	/**
	 * DirectiveLocations :
	 *   - Name
	 *   - DirectiveLocations | Name
	 */
	function parseDirectiveLocations(lexer) {
	  var locations = [];
	  do {
	    locations.push(parseName(lexer));
	  } while (skip(lexer, _lexer.TokenKind.PIPE));
	  return locations;
	}

	// Core parsing utility functions

	/**
	 * Returns a location object, used to identify the place in
	 * the source that created a given parsed object.
	 */
	function loc(lexer, startToken) {
	  if (!lexer.options.noLocation) {
	    return new Loc(startToken, lexer.lastToken, lexer.source);
	  }
	}

	function Loc(startToken, endToken, source) {
	  this.start = startToken.start;
	  this.end = endToken.end;
	  this.startToken = startToken;
	  this.endToken = endToken;
	  this.source = source;
	}

	// Print a simplified form when appearing in JSON/util.inspect.
	Loc.prototype.toJSON = Loc.prototype.inspect = function toJSON() {
	  return { start: this.start, end: this.end };
	};

	/**
	 * Determines if the next token is of a given kind
	 */
	function peek(lexer, kind) {
	  return lexer.token.kind === kind;
	}

	/**
	 * If the next token is of the given kind, return true after advancing
	 * the lexer. Otherwise, do not change the parser state and return false.
	 */
	function skip(lexer, kind) {
	  var match = lexer.token.kind === kind;
	  if (match) {
	    lexer.advance();
	  }
	  return match;
	}

	/**
	 * If the next token is of the given kind, return that token after advancing
	 * the lexer. Otherwise, do not change the parser state and throw an error.
	 */
	function expect(lexer, kind) {
	  var token = lexer.token;
	  if (token.kind === kind) {
	    lexer.advance();
	    return token;
	  }
	  throw (0, _error.syntaxError)(lexer.source, token.start, 'Expected ' + kind + ', found ' + (0, _lexer.getTokenDesc)(token));
	}

	/**
	 * If the next token is a keyword with the given value, return that token after
	 * advancing the lexer. Otherwise, do not change the parser state and return
	 * false.
	 */
	function expectKeyword(lexer, value) {
	  var token = lexer.token;
	  if (token.kind === _lexer.TokenKind.NAME && token.value === value) {
	    lexer.advance();
	    return token;
	  }
	  throw (0, _error.syntaxError)(lexer.source, token.start, 'Expected "' + value + '", found ' + (0, _lexer.getTokenDesc)(token));
	}

	/**
	 * Helper function for creating an error when an unexpected lexed token
	 * is encountered.
	 */
	function unexpected(lexer, atToken) {
	  var token = atToken || lexer.token;
	  return (0, _error.syntaxError)(lexer.source, token.start, 'Unexpected ' + (0, _lexer.getTokenDesc)(token));
	}

	/**
	 * Returns a possibly empty list of parse nodes, determined by
	 * the parseFn. This list begins with a lex token of openKind
	 * and ends with a lex token of closeKind. Advances the parser
	 * to the next lex token after the closing token.
	 */
	function any(lexer, openKind, parseFn, closeKind) {
	  expect(lexer, openKind);
	  var nodes = [];
	  while (!skip(lexer, closeKind)) {
	    nodes.push(parseFn(lexer));
	  }
	  return nodes;
	}

	/**
	 * Returns a non-empty list of parse nodes, determined by
	 * the parseFn. This list begins with a lex token of openKind
	 * and ends with a lex token of closeKind. Advances the parser
	 * to the next lex token after the closing token.
	 */
	function many(lexer, openKind, parseFn, closeKind) {
	  expect(lexer, openKind);
	  var nodes = [parseFn(lexer)];
	  while (!skip(lexer, closeKind)) {
	    nodes.push(parseFn(lexer));
	  }
	  return nodes;
	}

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _GraphQLError = __webpack_require__(9);

	Object.defineProperty(exports, 'GraphQLError', {
	  enumerable: true,
	  get: function get() {
	    return _GraphQLError.GraphQLError;
	  }
	});

	var _syntaxError = __webpack_require__(16);

	Object.defineProperty(exports, 'syntaxError', {
	  enumerable: true,
	  get: function get() {
	    return _syntaxError.syntaxError;
	  }
	});

	var _locatedError = __webpack_require__(17);

	Object.defineProperty(exports, 'locatedError', {
	  enumerable: true,
	  get: function get() {
	    return _locatedError.locatedError;
	  }
	});

	var _formatError = __webpack_require__(18);

	Object.defineProperty(exports, 'formatError', {
	  enumerable: true,
	  get: function get() {
	    return _formatError.formatError;
	  }
	});

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.GraphQLError = GraphQLError;

	var _language = __webpack_require__(10);

	/**
	 * A GraphQLError describes an Error found during the parse, validate, or
	 * execute phases of performing a GraphQL operation. In addition to a message
	 * and stack trace, it also includes information about the locations in a
	 * GraphQL document and/or execution result that correspond to the Error.
	 */
	function GraphQLError( // eslint-disable-line no-redeclare
	message, nodes, source, positions, path, originalError) {
	  // Include (non-enumerable) stack trace.
	  if (originalError && originalError.stack) {
	    Object.defineProperty(this, 'stack', {
	      value: originalError.stack,
	      writable: true,
	      configurable: true
	    });
	  } else if (Error.captureStackTrace) {
	    Error.captureStackTrace(this, GraphQLError);
	  } else {
	    Object.defineProperty(this, 'stack', {
	      value: Error().stack,
	      writable: true,
	      configurable: true
	    });
	  }

	  // Compute locations in the source for the given nodes/positions.
	  var _source = source;
	  if (!_source && nodes && nodes.length > 0) {
	    var node = nodes[0];
	    _source = node && node.loc && node.loc.source;
	  }

	  var _positions = positions;
	  if (!_positions && nodes) {
	    _positions = nodes.filter(function (node) {
	      return Boolean(node.loc);
	    }).map(function (node) {
	      return node.loc.start;
	    });
	  }
	  if (_positions && _positions.length === 0) {
	    _positions = undefined;
	  }

	  var _locations = void 0;
	  var _source2 = _source; // seems here Flow need a const to resolve type.
	  if (_source2 && _positions) {
	    _locations = _positions.map(function (pos) {
	      return (0, _language.getLocation)(_source2, pos);
	    });
	  }

	  Object.defineProperties(this, {
	    message: {
	      value: message,
	      // By being enumerable, JSON.stringify will include `message` in the
	      // resulting output. This ensures that the simplist possible GraphQL
	      // service adheres to the spec.
	      enumerable: true,
	      writable: true
	    },
	    locations: {
	      // Coercing falsey values to undefined ensures they will not be included
	      // in JSON.stringify() when not provided.
	      value: _locations || undefined,
	      // By being enumerable, JSON.stringify will include `locations` in the
	      // resulting output. This ensures that the simplist possible GraphQL
	      // service adheres to the spec.
	      enumerable: true
	    },
	    path: {
	      // Coercing falsey values to undefined ensures they will not be included
	      // in JSON.stringify() when not provided.
	      value: path || undefined,
	      // By being enumerable, JSON.stringify will include `path` in the
	      // resulting output. This ensures that the simplist possible GraphQL
	      // service adheres to the spec.
	      enumerable: true
	    },
	    nodes: {
	      value: nodes || undefined
	    },
	    source: {
	      value: _source || undefined
	    },
	    positions: {
	      value: _positions || undefined
	    },
	    originalError: {
	      value: originalError
	    }
	  });
	}
	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	GraphQLError.prototype = Object.create(Error.prototype, {
	  constructor: { value: GraphQLError },
	  name: { value: 'GraphQLError' }
	});

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.BREAK = exports.visitWithTypeInfo = exports.visitInParallel = exports.visit = exports.Source = exports.print = exports.parseType = exports.parseValue = exports.parse = exports.TokenKind = exports.createLexer = exports.Kind = exports.getLocation = undefined;

	var _location = __webpack_require__(11);

	Object.defineProperty(exports, 'getLocation', {
	  enumerable: true,
	  get: function get() {
	    return _location.getLocation;
	  }
	});

	var _lexer = __webpack_require__(12);

	Object.defineProperty(exports, 'createLexer', {
	  enumerable: true,
	  get: function get() {
	    return _lexer.createLexer;
	  }
	});
	Object.defineProperty(exports, 'TokenKind', {
	  enumerable: true,
	  get: function get() {
	    return _lexer.TokenKind;
	  }
	});

	var _parser = __webpack_require__(7);

	Object.defineProperty(exports, 'parse', {
	  enumerable: true,
	  get: function get() {
	    return _parser.parse;
	  }
	});
	Object.defineProperty(exports, 'parseValue', {
	  enumerable: true,
	  get: function get() {
	    return _parser.parseValue;
	  }
	});
	Object.defineProperty(exports, 'parseType', {
	  enumerable: true,
	  get: function get() {
	    return _parser.parseType;
	  }
	});

	var _printer = __webpack_require__(13);

	Object.defineProperty(exports, 'print', {
	  enumerable: true,
	  get: function get() {
	    return _printer.print;
	  }
	});

	var _source = __webpack_require__(6);

	Object.defineProperty(exports, 'Source', {
	  enumerable: true,
	  get: function get() {
	    return _source.Source;
	  }
	});

	var _visitor = __webpack_require__(14);

	Object.defineProperty(exports, 'visit', {
	  enumerable: true,
	  get: function get() {
	    return _visitor.visit;
	  }
	});
	Object.defineProperty(exports, 'visitInParallel', {
	  enumerable: true,
	  get: function get() {
	    return _visitor.visitInParallel;
	  }
	});
	Object.defineProperty(exports, 'visitWithTypeInfo', {
	  enumerable: true,
	  get: function get() {
	    return _visitor.visitWithTypeInfo;
	  }
	});
	Object.defineProperty(exports, 'BREAK', {
	  enumerable: true,
	  get: function get() {
	    return _visitor.BREAK;
	  }
	});

	var _kinds = __webpack_require__(15);

	var Kind = _interopRequireWildcard(_kinds);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	exports.Kind = Kind;

/***/ },
/* 11 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.getLocation = getLocation;


	/**
	 * Takes a Source and a UTF-8 character offset, and returns the corresponding
	 * line and column as a SourceLocation.
	 */

	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	function getLocation(source, position) {
	  var lineRegexp = /\r\n|[\n\r]/g;
	  var line = 1;
	  var column = position + 1;
	  var match = void 0;
	  while ((match = lineRegexp.exec(source.body)) && match.index < position) {
	    line += 1;
	    column = position + 1 - (match.index + match[0].length);
	  }
	  return { line: line, column: column };
	}

	/**
	 * Represents a location in a Source.
	 */

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.TokenKind = undefined;
	exports.createLexer = createLexer;
	exports.getTokenDesc = getTokenDesc;

	var _error = __webpack_require__(8);

	/**
	 * Given a Source object, this returns a Lexer for that source.
	 * A Lexer is a stateful stream generator in that every time
	 * it is advanced, it returns the next token in the Source. Assuming the
	 * source lexes, the final Token emitted by the lexer will be of kind
	 * EOF, after which the lexer will repeatedly return the same EOF token
	 * whenever called.
	 */
	function createLexer(source, options) {
	  var startOfFileToken = new Tok(SOF, 0, 0, 0, 0, null);
	  var lexer = {
	    source: source,
	    options: options,
	    lastToken: startOfFileToken,
	    token: startOfFileToken,
	    line: 1,
	    lineStart: 0,
	    advance: advanceLexer
	  };
	  return lexer;
	} /*  /
	  /**
	   *  Copyright (c) 2015, Facebook, Inc.
	   *  All rights reserved.
	   *
	   *  This source code is licensed under the BSD-style license found in the
	   *  LICENSE file in the root directory of this source tree. An additional grant
	   *  of patent rights can be found in the PATENTS file in the same directory.
	   */

	function advanceLexer() {
	  var token = this.lastToken = this.token;
	  if (token.kind !== EOF) {
	    do {
	      token = token.next = readToken(this, token);
	    } while (token.kind === COMMENT);
	    this.token = token;
	  }
	  return token;
	}

	/**
	 * The return type of createLexer.
	 */


	// Each kind of token.
	var SOF = '<SOF>';
	var EOF = '<EOF>';
	var BANG = '!';
	var DOLLAR = '$';
	var PAREN_L = '(';
	var PAREN_R = ')';
	var SPREAD = '...';
	var COLON = ':';
	var EQUALS = '=';
	var AT = '@';
	var BRACKET_L = '[';
	var BRACKET_R = ']';
	var BRACE_L = '{';
	var PIPE = '|';
	var BRACE_R = '}';
	var NAME = 'Name';
	var INT = 'Int';
	var FLOAT = 'Float';
	var STRING = 'String';
	var COMMENT = 'Comment';

	/**
	 * An exported enum describing the different kinds of tokens that the
	 * lexer emits.
	 */
	var TokenKind = exports.TokenKind = {
	  SOF: SOF,
	  EOF: EOF,
	  BANG: BANG,
	  DOLLAR: DOLLAR,
	  PAREN_L: PAREN_L,
	  PAREN_R: PAREN_R,
	  SPREAD: SPREAD,
	  COLON: COLON,
	  EQUALS: EQUALS,
	  AT: AT,
	  BRACKET_L: BRACKET_L,
	  BRACKET_R: BRACKET_R,
	  BRACE_L: BRACE_L,
	  PIPE: PIPE,
	  BRACE_R: BRACE_R,
	  NAME: NAME,
	  INT: INT,
	  FLOAT: FLOAT,
	  STRING: STRING,
	  COMMENT: COMMENT
	};

	/**
	 * A helper function to describe a token as a string for debugging
	 */
	function getTokenDesc(token) {
	  var value = token.value;
	  return value ? token.kind + ' "' + value + '"' : token.kind;
	}

	var charCodeAt = String.prototype.charCodeAt;
	var slice = String.prototype.slice;

	/**
	 * Helper function for constructing the Token object.
	 */
	function Tok(kind, start, end, line, column, prev, value) {
	  this.kind = kind;
	  this.start = start;
	  this.end = end;
	  this.line = line;
	  this.column = column;
	  this.value = value;
	  this.prev = prev;
	  this.next = null;
	}

	// Print a simplified form when appearing in JSON/util.inspect.
	Tok.prototype.toJSON = Tok.prototype.inspect = function toJSON() {
	  return {
	    kind: this.kind,
	    value: this.value,
	    line: this.line,
	    column: this.column
	  };
	};

	function printCharCode(code) {
	  return (
	    // NaN/undefined represents access beyond the end of the file.
	    isNaN(code) ? EOF :
	    // Trust JSON for ASCII.
	    code < 0x007F ? JSON.stringify(String.fromCharCode(code)) :
	    // Otherwise print the escaped form.
	    '"\\u' + ('00' + code.toString(16).toUpperCase()).slice(-4) + '"'
	  );
	}

	/**
	 * Gets the next token from the source starting at the given position.
	 *
	 * This skips over whitespace and comments until it finds the next lexable
	 * token, then lexes punctuators immediately or calls the appropriate helper
	 * function for more complicated tokens.
	 */
	function readToken(lexer, prev) {
	  var source = lexer.source;
	  var body = source.body;
	  var bodyLength = body.length;

	  var position = positionAfterWhitespace(body, prev.end, lexer);
	  var line = lexer.line;
	  var col = 1 + position - lexer.lineStart;

	  if (position >= bodyLength) {
	    return new Tok(EOF, bodyLength, bodyLength, line, col, prev);
	  }

	  var code = charCodeAt.call(body, position);

	  // SourceCharacter
	  if (code < 0x0020 && code !== 0x0009 && code !== 0x000A && code !== 0x000D) {
	    throw (0, _error.syntaxError)(source, position, 'Invalid character ' + printCharCode(code) + '.');
	  }

	  switch (code) {
	    // !
	    case 33:
	      return new Tok(BANG, position, position + 1, line, col, prev);
	    // #
	    case 35:
	      return readComment(source, position, line, col, prev);
	    // $
	    case 36:
	      return new Tok(DOLLAR, position, position + 1, line, col, prev);
	    // (
	    case 40:
	      return new Tok(PAREN_L, position, position + 1, line, col, prev);
	    // )
	    case 41:
	      return new Tok(PAREN_R, position, position + 1, line, col, prev);
	    // .
	    case 46:
	      if (charCodeAt.call(body, position + 1) === 46 && charCodeAt.call(body, position + 2) === 46) {
	        return new Tok(SPREAD, position, position + 3, line, col, prev);
	      }
	      break;
	    // :
	    case 58:
	      return new Tok(COLON, position, position + 1, line, col, prev);
	    // =
	    case 61:
	      return new Tok(EQUALS, position, position + 1, line, col, prev);
	    // @
	    case 64:
	      return new Tok(AT, position, position + 1, line, col, prev);
	    // [
	    case 91:
	      return new Tok(BRACKET_L, position, position + 1, line, col, prev);
	    // ]
	    case 93:
	      return new Tok(BRACKET_R, position, position + 1, line, col, prev);
	    // {
	    case 123:
	      return new Tok(BRACE_L, position, position + 1, line, col, prev);
	    // |
	    case 124:
	      return new Tok(PIPE, position, position + 1, line, col, prev);
	    // }
	    case 125:
	      return new Tok(BRACE_R, position, position + 1, line, col, prev);
	    // A-Z _ a-z
	    case 65:case 66:case 67:case 68:case 69:case 70:case 71:case 72:
	    case 73:case 74:case 75:case 76:case 77:case 78:case 79:case 80:
	    case 81:case 82:case 83:case 84:case 85:case 86:case 87:case 88:
	    case 89:case 90:
	    case 95:
	    case 97:case 98:case 99:case 100:case 101:case 102:case 103:case 104:
	    case 105:case 106:case 107:case 108:case 109:case 110:case 111:
	    case 112:case 113:case 114:case 115:case 116:case 117:case 118:
	    case 119:case 120:case 121:case 122:
	      return readName(source, position, line, col, prev);
	    // - 0-9
	    case 45:
	    case 48:case 49:case 50:case 51:case 52:
	    case 53:case 54:case 55:case 56:case 57:
	      return readNumber(source, position, code, line, col, prev);
	    // "
	    case 34:
	      return readString(source, position, line, col, prev);
	  }

	  throw (0, _error.syntaxError)(source, position, 'Unexpected character ' + printCharCode(code) + '.');
	}

	/**
	 * Reads from body starting at startPosition until it finds a non-whitespace
	 * or commented character, then returns the position of that character for
	 * lexing.
	 */
	function positionAfterWhitespace(body, startPosition, lexer) {
	  var bodyLength = body.length;
	  var position = startPosition;
	  while (position < bodyLength) {
	    var code = charCodeAt.call(body, position);
	    // tab | space | comma | BOM
	    if (code === 9 || code === 32 || code === 44 || code === 0xFEFF) {
	      ++position;
	    } else if (code === 10) {
	      // new line
	      ++position;
	      ++lexer.line;
	      lexer.lineStart = position;
	    } else if (code === 13) {
	      // carriage return
	      if (charCodeAt.call(body, position + 1) === 10) {
	        position += 2;
	      } else {
	        ++position;
	      }
	      ++lexer.line;
	      lexer.lineStart = position;
	    } else {
	      break;
	    }
	  }
	  return position;
	}

	/**
	 * Reads a comment token from the source file.
	 *
	 * #[\u0009\u0020-\uFFFF]*
	 */
	function readComment(source, start, line, col, prev) {
	  var body = source.body;
	  var code = void 0;
	  var position = start;

	  do {
	    code = charCodeAt.call(body, ++position);
	  } while (code !== null && (
	  // SourceCharacter but not LineTerminator
	  code > 0x001F || code === 0x0009));

	  return new Tok(COMMENT, start, position, line, col, prev, slice.call(body, start + 1, position));
	}

	/**
	 * Reads a number token from the source file, either a float
	 * or an int depending on whether a decimal point appears.
	 *
	 * Int:   -?(0|[1-9][0-9]*)
	 * Float: -?(0|[1-9][0-9]*)(\.[0-9]+)?((E|e)(+|-)?[0-9]+)?
	 */
	function readNumber(source, start, firstCode, line, col, prev) {
	  var body = source.body;
	  var code = firstCode;
	  var position = start;
	  var isFloat = false;

	  if (code === 45) {
	    // -
	    code = charCodeAt.call(body, ++position);
	  }

	  if (code === 48) {
	    // 0
	    code = charCodeAt.call(body, ++position);
	    if (code >= 48 && code <= 57) {
	      throw (0, _error.syntaxError)(source, position, 'Invalid number, unexpected digit after 0: ' + printCharCode(code) + '.');
	    }
	  } else {
	    position = readDigits(source, position, code);
	    code = charCodeAt.call(body, position);
	  }

	  if (code === 46) {
	    // .
	    isFloat = true;

	    code = charCodeAt.call(body, ++position);
	    position = readDigits(source, position, code);
	    code = charCodeAt.call(body, position);
	  }

	  if (code === 69 || code === 101) {
	    // E e
	    isFloat = true;

	    code = charCodeAt.call(body, ++position);
	    if (code === 43 || code === 45) {
	      // + -
	      code = charCodeAt.call(body, ++position);
	    }
	    position = readDigits(source, position, code);
	  }

	  return new Tok(isFloat ? FLOAT : INT, start, position, line, col, prev, slice.call(body, start, position));
	}

	/**
	 * Returns the new position in the source after reading digits.
	 */
	function readDigits(source, start, firstCode) {
	  var body = source.body;
	  var position = start;
	  var code = firstCode;
	  if (code >= 48 && code <= 57) {
	    // 0 - 9
	    do {
	      code = charCodeAt.call(body, ++position);
	    } while (code >= 48 && code <= 57); // 0 - 9
	    return position;
	  }
	  throw (0, _error.syntaxError)(source, position, 'Invalid number, expected digit but got: ' + printCharCode(code) + '.');
	}

	/**
	 * Reads a string token from the source file.
	 *
	 * "([^"\\\u000A\u000D]|(\\(u[0-9a-fA-F]{4}|["\\/bfnrt])))*"
	 */
	function readString(source, start, line, col, prev) {
	  var body = source.body;
	  var position = start + 1;
	  var chunkStart = position;
	  var code = 0;
	  var value = '';

	  while (position < body.length && (code = charCodeAt.call(body, position)) !== null &&
	  // not LineTerminator
	  code !== 0x000A && code !== 0x000D &&
	  // not Quote (")
	  code !== 34) {
	    // SourceCharacter
	    if (code < 0x0020 && code !== 0x0009) {
	      throw (0, _error.syntaxError)(source, position, 'Invalid character within String: ' + printCharCode(code) + '.');
	    }

	    ++position;
	    if (code === 92) {
	      // \
	      value += slice.call(body, chunkStart, position - 1);
	      code = charCodeAt.call(body, position);
	      switch (code) {
	        case 34:
	          value += '"';break;
	        case 47:
	          value += '\/';break;
	        case 92:
	          value += '\\';break;
	        case 98:
	          value += '\b';break;
	        case 102:
	          value += '\f';break;
	        case 110:
	          value += '\n';break;
	        case 114:
	          value += '\r';break;
	        case 116:
	          value += '\t';break;
	        case 117:
	          // u
	          var charCode = uniCharCode(charCodeAt.call(body, position + 1), charCodeAt.call(body, position + 2), charCodeAt.call(body, position + 3), charCodeAt.call(body, position + 4));
	          if (charCode < 0) {
	            throw (0, _error.syntaxError)(source, position, 'Invalid character escape sequence: ' + ('\\u' + body.slice(position + 1, position + 5) + '.'));
	          }
	          value += String.fromCharCode(charCode);
	          position += 4;
	          break;
	        default:
	          throw (0, _error.syntaxError)(source, position, 'Invalid character escape sequence: \\' + String.fromCharCode(code) + '.');
	      }
	      ++position;
	      chunkStart = position;
	    }
	  }

	  if (code !== 34) {
	    // quote (")
	    throw (0, _error.syntaxError)(source, position, 'Unterminated string.');
	  }

	  value += slice.call(body, chunkStart, position);
	  return new Tok(STRING, start, position + 1, line, col, prev, value);
	}

	/**
	 * Converts four hexidecimal chars to the integer that the
	 * string represents. For example, uniCharCode('0','0','0','f')
	 * will return 15, and uniCharCode('0','0','f','f') returns 255.
	 *
	 * Returns a negative number on error, if a char was invalid.
	 *
	 * This is implemented by noting that char2hex() returns -1 on error,
	 * which means the result of ORing the char2hex() will also be negative.
	 */
	function uniCharCode(a, b, c, d) {
	  return char2hex(a) << 12 | char2hex(b) << 8 | char2hex(c) << 4 | char2hex(d);
	}

	/**
	 * Converts a hex character to its integer value.
	 * '0' becomes 0, '9' becomes 9
	 * 'A' becomes 10, 'F' becomes 15
	 * 'a' becomes 10, 'f' becomes 15
	 *
	 * Returns -1 on error.
	 */
	function char2hex(a) {
	  return a >= 48 && a <= 57 ? a - 48 : // 0-9
	  a >= 65 && a <= 70 ? a - 55 : // A-F
	  a >= 97 && a <= 102 ? a - 87 : // a-f
	  -1;
	}

	/**
	 * Reads an alphanumeric + underscore name from the source.
	 *
	 * [_A-Za-z][_0-9A-Za-z]*
	 */
	function readName(source, position, line, col, prev) {
	  var body = source.body;
	  var bodyLength = body.length;
	  var end = position + 1;
	  var code = 0;
	  while (end !== bodyLength && (code = charCodeAt.call(body, end)) !== null && (code === 95 || // _
	  code >= 48 && code <= 57 || // 0-9
	  code >= 65 && code <= 90 || // A-Z
	  code >= 97 && code <= 122 // a-z
	  )) {
	    ++end;
	  }
	  return new Tok(NAME, position, end, line, col, prev, slice.call(body, position, end));
	}

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.print = print;

	var _visitor = __webpack_require__(14);

	/**
	 * Converts an AST into a string, using one set of reasonable
	 * formatting rules.
	 */
	function print(ast) {
	  return (0, _visitor.visit)(ast, { leave: printDocASTReducer });
	} /**
	   *  Copyright (c) 2015, Facebook, Inc.
	   *  All rights reserved.
	   *
	   *  This source code is licensed under the BSD-style license found in the
	   *  LICENSE file in the root directory of this source tree. An additional grant
	   *  of patent rights can be found in the PATENTS file in the same directory.
	   */

	var printDocASTReducer = {
	  Name: function Name(node) {
	    return node.value;
	  },
	  Variable: function Variable(node) {
	    return '$' + node.name;
	  },

	  // Document

	  Document: function Document(node) {
	    return join(node.definitions, '\n\n') + '\n';
	  },

	  OperationDefinition: function OperationDefinition(node) {
	    var op = node.operation;
	    var name = node.name;
	    var varDefs = wrap('(', join(node.variableDefinitions, ', '), ')');
	    var directives = join(node.directives, ' ');
	    var selectionSet = node.selectionSet;
	    // Anonymous queries with no directives or variable definitions can use
	    // the query short form.
	    return !name && !directives && !varDefs && op === 'query' ? selectionSet : join([op, join([name, varDefs]), directives, selectionSet], ' ');
	  },


	  VariableDefinition: function VariableDefinition(_ref) {
	    var variable = _ref.variable;
	    var type = _ref.type;
	    var defaultValue = _ref.defaultValue;
	    return variable + ': ' + type + wrap(' = ', defaultValue);
	  },

	  SelectionSet: function SelectionSet(_ref2) {
	    var selections = _ref2.selections;
	    return block(selections);
	  },

	  Field: function Field(_ref3) {
	    var alias = _ref3.alias;
	    var name = _ref3.name;
	    var args = _ref3.arguments;
	    var directives = _ref3.directives;
	    var selectionSet = _ref3.selectionSet;
	    return join([wrap('', alias, ': ') + name + wrap('(', join(args, ', '), ')'), join(directives, ' '), selectionSet], ' ');
	  },

	  Argument: function Argument(_ref4) {
	    var name = _ref4.name;
	    var value = _ref4.value;
	    return name + ': ' + value;
	  },

	  // Fragments

	  FragmentSpread: function FragmentSpread(_ref5) {
	    var name = _ref5.name;
	    var directives = _ref5.directives;
	    return '...' + name + wrap(' ', join(directives, ' '));
	  },

	  InlineFragment: function InlineFragment(_ref6) {
	    var typeCondition = _ref6.typeCondition;
	    var directives = _ref6.directives;
	    var selectionSet = _ref6.selectionSet;
	    return join(['...', wrap('on ', typeCondition), join(directives, ' '), selectionSet], ' ');
	  },

	  FragmentDefinition: function FragmentDefinition(_ref7) {
	    var name = _ref7.name;
	    var typeCondition = _ref7.typeCondition;
	    var directives = _ref7.directives;
	    var selectionSet = _ref7.selectionSet;
	    return 'fragment ' + name + ' on ' + typeCondition + ' ' + wrap('', join(directives, ' '), ' ') + selectionSet;
	  },

	  // Value

	  IntValue: function IntValue(_ref8) {
	    var value = _ref8.value;
	    return value;
	  },
	  FloatValue: function FloatValue(_ref9) {
	    var value = _ref9.value;
	    return value;
	  },
	  StringValue: function StringValue(_ref10) {
	    var value = _ref10.value;
	    return JSON.stringify(value);
	  },
	  BooleanValue: function BooleanValue(_ref11) {
	    var value = _ref11.value;
	    return JSON.stringify(value);
	  },
	  EnumValue: function EnumValue(_ref12) {
	    var value = _ref12.value;
	    return value;
	  },
	  ListValue: function ListValue(_ref13) {
	    var values = _ref13.values;
	    return '[' + join(values, ', ') + ']';
	  },
	  ObjectValue: function ObjectValue(_ref14) {
	    var fields = _ref14.fields;
	    return '{' + join(fields, ', ') + '}';
	  },
	  ObjectField: function ObjectField(_ref15) {
	    var name = _ref15.name;
	    var value = _ref15.value;
	    return name + ': ' + value;
	  },

	  // Directive

	  Directive: function Directive(_ref16) {
	    var name = _ref16.name;
	    var args = _ref16.arguments;
	    return '@' + name + wrap('(', join(args, ', '), ')');
	  },

	  // Type

	  NamedType: function NamedType(_ref17) {
	    var name = _ref17.name;
	    return name;
	  },
	  ListType: function ListType(_ref18) {
	    var type = _ref18.type;
	    return '[' + type + ']';
	  },
	  NonNullType: function NonNullType(_ref19) {
	    var type = _ref19.type;
	    return type + '!';
	  },

	  // Type System Definitions

	  SchemaDefinition: function SchemaDefinition(_ref20) {
	    var directives = _ref20.directives;
	    var operationTypes = _ref20.operationTypes;
	    return join(['schema', join(directives, ' '), block(operationTypes)], ' ');
	  },

	  OperationTypeDefinition: function OperationTypeDefinition(_ref21) {
	    var operation = _ref21.operation;
	    var type = _ref21.type;
	    return operation + ': ' + type;
	  },

	  ScalarTypeDefinition: function ScalarTypeDefinition(_ref22) {
	    var name = _ref22.name;
	    var directives = _ref22.directives;
	    return join(['scalar', name, join(directives, ' ')], ' ');
	  },

	  ObjectTypeDefinition: function ObjectTypeDefinition(_ref23) {
	    var name = _ref23.name;
	    var interfaces = _ref23.interfaces;
	    var directives = _ref23.directives;
	    var fields = _ref23.fields;
	    return join(['type', name, wrap('implements ', join(interfaces, ', ')), join(directives, ' '), block(fields)], ' ');
	  },

	  FieldDefinition: function FieldDefinition(_ref24) {
	    var name = _ref24.name;
	    var args = _ref24.arguments;
	    var type = _ref24.type;
	    var directives = _ref24.directives;
	    return name + wrap('(', join(args, ', '), ')') + ': ' + type + wrap(' ', join(directives, ' '));
	  },

	  InputValueDefinition: function InputValueDefinition(_ref25) {
	    var name = _ref25.name;
	    var type = _ref25.type;
	    var defaultValue = _ref25.defaultValue;
	    var directives = _ref25.directives;
	    return join([name + ': ' + type, wrap('= ', defaultValue), join(directives, ' ')], ' ');
	  },

	  InterfaceTypeDefinition: function InterfaceTypeDefinition(_ref26) {
	    var name = _ref26.name;
	    var directives = _ref26.directives;
	    var fields = _ref26.fields;
	    return join(['interface', name, join(directives, ' '), block(fields)], ' ');
	  },

	  UnionTypeDefinition: function UnionTypeDefinition(_ref27) {
	    var name = _ref27.name;
	    var directives = _ref27.directives;
	    var types = _ref27.types;
	    return join(['union', name, join(directives, ' '), '= ' + join(types, ' | ')], ' ');
	  },

	  EnumTypeDefinition: function EnumTypeDefinition(_ref28) {
	    var name = _ref28.name;
	    var directives = _ref28.directives;
	    var values = _ref28.values;
	    return join(['enum', name, join(directives, ' '), block(values)], ' ');
	  },

	  EnumValueDefinition: function EnumValueDefinition(_ref29) {
	    var name = _ref29.name;
	    var directives = _ref29.directives;
	    return join([name, join(directives, ' ')], ' ');
	  },

	  InputObjectTypeDefinition: function InputObjectTypeDefinition(_ref30) {
	    var name = _ref30.name;
	    var directives = _ref30.directives;
	    var fields = _ref30.fields;
	    return join(['input', name, join(directives, ' '), block(fields)], ' ');
	  },

	  TypeExtensionDefinition: function TypeExtensionDefinition(_ref31) {
	    var definition = _ref31.definition;
	    return 'extend ' + definition;
	  },

	  DirectiveDefinition: function DirectiveDefinition(_ref32) {
	    var name = _ref32.name;
	    var args = _ref32.arguments;
	    var locations = _ref32.locations;
	    return 'directive @' + name + wrap('(', join(args, ', '), ')') + ' on ' + join(locations, ' | ');
	  }
	};

	/**
	 * Given maybeArray, print an empty string if it is null or empty, otherwise
	 * print all items together separated by separator if provided
	 */
	function join(maybeArray, separator) {
	  return maybeArray ? maybeArray.filter(function (x) {
	    return x;
	  }).join(separator || '') : '';
	}

	/**
	 * Given array, print each item on its own line, wrapped in an
	 * indented "{ }" block.
	 */
	function block(array) {
	  return array && array.length !== 0 ? indent('{\n' + join(array, '\n')) + '\n}' : '{}';
	}

	/**
	 * If maybeString is not null or empty, then wrap with start and end, otherwise
	 * print an empty string.
	 */
	function wrap(start, maybeString, end) {
	  return maybeString ? start + maybeString + (end || '') : '';
	}

	function indent(maybeString) {
	  return maybeString && maybeString.replace(/\n/g, '\n  ');
	}

/***/ },
/* 14 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.visit = visit;
	exports.visitInParallel = visitInParallel;
	exports.visitWithTypeInfo = visitWithTypeInfo;
	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	var QueryDocumentKeys = exports.QueryDocumentKeys = {
	  Name: [],

	  Document: ['definitions'],
	  OperationDefinition: ['name', 'variableDefinitions', 'directives', 'selectionSet'],
	  VariableDefinition: ['variable', 'type', 'defaultValue'],
	  Variable: ['name'],
	  SelectionSet: ['selections'],
	  Field: ['alias', 'name', 'arguments', 'directives', 'selectionSet'],
	  Argument: ['name', 'value'],

	  FragmentSpread: ['name', 'directives'],
	  InlineFragment: ['typeCondition', 'directives', 'selectionSet'],
	  FragmentDefinition: ['name', 'typeCondition', 'directives', 'selectionSet'],

	  IntValue: [],
	  FloatValue: [],
	  StringValue: [],
	  BooleanValue: [],
	  EnumValue: [],
	  ListValue: ['values'],
	  ObjectValue: ['fields'],
	  ObjectField: ['name', 'value'],

	  Directive: ['name', 'arguments'],

	  NamedType: ['name'],
	  ListType: ['type'],
	  NonNullType: ['type'],

	  SchemaDefinition: ['directives', 'operationTypes'],
	  OperationTypeDefinition: ['type'],

	  ScalarTypeDefinition: ['name', 'directives'],
	  ObjectTypeDefinition: ['name', 'interfaces', 'directives', 'fields'],
	  FieldDefinition: ['name', 'arguments', 'type', 'directives'],
	  InputValueDefinition: ['name', 'type', 'defaultValue', 'directives'],
	  InterfaceTypeDefinition: ['name', 'directives', 'fields'],
	  UnionTypeDefinition: ['name', 'directives', 'types'],
	  EnumTypeDefinition: ['name', 'directives', 'values'],
	  EnumValueDefinition: ['name', 'directives'],
	  InputObjectTypeDefinition: ['name', 'directives', 'fields'],

	  TypeExtensionDefinition: ['definition'],

	  DirectiveDefinition: ['name', 'arguments', 'locations']
	};

	var BREAK = exports.BREAK = {};

	/**
	 * visit() will walk through an AST using a depth first traversal, calling
	 * the visitor's enter function at each node in the traversal, and calling the
	 * leave function after visiting that node and all of its child nodes.
	 *
	 * By returning different values from the enter and leave functions, the
	 * behavior of the visitor can be altered, including skipping over a sub-tree of
	 * the AST (by returning false), editing the AST by returning a value or null
	 * to remove the value, or to stop the whole traversal by returning BREAK.
	 *
	 * When using visit() to edit an AST, the original AST will not be modified, and
	 * a new version of the AST with the changes applied will be returned from the
	 * visit function.
	 *
	 *     const editedAST = visit(ast, {
	 *       enter(node, key, parent, path, ancestors) {
	 *         // @return
	 *         //   undefined: no action
	 *         //   false: skip visiting this node
	 *         //   visitor.BREAK: stop visiting altogether
	 *         //   null: delete this node
	 *         //   any value: replace this node with the returned value
	 *       },
	 *       leave(node, key, parent, path, ancestors) {
	 *         // @return
	 *         //   undefined: no action
	 *         //   false: no action
	 *         //   visitor.BREAK: stop visiting altogether
	 *         //   null: delete this node
	 *         //   any value: replace this node with the returned value
	 *       }
	 *     });
	 *
	 * Alternatively to providing enter() and leave() functions, a visitor can
	 * instead provide functions named the same as the kinds of AST nodes, or
	 * enter/leave visitors at a named key, leading to four permutations of
	 * visitor API:
	 *
	 * 1) Named visitors triggered when entering a node a specific kind.
	 *
	 *     visit(ast, {
	 *       Kind(node) {
	 *         // enter the "Kind" node
	 *       }
	 *     })
	 *
	 * 2) Named visitors that trigger upon entering and leaving a node of
	 *    a specific kind.
	 *
	 *     visit(ast, {
	 *       Kind: {
	 *         enter(node) {
	 *           // enter the "Kind" node
	 *         }
	 *         leave(node) {
	 *           // leave the "Kind" node
	 *         }
	 *       }
	 *     })
	 *
	 * 3) Generic visitors that trigger upon entering and leaving any node.
	 *
	 *     visit(ast, {
	 *       enter(node) {
	 *         // enter any node
	 *       },
	 *       leave(node) {
	 *         // leave any node
	 *       }
	 *     })
	 *
	 * 4) Parallel visitors for entering and leaving nodes of a specific kind.
	 *
	 *     visit(ast, {
	 *       enter: {
	 *         Kind(node) {
	 *           // enter the "Kind" node
	 *         }
	 *       },
	 *       leave: {
	 *         Kind(node) {
	 *           // leave the "Kind" node
	 *         }
	 *       }
	 *     })
	 */
	function visit(root, visitor, keyMap) {
	  var visitorKeys = keyMap || QueryDocumentKeys;

	  var stack = void 0;
	  var inArray = Array.isArray(root);
	  var keys = [root];
	  var index = -1;
	  var edits = [];
	  var parent = void 0;
	  var path = [];
	  var ancestors = [];
	  var newRoot = root;

	  do {
	    index++;
	    var isLeaving = index === keys.length;
	    var key = void 0;
	    var node = void 0;
	    var isEdited = isLeaving && edits.length !== 0;
	    if (isLeaving) {
	      key = ancestors.length === 0 ? undefined : path.pop();
	      node = parent;
	      parent = ancestors.pop();
	      if (isEdited) {
	        if (inArray) {
	          node = node.slice();
	        } else {
	          var clone = {};
	          for (var k in node) {
	            if (node.hasOwnProperty(k)) {
	              clone[k] = node[k];
	            }
	          }
	          node = clone;
	        }
	        var editOffset = 0;
	        for (var ii = 0; ii < edits.length; ii++) {
	          var editKey = edits[ii][0];
	          var editValue = edits[ii][1];
	          if (inArray) {
	            editKey -= editOffset;
	          }
	          if (inArray && editValue === null) {
	            node.splice(editKey, 1);
	            editOffset++;
	          } else {
	            node[editKey] = editValue;
	          }
	        }
	      }
	      index = stack.index;
	      keys = stack.keys;
	      edits = stack.edits;
	      inArray = stack.inArray;
	      stack = stack.prev;
	    } else {
	      key = parent ? inArray ? index : keys[index] : undefined;
	      node = parent ? parent[key] : newRoot;
	      if (node === null || node === undefined) {
	        continue;
	      }
	      if (parent) {
	        path.push(key);
	      }
	    }

	    var result = void 0;
	    if (!Array.isArray(node)) {
	      if (!isNode(node)) {
	        throw new Error('Invalid AST Node: ' + JSON.stringify(node));
	      }
	      var visitFn = getVisitFn(visitor, node.kind, isLeaving);
	      if (visitFn) {
	        result = visitFn.call(visitor, node, key, parent, path, ancestors);

	        if (result === BREAK) {
	          break;
	        }

	        if (result === false) {
	          if (!isLeaving) {
	            path.pop();
	            continue;
	          }
	        } else if (result !== undefined) {
	          edits.push([key, result]);
	          if (!isLeaving) {
	            if (isNode(result)) {
	              node = result;
	            } else {
	              path.pop();
	              continue;
	            }
	          }
	        }
	      }
	    }

	    if (result === undefined && isEdited) {
	      edits.push([key, node]);
	    }

	    if (!isLeaving) {
	      stack = { inArray: inArray, index: index, keys: keys, edits: edits, prev: stack };
	      inArray = Array.isArray(node);
	      keys = inArray ? node : visitorKeys[node.kind] || [];
	      index = -1;
	      edits = [];
	      if (parent) {
	        ancestors.push(parent);
	      }
	      parent = node;
	    }
	  } while (stack !== undefined);

	  if (edits.length !== 0) {
	    newRoot = edits[edits.length - 1][1];
	  }

	  return newRoot;
	}

	function isNode(maybeNode) {
	  return maybeNode && typeof maybeNode.kind === 'string';
	}

	/**
	 * Creates a new visitor instance which delegates to many visitors to run in
	 * parallel. Each visitor will be visited for each node before moving on.
	 *
	 * If a prior visitor edits a node, no following visitors will see that node.
	 */
	function visitInParallel(visitors) {
	  var skipping = new Array(visitors.length);

	  return {
	    enter: function enter(node) {
	      for (var i = 0; i < visitors.length; i++) {
	        if (!skipping[i]) {
	          var fn = getVisitFn(visitors[i], node.kind, /* isLeaving */false);
	          if (fn) {
	            var result = fn.apply(visitors[i], arguments);
	            if (result === false) {
	              skipping[i] = node;
	            } else if (result === BREAK) {
	              skipping[i] = BREAK;
	            } else if (result !== undefined) {
	              return result;
	            }
	          }
	        }
	      }
	    },
	    leave: function leave(node) {
	      for (var i = 0; i < visitors.length; i++) {
	        if (!skipping[i]) {
	          var fn = getVisitFn(visitors[i], node.kind, /* isLeaving */true);
	          if (fn) {
	            var result = fn.apply(visitors[i], arguments);
	            if (result === BREAK) {
	              skipping[i] = BREAK;
	            } else if (result !== undefined && result !== false) {
	              return result;
	            }
	          }
	        } else if (skipping[i] === node) {
	          skipping[i] = null;
	        }
	      }
	    }
	  };
	}

	/**
	 * Creates a new visitor instance which maintains a provided TypeInfo instance
	 * along with visiting visitor.
	 */
	function visitWithTypeInfo(typeInfo, visitor) {
	  return {
	    enter: function enter(node) {
	      typeInfo.enter(node);
	      var fn = getVisitFn(visitor, node.kind, /* isLeaving */false);
	      if (fn) {
	        var result = fn.apply(visitor, arguments);
	        if (result !== undefined) {
	          typeInfo.leave(node);
	          if (isNode(result)) {
	            typeInfo.enter(result);
	          }
	        }
	        return result;
	      }
	    },
	    leave: function leave(node) {
	      var fn = getVisitFn(visitor, node.kind, /* isLeaving */true);
	      var result = void 0;
	      if (fn) {
	        result = fn.apply(visitor, arguments);
	      }
	      typeInfo.leave(node);
	      return result;
	    }
	  };
	}

	/**
	 * Given a visitor instance, if it is leaving or not, and a node kind, return
	 * the function the visitor runtime should call.
	 */
	function getVisitFn(visitor, kind, isLeaving) {
	  var kindVisitor = visitor[kind];
	  if (kindVisitor) {
	    if (!isLeaving && typeof kindVisitor === 'function') {
	      // { Kind() {} }
	      return kindVisitor;
	    }
	    var kindSpecificVisitor = isLeaving ? kindVisitor.leave : kindVisitor.enter;
	    if (typeof kindSpecificVisitor === 'function') {
	      // { Kind: { enter() {}, leave() {} } }
	      return kindSpecificVisitor;
	    }
	  } else {
	    var specificVisitor = isLeaving ? visitor.leave : visitor.enter;
	    if (specificVisitor) {
	      if (typeof specificVisitor === 'function') {
	        // { enter() {}, leave() {} }
	        return specificVisitor;
	      }
	      var specificKindVisitor = specificVisitor[kind];
	      if (typeof specificKindVisitor === 'function') {
	        // { enter: { Kind() {} }, leave: { Kind() {} } }
	        return specificKindVisitor;
	      }
	    }
	  }
	}

/***/ },
/* 15 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	// Name

	var NAME = exports.NAME = 'Name';

	// Document

	var DOCUMENT = exports.DOCUMENT = 'Document';
	var OPERATION_DEFINITION = exports.OPERATION_DEFINITION = 'OperationDefinition';
	var VARIABLE_DEFINITION = exports.VARIABLE_DEFINITION = 'VariableDefinition';
	var VARIABLE = exports.VARIABLE = 'Variable';
	var SELECTION_SET = exports.SELECTION_SET = 'SelectionSet';
	var FIELD = exports.FIELD = 'Field';
	var ARGUMENT = exports.ARGUMENT = 'Argument';

	// Fragments

	var FRAGMENT_SPREAD = exports.FRAGMENT_SPREAD = 'FragmentSpread';
	var INLINE_FRAGMENT = exports.INLINE_FRAGMENT = 'InlineFragment';
	var FRAGMENT_DEFINITION = exports.FRAGMENT_DEFINITION = 'FragmentDefinition';

	// Values

	var INT = exports.INT = 'IntValue';
	var FLOAT = exports.FLOAT = 'FloatValue';
	var STRING = exports.STRING = 'StringValue';
	var BOOLEAN = exports.BOOLEAN = 'BooleanValue';
	var ENUM = exports.ENUM = 'EnumValue';
	var LIST = exports.LIST = 'ListValue';
	var OBJECT = exports.OBJECT = 'ObjectValue';
	var OBJECT_FIELD = exports.OBJECT_FIELD = 'ObjectField';

	// Directives

	var DIRECTIVE = exports.DIRECTIVE = 'Directive';

	// Types

	var NAMED_TYPE = exports.NAMED_TYPE = 'NamedType';
	var LIST_TYPE = exports.LIST_TYPE = 'ListType';
	var NON_NULL_TYPE = exports.NON_NULL_TYPE = 'NonNullType';

	// Type System Definitions

	var SCHEMA_DEFINITION = exports.SCHEMA_DEFINITION = 'SchemaDefinition';
	var OPERATION_TYPE_DEFINITION = exports.OPERATION_TYPE_DEFINITION = 'OperationTypeDefinition';

	// Type Definitions

	var SCALAR_TYPE_DEFINITION = exports.SCALAR_TYPE_DEFINITION = 'ScalarTypeDefinition';
	var OBJECT_TYPE_DEFINITION = exports.OBJECT_TYPE_DEFINITION = 'ObjectTypeDefinition';
	var FIELD_DEFINITION = exports.FIELD_DEFINITION = 'FieldDefinition';
	var INPUT_VALUE_DEFINITION = exports.INPUT_VALUE_DEFINITION = 'InputValueDefinition';
	var INTERFACE_TYPE_DEFINITION = exports.INTERFACE_TYPE_DEFINITION = 'InterfaceTypeDefinition';
	var UNION_TYPE_DEFINITION = exports.UNION_TYPE_DEFINITION = 'UnionTypeDefinition';
	var ENUM_TYPE_DEFINITION = exports.ENUM_TYPE_DEFINITION = 'EnumTypeDefinition';
	var ENUM_VALUE_DEFINITION = exports.ENUM_VALUE_DEFINITION = 'EnumValueDefinition';
	var INPUT_OBJECT_TYPE_DEFINITION = exports.INPUT_OBJECT_TYPE_DEFINITION = 'InputObjectTypeDefinition';

	// Type Extensions

	var TYPE_EXTENSION_DEFINITION = exports.TYPE_EXTENSION_DEFINITION = 'TypeExtensionDefinition';

	// Directive Definitions

	var DIRECTIVE_DEFINITION = exports.DIRECTIVE_DEFINITION = 'DirectiveDefinition';

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.syntaxError = syntaxError;

	var _location = __webpack_require__(11);

	var _GraphQLError = __webpack_require__(9);

	/**
	 * Produces a GraphQLError representing a syntax error, containing useful
	 * descriptive information about the syntax error's position in the source.
	 */

	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	function syntaxError(source, position, description) {
	  var location = (0, _location.getLocation)(source, position);
	  var error = new _GraphQLError.GraphQLError('Syntax Error ' + source.name + ' (' + location.line + ':' + location.column + ') ' + description + '\n\n' + highlightSourceAtLocation(source, location), undefined, source, [position]);
	  return error;
	}

	/**
	 * Render a helpful description of the location of the error in the GraphQL
	 * Source document.
	 */
	function highlightSourceAtLocation(source, location) {
	  var line = location.line;
	  var prevLineNum = (line - 1).toString();
	  var lineNum = line.toString();
	  var nextLineNum = (line + 1).toString();
	  var padLen = nextLineNum.length;
	  var lines = source.body.split(/\r\n|[\n\r]/g);
	  return (line >= 2 ? lpad(padLen, prevLineNum) + ': ' + lines[line - 2] + '\n' : '') + lpad(padLen, lineNum) + ': ' + lines[line - 1] + '\n' + Array(2 + padLen + location.column).join(' ') + '^\n' + (line < lines.length ? lpad(padLen, nextLineNum) + ': ' + lines[line] + '\n' : '');
	}

	function lpad(len, str) {
	  return Array(len - str.length + 1).join(' ') + str;
	}

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.locatedError = locatedError;

	var _GraphQLError = __webpack_require__(9);

	/**
	 * Given an arbitrary Error, presumably thrown while attempting to execute a
	 * GraphQL operation, produce a new GraphQLError aware of the location in the
	 * document responsible for the original Error.
	 */
	function locatedError(originalError, nodes, path) {
	  // Note: this uses a brand-check to support GraphQL errors originating from
	  // other contexts.
	  if (originalError && originalError.locations) {
	    return originalError;
	  }

	  var message = originalError ? originalError.message || String(originalError) : 'An unknown error occurred.';
	  return new _GraphQLError.GraphQLError(message, nodes, undefined, undefined, path, originalError);
	}
	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.formatError = formatError;

	var _invariant = __webpack_require__(19);

	var _invariant2 = _interopRequireDefault(_invariant);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Given a GraphQLError, format it according to the rules described by the
	 * Response Format, Errors section of the GraphQL Specification.
	 */
	function formatError(error) {
	  (0, _invariant2.default)(error, 'Received null or undefined error.');
	  return {
	    message: error.message,
	    locations: error.locations
	  };
	}
	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

/***/ },
/* 19 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = invariant;

	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	function invariant(condition, message) {
	  if (!condition) {
	    throw new Error(message);
	  }
	}

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.ValidationContext = undefined;
	exports.validate = validate;
	exports.visitUsingRules = visitUsingRules;

	var _invariant = __webpack_require__(19);

	var _invariant2 = _interopRequireDefault(_invariant);

	var _error = __webpack_require__(8);

	var _visitor = __webpack_require__(14);

	var _kinds = __webpack_require__(15);

	var Kind = _interopRequireWildcard(_kinds);

	var _schema = __webpack_require__(21);

	var _TypeInfo = __webpack_require__(32);

	var _specifiedRules = __webpack_require__(34);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	/**
	 * Implements the "Validation" section of the spec.
	 *
	 * Validation runs synchronously, returning an array of encountered errors, or
	 * an empty array if no errors were encountered and the document is valid.
	 *
	 * A list of specific validation rules may be provided. If not provided, the
	 * default list of rules defined by the GraphQL specification will be used.
	 *
	 * Each validation rules is a function which returns a visitor
	 * (see the language/visitor API). Visitor methods are expected to return
	 * GraphQLErrors, or Arrays of GraphQLErrors when invalid.
	 */
	function validate(schema, ast, rules) {
	  (0, _invariant2.default)(schema, 'Must provide schema');
	  (0, _invariant2.default)(ast, 'Must provide document');
	  (0, _invariant2.default)(schema instanceof _schema.GraphQLSchema, 'Schema must be an instance of GraphQLSchema. Also ensure that there are ' + 'not multiple versions of GraphQL installed in your node_modules directory.');
	  var typeInfo = new _TypeInfo.TypeInfo(schema);
	  return visitUsingRules(schema, typeInfo, ast, rules || _specifiedRules.specifiedRules);
	}

	/**
	 * This uses a specialized visitor which runs multiple visitors in parallel,
	 * while maintaining the visitor skip and break API.
	 *
	 * @internal
	 */
	function visitUsingRules(schema, typeInfo, documentAST, rules) {
	  var context = new ValidationContext(schema, documentAST, typeInfo);
	  var visitors = rules.map(function (rule) {
	    return rule(context);
	  });
	  // Visit the whole document with each instance of all provided rules.
	  (0, _visitor.visit)(documentAST, (0, _visitor.visitWithTypeInfo)(typeInfo, (0, _visitor.visitInParallel)(visitors)));
	  return context.getErrors();
	}

	/**
	 * An instance of this class is passed as the "this" context to all validators,
	 * allowing access to commonly useful contextual information from within a
	 * validation rule.
	 */
	var ValidationContext = exports.ValidationContext = function () {
	  function ValidationContext(schema, ast, typeInfo) {
	    _classCallCheck(this, ValidationContext);

	    this._schema = schema;
	    this._ast = ast;
	    this._typeInfo = typeInfo;
	    this._errors = [];
	    this._fragmentSpreads = new Map();
	    this._recursivelyReferencedFragments = new Map();
	    this._variableUsages = new Map();
	    this._recursiveVariableUsages = new Map();
	  }

	  ValidationContext.prototype.reportError = function reportError(error) {
	    this._errors.push(error);
	  };

	  ValidationContext.prototype.getErrors = function getErrors() {
	    return this._errors;
	  };

	  ValidationContext.prototype.getSchema = function getSchema() {
	    return this._schema;
	  };

	  ValidationContext.prototype.getDocument = function getDocument() {
	    return this._ast;
	  };

	  ValidationContext.prototype.getFragment = function getFragment(name) {
	    var fragments = this._fragments;
	    if (!fragments) {
	      this._fragments = fragments = this.getDocument().definitions.reduce(function (frags, statement) {
	        if (statement.kind === Kind.FRAGMENT_DEFINITION) {
	          frags[statement.name.value] = statement;
	        }
	        return frags;
	      }, {});
	    }
	    return fragments[name];
	  };

	  ValidationContext.prototype.getFragmentSpreads = function getFragmentSpreads(node) {
	    var spreads = this._fragmentSpreads.get(node);
	    if (!spreads) {
	      spreads = [];
	      var setsToVisit = [node];
	      while (setsToVisit.length !== 0) {
	        var set = setsToVisit.pop();
	        for (var i = 0; i < set.selections.length; i++) {
	          var selection = set.selections[i];
	          if (selection.kind === Kind.FRAGMENT_SPREAD) {
	            spreads.push(selection);
	          } else if (selection.selectionSet) {
	            setsToVisit.push(selection.selectionSet);
	          }
	        }
	      }
	      this._fragmentSpreads.set(node, spreads);
	    }
	    return spreads;
	  };

	  ValidationContext.prototype.getRecursivelyReferencedFragments = function getRecursivelyReferencedFragments(operation) {
	    var fragments = this._recursivelyReferencedFragments.get(operation);
	    if (!fragments) {
	      fragments = [];
	      var collectedNames = Object.create(null);
	      var nodesToVisit = [operation.selectionSet];
	      while (nodesToVisit.length !== 0) {
	        var _node = nodesToVisit.pop();
	        var spreads = this.getFragmentSpreads(_node);
	        for (var i = 0; i < spreads.length; i++) {
	          var fragName = spreads[i].name.value;
	          if (collectedNames[fragName] !== true) {
	            collectedNames[fragName] = true;
	            var fragment = this.getFragment(fragName);
	            if (fragment) {
	              fragments.push(fragment);
	              nodesToVisit.push(fragment.selectionSet);
	            }
	          }
	        }
	      }
	      this._recursivelyReferencedFragments.set(operation, fragments);
	    }
	    return fragments;
	  };

	  ValidationContext.prototype.getVariableUsages = function getVariableUsages(node) {
	    var _this = this;

	    var usages = this._variableUsages.get(node);
	    if (!usages) {
	      (function () {
	        var newUsages = [];
	        var typeInfo = new _TypeInfo.TypeInfo(_this._schema);
	        (0, _visitor.visit)(node, (0, _visitor.visitWithTypeInfo)(typeInfo, {
	          VariableDefinition: function VariableDefinition() {
	            return false;
	          },
	          Variable: function Variable(variable) {
	            newUsages.push({ node: variable, type: typeInfo.getInputType() });
	          }
	        }));
	        usages = newUsages;
	        _this._variableUsages.set(node, usages);
	      })();
	    }
	    return usages;
	  };

	  ValidationContext.prototype.getRecursiveVariableUsages = function getRecursiveVariableUsages(operation) {
	    var usages = this._recursiveVariableUsages.get(operation);
	    if (!usages) {
	      usages = this.getVariableUsages(operation);
	      var fragments = this.getRecursivelyReferencedFragments(operation);
	      for (var i = 0; i < fragments.length; i++) {
	        Array.prototype.push.apply(usages, this.getVariableUsages(fragments[i]));
	      }
	      this._recursiveVariableUsages.set(operation, usages);
	    }
	    return usages;
	  };

	  ValidationContext.prototype.getType = function getType() {
	    return this._typeInfo.getType();
	  };

	  ValidationContext.prototype.getParentType = function getParentType() {
	    return this._typeInfo.getParentType();
	  };

	  ValidationContext.prototype.getInputType = function getInputType() {
	    return this._typeInfo.getInputType();
	  };

	  ValidationContext.prototype.getFieldDef = function getFieldDef() {
	    return this._typeInfo.getFieldDef();
	  };

	  ValidationContext.prototype.getDirective = function getDirective() {
	    return this._typeInfo.getDirective();
	  };

	  ValidationContext.prototype.getArgument = function getArgument() {
	    return this._typeInfo.getArgument();
	  };

	  return ValidationContext;
	}();

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.GraphQLSchema = undefined;

	var _definition = __webpack_require__(22);

	var _directives = __webpack_require__(25);

	var _introspection = __webpack_require__(27);

	var _find = __webpack_require__(30);

	var _find2 = _interopRequireDefault(_find);

	var _invariant = __webpack_require__(19);

	var _invariant2 = _interopRequireDefault(_invariant);

	var _typeComparators = __webpack_require__(31);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	/**
	 * Schema Definition
	 *
	 * A Schema is created by supplying the root types of each type of operation,
	 * query and mutation (optional). A schema definition is then supplied to the
	 * validator and executor.
	 *
	 * Example:
	 *
	 *     const MyAppSchema = new GraphQLSchema({
	 *       query: MyAppQueryRootType,
	 *       mutation: MyAppMutationRootType,
	 *     })
	 *
	 * Note: If an array of `directives` are provided to GraphQLSchema, that will be
	 * the exact list of directives represented and allowed. If `directives` is not
	 * provided then a default set of the specified directives (e.g. @include and
	 * @skip) will be used. If you wish to provide *additional* directives to these
	 * specified directives, you must explicitly declare them. Example:
	 *
	 *     const MyAppSchema = new GraphQLSchema({
	 *       ...
	 *       directives: specifiedDirectives.concat([ myCustomDirective ]),
	 *     })
	 *
	 */
	var GraphQLSchema = exports.GraphQLSchema = function () {
	  function GraphQLSchema(config) {
	    var _this = this;

	    _classCallCheck(this, GraphQLSchema);

	    (0, _invariant2.default)(typeof config === 'object', 'Must provide configuration object.');

	    (0, _invariant2.default)(config.query instanceof _definition.GraphQLObjectType, 'Schema query must be Object Type but got: ' + String(config.query) + '.');
	    this._queryType = config.query;

	    (0, _invariant2.default)(!config.mutation || config.mutation instanceof _definition.GraphQLObjectType, 'Schema mutation must be Object Type if provided but got: ' + String(config.mutation) + '.');
	    this._mutationType = config.mutation;

	    (0, _invariant2.default)(!config.subscription || config.subscription instanceof _definition.GraphQLObjectType, 'Schema subscription must be Object Type if provided but got: ' + String(config.subscription) + '.');
	    this._subscriptionType = config.subscription;

	    (0, _invariant2.default)(!config.types || Array.isArray(config.types), 'Schema types must be Array if provided but got: ' + String(config.types) + '.');

	    (0, _invariant2.default)(!config.directives || Array.isArray(config.directives) && config.directives.every(function (directive) {
	      return directive instanceof _directives.GraphQLDirective;
	    }), 'Schema directives must be Array<GraphQLDirective> if provided but got: ' + String(config.directives) + '.');
	    // Provide specified directives (e.g. @include and @skip) by default.
	    this._directives = config.directives || _directives.specifiedDirectives;

	    // Build type map now to detect any errors within this schema.
	    var initialTypes = [this.getQueryType(), this.getMutationType(), this.getSubscriptionType(), _introspection.__Schema];

	    var types = config.types;
	    if (types) {
	      initialTypes = initialTypes.concat(types);
	    }

	    this._typeMap = initialTypes.reduce(typeMapReducer, Object.create(null));

	    // Keep track of all implementations by interface name.
	    this._implementations = Object.create(null);
	    Object.keys(this._typeMap).forEach(function (typeName) {
	      var type = _this._typeMap[typeName];
	      if (type instanceof _definition.GraphQLObjectType) {
	        type.getInterfaces().forEach(function (iface) {
	          var impls = _this._implementations[iface.name];
	          if (impls) {
	            impls.push(type);
	          } else {
	            _this._implementations[iface.name] = [type];
	          }
	        });
	      }
	    });

	    // Enforce correct interface implementations.
	    Object.keys(this._typeMap).forEach(function (typeName) {
	      var type = _this._typeMap[typeName];
	      if (type instanceof _definition.GraphQLObjectType) {
	        type.getInterfaces().forEach(function (iface) {
	          return assertObjectImplementsInterface(_this, type, iface);
	        });
	      }
	    });
	  }

	  GraphQLSchema.prototype.getQueryType = function getQueryType() {
	    return this._queryType;
	  };

	  GraphQLSchema.prototype.getMutationType = function getMutationType() {
	    return this._mutationType;
	  };

	  GraphQLSchema.prototype.getSubscriptionType = function getSubscriptionType() {
	    return this._subscriptionType;
	  };

	  GraphQLSchema.prototype.getTypeMap = function getTypeMap() {
	    return this._typeMap;
	  };

	  GraphQLSchema.prototype.getType = function getType(name) {
	    return this.getTypeMap()[name];
	  };

	  GraphQLSchema.prototype.getPossibleTypes = function getPossibleTypes(abstractType) {
	    if (abstractType instanceof _definition.GraphQLUnionType) {
	      return abstractType.getTypes();
	    }
	    (0, _invariant2.default)(abstractType instanceof _definition.GraphQLInterfaceType);
	    return this._implementations[abstractType.name];
	  };

	  GraphQLSchema.prototype.isPossibleType = function isPossibleType(abstractType, possibleType) {
	    var possibleTypeMap = this._possibleTypeMap;
	    if (!possibleTypeMap) {
	      this._possibleTypeMap = possibleTypeMap = Object.create(null);
	    }

	    if (!possibleTypeMap[abstractType.name]) {
	      var possibleTypes = this.getPossibleTypes(abstractType);
	      (0, _invariant2.default)(Array.isArray(possibleTypes), 'Could not find possible implementing types for ' + abstractType.name + ' ' + 'in schema. Check that schema.types is defined and is an array of ' + 'all possible types in the schema.');
	      possibleTypeMap[abstractType.name] = possibleTypes.reduce(function (map, type) {
	        return map[type.name] = true, map;
	      }, Object.create(null));
	    }

	    return Boolean(possibleTypeMap[abstractType.name][possibleType.name]);
	  };

	  GraphQLSchema.prototype.getDirectives = function getDirectives() {
	    return this._directives;
	  };

	  GraphQLSchema.prototype.getDirective = function getDirective(name) {
	    return (0, _find2.default)(this.getDirectives(), function (directive) {
	      return directive.name === name;
	    });
	  };

	  return GraphQLSchema;
	}();

	function typeMapReducer(map, type) {
	  if (!type) {
	    return map;
	  }
	  if (type instanceof _definition.GraphQLList || type instanceof _definition.GraphQLNonNull) {
	    return typeMapReducer(map, type.ofType);
	  }
	  if (map[type.name]) {
	    (0, _invariant2.default)(map[type.name] === type, 'Schema must contain unique named types but contains multiple ' + ('types named "' + type.name + '".'));
	    return map;
	  }
	  map[type.name] = type;

	  var reducedMap = map;

	  if (type instanceof _definition.GraphQLUnionType) {
	    reducedMap = type.getTypes().reduce(typeMapReducer, reducedMap);
	  }

	  if (type instanceof _definition.GraphQLObjectType) {
	    reducedMap = type.getInterfaces().reduce(typeMapReducer, reducedMap);
	  }

	  if (type instanceof _definition.GraphQLObjectType || type instanceof _definition.GraphQLInterfaceType) {
	    (function () {
	      var fieldMap = type.getFields();
	      Object.keys(fieldMap).forEach(function (fieldName) {
	        var field = fieldMap[fieldName];

	        if (field.args) {
	          var fieldArgTypes = field.args.map(function (arg) {
	            return arg.type;
	          });
	          reducedMap = fieldArgTypes.reduce(typeMapReducer, reducedMap);
	        }
	        reducedMap = typeMapReducer(reducedMap, field.type);
	      });
	    })();
	  }

	  if (type instanceof _definition.GraphQLInputObjectType) {
	    (function () {
	      var fieldMap = type.getFields();
	      Object.keys(fieldMap).forEach(function (fieldName) {
	        var field = fieldMap[fieldName];
	        reducedMap = typeMapReducer(reducedMap, field.type);
	      });
	    })();
	  }

	  return reducedMap;
	}

	function assertObjectImplementsInterface(schema, object, iface) {
	  var objectFieldMap = object.getFields();
	  var ifaceFieldMap = iface.getFields();

	  // Assert each interface field is implemented.
	  Object.keys(ifaceFieldMap).forEach(function (fieldName) {
	    var objectField = objectFieldMap[fieldName];
	    var ifaceField = ifaceFieldMap[fieldName];

	    // Assert interface field exists on object.
	    (0, _invariant2.default)(objectField, '"' + iface.name + '" expects field "' + fieldName + '" but "' + object.name + '" ' + 'does not provide it.');

	    // Assert interface field type is satisfied by object field type, by being
	    // a valid subtype. (covariant)
	    (0, _invariant2.default)((0, _typeComparators.isTypeSubTypeOf)(schema, objectField.type, ifaceField.type), iface.name + '.' + fieldName + ' expects type "' + String(ifaceField.type) + '" ' + 'but ' + (object.name + '.' + fieldName + ' provides type "' + String(objectField.type) + '".'));

	    // Assert each interface field arg is implemented.
	    ifaceField.args.forEach(function (ifaceArg) {
	      var argName = ifaceArg.name;
	      var objectArg = (0, _find2.default)(objectField.args, function (arg) {
	        return arg.name === argName;
	      });

	      // Assert interface field arg exists on object field.
	      (0, _invariant2.default)(objectArg, iface.name + '.' + fieldName + ' expects argument "' + argName + '" but ' + (object.name + '.' + fieldName + ' does not provide it.'));

	      // Assert interface field arg type matches object field arg type.
	      // (invariant)
	      (0, _invariant2.default)((0, _typeComparators.isEqualType)(ifaceArg.type, objectArg.type), iface.name + '.' + fieldName + '(' + argName + ':) expects type ' + ('"' + String(ifaceArg.type) + '" but ') + (object.name + '.' + fieldName + '(' + argName + ':) provides type ') + ('"' + String(objectArg.type) + '".'));
	    });

	    // Assert additional arguments must not be required.
	    objectField.args.forEach(function (objectArg) {
	      var argName = objectArg.name;
	      var ifaceArg = (0, _find2.default)(ifaceField.args, function (arg) {
	        return arg.name === argName;
	      });
	      if (!ifaceArg) {
	        (0, _invariant2.default)(!(objectArg.type instanceof _definition.GraphQLNonNull), object.name + '.' + fieldName + '(' + argName + ':) is of required type ' + ('"' + String(objectArg.type) + '" but is not also provided by the ') + ('interface ' + iface.name + '.' + fieldName + '.'));
	      }
	    });
	  });
	}

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.GraphQLNonNull = exports.GraphQLList = exports.GraphQLInputObjectType = exports.GraphQLEnumType = exports.GraphQLUnionType = exports.GraphQLInterfaceType = exports.GraphQLObjectType = exports.GraphQLScalarType = undefined;

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	exports.isType = isType;
	exports.isInputType = isInputType;
	exports.isOutputType = isOutputType;
	exports.isLeafType = isLeafType;
	exports.isCompositeType = isCompositeType;
	exports.isAbstractType = isAbstractType;
	exports.getNullableType = getNullableType;
	exports.getNamedType = getNamedType;

	var _invariant = __webpack_require__(19);

	var _invariant2 = _interopRequireDefault(_invariant);

	var _isNullish = __webpack_require__(23);

	var _isNullish2 = _interopRequireDefault(_isNullish);

	var _kinds = __webpack_require__(15);

	var _assertValidName = __webpack_require__(24);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	// Predicates

	/**
	 * These are all of the possible kinds of types.
	 */
	function isType(type) {
	  return type instanceof GraphQLScalarType || type instanceof GraphQLObjectType || type instanceof GraphQLInterfaceType || type instanceof GraphQLUnionType || type instanceof GraphQLEnumType || type instanceof GraphQLInputObjectType || type instanceof GraphQLList || type instanceof GraphQLNonNull;
	}

	/**
	 * These types may be used as input types for arguments and directives.
	 */
	function isInputType(type) {
	  var namedType = getNamedType(type);
	  return namedType instanceof GraphQLScalarType || namedType instanceof GraphQLEnumType || namedType instanceof GraphQLInputObjectType;
	}

	/**
	 * These types may be used as output types as the result of fields.
	 */
	function isOutputType(type) {
	  var namedType = getNamedType(type);
	  return namedType instanceof GraphQLScalarType || namedType instanceof GraphQLObjectType || namedType instanceof GraphQLInterfaceType || namedType instanceof GraphQLUnionType || namedType instanceof GraphQLEnumType;
	}

	/**
	 * These types may describe types which may be leaf values.
	 */
	function isLeafType(type) {
	  var namedType = getNamedType(type);
	  return namedType instanceof GraphQLScalarType || namedType instanceof GraphQLEnumType;
	}

	/**
	 * These types may describe the parent context of a selection set.
	 */
	function isCompositeType(type) {
	  return type instanceof GraphQLObjectType || type instanceof GraphQLInterfaceType || type instanceof GraphQLUnionType;
	}

	/**
	 * These types may describe the parent context of a selection set.
	 */
	function isAbstractType(type) {
	  return type instanceof GraphQLInterfaceType || type instanceof GraphQLUnionType;
	}

	/**
	 * These types can all accept null as a value.
	 */
	function getNullableType(type) {
	  return type instanceof GraphQLNonNull ? type.ofType : type;
	}

	/**
	 * These named types do not include modifiers like List or NonNull.
	 */
	function getNamedType(type) {
	  var unmodifiedType = type;
	  while (unmodifiedType instanceof GraphQLList || unmodifiedType instanceof GraphQLNonNull) {
	    unmodifiedType = unmodifiedType.ofType;
	  }
	  return unmodifiedType;
	}

	/**
	 * Used while defining GraphQL types to allow for circular references in
	 * otherwise immutable type definitions.
	 */


	function resolveThunk(thunk) {
	  return typeof thunk === 'function' ? thunk() : thunk;
	}

	/**
	 * Scalar Type Definition
	 *
	 * The leaf values of any request and input values to arguments are
	 * Scalars (or Enums) and are defined with a name and a series of functions
	 * used to parse input from ast or variables and to ensure validity.
	 *
	 * Example:
	 *
	 *     const OddType = new GraphQLScalarType({
	 *       name: 'Odd',
	 *       serialize(value) {
	 *         return value % 2 === 1 ? value : null;
	 *       }
	 *     });
	 *
	 */

	var GraphQLScalarType = exports.GraphQLScalarType = function () {
	  function GraphQLScalarType(config) {
	    _classCallCheck(this, GraphQLScalarType);

	    (0, _invariant2.default)(config.name, 'Type must be named.');
	    (0, _assertValidName.assertValidName)(config.name);
	    this.name = config.name;
	    this.description = config.description;
	    (0, _invariant2.default)(typeof config.serialize === 'function', this.name + ' must provide "serialize" function. If this custom Scalar ' + 'is also used as an input type, ensure "parseValue" and "parseLiteral" ' + 'functions are also provided.');
	    if (config.parseValue || config.parseLiteral) {
	      (0, _invariant2.default)(typeof config.parseValue === 'function' && typeof config.parseLiteral === 'function', this.name + ' must provide both "parseValue" and "parseLiteral" ' + 'functions.');
	    }
	    this._scalarConfig = config;
	  }

	  // Serializes an internal value to include in a response.


	  GraphQLScalarType.prototype.serialize = function serialize(value) {
	    var serializer = this._scalarConfig.serialize;
	    return serializer(value);
	  };

	  // Parses an externally provided value to use as an input.


	  GraphQLScalarType.prototype.parseValue = function parseValue(value) {
	    var parser = this._scalarConfig.parseValue;
	    return parser ? parser(value) : null;
	  };

	  // Parses an externally provided literal value to use as an input.


	  GraphQLScalarType.prototype.parseLiteral = function parseLiteral(valueAST) {
	    var parser = this._scalarConfig.parseLiteral;
	    return parser ? parser(valueAST) : null;
	  };

	  GraphQLScalarType.prototype.toString = function toString() {
	    return this.name;
	  };

	  return GraphQLScalarType;
	}();

	/**
	 * Object Type Definition
	 *
	 * Almost all of the GraphQL types you define will be object types. Object types
	 * have a name, but most importantly describe their fields.
	 *
	 * Example:
	 *
	 *     const AddressType = new GraphQLObjectType({
	 *       name: 'Address',
	 *       fields: {
	 *         street: { type: GraphQLString },
	 *         number: { type: GraphQLInt },
	 *         formatted: {
	 *           type: GraphQLString,
	 *           resolve(obj) {
	 *             return obj.number + ' ' + obj.street
	 *           }
	 *         }
	 *       }
	 *     });
	 *
	 * When two types need to refer to each other, or a type needs to refer to
	 * itself in a field, you can use a function expression (aka a closure or a
	 * thunk) to supply the fields lazily.
	 *
	 * Example:
	 *
	 *     const PersonType = new GraphQLObjectType({
	 *       name: 'Person',
	 *       fields: () => ({
	 *         name: { type: GraphQLString },
	 *         bestFriend: { type: PersonType },
	 *       })
	 *     });
	 *
	 */
	var GraphQLObjectType = exports.GraphQLObjectType = function () {
	  function GraphQLObjectType(config) {
	    _classCallCheck(this, GraphQLObjectType);

	    (0, _invariant2.default)(config.name, 'Type must be named.');
	    (0, _assertValidName.assertValidName)(config.name);
	    this.name = config.name;
	    this.description = config.description;
	    if (config.isTypeOf) {
	      (0, _invariant2.default)(typeof config.isTypeOf === 'function', this.name + ' must provide "isTypeOf" as a function.');
	    }
	    this.isTypeOf = config.isTypeOf;
	    this._typeConfig = config;
	  }

	  GraphQLObjectType.prototype.getFields = function getFields() {
	    return this._fields || (this._fields = defineFieldMap(this, this._typeConfig.fields));
	  };

	  GraphQLObjectType.prototype.getInterfaces = function getInterfaces() {
	    return this._interfaces || (this._interfaces = defineInterfaces(this, this._typeConfig.interfaces));
	  };

	  GraphQLObjectType.prototype.toString = function toString() {
	    return this.name;
	  };

	  return GraphQLObjectType;
	}();

	function defineInterfaces(type, interfacesThunk) {
	  var interfaces = resolveThunk(interfacesThunk);
	  if (!interfaces) {
	    return [];
	  }
	  (0, _invariant2.default)(Array.isArray(interfaces), type.name + ' interfaces must be an Array or a function which returns ' + 'an Array.');
	  interfaces.forEach(function (iface) {
	    (0, _invariant2.default)(iface instanceof GraphQLInterfaceType, type.name + ' may only implement Interface types, it cannot ' + ('implement: ' + String(iface) + '.'));
	    if (typeof iface.resolveType !== 'function') {
	      (0, _invariant2.default)(typeof type.isTypeOf === 'function', 'Interface Type ' + iface.name + ' does not provide a "resolveType" ' + ('function and implementing Type ' + type.name + ' does not provide a ') + '"isTypeOf" function. There is no way to resolve this implementing ' + 'type during execution.');
	    }
	  });
	  return interfaces;
	}

	function defineFieldMap(type, fieldsThunk) {
	  var fieldMap = resolveThunk(fieldsThunk);
	  (0, _invariant2.default)(isPlainObj(fieldMap), type.name + ' fields must be an object with field names as keys or a ' + 'function which returns such an object.');

	  var fieldNames = Object.keys(fieldMap);
	  (0, _invariant2.default)(fieldNames.length > 0, type.name + ' fields must be an object with field names as keys or a ' + 'function which returns such an object.');

	  var resultFieldMap = {};
	  fieldNames.forEach(function (fieldName) {
	    (0, _assertValidName.assertValidName)(fieldName);
	    var fieldConfig = fieldMap[fieldName];
	    (0, _invariant2.default)(!fieldConfig.hasOwnProperty('isDeprecated'), type.name + '.' + fieldName + ' should provide "deprecationReason" instead ' + 'of "isDeprecated".');
	    var field = _extends({}, fieldConfig, {
	      isDeprecated: Boolean(fieldConfig.deprecationReason),
	      name: fieldName
	    });
	    (0, _invariant2.default)(isOutputType(field.type), type.name + '.' + fieldName + ' field type must be Output Type but ' + ('got: ' + String(field.type) + '.'));
	    var argsConfig = fieldConfig.args;
	    if (!argsConfig) {
	      field.args = [];
	    } else {
	      (0, _invariant2.default)(isPlainObj(argsConfig), type.name + '.' + fieldName + ' args must be an object with argument ' + 'names as keys.');
	      field.args = Object.keys(argsConfig).map(function (argName) {
	        (0, _assertValidName.assertValidName)(argName);
	        var arg = argsConfig[argName];
	        (0, _invariant2.default)(isInputType(arg.type), type.name + '.' + fieldName + '(' + argName + ':) argument type must be ' + ('Input Type but got: ' + String(arg.type) + '.'));
	        return {
	          name: argName,
	          description: arg.description === undefined ? null : arg.description,
	          type: arg.type,
	          defaultValue: arg.defaultValue === undefined ? null : arg.defaultValue
	        };
	      });
	    }
	    resultFieldMap[fieldName] = field;
	  });
	  return resultFieldMap;
	}

	function isPlainObj(obj) {
	  return obj && typeof obj === 'object' && !Array.isArray(obj);
	}

	/**
	 * Interface Type Definition
	 *
	 * When a field can return one of a heterogeneous set of types, a Interface type
	 * is used to describe what types are possible, what fields are in common across
	 * all types, as well as a function to determine which type is actually used
	 * when the field is resolved.
	 *
	 * Example:
	 *
	 *     const EntityType = new GraphQLInterfaceType({
	 *       name: 'Entity',
	 *       fields: {
	 *         name: { type: GraphQLString }
	 *       }
	 *     });
	 *
	 */
	var GraphQLInterfaceType = exports.GraphQLInterfaceType = function () {
	  function GraphQLInterfaceType(config) {
	    _classCallCheck(this, GraphQLInterfaceType);

	    (0, _invariant2.default)(config.name, 'Type must be named.');
	    (0, _assertValidName.assertValidName)(config.name);
	    this.name = config.name;
	    this.description = config.description;
	    if (config.resolveType) {
	      (0, _invariant2.default)(typeof config.resolveType === 'function', this.name + ' must provide "resolveType" as a function.');
	    }
	    this.resolveType = config.resolveType;
	    this._typeConfig = config;
	  }

	  GraphQLInterfaceType.prototype.getFields = function getFields() {
	    return this._fields || (this._fields = defineFieldMap(this, this._typeConfig.fields));
	  };

	  GraphQLInterfaceType.prototype.toString = function toString() {
	    return this.name;
	  };

	  return GraphQLInterfaceType;
	}();

	/**
	 * Union Type Definition
	 *
	 * When a field can return one of a heterogeneous set of types, a Union type
	 * is used to describe what types are possible as well as providing a function
	 * to determine which type is actually used when the field is resolved.
	 *
	 * Example:
	 *
	 *     const PetType = new GraphQLUnionType({
	 *       name: 'Pet',
	 *       types: [ DogType, CatType ],
	 *       resolveType(value) {
	 *         if (value instanceof Dog) {
	 *           return DogType;
	 *         }
	 *         if (value instanceof Cat) {
	 *           return CatType;
	 *         }
	 *       }
	 *     });
	 *
	 */
	var GraphQLUnionType = exports.GraphQLUnionType = function () {
	  function GraphQLUnionType(config) {
	    _classCallCheck(this, GraphQLUnionType);

	    (0, _invariant2.default)(config.name, 'Type must be named.');
	    (0, _assertValidName.assertValidName)(config.name);
	    this.name = config.name;
	    this.description = config.description;
	    if (config.resolveType) {
	      (0, _invariant2.default)(typeof config.resolveType === 'function', this.name + ' must provide "resolveType" as a function.');
	    }
	    this.resolveType = config.resolveType;
	    this._typeConfig = config;
	  }

	  GraphQLUnionType.prototype.getTypes = function getTypes() {
	    return this._types || (this._types = defineTypes(this, this._typeConfig.types));
	  };

	  GraphQLUnionType.prototype.toString = function toString() {
	    return this.name;
	  };

	  return GraphQLUnionType;
	}();

	function defineTypes(unionType, typesThunk) {
	  var types = resolveThunk(typesThunk);

	  (0, _invariant2.default)(Array.isArray(types) && types.length > 0, 'Must provide Array of types or a function which returns ' + ('such an array for Union ' + unionType.name + '.'));
	  types.forEach(function (objType) {
	    (0, _invariant2.default)(objType instanceof GraphQLObjectType, unionType.name + ' may only contain Object types, it cannot contain: ' + (String(objType) + '.'));
	    if (typeof unionType.resolveType !== 'function') {
	      (0, _invariant2.default)(typeof objType.isTypeOf === 'function', 'Union type "' + unionType.name + '" does not provide a "resolveType" ' + ('function and possible type "' + objType.name + '" does not provide an ') + '"isTypeOf" function. There is no way to resolve this possible type ' + 'during execution.');
	    }
	  });

	  return types;
	}

	/**
	 * Enum Type Definition
	 *
	 * Some leaf values of requests and input values are Enums. GraphQL serializes
	 * Enum values as strings, however internally Enums can be represented by any
	 * kind of type, often integers.
	 *
	 * Example:
	 *
	 *     const RGBType = new GraphQLEnumType({
	 *       name: 'RGB',
	 *       values: {
	 *         RED: { value: 0 },
	 *         GREEN: { value: 1 },
	 *         BLUE: { value: 2 }
	 *       }
	 *     });
	 *
	 * Note: If a value is not provided in a definition, the name of the enum value
	 * will be used as its internal value.
	 */
	var GraphQLEnumType /* <T> */ = exports.GraphQLEnumType = function () {
	  function GraphQLEnumType(config /* <T> */) {
	    _classCallCheck(this, GraphQLEnumType);

	    this.name = config.name;
	    (0, _assertValidName.assertValidName)(config.name);
	    this.description = config.description;
	    this._values = defineEnumValues(this, config.values);
	    this._enumConfig = config;
	  }

	  GraphQLEnumType.prototype.getValues = function getValues() {
	    return this._values;
	  };

	  GraphQLEnumType.prototype.serialize = function serialize(value /* T */) {
	    var enumValue = this._getValueLookup().get(value);
	    return enumValue ? enumValue.name : null;
	  };

	  GraphQLEnumType.prototype.parseValue = function parseValue(value) /* T */{
	    if (typeof value === 'string') {
	      var enumValue = this._getNameLookup()[value];
	      if (enumValue) {
	        return enumValue.value;
	      }
	    }
	  };

	  GraphQLEnumType.prototype.parseLiteral = function parseLiteral(valueAST) /* T */{
	    if (valueAST.kind === _kinds.ENUM) {
	      var enumValue = this._getNameLookup()[valueAST.value];
	      if (enumValue) {
	        return enumValue.value;
	      }
	    }
	  };

	  GraphQLEnumType.prototype._getValueLookup = function _getValueLookup() {
	    var _this = this;

	    if (!this._valueLookup) {
	      (function () {
	        var lookup = new Map();
	        _this.getValues().forEach(function (value) {
	          lookup.set(value.value, value);
	        });
	        _this._valueLookup = lookup;
	      })();
	    }
	    return this._valueLookup;
	  };

	  GraphQLEnumType.prototype._getNameLookup = function _getNameLookup() {
	    var _this2 = this;

	    if (!this._nameLookup) {
	      (function () {
	        var lookup = Object.create(null);
	        _this2.getValues().forEach(function (value) {
	          lookup[value.name] = value;
	        });
	        _this2._nameLookup = lookup;
	      })();
	    }
	    return this._nameLookup;
	  };

	  GraphQLEnumType.prototype.toString = function toString() {
	    return this.name;
	  };

	  return GraphQLEnumType;
	}();

	function defineEnumValues(type, valueMap /* <T> */
	) {
	  (0, _invariant2.default)(isPlainObj(valueMap), type.name + ' values must be an object with value names as keys.');
	  var valueNames = Object.keys(valueMap);
	  (0, _invariant2.default)(valueNames.length > 0, type.name + ' values must be an object with value names as keys.');
	  return valueNames.map(function (valueName) {
	    (0, _assertValidName.assertValidName)(valueName);
	    var value = valueMap[valueName];
	    (0, _invariant2.default)(isPlainObj(value), type.name + '.' + valueName + ' must refer to an object with a "value" key ' + ('representing an internal value but got: ' + String(value) + '.'));
	    (0, _invariant2.default)(!value.hasOwnProperty('isDeprecated'), type.name + '.' + valueName + ' should provide "deprecationReason" instead ' + 'of "isDeprecated".');
	    return {
	      name: valueName,
	      description: value.description,
	      isDeprecated: Boolean(value.deprecationReason),
	      deprecationReason: value.deprecationReason,
	      value: (0, _isNullish2.default)(value.value) ? valueName : value.value
	    };
	  });
	} /* <T> */


	/**
	 * Input Object Type Definition
	 *
	 * An input object defines a structured collection of fields which may be
	 * supplied to a field argument.
	 *
	 * Using `NonNull` will ensure that a value must be provided by the query
	 *
	 * Example:
	 *
	 *     const GeoPoint = new GraphQLInputObjectType({
	 *       name: 'GeoPoint',
	 *       fields: {
	 *         lat: { type: new GraphQLNonNull(GraphQLFloat) },
	 *         lon: { type: new GraphQLNonNull(GraphQLFloat) },
	 *         alt: { type: GraphQLFloat, defaultValue: 0 },
	 *       }
	 *     });
	 *
	 */
	var GraphQLInputObjectType = exports.GraphQLInputObjectType = function () {
	  function GraphQLInputObjectType(config) {
	    _classCallCheck(this, GraphQLInputObjectType);

	    (0, _invariant2.default)(config.name, 'Type must be named.');
	    (0, _assertValidName.assertValidName)(config.name);
	    this.name = config.name;
	    this.description = config.description;
	    this._typeConfig = config;
	  }

	  GraphQLInputObjectType.prototype.getFields = function getFields() {
	    return this._fields || (this._fields = this._defineFieldMap());
	  };

	  GraphQLInputObjectType.prototype._defineFieldMap = function _defineFieldMap() {
	    var _this3 = this;

	    var fieldMap = resolveThunk(this._typeConfig.fields);
	    (0, _invariant2.default)(isPlainObj(fieldMap), this.name + ' fields must be an object with field names as keys or a ' + 'function which returns such an object.');
	    var fieldNames = Object.keys(fieldMap);
	    (0, _invariant2.default)(fieldNames.length > 0, this.name + ' fields must be an object with field names as keys or a ' + 'function which returns such an object.');
	    var resultFieldMap = {};
	    fieldNames.forEach(function (fieldName) {
	      (0, _assertValidName.assertValidName)(fieldName);
	      var field = _extends({}, fieldMap[fieldName], {
	        name: fieldName
	      });
	      (0, _invariant2.default)(isInputType(field.type), _this3.name + '.' + fieldName + ' field type must be Input Type but ' + ('got: ' + String(field.type) + '.'));
	      resultFieldMap[fieldName] = field;
	    });
	    return resultFieldMap;
	  };

	  GraphQLInputObjectType.prototype.toString = function toString() {
	    return this.name;
	  };

	  return GraphQLInputObjectType;
	}();

	/**
	 * List Modifier
	 *
	 * A list is a kind of type marker, a wrapping type which points to another
	 * type. Lists are often created within the context of defining the fields of
	 * an object type.
	 *
	 * Example:
	 *
	 *     const PersonType = new GraphQLObjectType({
	 *       name: 'Person',
	 *       fields: () => ({
	 *         parents: { type: new GraphQLList(Person) },
	 *         children: { type: new GraphQLList(Person) },
	 *       })
	 *     })
	 *
	 */
	var GraphQLList = exports.GraphQLList = function () {
	  function GraphQLList(type) {
	    _classCallCheck(this, GraphQLList);

	    (0, _invariant2.default)(isType(type), 'Can only create List of a GraphQLType but got: ' + String(type) + '.');
	    this.ofType = type;
	  }

	  GraphQLList.prototype.toString = function toString() {
	    return '[' + String(this.ofType) + ']';
	  };

	  return GraphQLList;
	}();

	/**
	 * Non-Null Modifier
	 *
	 * A non-null is a kind of type marker, a wrapping type which points to another
	 * type. Non-null types enforce that their values are never null and can ensure
	 * an error is raised if this ever occurs during a request. It is useful for
	 * fields which you can make a strong guarantee on non-nullability, for example
	 * usually the id field of a database row will never be null.
	 *
	 * Example:
	 *
	 *     const RowType = new GraphQLObjectType({
	 *       name: 'Row',
	 *       fields: () => ({
	 *         id: { type: new GraphQLNonNull(GraphQLString) },
	 *       })
	 *     })
	 *
	 * Note: the enforcement of non-nullability occurs within the executor.
	 */


	var GraphQLNonNull = exports.GraphQLNonNull = function () {
	  function GraphQLNonNull(type) {
	    _classCallCheck(this, GraphQLNonNull);

	    (0, _invariant2.default)(isType(type) && !(type instanceof GraphQLNonNull), 'Can only create NonNull of a Nullable GraphQLType but got: ' + (String(type) + '.'));
	    this.ofType = type;
	  }

	  GraphQLNonNull.prototype.toString = function toString() {
	    return this.ofType.toString() + '!';
	  };

	  return GraphQLNonNull;
	}();

/***/ },
/* 23 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isNullish;

	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	/**
	 * Returns true if a value is null, undefined, or NaN.
	 */
	function isNullish(value) {
	  return value === null || value === undefined || value !== value;
	}

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.assertValidName = assertValidName;

	var _invariant = __webpack_require__(19);

	var _invariant2 = _interopRequireDefault(_invariant);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var NAME_RX = /^[_a-zA-Z][_a-zA-Z0-9]*$/;

	// Helper to assert that provided names are valid.

	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	function assertValidName(name) {
	  (0, _invariant2.default)(NAME_RX.test(name), 'Names must match /^[_a-zA-Z][_a-zA-Z0-9]*$/ but "' + name + '" does not.');
	}

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.specifiedDirectives = exports.GraphQLDeprecatedDirective = exports.DEFAULT_DEPRECATION_REASON = exports.GraphQLSkipDirective = exports.GraphQLIncludeDirective = exports.GraphQLDirective = exports.DirectiveLocation = undefined;

	var _definition = __webpack_require__(22);

	var _scalars = __webpack_require__(26);

	var _invariant = __webpack_require__(19);

	var _invariant2 = _interopRequireDefault(_invariant);

	var _assertValidName = __webpack_require__(24);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	var DirectiveLocation = exports.DirectiveLocation = {
	  // Operations
	  QUERY: 'QUERY',
	  MUTATION: 'MUTATION',
	  SUBSCRIPTION: 'SUBSCRIPTION',
	  FIELD: 'FIELD',
	  FRAGMENT_DEFINITION: 'FRAGMENT_DEFINITION',
	  FRAGMENT_SPREAD: 'FRAGMENT_SPREAD',
	  INLINE_FRAGMENT: 'INLINE_FRAGMENT',
	  // Schema Definitions
	  SCHEMA: 'SCHEMA',
	  SCALAR: 'SCALAR',
	  OBJECT: 'OBJECT',
	  FIELD_DEFINITION: 'FIELD_DEFINITION',
	  ARGUMENT_DEFINITION: 'ARGUMENT_DEFINITION',
	  INTERFACE: 'INTERFACE',
	  UNION: 'UNION',
	  ENUM: 'ENUM',
	  ENUM_VALUE: 'ENUM_VALUE',
	  INPUT_OBJECT: 'INPUT_OBJECT',
	  INPUT_FIELD_DEFINITION: 'INPUT_FIELD_DEFINITION'
	};

	// eslint-disable-line

	/**
	 * Directives are used by the GraphQL runtime as a way of modifying execution
	 * behavior. Type system creators will usually not create these directly.
	 */
	var GraphQLDirective = exports.GraphQLDirective = function GraphQLDirective(config) {
	  _classCallCheck(this, GraphQLDirective);

	  (0, _invariant2.default)(config.name, 'Directive must be named.');
	  (0, _assertValidName.assertValidName)(config.name);
	  (0, _invariant2.default)(Array.isArray(config.locations), 'Must provide locations for directive.');
	  this.name = config.name;
	  this.description = config.description;
	  this.locations = config.locations;

	  var args = config.args;
	  if (!args) {
	    this.args = [];
	  } else {
	    (0, _invariant2.default)(!Array.isArray(args), '@' + config.name + ' args must be an object with argument names as keys.');
	    this.args = Object.keys(args).map(function (argName) {
	      (0, _assertValidName.assertValidName)(argName);
	      var arg = args[argName];
	      (0, _invariant2.default)((0, _definition.isInputType)(arg.type), '@' + config.name + '(' + argName + ':) argument type must be ' + ('Input Type but got: ' + String(arg.type) + '.'));
	      return {
	        name: argName,
	        description: arg.description === undefined ? null : arg.description,
	        type: arg.type,
	        defaultValue: arg.defaultValue === undefined ? null : arg.defaultValue
	      };
	    });
	  }
	};

	/**
	 * Used to conditionally include fields or fragments.
	 */
	var GraphQLIncludeDirective = exports.GraphQLIncludeDirective = new GraphQLDirective({
	  name: 'include',
	  description: 'Directs the executor to include this field or fragment only when ' + 'the `if` argument is true.',
	  locations: [DirectiveLocation.FIELD, DirectiveLocation.FRAGMENT_SPREAD, DirectiveLocation.INLINE_FRAGMENT],
	  args: {
	    if: {
	      type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
	      description: 'Included when true.'
	    }
	  }
	});

	/**
	 * Used to conditionally skip (exclude) fields or fragments.
	 */
	var GraphQLSkipDirective = exports.GraphQLSkipDirective = new GraphQLDirective({
	  name: 'skip',
	  description: 'Directs the executor to skip this field or fragment when the `if` ' + 'argument is true.',
	  locations: [DirectiveLocation.FIELD, DirectiveLocation.FRAGMENT_SPREAD, DirectiveLocation.INLINE_FRAGMENT],
	  args: {
	    if: {
	      type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
	      description: 'Skipped when true.'
	    }
	  }
	});

	/**
	 * Constant string used for default reason for a deprecation.
	 */
	var DEFAULT_DEPRECATION_REASON = exports.DEFAULT_DEPRECATION_REASON = 'No longer supported';

	/**
	 * Used to declare element of a GraphQL schema as deprecated.
	 */
	var GraphQLDeprecatedDirective = exports.GraphQLDeprecatedDirective = new GraphQLDirective({
	  name: 'deprecated',
	  description: 'Marks an element of a GraphQL schema as no longer supported.',
	  locations: [DirectiveLocation.FIELD_DEFINITION, DirectiveLocation.ENUM_VALUE],
	  args: {
	    reason: {
	      type: _scalars.GraphQLString,
	      description: 'Explains why this element was deprecated, usually also including a ' + 'suggestion for how to access supported similar data. Formatted ' + 'in [Markdown](https://daringfireball.net/projects/markdown/).',
	      defaultValue: DEFAULT_DEPRECATION_REASON
	    }
	  }
	});

	/**
	 * The full list of specified directives.
	 */
	var specifiedDirectives = exports.specifiedDirectives = [GraphQLIncludeDirective, GraphQLSkipDirective, GraphQLDeprecatedDirective];

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.GraphQLID = exports.GraphQLBoolean = exports.GraphQLString = exports.GraphQLFloat = exports.GraphQLInt = undefined;

	var _definition = __webpack_require__(22);

	var _kinds = __webpack_require__(15);

	var Kind = _interopRequireWildcard(_kinds);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	// As per the GraphQL Spec, Integers are only treated as valid when a valid
	// 32-bit signed integer, providing the broadest support across platforms.
	//
	// n.b. JavaScript's integers are safe between -(2^53 - 1) and 2^53 - 1 because
	// they are internally represented as IEEE 754 doubles.

	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	var MAX_INT = 2147483647;
	var MIN_INT = -2147483648;

	function coerceInt(value) {
	  if (value === '') {
	    throw new TypeError('Int cannot represent non 32-bit signed integer value: (empty string)');
	  }
	  var num = Number(value);
	  if (num === num && num <= MAX_INT && num >= MIN_INT) {
	    return (num < 0 ? Math.ceil : Math.floor)(num);
	  }
	  throw new TypeError('Int cannot represent non 32-bit signed integer value: ' + value);
	}

	var GraphQLInt = exports.GraphQLInt = new _definition.GraphQLScalarType({
	  name: 'Int',
	  description: 'The `Int` scalar type represents non-fractional signed whole numeric ' + 'values. Int can represent values between -(2^31) and 2^31 - 1. ',
	  serialize: coerceInt,
	  parseValue: coerceInt,
	  parseLiteral: function parseLiteral(ast) {
	    if (ast.kind === Kind.INT) {
	      var num = parseInt(ast.value, 10);
	      if (num <= MAX_INT && num >= MIN_INT) {
	        return num;
	      }
	    }
	    return null;
	  }
	});

	function coerceFloat(value) {
	  if (value === '') {
	    throw new TypeError('Float cannot represent non numeric value: (empty string)');
	  }
	  var num = Number(value);
	  if (num === num) {
	    return num;
	  }
	  throw new TypeError('Float cannot represent non numeric value: ' + value);
	}

	var GraphQLFloat = exports.GraphQLFloat = new _definition.GraphQLScalarType({
	  name: 'Float',
	  description: 'The `Float` scalar type represents signed double-precision fractional ' + 'values as specified by ' + '[IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point). ',
	  serialize: coerceFloat,
	  parseValue: coerceFloat,
	  parseLiteral: function parseLiteral(ast) {
	    return ast.kind === Kind.FLOAT || ast.kind === Kind.INT ? parseFloat(ast.value) : null;
	  }
	});

	var GraphQLString = exports.GraphQLString = new _definition.GraphQLScalarType({
	  name: 'String',
	  description: 'The `String` scalar type represents textual data, represented as UTF-8 ' + 'character sequences. The String type is most often used by GraphQL to ' + 'represent free-form human-readable text.',
	  serialize: String,
	  parseValue: String,
	  parseLiteral: function parseLiteral(ast) {
	    return ast.kind === Kind.STRING ? ast.value : null;
	  }
	});

	var GraphQLBoolean = exports.GraphQLBoolean = new _definition.GraphQLScalarType({
	  name: 'Boolean',
	  description: 'The `Boolean` scalar type represents `true` or `false`.',
	  serialize: Boolean,
	  parseValue: Boolean,
	  parseLiteral: function parseLiteral(ast) {
	    return ast.kind === Kind.BOOLEAN ? ast.value : null;
	  }
	});

	var GraphQLID = exports.GraphQLID = new _definition.GraphQLScalarType({
	  name: 'ID',
	  description: 'The `ID` scalar type represents a unique identifier, often used to ' + 'refetch an object or as key for a cache. The ID type appears in a JSON ' + 'response as a String; however, it is not intended to be human-readable. ' + 'When expected as an input type, any string (such as `"4"`) or integer ' + '(such as `4`) input value will be accepted as an ID.',
	  serialize: String,
	  parseValue: String,
	  parseLiteral: function parseLiteral(ast) {
	    return ast.kind === Kind.STRING || ast.kind === Kind.INT ? ast.value : null;
	  }
	});

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.TypeNameMetaFieldDef = exports.TypeMetaFieldDef = exports.SchemaMetaFieldDef = exports.__TypeKind = exports.TypeKind = exports.__EnumValue = exports.__InputValue = exports.__Field = exports.__Type = exports.__DirectiveLocation = exports.__Directive = exports.__Schema = undefined;

	var _isNullish = __webpack_require__(23);

	var _isNullish2 = _interopRequireDefault(_isNullish);

	var _astFromValue = __webpack_require__(28);

	var _printer = __webpack_require__(13);

	var _definition = __webpack_require__(22);

	var _scalars = __webpack_require__(26);

	var _directives = __webpack_require__(25);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	var __Schema = exports.__Schema = new _definition.GraphQLObjectType({
	  name: '__Schema',
	  description: 'A GraphQL Schema defines the capabilities of a GraphQL server. It ' + 'exposes all available types and directives on the server, as well as ' + 'the entry points for query, mutation, and subscription operations.',
	  fields: function fields() {
	    return {
	      types: {
	        description: 'A list of all types supported by this server.',
	        type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__Type))),
	        resolve: function resolve(schema) {
	          var typeMap = schema.getTypeMap();
	          return Object.keys(typeMap).map(function (key) {
	            return typeMap[key];
	          });
	        }
	      },
	      queryType: {
	        description: 'The type that query operations will be rooted at.',
	        type: new _definition.GraphQLNonNull(__Type),
	        resolve: function resolve(schema) {
	          return schema.getQueryType();
	        }
	      },
	      mutationType: {
	        description: 'If this server supports mutation, the type that ' + 'mutation operations will be rooted at.',
	        type: __Type,
	        resolve: function resolve(schema) {
	          return schema.getMutationType();
	        }
	      },
	      subscriptionType: {
	        description: 'If this server support subscription, the type that ' + 'subscription operations will be rooted at.',
	        type: __Type,
	        resolve: function resolve(schema) {
	          return schema.getSubscriptionType();
	        }
	      },
	      directives: {
	        description: 'A list of all directives supported by this server.',
	        type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__Directive))),
	        resolve: function resolve(schema) {
	          return schema.getDirectives();
	        }
	      }
	    };
	  }
	});

	var __Directive = exports.__Directive = new _definition.GraphQLObjectType({
	  name: '__Directive',
	  description: 'A Directive provides a way to describe alternate runtime execution and ' + 'type validation behavior in a GraphQL document.' + '\n\nIn some cases, you need to provide options to alter GraphQL\'s ' + 'execution behavior in ways field arguments will not suffice, such as ' + 'conditionally including or skipping a field. Directives provide this by ' + 'describing additional information to the executor.',
	  fields: function fields() {
	    return {
	      name: { type: new _definition.GraphQLNonNull(_scalars.GraphQLString) },
	      description: { type: _scalars.GraphQLString },
	      locations: {
	        type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__DirectiveLocation)))
	      },
	      args: {
	        type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__InputValue))),
	        resolve: function resolve(directive) {
	          return directive.args || [];
	        }
	      },
	      // NOTE: the following three fields are deprecated and are no longer part
	      // of the GraphQL specification.
	      onOperation: {
	        deprecationReason: 'Use `locations`.',
	        type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
	        resolve: function resolve(d) {
	          return d.locations.indexOf(_directives.DirectiveLocation.QUERY) !== -1 || d.locations.indexOf(_directives.DirectiveLocation.MUTATION) !== -1 || d.locations.indexOf(_directives.DirectiveLocation.SUBSCRIPTION) !== -1;
	        }
	      },
	      onFragment: {
	        deprecationReason: 'Use `locations`.',
	        type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
	        resolve: function resolve(d) {
	          return d.locations.indexOf(_directives.DirectiveLocation.FRAGMENT_SPREAD) !== -1 || d.locations.indexOf(_directives.DirectiveLocation.INLINE_FRAGMENT) !== -1 || d.locations.indexOf(_directives.DirectiveLocation.FRAGMENT_DEFINITION) !== -1;
	        }
	      },
	      onField: {
	        deprecationReason: 'Use `locations`.',
	        type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
	        resolve: function resolve(d) {
	          return d.locations.indexOf(_directives.DirectiveLocation.FIELD) !== -1;
	        }
	      }
	    };
	  }
	});

	var __DirectiveLocation = exports.__DirectiveLocation = new _definition.GraphQLEnumType({
	  name: '__DirectiveLocation',
	  description: 'A Directive can be adjacent to many parts of the GraphQL language, a ' + '__DirectiveLocation describes one such possible adjacencies.',
	  values: {
	    QUERY: {
	      value: _directives.DirectiveLocation.QUERY,
	      description: 'Location adjacent to a query operation.'
	    },
	    MUTATION: {
	      value: _directives.DirectiveLocation.MUTATION,
	      description: 'Location adjacent to a mutation operation.'
	    },
	    SUBSCRIPTION: {
	      value: _directives.DirectiveLocation.SUBSCRIPTION,
	      description: 'Location adjacent to a subscription operation.'
	    },
	    FIELD: {
	      value: _directives.DirectiveLocation.FIELD,
	      description: 'Location adjacent to a field.'
	    },
	    FRAGMENT_DEFINITION: {
	      value: _directives.DirectiveLocation.FRAGMENT_DEFINITION,
	      description: 'Location adjacent to a fragment definition.'
	    },
	    FRAGMENT_SPREAD: {
	      value: _directives.DirectiveLocation.FRAGMENT_SPREAD,
	      description: 'Location adjacent to a fragment spread.'
	    },
	    INLINE_FRAGMENT: {
	      value: _directives.DirectiveLocation.INLINE_FRAGMENT,
	      description: 'Location adjacent to an inline fragment.'
	    },
	    SCHEMA: {
	      value: _directives.DirectiveLocation.SCHEMA,
	      description: 'Location adjacent to a schema definition.'
	    },
	    SCALAR: {
	      value: _directives.DirectiveLocation.SCALAR,
	      description: 'Location adjacent to a scalar definition.'
	    },
	    OBJECT: {
	      value: _directives.DirectiveLocation.OBJECT,
	      description: 'Location adjacent to an object type definition.'
	    },
	    FIELD_DEFINITION: {
	      value: _directives.DirectiveLocation.FIELD_DEFINITION,
	      description: 'Location adjacent to a field definition.'
	    },
	    ARGUMENT_DEFINITION: {
	      value: _directives.DirectiveLocation.ARGUMENT_DEFINITION,
	      description: 'Location adjacent to an argument definition.'
	    },
	    INTERFACE: {
	      value: _directives.DirectiveLocation.INTERFACE,
	      description: 'Location adjacent to an interface definition.'
	    },
	    UNION: {
	      value: _directives.DirectiveLocation.UNION,
	      description: 'Location adjacent to a union definition.'
	    },
	    ENUM: {
	      value: _directives.DirectiveLocation.ENUM,
	      description: 'Location adjacent to an enum definition.'
	    },
	    ENUM_VALUE: {
	      value: _directives.DirectiveLocation.ENUM_VALUE,
	      description: 'Location adjacent to an enum value definition.'
	    },
	    INPUT_OBJECT: {
	      value: _directives.DirectiveLocation.INPUT_OBJECT,
	      description: 'Location adjacent to an input object type definition.'
	    },
	    INPUT_FIELD_DEFINITION: {
	      value: _directives.DirectiveLocation.INPUT_FIELD_DEFINITION,
	      description: 'Location adjacent to an input object field definition.'
	    }
	  }
	});

	var __Type = exports.__Type = new _definition.GraphQLObjectType({
	  name: '__Type',
	  description: 'The fundamental unit of any GraphQL Schema is the type. There are ' + 'many kinds of types in GraphQL as represented by the `__TypeKind` enum.' + '\n\nDepending on the kind of a type, certain fields describe ' + 'information about that type. Scalar types provide no information ' + 'beyond a name and description, while Enum types provide their values. ' + 'Object and Interface types provide the fields they describe. Abstract ' + 'types, Union and Interface, provide the Object types possible ' + 'at runtime. List and NonNull types compose other types.',
	  fields: function fields() {
	    return {
	      kind: {
	        type: new _definition.GraphQLNonNull(__TypeKind),
	        resolve: function resolve(type) {
	          if (type instanceof _definition.GraphQLScalarType) {
	            return TypeKind.SCALAR;
	          } else if (type instanceof _definition.GraphQLObjectType) {
	            return TypeKind.OBJECT;
	          } else if (type instanceof _definition.GraphQLInterfaceType) {
	            return TypeKind.INTERFACE;
	          } else if (type instanceof _definition.GraphQLUnionType) {
	            return TypeKind.UNION;
	          } else if (type instanceof _definition.GraphQLEnumType) {
	            return TypeKind.ENUM;
	          } else if (type instanceof _definition.GraphQLInputObjectType) {
	            return TypeKind.INPUT_OBJECT;
	          } else if (type instanceof _definition.GraphQLList) {
	            return TypeKind.LIST;
	          } else if (type instanceof _definition.GraphQLNonNull) {
	            return TypeKind.NON_NULL;
	          }
	          throw new Error('Unknown kind of type: ' + type);
	        }
	      },
	      name: { type: _scalars.GraphQLString },
	      description: { type: _scalars.GraphQLString },
	      fields: {
	        type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__Field)),
	        args: {
	          includeDeprecated: { type: _scalars.GraphQLBoolean, defaultValue: false }
	        },
	        resolve: function resolve(type, _ref) {
	          var includeDeprecated = _ref.includeDeprecated;

	          if (type instanceof _definition.GraphQLObjectType || type instanceof _definition.GraphQLInterfaceType) {
	            var _ret = function () {
	              var fieldMap = type.getFields();
	              var fields = Object.keys(fieldMap).map(function (fieldName) {
	                return fieldMap[fieldName];
	              });
	              if (!includeDeprecated) {
	                fields = fields.filter(function (field) {
	                  return !field.deprecationReason;
	                });
	              }
	              return {
	                v: fields
	              };
	            }();

	            if (typeof _ret === "object") return _ret.v;
	          }
	          return null;
	        }
	      },
	      interfaces: {
	        type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__Type)),
	        resolve: function resolve(type) {
	          if (type instanceof _definition.GraphQLObjectType) {
	            return type.getInterfaces();
	          }
	        }
	      },
	      possibleTypes: {
	        type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__Type)),
	        resolve: function resolve(type, args, context, _ref2) {
	          var schema = _ref2.schema;

	          if (type instanceof _definition.GraphQLInterfaceType || type instanceof _definition.GraphQLUnionType) {
	            return schema.getPossibleTypes(type);
	          }
	        }
	      },
	      enumValues: {
	        type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__EnumValue)),
	        args: {
	          includeDeprecated: { type: _scalars.GraphQLBoolean, defaultValue: false }
	        },
	        resolve: function resolve(type, _ref3) {
	          var includeDeprecated = _ref3.includeDeprecated;

	          if (type instanceof _definition.GraphQLEnumType) {
	            var values = type.getValues();
	            if (!includeDeprecated) {
	              values = values.filter(function (value) {
	                return !value.deprecationReason;
	              });
	            }
	            return values;
	          }
	        }
	      },
	      inputFields: {
	        type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__InputValue)),
	        resolve: function resolve(type) {
	          if (type instanceof _definition.GraphQLInputObjectType) {
	            var _ret2 = function () {
	              var fieldMap = type.getFields();
	              return {
	                v: Object.keys(fieldMap).map(function (fieldName) {
	                  return fieldMap[fieldName];
	                })
	              };
	            }();

	            if (typeof _ret2 === "object") return _ret2.v;
	          }
	        }
	      },
	      ofType: { type: __Type }
	    };
	  }
	});

	var __Field = exports.__Field = new _definition.GraphQLObjectType({
	  name: '__Field',
	  description: 'Object and Interface types are described by a list of Fields, each of ' + 'which has a name, potentially a list of arguments, and a return type.',
	  fields: function fields() {
	    return {
	      name: { type: new _definition.GraphQLNonNull(_scalars.GraphQLString) },
	      description: { type: _scalars.GraphQLString },
	      args: {
	        type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__InputValue))),
	        resolve: function resolve(field) {
	          return field.args || [];
	        }
	      },
	      type: { type: new _definition.GraphQLNonNull(__Type) },
	      isDeprecated: { type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean) },
	      deprecationReason: {
	        type: _scalars.GraphQLString
	      }
	    };
	  }
	});

	var __InputValue = exports.__InputValue = new _definition.GraphQLObjectType({
	  name: '__InputValue',
	  description: 'Arguments provided to Fields or Directives and the input fields of an ' + 'InputObject are represented as Input Values which describe their type ' + 'and optionally a default value.',
	  fields: function fields() {
	    return {
	      name: { type: new _definition.GraphQLNonNull(_scalars.GraphQLString) },
	      description: { type: _scalars.GraphQLString },
	      type: { type: new _definition.GraphQLNonNull(__Type) },
	      defaultValue: {
	        type: _scalars.GraphQLString,
	        description: 'A GraphQL-formatted string representing the default value for this ' + 'input value.',
	        resolve: function resolve(inputVal) {
	          return (0, _isNullish2.default)(inputVal.defaultValue) ? null : (0, _printer.print)((0, _astFromValue.astFromValue)(inputVal.defaultValue, inputVal.type));
	        }
	      }
	    };
	  }
	});

	var __EnumValue = exports.__EnumValue = new _definition.GraphQLObjectType({
	  name: '__EnumValue',
	  description: 'One possible value for a given Enum. Enum values are unique values, not ' + 'a placeholder for a string or numeric value. However an Enum value is ' + 'returned in a JSON response as a string.',
	  fields: function fields() {
	    return {
	      name: { type: new _definition.GraphQLNonNull(_scalars.GraphQLString) },
	      description: { type: _scalars.GraphQLString },
	      isDeprecated: { type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean) },
	      deprecationReason: {
	        type: _scalars.GraphQLString
	      }
	    };
	  }
	});

	var TypeKind = exports.TypeKind = {
	  SCALAR: 'SCALAR',
	  OBJECT: 'OBJECT',
	  INTERFACE: 'INTERFACE',
	  UNION: 'UNION',
	  ENUM: 'ENUM',
	  INPUT_OBJECT: 'INPUT_OBJECT',
	  LIST: 'LIST',
	  NON_NULL: 'NON_NULL'
	};

	var __TypeKind = exports.__TypeKind = new _definition.GraphQLEnumType({
	  name: '__TypeKind',
	  description: 'An enum describing what kind of type a given `__Type` is.',
	  values: {
	    SCALAR: {
	      value: TypeKind.SCALAR,
	      description: 'Indicates this type is a scalar.'
	    },
	    OBJECT: {
	      value: TypeKind.OBJECT,
	      description: 'Indicates this type is an object. ' + '`fields` and `interfaces` are valid fields.'
	    },
	    INTERFACE: {
	      value: TypeKind.INTERFACE,
	      description: 'Indicates this type is an interface. ' + '`fields` and `possibleTypes` are valid fields.'
	    },
	    UNION: {
	      value: TypeKind.UNION,
	      description: 'Indicates this type is a union. ' + '`possibleTypes` is a valid field.'
	    },
	    ENUM: {
	      value: TypeKind.ENUM,
	      description: 'Indicates this type is an enum. ' + '`enumValues` is a valid field.'
	    },
	    INPUT_OBJECT: {
	      value: TypeKind.INPUT_OBJECT,
	      description: 'Indicates this type is an input object. ' + '`inputFields` is a valid field.'
	    },
	    LIST: {
	      value: TypeKind.LIST,
	      description: 'Indicates this type is a list. ' + '`ofType` is a valid field.'
	    },
	    NON_NULL: {
	      value: TypeKind.NON_NULL,
	      description: 'Indicates this type is a non-null. ' + '`ofType` is a valid field.'
	    }
	  }
	});

	/**
	 * Note that these are GraphQLFieldDefinition and not GraphQLFieldConfig,
	 * so the format for args is different.
	 */

	var SchemaMetaFieldDef = exports.SchemaMetaFieldDef = {
	  name: '__schema',
	  type: new _definition.GraphQLNonNull(__Schema),
	  description: 'Access the current type schema of this server.',
	  args: [],
	  resolve: function resolve(source, args, context, _ref4) {
	    var schema = _ref4.schema;
	    return schema;
	  }
	};

	var TypeMetaFieldDef = exports.TypeMetaFieldDef = {
	  name: '__type',
	  type: __Type,
	  description: 'Request the type information of a single type.',
	  args: [{ name: 'name', type: new _definition.GraphQLNonNull(_scalars.GraphQLString) }],
	  resolve: function resolve(source, _ref5, context, _ref6) {
	    var name = _ref5.name;
	    var schema = _ref6.schema;
	    return schema.getType(name);
	  }
	};

	var TypeNameMetaFieldDef = exports.TypeNameMetaFieldDef = {
	  name: '__typename',
	  type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
	  description: 'The name of the current Object type at runtime.',
	  args: [],
	  resolve: function resolve(source, args, context, _ref7) {
	    var parentType = _ref7.parentType;
	    return parentType.name;
	  }
	};

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.astFromValue = astFromValue;

	var _iterall = __webpack_require__(29);

	var _invariant = __webpack_require__(19);

	var _invariant2 = _interopRequireDefault(_invariant);

	var _isNullish = __webpack_require__(23);

	var _isNullish2 = _interopRequireDefault(_isNullish);

	var _kinds = __webpack_require__(15);

	var _definition = __webpack_require__(22);

	var _scalars = __webpack_require__(26);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Produces a GraphQL Value AST given a JavaScript value.
	 *
	 * A GraphQL type must be provided, which will be used to interpret different
	 * JavaScript values.
	 *
	 * | JSON Value    | GraphQL Value        |
	 * | ------------- | -------------------- |
	 * | Object        | Input Object         |
	 * | Array         | List                 |
	 * | Boolean       | Boolean              |
	 * | String        | String / Enum Value  |
	 * | Number        | Int / Float          |
	 * | Mixed         | Enum Value           |
	 *
	 */

	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	function astFromValue(value, type) {
	  // Ensure flow knows that we treat function params as const.
	  var _value = value;

	  if (type instanceof _definition.GraphQLNonNull) {
	    // Note: we're not checking that the result is non-null.
	    // This function is not responsible for validating the input value.
	    return astFromValue(_value, type.ofType);
	  }

	  if ((0, _isNullish2.default)(_value)) {
	    return null;
	  }

	  // Convert JavaScript array to GraphQL list. If the GraphQLType is a list, but
	  // the value is not an array, convert the value using the list's item type.
	  if (type instanceof _definition.GraphQLList) {
	    var _ret = function () {
	      var itemType = type.ofType;
	      if ((0, _iterall.isCollection)(_value)) {
	        var _ret2 = function () {
	          var valuesASTs = [];
	          (0, _iterall.forEach)(_value, function (item) {
	            var itemAST = astFromValue(item, itemType);
	            if (itemAST) {
	              valuesASTs.push(itemAST);
	            }
	          });
	          return {
	            v: {
	              v: { kind: _kinds.LIST, values: valuesASTs }
	            }
	          };
	        }();

	        if (typeof _ret2 === "object") return _ret2.v;
	      }
	      return {
	        v: astFromValue(_value, itemType)
	      };
	    }();

	    if (typeof _ret === "object") return _ret.v;
	  }

	  // Populate the fields of the input object by creating ASTs from each value
	  // in the JavaScript object according to the fields in the input type.
	  if (type instanceof _definition.GraphQLInputObjectType) {
	    var _ret3 = function () {
	      if (_value === null || typeof _value !== 'object') {
	        return {
	          v: null
	        };
	      }
	      var fields = type.getFields();
	      var fieldASTs = [];
	      Object.keys(fields).forEach(function (fieldName) {
	        var fieldType = fields[fieldName].type;
	        var fieldValue = astFromValue(_value[fieldName], fieldType);
	        if (fieldValue) {
	          fieldASTs.push({
	            kind: _kinds.OBJECT_FIELD,
	            name: { kind: _kinds.NAME, value: fieldName },
	            value: fieldValue
	          });
	        }
	      });
	      return {
	        v: { kind: _kinds.OBJECT, fields: fieldASTs }
	      };
	    }();

	    if (typeof _ret3 === "object") return _ret3.v;
	  }

	  (0, _invariant2.default)(type instanceof _definition.GraphQLScalarType || type instanceof _definition.GraphQLEnumType, 'Must provide Input Type, cannot use: ' + String(type));

	  // Since value is an internally represented value, it must be serialized
	  // to an externally represented value before converting into an AST.
	  var serialized = type.serialize(_value);
	  if ((0, _isNullish2.default)(serialized)) {
	    return null;
	  }

	  // Others serialize based on their corresponding JavaScript scalar types.
	  if (typeof serialized === 'boolean') {
	    return { kind: _kinds.BOOLEAN, value: serialized };
	  }

	  // JavaScript numbers can be Int or Float values.
	  if (typeof serialized === 'number') {
	    var stringNum = String(serialized);
	    return (/^[0-9]+$/.test(stringNum) ? { kind: _kinds.INT, value: stringNum } : { kind: _kinds.FLOAT, value: stringNum }
	    );
	  }

	  if (typeof serialized === 'string') {
	    // Enum types use Enum literals.
	    if (type instanceof _definition.GraphQLEnumType) {
	      return { kind: _kinds.ENUM, value: serialized };
	    }

	    // ID types can use Int literals.
	    if (type === _scalars.GraphQLID && /^[0-9]+$/.test(serialized)) {
	      return { kind: _kinds.INT, value: serialized };
	    }

	    // Use JSON stringify, which uses the same string encoding as GraphQL,
	    // then remove the quotes.
	    return {
	      kind: _kinds.STRING,
	      value: JSON.stringify(serialized).slice(1, -1)
	    };
	  }

	  throw new TypeError('Cannot convert value to AST: ' + String(serialized));
	}

/***/ },
/* 29 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2016, Lee Byron
	 * All rights reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * @ignore
	 */

	/**
	 * [Iterator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterator)
	 * is a *protocol* which describes a standard way to produce a sequence of
	 * values, typically the values of the Iterable represented by this Iterator.
	 *
	 * While described by the [ES2015 version of JavaScript](http://www.ecma-international.org/ecma-262/6.0/#sec-iterator-interface)
	 * it can be utilized by any version of JavaScript.
	 *
	 * @typedef {Object} Iterator
	 * @template T The type of each iterated value
	 * @property {function (): { value: T, done: boolean }} next
	 *   A method which produces either the next value in a sequence or a result
	 *   where the `done` property is `true` indicating the end of the Iterator.
	 */

	/**
	 * [Iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable)
	 * is a *protocol* which when implemented allows a JavaScript object to define
	 * their iteration behavior, such as what values are looped over in a `for..of`
	 * loop or `iterall`'s `forEach` function. Many [built-in types](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#Builtin_iterables)
	 * implement the Iterable protocol, including `Array` and `Map`.
	 *
	 * While described by the [ES2015 version of JavaScript](http://www.ecma-international.org/ecma-262/6.0/#sec-iterable-interface)
	 * it can be utilized by any version of JavaScript.
	 *
	 * @typedef {Object} Iterable
	 * @template T The type of each iterated value
	 * @property {function (): Iterator<T>} Symbol.iterator
	 *   A method which produces an Iterator for this Iterable.
	 */

	// In ES2015 (or a polyfilled) environment, this will be Symbol.iterator
	var SYMBOL_ITERATOR = typeof Symbol === 'function' && Symbol.iterator

	/**
	 * A property name to be used as the name of an Iterable's method responsible
	 * for producing an Iterator, referred to as `@@iterator`. Typically represents
	 * the value `Symbol.iterator` but falls back to the string `"@@iterator"` when
	 * `Symbol.iterator` is not defined.
	 *
	 * Use `$$iterator` for defining new Iterables instead of `Symbol.iterator`,
	 * but do not use it for accessing existing Iterables, instead use
	 * `getIterator()` or `isIterable()`.
	 *
	 * @example
	 *
	 * var $$iterator = require('iterall').$$iterator
	 *
	 * function Counter (to) {
	 *   this.to = to
	 * }
	 *
	 * Counter.prototype[$$iterator] = function () {
	 *   return {
	 *     to: this.to,
	 *     num: 0,
	 *     next () {
	 *       if (this.num >= this.to) {
	 *         return { value: undefined, done: true }
	 *       }
	 *       return { value: this.num++, done: false }
	 *     }
	 *   }
	 * }
	 *
	 * var counter = new Counter(3)
	 * for (var number of counter) {
	 *   console.log(number) // 0 ... 1 ... 2
	 * }
	 *
	 * @type {Symbol|string}
	 */
	var $$iterator = SYMBOL_ITERATOR || '@@iterator'
	exports.$$iterator = $$iterator

	/**
	 * Returns true if the provided object implements the Iterator protocol via
	 * either implementing a `Symbol.iterator` or `"@@iterator"` method.
	 *
	 * @example
	 *
	 * var isIterable = require('iterall').isIterable
	 * isIterable([ 1, 2, 3 ]) // true
	 * isIterable('ABC') // true
	 * isIterable({ length: 1, 0: 'Alpha' }) // false
	 * isIterable({ key: 'value' }) // false
	 * isIterable(new Map()) // true
	 *
	 * @param obj
	 *   A value which might implement the Iterable protocol.
	 * @return {boolean} true if Iterable.
	 */
	function isIterable (obj) {
	  return !!getIteratorMethod(obj)
	}
	exports.isIterable = isIterable

	/**
	 * Returns true if the provided object implements the Array-like protocol via
	 * defining a positive-integer `length` property.
	 *
	 * @example
	 *
	 * var isArrayLike = require('iterall').isArrayLike
	 * isArrayLike([ 1, 2, 3 ]) // true
	 * isArrayLike('ABC') // true
	 * isArrayLike({ length: 1, 0: 'Alpha' }) // true
	 * isArrayLike({ key: 'value' }) // false
	 * isArrayLike(new Map()) // false
	 *
	 * @param obj
	 *   A value which might implement the Array-like protocol.
	 * @return {boolean} true if Array-like.
	 */
	function isArrayLike (obj) {
	  var length = obj != null && obj.length
	  return typeof length === 'number' && length >= 0 && length % 1 === 0
	}
	exports.isArrayLike = isArrayLike

	/**
	 * Returns true if the provided object is an Object (i.e. not a string literal)
	 * and is either Iterable or Array-like.
	 *
	 * This may be used in place of [Array.isArray()][isArray] to determine if an
	 * object should be iterated-over. It always excludes string literals and
	 * includes Arrays (regardless of if it is Iterable). It also includes other
	 * Array-like objects such as NodeList, TypedArray, and Buffer.
	 *
	 * @example
	 *
	 * var isCollection = require('iterall').isCollection
	 * isCollection([ 1, 2, 3 ]) // true
	 * isCollection('ABC') // false
	 * isCollection({ length: 1, 0: 'Alpha' }) // true
	 * isCollection({ key: 'value' }) // false
	 * isCollection(new Map()) // true
	 *
	 * @example
	 *
	 * var forEach = require('iterall').forEach
	 * if (isCollection(obj)) {
	 *   forEach(obj, function (value) {
	 *     console.log(value)
	 *   })
	 * }
	 *
	 * @param obj
	 *   An Object value which might implement the Iterable or Array-like protocols.
	 * @return {boolean} true if Iterable or Array-like Object.
	 */
	function isCollection (obj) {
	  return Object(obj) === obj && (isArrayLike(obj) || isIterable(obj))
	}
	exports.isCollection = isCollection

	/**
	 * If the provided object implements the Iterator protocol, its Iterator object
	 * is returned. Otherwise returns undefined.
	 *
	 * @example
	 *
	 * var getIterator = require('iterall').getIterator
	 * var iterator = getIterator([ 1, 2, 3 ])
	 * iterator.next() // { value: 1, done: false }
	 * iterator.next() // { value: 2, done: false }
	 * iterator.next() // { value: 3, done: false }
	 * iterator.next() // { value: undefined, done: true }
	 *
	 * @template T the type of each iterated value
	 * @param {Iterable<T>} iterable
	 *   An Iterable object which is the source of an Iterator.
	 * @return {Iterator<T>} new Iterator instance.
	 */
	function getIterator (iterable) {
	  var method = getIteratorMethod(iterable)
	  if (method) {
	    return method.call(iterable)
	  }
	}
	exports.getIterator = getIterator

	/**
	 * If the provided object implements the Iterator protocol, the method
	 * responsible for producing its Iterator object is returned.
	 *
	 * This is used in rare cases for performance tuning. This method must be called
	 * with obj as the contextual this-argument.
	 *
	 * @example
	 *
	 * var getIteratorMethod = require('iterall').getIteratorMethod
	 * var myArray = [ 1, 2, 3 ]
	 * var method = getIteratorMethod(myArray)
	 * if (method) {
	 *   var iterator = method.call(myArray)
	 * }
	 *
	 * @template T the type of each iterated value
	 * @param {Iterable<T>} iterable
	 *   An Iterable object which defines an `@@iterator` method.
	 * @return {function(): Iterator<T>} `@@iterator` method.
	 */
	function getIteratorMethod (iterable) {
	  if (iterable != null) {
	    var method = SYMBOL_ITERATOR && iterable[SYMBOL_ITERATOR] || iterable['@@iterator']
	    if (typeof method === 'function') {
	      return method
	    }
	  }
	}
	exports.getIteratorMethod = getIteratorMethod

	/**
	 * Given an object which either implements the Iterable protocol or is
	 * Array-like, iterate over it, calling the `callback` at each iteration.
	 *
	 * Use `forEach` where you would expect to use a `for ... of` loop in ES6.
	 * However `forEach` adheres to the behavior of [Array#forEach][] described in
	 * the ECMAScript specification, skipping over "holes" in Array-likes. It will
	 * also delegate to a `forEach` method on `collection` if one is defined,
	 * ensuring native performance for `Arrays`.
	 *
	 * Similar to [Array#forEach][], the `callback` function accepts three
	 * arguments, and is provided with `thisArg` as the calling context.
	 *
	 * Note: providing an infinite Iterator to forEach will produce an error.
	 *
	 * [Array#forEach]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach
	 *
	 * @example
	 *
	 * var forEach = require('iterall').forEach
	 *
	 * forEach(myIterable, function (value, index, iterable) {
	 *   console.log(value, index, iterable === myIterable)
	 * })
	 *
	 * @example
	 *
	 * // ES6:
	 * for (let value of myIterable) {
	 *   console.log(value)
	 * }
	 *
	 * // Any JavaScript environment:
	 * forEach(myIterable, function (value) {
	 *   console.log(value)
	 * })
	 *
	 * @template T the type of each iterated value
	 * @param {Iterable<T>|{ length: number }} collection
	 *   The Iterable or array to iterate over.
	 * @param {function(T, number, object)} callback
	 *   Function to execute for each iteration, taking up to three arguments
	 * @param [thisArg]
	 *   Optional. Value to use as `this` when executing `callback`.
	 */
	function forEach (collection, callback, thisArg) {
	  if (collection != null) {
	    if (typeof collection.forEach === 'function') {
	      return collection.forEach(callback, thisArg)
	    }
	    var i = 0
	    var iterator = getIterator(collection)
	    if (iterator) {
	      var step
	      while (!(step = iterator.next()).done) {
	        callback.call(thisArg, step.value, i++, collection)
	        // Infinite Iterators could cause forEach to run forever.
	        // After a very large number of iterations, produce an error.
	        /* istanbul ignore if */
	        if (i > 9999999) {
	          throw new TypeError('Near-infinite iteration.')
	        }
	      }
	    } else if (isArrayLike(collection)) {
	      for (; i < collection.length; i++) {
	        if (collection.hasOwnProperty(i)) {
	          callback.call(thisArg, collection[i], i, collection)
	        }
	      }
	    }
	  }
	}
	exports.forEach = forEach

	/**
	 * Similar to `getIterator()`, this method returns a new Iterator given an
	 * Iterable. However it will also create an Iterator for a non-Iterable
	 * Array-like collection, such as Array in a non-ES2015 environment.
	 *
	 * `createIterator` is complimentary to `forEach`, but allows a "pull"-based
	 * iteration as opposed to `forEach`'s "push"-based iteration.
	 *
	 * `createIterator` produces an Iterator for Array-likes with the same behavior
	 * as ArrayIteratorPrototype described in the ECMAScript specification, and
	 * does *not* skip over "holes".
	 *
	 * @example
	 *
	 * var createIterator = require('iterall').createIterator
	 *
	 * var myArraylike = { length: 3, 0: 'Alpha', 1: 'Bravo', 2: 'Charlie' }
	 * var iterator = createIterator(myArraylike)
	 * iterator.next() // { value: 'Alpha', done: false }
	 * iterator.next() // { value: 'Bravo', done: false }
	 * iterator.next() // { value: 'Charlie', done: false }
	 * iterator.next() // { value: undefined, done: true }
	 *
	 * @template T the type of each iterated value
	 * @param {Iterable<T>|{ length: number }} collection
	 *   An Iterable or Array-like object to produce an Iterator.
	 * @return {Iterator<T>} new Iterator instance.
	 */
	function createIterator (collection) {
	  if (collection != null) {
	    var iterator = getIterator(collection)
	    if (iterator) {
	      return iterator
	    }
	    if (isArrayLike(collection)) {
	      return new ArrayLikeIterator(collection)
	    }
	  }
	}
	exports.createIterator = createIterator

	// When the object provided to `createIterator` is not Iterable but is
	// Array-like, this simple Iterator is created.
	function ArrayLikeIterator (obj) {
	  this._o = obj
	  this._i = 0
	}

	// Note: all Iterators are themselves Iterable.
	ArrayLikeIterator.prototype[$$iterator] = function () {
	  return this
	}

	// A simple state-machine determines the IteratorResult returned, yielding
	// each value in the Array-like object in order of their indicies.
	ArrayLikeIterator.prototype.next = function () {
	  if (this._o === void 0 || this._i >= this._o.length) {
	    this._o = void 0
	    return { value: void 0, done: true }
	  }
	  return { value: this._o[this._i++], done: false }
	}


/***/ },
/* 30 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = find;

	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	function find(list, predicate) {
	  for (var i = 0; i < list.length; i++) {
	    if (predicate(list[i])) {
	      return list[i];
	    }
	  }
	}

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.isEqualType = isEqualType;
	exports.isTypeSubTypeOf = isTypeSubTypeOf;
	exports.doTypesOverlap = doTypesOverlap;

	var _definition = __webpack_require__(22);

	/**
	 * Provided two types, return true if the types are equal (invariant).
	 */
	function isEqualType(typeA, typeB) {
	  // Equivalent types are equal.
	  if (typeA === typeB) {
	    return true;
	  }

	  // If either type is non-null, the other must also be non-null.
	  if (typeA instanceof _definition.GraphQLNonNull && typeB instanceof _definition.GraphQLNonNull) {
	    return isEqualType(typeA.ofType, typeB.ofType);
	  }

	  // If either type is a list, the other must also be a list.
	  if (typeA instanceof _definition.GraphQLList && typeB instanceof _definition.GraphQLList) {
	    return isEqualType(typeA.ofType, typeB.ofType);
	  }

	  // Otherwise the types are not equal.
	  return false;
	}

	/**
	 * Provided a type and a super type, return true if the first type is either
	 * equal or a subset of the second super type (covariant).
	 */

	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	function isTypeSubTypeOf(schema, maybeSubType, superType) {
	  // Equivalent type is a valid subtype
	  if (maybeSubType === superType) {
	    return true;
	  }

	  // If superType is non-null, maybeSubType must also be non-null.
	  if (superType instanceof _definition.GraphQLNonNull) {
	    if (maybeSubType instanceof _definition.GraphQLNonNull) {
	      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
	    }
	    return false;
	  } else if (maybeSubType instanceof _definition.GraphQLNonNull) {
	    // If superType is nullable, maybeSubType may be non-null or nullable.
	    return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);
	  }

	  // If superType type is a list, maybeSubType type must also be a list.
	  if (superType instanceof _definition.GraphQLList) {
	    if (maybeSubType instanceof _definition.GraphQLList) {
	      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
	    }
	    return false;
	  } else if (maybeSubType instanceof _definition.GraphQLList) {
	    // If superType is not a list, maybeSubType must also be not a list.
	    return false;
	  }

	  // If superType type is an abstract type, maybeSubType type may be a currently
	  // possible object type.
	  if ((0, _definition.isAbstractType)(superType) && maybeSubType instanceof _definition.GraphQLObjectType && schema.isPossibleType(superType, maybeSubType)) {
	    return true;
	  }

	  // Otherwise, the child type is not a valid subtype of the parent type.
	  return false;
	}

	/**
	 * Provided two composite types, determine if they "overlap". Two composite
	 * types overlap when the Sets of possible concrete types for each intersect.
	 *
	 * This is often used to determine if a fragment of a given type could possibly
	 * be visited in a context of another type.
	 *
	 * This function is commutative.
	 */
	function doTypesOverlap(schema, typeA, typeB) {
	  // So flow is aware this is constant
	  var _typeB = typeB;

	  // Equivalent types overlap
	  if (typeA === _typeB) {
	    return true;
	  }

	  if (typeA instanceof _definition.GraphQLInterfaceType || typeA instanceof _definition.GraphQLUnionType) {
	    if (_typeB instanceof _definition.GraphQLInterfaceType || _typeB instanceof _definition.GraphQLUnionType) {
	      // If both types are abstract, then determine if there is any intersection
	      // between possible concrete types of each.
	      return schema.getPossibleTypes(typeA).some(function (type) {
	        return schema.isPossibleType(_typeB, type);
	      });
	    }
	    // Determine if the latter type is a possible concrete type of the former.
	    return schema.isPossibleType(typeA, _typeB);
	  }

	  if (_typeB instanceof _definition.GraphQLInterfaceType || _typeB instanceof _definition.GraphQLUnionType) {
	    // Determine if the former type is a possible concrete type of the latter.
	    return schema.isPossibleType(_typeB, typeA);
	  }

	  // Otherwise the types do not overlap.
	  return false;
	}

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.TypeInfo = undefined;

	var _kinds = __webpack_require__(15);

	var Kind = _interopRequireWildcard(_kinds);

	var _definition = __webpack_require__(22);

	var _introspection = __webpack_require__(27);

	var _typeFromAST = __webpack_require__(33);

	var _find = __webpack_require__(30);

	var _find2 = _interopRequireDefault(_find);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	/**
	 * TypeInfo is a utility class which, given a GraphQL schema, can keep track
	 * of the current field and type definitions at any point in a GraphQL document
	 * AST during a recursive descent by calling `enter(node)` and `leave(node)`.
	 */
	var TypeInfo = exports.TypeInfo = function () {
	  function TypeInfo(schema,
	  // NOTE: this experimental optional second parameter is only needed in order
	  // to support non-spec-compliant codebases. You should never need to use it.
	  getFieldDefFn) {
	    _classCallCheck(this, TypeInfo);

	    this._schema = schema;
	    this._typeStack = [];
	    this._parentTypeStack = [];
	    this._inputTypeStack = [];
	    this._fieldDefStack = [];
	    this._directive = null;
	    this._argument = null;
	    this._getFieldDef = getFieldDefFn || getFieldDef;
	  }

	  TypeInfo.prototype.getType = function getType() {
	    if (this._typeStack.length > 0) {
	      return this._typeStack[this._typeStack.length - 1];
	    }
	  };

	  TypeInfo.prototype.getParentType = function getParentType() {
	    if (this._parentTypeStack.length > 0) {
	      return this._parentTypeStack[this._parentTypeStack.length - 1];
	    }
	  };

	  TypeInfo.prototype.getInputType = function getInputType() {
	    if (this._inputTypeStack.length > 0) {
	      return this._inputTypeStack[this._inputTypeStack.length - 1];
	    }
	  };

	  TypeInfo.prototype.getFieldDef = function getFieldDef() {
	    if (this._fieldDefStack.length > 0) {
	      return this._fieldDefStack[this._fieldDefStack.length - 1];
	    }
	  };

	  TypeInfo.prototype.getDirective = function getDirective() {
	    return this._directive;
	  };

	  TypeInfo.prototype.getArgument = function getArgument() {
	    return this._argument;
	  };

	  // Flow does not yet handle this case.


	  TypeInfo.prototype.enter = function enter(node /* Node */) {
	    var schema = this._schema;
	    switch (node.kind) {
	      case Kind.SELECTION_SET:
	        var namedType = (0, _definition.getNamedType)(this.getType());
	        var compositeType = void 0;
	        if ((0, _definition.isCompositeType)(namedType)) {
	          // isCompositeType is a type refining predicate, so this is safe.
	          compositeType = namedType;
	        }
	        this._parentTypeStack.push(compositeType);
	        break;
	      case Kind.FIELD:
	        var parentType = this.getParentType();
	        var fieldDef = void 0;
	        if (parentType) {
	          fieldDef = this._getFieldDef(schema, parentType, node);
	        }
	        this._fieldDefStack.push(fieldDef);
	        this._typeStack.push(fieldDef && fieldDef.type);
	        break;
	      case Kind.DIRECTIVE:
	        this._directive = schema.getDirective(node.name.value);
	        break;
	      case Kind.OPERATION_DEFINITION:
	        var type = void 0;
	        if (node.operation === 'query') {
	          type = schema.getQueryType();
	        } else if (node.operation === 'mutation') {
	          type = schema.getMutationType();
	        } else if (node.operation === 'subscription') {
	          type = schema.getSubscriptionType();
	        }
	        this._typeStack.push(type);
	        break;
	      case Kind.INLINE_FRAGMENT:
	      case Kind.FRAGMENT_DEFINITION:
	        var typeConditionAST = node.typeCondition;
	        var outputType = typeConditionAST ? (0, _typeFromAST.typeFromAST)(schema, typeConditionAST) : this.getType();
	        this._typeStack.push(outputType);
	        break;
	      case Kind.VARIABLE_DEFINITION:
	        var inputType = (0, _typeFromAST.typeFromAST)(schema, node.type);
	        this._inputTypeStack.push(inputType);
	        break;
	      case Kind.ARGUMENT:
	        var argDef = void 0;
	        var argType = void 0;
	        var fieldOrDirective = this.getDirective() || this.getFieldDef();
	        if (fieldOrDirective) {
	          argDef = (0, _find2.default)(fieldOrDirective.args, function (arg) {
	            return arg.name === node.name.value;
	          });
	          if (argDef) {
	            argType = argDef.type;
	          }
	        }
	        this._argument = argDef;
	        this._inputTypeStack.push(argType);
	        break;
	      case Kind.LIST:
	        var listType = (0, _definition.getNullableType)(this.getInputType());
	        this._inputTypeStack.push(listType instanceof _definition.GraphQLList ? listType.ofType : undefined);
	        break;
	      case Kind.OBJECT_FIELD:
	        var objectType = (0, _definition.getNamedType)(this.getInputType());
	        var fieldType = void 0;
	        if (objectType instanceof _definition.GraphQLInputObjectType) {
	          var inputField = objectType.getFields()[node.name.value];
	          fieldType = inputField ? inputField.type : undefined;
	        }
	        this._inputTypeStack.push(fieldType);
	        break;
	    }
	  };

	  TypeInfo.prototype.leave = function leave(node) {
	    switch (node.kind) {
	      case Kind.SELECTION_SET:
	        this._parentTypeStack.pop();
	        break;
	      case Kind.FIELD:
	        this._fieldDefStack.pop();
	        this._typeStack.pop();
	        break;
	      case Kind.DIRECTIVE:
	        this._directive = null;
	        break;
	      case Kind.OPERATION_DEFINITION:
	      case Kind.INLINE_FRAGMENT:
	      case Kind.FRAGMENT_DEFINITION:
	        this._typeStack.pop();
	        break;
	      case Kind.VARIABLE_DEFINITION:
	        this._inputTypeStack.pop();
	        break;
	      case Kind.ARGUMENT:
	        this._argument = null;
	        this._inputTypeStack.pop();
	        break;
	      case Kind.LIST:
	      case Kind.OBJECT_FIELD:
	        this._inputTypeStack.pop();
	        break;
	    }
	  };

	  return TypeInfo;
	}();

	/**
	 * Not exactly the same as the executor's definition of getFieldDef, in this
	 * statically evaluated environment we do not always have an Object type,
	 * and need to handle Interface and Union types.
	 */


	function getFieldDef(schema, parentType, fieldAST) {
	  var name = fieldAST.name.value;
	  if (name === _introspection.SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {
	    return _introspection.SchemaMetaFieldDef;
	  }
	  if (name === _introspection.TypeMetaFieldDef.name && schema.getQueryType() === parentType) {
	    return _introspection.TypeMetaFieldDef;
	  }
	  if (name === _introspection.TypeNameMetaFieldDef.name && (parentType instanceof _definition.GraphQLObjectType || parentType instanceof _definition.GraphQLInterfaceType || parentType instanceof _definition.GraphQLUnionType)) {
	    return _introspection.TypeNameMetaFieldDef;
	  }
	  if (parentType instanceof _definition.GraphQLObjectType || parentType instanceof _definition.GraphQLInterfaceType) {
	    return parentType.getFields()[name];
	  }
	}

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.typeFromAST = typeFromAST;

	var _invariant = __webpack_require__(19);

	var _invariant2 = _interopRequireDefault(_invariant);

	var _kinds = __webpack_require__(15);

	var _definition = __webpack_require__(22);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function typeFromAST(schema, inputTypeAST) {
	  var innerType = void 0;
	  if (inputTypeAST.kind === _kinds.LIST_TYPE) {
	    innerType = typeFromAST(schema, inputTypeAST.type);
	    return innerType && new _definition.GraphQLList(innerType);
	  }
	  if (inputTypeAST.kind === _kinds.NON_NULL_TYPE) {
	    innerType = typeFromAST(schema, inputTypeAST.type);
	    return innerType && new _definition.GraphQLNonNull(innerType);
	  }
	  (0, _invariant2.default)(inputTypeAST.kind === _kinds.NAMED_TYPE, 'Must be a named type.');
	  return schema.getType(inputTypeAST.name.value);
	}
	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.specifiedRules = undefined;

	var _UniqueOperationNames = __webpack_require__(35);

	var _LoneAnonymousOperation = __webpack_require__(36);

	var _KnownTypeNames = __webpack_require__(37);

	var _FragmentsOnCompositeTypes = __webpack_require__(40);

	var _VariablesAreInputTypes = __webpack_require__(41);

	var _ScalarLeafs = __webpack_require__(42);

	var _FieldsOnCorrectType = __webpack_require__(43);

	var _UniqueFragmentNames = __webpack_require__(44);

	var _KnownFragmentNames = __webpack_require__(45);

	var _NoUnusedFragments = __webpack_require__(46);

	var _PossibleFragmentSpreads = __webpack_require__(47);

	var _NoFragmentCycles = __webpack_require__(48);

	var _UniqueVariableNames = __webpack_require__(49);

	var _NoUndefinedVariables = __webpack_require__(50);

	var _NoUnusedVariables = __webpack_require__(51);

	var _KnownDirectives = __webpack_require__(52);

	var _KnownArgumentNames = __webpack_require__(53);

	var _UniqueArgumentNames = __webpack_require__(54);

	var _ArgumentsOfCorrectType = __webpack_require__(55);

	var _ProvidedNonNullArguments = __webpack_require__(58);

	var _DefaultValuesOfCorrectType = __webpack_require__(59);

	var _VariablesInAllowedPosition = __webpack_require__(60);

	var _OverlappingFieldsCanBeMerged = __webpack_require__(61);

	var _UniqueInputFieldNames = __webpack_require__(62);

	/**
	 * This set includes all validation rules defined by the GraphQL spec.
	 */


	// Spec Section: "Field Selection Merging"


	// Spec Section: "Variable Default Values Are Correctly Typed"


	// Spec Section: "Argument Values Type Correctness"


	// Spec Section: "Argument Names"


	// Spec Section: "All Variables Used"


	// Spec Section: "Variable Uniqueness"


	// Spec Section: "Fragment spread is possible"


	// Spec Section: "Fragment spread target defined"


	// Spec Section: "Field Selections on Objects, Interfaces, and Unions Types"


	// Spec Section: "Variables are Input Types"


	// Spec Section: "Fragment Spread Type Existence"

	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	// Spec Section: "Operation Name Uniqueness"
	var specifiedRules = exports.specifiedRules = [_UniqueOperationNames.UniqueOperationNames, _LoneAnonymousOperation.LoneAnonymousOperation, _KnownTypeNames.KnownTypeNames, _FragmentsOnCompositeTypes.FragmentsOnCompositeTypes, _VariablesAreInputTypes.VariablesAreInputTypes, _ScalarLeafs.ScalarLeafs, _FieldsOnCorrectType.FieldsOnCorrectType, _UniqueFragmentNames.UniqueFragmentNames, _KnownFragmentNames.KnownFragmentNames, _NoUnusedFragments.NoUnusedFragments, _PossibleFragmentSpreads.PossibleFragmentSpreads, _NoFragmentCycles.NoFragmentCycles, _UniqueVariableNames.UniqueVariableNames, _NoUndefinedVariables.NoUndefinedVariables, _NoUnusedVariables.NoUnusedVariables, _KnownDirectives.KnownDirectives, _KnownArgumentNames.KnownArgumentNames, _UniqueArgumentNames.UniqueArgumentNames, _ArgumentsOfCorrectType.ArgumentsOfCorrectType, _ProvidedNonNullArguments.ProvidedNonNullArguments, _DefaultValuesOfCorrectType.DefaultValuesOfCorrectType, _VariablesInAllowedPosition.VariablesInAllowedPosition, _OverlappingFieldsCanBeMerged.OverlappingFieldsCanBeMerged, _UniqueInputFieldNames.UniqueInputFieldNames];

	// Spec Section: "Input Object Field Uniqueness"


	// Spec Section: "All Variable Usages Are Allowed"


	// Spec Section: "Argument Optionality"


	// Spec Section: "Argument Uniqueness"


	// Spec Section: "Directives Are Defined"


	// Spec Section: "All Variable Used Defined"


	// Spec Section: "Fragments must not form cycles"


	// Spec Section: "Fragments must be used"


	// Spec Section: "Fragment Name Uniqueness"


	// Spec Section: "Leaf Field Selections"


	// Spec Section: "Fragments on Composite Types"


	// Spec Section: "Lone Anonymous Operation"

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.duplicateOperationNameMessage = duplicateOperationNameMessage;
	exports.UniqueOperationNames = UniqueOperationNames;

	var _error = __webpack_require__(8);

	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	function duplicateOperationNameMessage(operationName) {
	  return 'There can only be one operation named "' + operationName + '".';
	}

	/**
	 * Unique operation names
	 *
	 * A GraphQL document is only valid if all defined operations have unique names.
	 */
	function UniqueOperationNames(context) {
	  var knownOperationNames = Object.create(null);
	  return {
	    OperationDefinition: function OperationDefinition(node) {
	      var operationName = node.name;
	      if (operationName) {
	        if (knownOperationNames[operationName.value]) {
	          context.reportError(new _error.GraphQLError(duplicateOperationNameMessage(operationName.value), [knownOperationNames[operationName.value], operationName]));
	        } else {
	          knownOperationNames[operationName.value] = operationName;
	        }
	      }
	      return false;
	    },

	    FragmentDefinition: function FragmentDefinition() {
	      return false;
	    }
	  };
	}

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.anonOperationNotAloneMessage = anonOperationNotAloneMessage;
	exports.LoneAnonymousOperation = LoneAnonymousOperation;

	var _error = __webpack_require__(8);

	var _kinds = __webpack_require__(15);

	function anonOperationNotAloneMessage() {
	  return 'This anonymous operation must be the only defined operation.';
	}

	/**
	 * Lone anonymous operation
	 *
	 * A GraphQL document is only valid if when it contains an anonymous operation
	 * (the query short-hand) that it contains only that one operation definition.
	 */

	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	function LoneAnonymousOperation(context) {
	  var operationCount = 0;
	  return {
	    Document: function Document(node) {
	      operationCount = node.definitions.filter(function (definition) {
	        return definition.kind === _kinds.OPERATION_DEFINITION;
	      }).length;
	    },
	    OperationDefinition: function OperationDefinition(node) {
	      if (!node.name && operationCount > 1) {
	        context.reportError(new _error.GraphQLError(anonOperationNotAloneMessage(), [node]));
	      }
	    }
	  };
	}

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.unknownTypeMessage = unknownTypeMessage;
	exports.KnownTypeNames = KnownTypeNames;

	var _error = __webpack_require__(8);

	var _suggestionList = __webpack_require__(38);

	var _suggestionList2 = _interopRequireDefault(_suggestionList);

	var _quotedOrList = __webpack_require__(39);

	var _quotedOrList2 = _interopRequireDefault(_quotedOrList);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	function unknownTypeMessage(type, suggestedTypes) {
	  var message = 'Unknown type "' + String(type) + '".';
	  if (suggestedTypes.length) {
	    message += ' Did you mean ' + (0, _quotedOrList2.default)(suggestedTypes) + '?';
	  }
	  return message;
	}

	/**
	 * Known type names
	 *
	 * A GraphQL document is only valid if referenced types (specifically
	 * variable definitions and fragment conditions) are defined by the type schema.
	 */
	function KnownTypeNames(context) {
	  return {
	    // TODO: when validating IDL, re-enable these. Experimental version does not
	    // add unreferenced types, resulting in false-positive errors. Squelched
	    // errors for now.
	    ObjectTypeDefinition: function ObjectTypeDefinition() {
	      return false;
	    },
	    InterfaceTypeDefinition: function InterfaceTypeDefinition() {
	      return false;
	    },
	    UnionTypeDefinition: function UnionTypeDefinition() {
	      return false;
	    },
	    InputObjectTypeDefinition: function InputObjectTypeDefinition() {
	      return false;
	    },
	    NamedType: function NamedType(node) {
	      var schema = context.getSchema();
	      var typeName = node.name.value;
	      var type = schema.getType(typeName);
	      if (!type) {
	        context.reportError(new _error.GraphQLError(unknownTypeMessage(typeName, (0, _suggestionList2.default)(typeName, Object.keys(schema.getTypeMap()))), [node]));
	      }
	    }
	  };
	}

/***/ },
/* 38 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = suggestionList;

	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	/**
	 * Given an invalid input string and a list of valid options, returns a filtered
	 * list of valid options sorted based on their similarity with the input.
	 */
	function suggestionList(input, options) {
	  var optionsByDistance = Object.create(null);
	  var oLength = options.length;
	  var inputThreshold = input.length / 2;
	  for (var i = 0; i < oLength; i++) {
	    var distance = lexicalDistance(input, options[i]);
	    var threshold = Math.max(inputThreshold, options[i].length / 2, 1);
	    if (distance <= threshold) {
	      optionsByDistance[options[i]] = distance;
	    }
	  }
	  return Object.keys(optionsByDistance).sort(function (a, b) {
	    return optionsByDistance[a] - optionsByDistance[b];
	  });
	}

	/**
	 * Computes the lexical distance between strings A and B.
	 *
	 * The "distance" between two strings is given by counting the minimum number
	 * of edits needed to transform string A into string B. An edit can be an
	 * insertion, deletion, or substitution of a single character, or a swap of two
	 * adjacent characters.
	 *
	 * This distance can be useful for detecting typos in input or sorting
	 *
	 * @param {string} a
	 * @param {string} b
	 * @return {int} distance in number of edits
	 */
	function lexicalDistance(a, b) {
	  var i = void 0;
	  var j = void 0;
	  var d = [];
	  var aLength = a.length;
	  var bLength = b.length;

	  for (i = 0; i <= aLength; i++) {
	    d[i] = [i];
	  }

	  for (j = 1; j <= bLength; j++) {
	    d[0][j] = j;
	  }

	  for (i = 1; i <= aLength; i++) {
	    for (j = 1; j <= bLength; j++) {
	      var cost = a[i - 1] === b[j - 1] ? 0 : 1;

	      d[i][j] = Math.min(d[i - 1][j] + 1, d[i][j - 1] + 1, d[i - 1][j - 1] + cost);

	      if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
	        d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + cost);
	      }
	    }
	  }

	  return d[aLength][bLength];
	}

/***/ },
/* 39 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = quotedOrList;

	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	var MAX_LENGTH = 5;

	/**
	 * Given [ A, B, C ] return '"A", "B", or "C"'.
	 */
	function quotedOrList(items) {
	  var selected = items.slice(0, MAX_LENGTH);
	  return selected.map(function (item) {
	    return '"' + item + '"';
	  }).reduce(function (list, quoted, index) {
	    return list + (selected.length > 2 ? ', ' : ' ') + (index === selected.length - 1 ? 'or ' : '') + quoted;
	  });
	}

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.inlineFragmentOnNonCompositeErrorMessage = inlineFragmentOnNonCompositeErrorMessage;
	exports.fragmentOnNonCompositeErrorMessage = fragmentOnNonCompositeErrorMessage;
	exports.FragmentsOnCompositeTypes = FragmentsOnCompositeTypes;

	var _error = __webpack_require__(8);

	var _printer = __webpack_require__(13);

	var _definition = __webpack_require__(22);

	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	function inlineFragmentOnNonCompositeErrorMessage(type) {
	  return 'Fragment cannot condition on non composite type "' + String(type) + '".';
	}

	function fragmentOnNonCompositeErrorMessage(fragName, type) {
	  return 'Fragment "' + fragName + '" cannot condition on non composite ' + ('type "' + String(type) + '".');
	}

	/**
	 * Fragments on composite type
	 *
	 * Fragments use a type condition to determine if they apply, since fragments
	 * can only be spread into a composite type (object, interface, or union), the
	 * type condition must also be a composite type.
	 */
	function FragmentsOnCompositeTypes(context) {
	  return {
	    InlineFragment: function InlineFragment(node) {
	      var type = context.getType();
	      if (node.typeCondition && type && !(0, _definition.isCompositeType)(type)) {
	        context.reportError(new _error.GraphQLError(inlineFragmentOnNonCompositeErrorMessage((0, _printer.print)(node.typeCondition)), [node.typeCondition]));
	      }
	    },
	    FragmentDefinition: function FragmentDefinition(node) {
	      var type = context.getType();
	      if (type && !(0, _definition.isCompositeType)(type)) {
	        context.reportError(new _error.GraphQLError(fragmentOnNonCompositeErrorMessage(node.name.value, (0, _printer.print)(node.typeCondition)), [node.typeCondition]));
	      }
	    }
	  };
	}

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.nonInputTypeOnVarMessage = nonInputTypeOnVarMessage;
	exports.VariablesAreInputTypes = VariablesAreInputTypes;

	var _error = __webpack_require__(8);

	var _printer = __webpack_require__(13);

	var _definition = __webpack_require__(22);

	var _typeFromAST = __webpack_require__(33);

	function nonInputTypeOnVarMessage(variableName, typeName) {
	  return 'Variable "$' + variableName + '" cannot be non-input type "' + typeName + '".';
	}

	/**
	 * Variables are input types
	 *
	 * A GraphQL operation is only valid if all the variables it defines are of
	 * input types (scalar, enum, or input object).
	 */

	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	function VariablesAreInputTypes(context) {
	  return {
	    VariableDefinition: function VariableDefinition(node) {
	      var type = (0, _typeFromAST.typeFromAST)(context.getSchema(), node.type);

	      // If the variable type is not an input type, return an error.
	      if (type && !(0, _definition.isInputType)(type)) {
	        var variableName = node.variable.name.value;
	        context.reportError(new _error.GraphQLError(nonInputTypeOnVarMessage(variableName, (0, _printer.print)(node.type)), [node.type]));
	      }
	    }
	  };
	}

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.noSubselectionAllowedMessage = noSubselectionAllowedMessage;
	exports.requiredSubselectionMessage = requiredSubselectionMessage;
	exports.ScalarLeafs = ScalarLeafs;

	var _error = __webpack_require__(8);

	var _definition = __webpack_require__(22);

	function noSubselectionAllowedMessage(fieldName, type) {
	  return 'Field "' + fieldName + '" must not have a selection since ' + ('type "' + String(type) + '" has no subfields.');
	}
	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	function requiredSubselectionMessage(fieldName, type) {
	  return 'Field "' + fieldName + '" of type "' + String(type) + '" must have a ' + ('selection of subfields. Did you mean "' + fieldName + ' { ... }"?');
	}

	/**
	 * Scalar leafs
	 *
	 * A GraphQL document is valid only if all leaf fields (fields without
	 * sub selections) are of scalar or enum types.
	 */
	function ScalarLeafs(context) {
	  return {
	    Field: function Field(node) {
	      var type = context.getType();
	      if (type) {
	        if ((0, _definition.isLeafType)(type)) {
	          if (node.selectionSet) {
	            context.reportError(new _error.GraphQLError(noSubselectionAllowedMessage(node.name.value, type), [node.selectionSet]));
	          }
	        } else if (!node.selectionSet) {
	          context.reportError(new _error.GraphQLError(requiredSubselectionMessage(node.name.value, type), [node]));
	        }
	      }
	    }
	  };
	}

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.undefinedFieldMessage = undefinedFieldMessage;
	exports.FieldsOnCorrectType = FieldsOnCorrectType;

	var _error = __webpack_require__(8);

	var _suggestionList = __webpack_require__(38);

	var _suggestionList2 = _interopRequireDefault(_suggestionList);

	var _quotedOrList = __webpack_require__(39);

	var _quotedOrList2 = _interopRequireDefault(_quotedOrList);

	var _definition = __webpack_require__(22);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function undefinedFieldMessage(fieldName, type, suggestedTypeNames, suggestedFieldNames) {
	  var message = 'Cannot query field "' + fieldName + '" on type "' + type + '".';
	  if (suggestedTypeNames.length !== 0) {
	    var suggestions = (0, _quotedOrList2.default)(suggestedTypeNames);
	    message += ' Did you mean to use an inline fragment on ' + suggestions + '?';
	  } else if (suggestedFieldNames.length !== 0) {
	    message += ' Did you mean ' + (0, _quotedOrList2.default)(suggestedFieldNames) + '?';
	  }
	  return message;
	}

	/**
	 * Fields on correct type
	 *
	 * A GraphQL document is only valid if all fields selected are defined by the
	 * parent type, or are an allowed meta field such as __typename.
	 */

	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	function FieldsOnCorrectType(context) {
	  return {
	    Field: function Field(node) {
	      var type = context.getParentType();
	      if (type) {
	        var fieldDef = context.getFieldDef();
	        if (!fieldDef) {
	          // This field doesn't exist, lets look for suggestions.
	          var schema = context.getSchema();
	          var fieldName = node.name.value;
	          // First determine if there are any suggested types to condition on.
	          var suggestedTypeNames = getSuggestedTypeNames(schema, type, fieldName);
	          // If there are no suggested types, then perhaps this was a typo?
	          var suggestedFieldNames = suggestedTypeNames.length !== 0 ? [] : getSuggestedFieldNames(schema, type, fieldName);

	          // Report an error, including helpful suggestions.
	          context.reportError(new _error.GraphQLError(undefinedFieldMessage(fieldName, type.name, suggestedTypeNames, suggestedFieldNames), [node]));
	        }
	      }
	    }
	  };
	}

	/**
	 * Go through all of the implementations of type, as well as the interfaces
	 * that they implement. If any of those types include the provided field,
	 * suggest them, sorted by how often the type is referenced,  starting
	 * with Interfaces.
	 */
	function getSuggestedTypeNames(schema, type, fieldName) {
	  if (type instanceof _definition.GraphQLInterfaceType || type instanceof _definition.GraphQLUnionType) {
	    var _ret = function () {
	      var suggestedObjectTypes = [];
	      var interfaceUsageCount = Object.create(null);
	      schema.getPossibleTypes(type).forEach(function (possibleType) {
	        if (!possibleType.getFields()[fieldName]) {
	          return;
	        }
	        // This object type defines this field.
	        suggestedObjectTypes.push(possibleType.name);
	        possibleType.getInterfaces().forEach(function (possibleInterface) {
	          if (!possibleInterface.getFields()[fieldName]) {
	            return;
	          }
	          // This interface type defines this field.
	          interfaceUsageCount[possibleInterface.name] = (interfaceUsageCount[possibleInterface.name] || 0) + 1;
	        });
	      });

	      // Suggest interface types based on how common they are.
	      var suggestedInterfaceTypes = Object.keys(interfaceUsageCount).sort(function (a, b) {
	        return interfaceUsageCount[b] - interfaceUsageCount[a];
	      });

	      // Suggest both interface and object types.
	      return {
	        v: suggestedInterfaceTypes.concat(suggestedObjectTypes)
	      };
	    }();

	    if (typeof _ret === "object") return _ret.v;
	  }

	  // Otherwise, must be an Object type, which does not have possible fields.
	  return [];
	}

	/**
	 * For the field name provided, determine if there are any similar field names
	 * that may be the result of a typo.
	 */
	function getSuggestedFieldNames(schema, type, fieldName) {
	  if (type instanceof _definition.GraphQLObjectType || type instanceof _definition.GraphQLInterfaceType) {
	    var possibleFieldNames = Object.keys(type.getFields());
	    return (0, _suggestionList2.default)(fieldName, possibleFieldNames);
	  }
	  // Otherwise, must be a Union type, which does not define fields.
	  return [];
	}

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.duplicateFragmentNameMessage = duplicateFragmentNameMessage;
	exports.UniqueFragmentNames = UniqueFragmentNames;

	var _error = __webpack_require__(8);

	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	function duplicateFragmentNameMessage(fragName) {
	  return 'There can only be one fragment named "' + fragName + '".';
	}

	/**
	 * Unique fragment names
	 *
	 * A GraphQL document is only valid if all defined fragments have unique names.
	 */
	function UniqueFragmentNames(context) {
	  var knownFragmentNames = Object.create(null);
	  return {
	    OperationDefinition: function OperationDefinition() {
	      return false;
	    },
	    FragmentDefinition: function FragmentDefinition(node) {
	      var fragmentName = node.name.value;
	      if (knownFragmentNames[fragmentName]) {
	        context.reportError(new _error.GraphQLError(duplicateFragmentNameMessage(fragmentName), [knownFragmentNames[fragmentName], node.name]));
	      } else {
	        knownFragmentNames[fragmentName] = node.name;
	      }
	      return false;
	    }
	  };
	}

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.unknownFragmentMessage = unknownFragmentMessage;
	exports.KnownFragmentNames = KnownFragmentNames;

	var _error = __webpack_require__(8);

	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	function unknownFragmentMessage(fragName) {
	  return 'Unknown fragment "' + fragName + '".';
	}

	/**
	 * Known fragment names
	 *
	 * A GraphQL document is only valid if all `...Fragment` fragment spreads refer
	 * to fragments defined in the same document.
	 */
	function KnownFragmentNames(context) {
	  return {
	    FragmentSpread: function FragmentSpread(node) {
	      var fragmentName = node.name.value;
	      var fragment = context.getFragment(fragmentName);
	      if (!fragment) {
	        context.reportError(new _error.GraphQLError(unknownFragmentMessage(fragmentName), [node.name]));
	      }
	    }
	  };
	}

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.unusedFragMessage = unusedFragMessage;
	exports.NoUnusedFragments = NoUnusedFragments;

	var _error = __webpack_require__(8);

	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	function unusedFragMessage(fragName) {
	  return 'Fragment "' + fragName + '" is never used.';
	}

	/**
	 * No unused fragments
	 *
	 * A GraphQL document is only valid if all fragment definitions are spread
	 * within operations, or spread within other fragments spread within operations.
	 */
	function NoUnusedFragments(context) {
	  var operationDefs = [];
	  var fragmentDefs = [];

	  return {
	    OperationDefinition: function OperationDefinition(node) {
	      operationDefs.push(node);
	      return false;
	    },
	    FragmentDefinition: function FragmentDefinition(node) {
	      fragmentDefs.push(node);
	      return false;
	    },

	    Document: {
	      leave: function leave() {
	        var fragmentNameUsed = Object.create(null);
	        operationDefs.forEach(function (operation) {
	          context.getRecursivelyReferencedFragments(operation).forEach(function (fragment) {
	            fragmentNameUsed[fragment.name.value] = true;
	          });
	        });

	        fragmentDefs.forEach(function (fragmentDef) {
	          var fragName = fragmentDef.name.value;
	          if (fragmentNameUsed[fragName] !== true) {
	            context.reportError(new _error.GraphQLError(unusedFragMessage(fragName), [fragmentDef]));
	          }
	        });
	      }
	    }
	  };
	}

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.typeIncompatibleSpreadMessage = typeIncompatibleSpreadMessage;
	exports.typeIncompatibleAnonSpreadMessage = typeIncompatibleAnonSpreadMessage;
	exports.PossibleFragmentSpreads = PossibleFragmentSpreads;

	var _error = __webpack_require__(8);

	var _typeComparators = __webpack_require__(31);

	var _typeFromAST = __webpack_require__(33);

	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	function typeIncompatibleSpreadMessage(fragName, parentType, fragType) {
	  return 'Fragment "' + fragName + '" cannot be spread here as objects of ' + ('type "' + String(parentType) + '" can never be of type "' + String(fragType) + '".');
	}

	function typeIncompatibleAnonSpreadMessage(parentType, fragType) {
	  return 'Fragment cannot be spread here as objects of ' + ('type "' + String(parentType) + '" can never be of type "' + String(fragType) + '".');
	}

	/**
	 * Possible fragment spread
	 *
	 * A fragment spread is only valid if the type condition could ever possibly
	 * be true: if there is a non-empty intersection of the possible parent types,
	 * and possible types which pass the type condition.
	 */
	function PossibleFragmentSpreads(context) {
	  return {
	    InlineFragment: function InlineFragment(node) {
	      var fragType = context.getType();
	      var parentType = context.getParentType();
	      if (fragType && parentType && !(0, _typeComparators.doTypesOverlap)(context.getSchema(), fragType, parentType)) {
	        context.reportError(new _error.GraphQLError(typeIncompatibleAnonSpreadMessage(parentType, fragType), [node]));
	      }
	    },
	    FragmentSpread: function FragmentSpread(node) {
	      var fragName = node.name.value;
	      var fragType = getFragmentType(context, fragName);
	      var parentType = context.getParentType();
	      if (fragType && parentType && !(0, _typeComparators.doTypesOverlap)(context.getSchema(), fragType, parentType)) {
	        context.reportError(new _error.GraphQLError(typeIncompatibleSpreadMessage(fragName, parentType, fragType), [node]));
	      }
	    }
	  };
	}

	function getFragmentType(context, name) {
	  var frag = context.getFragment(name);
	  return frag && (0, _typeFromAST.typeFromAST)(context.getSchema(), frag.typeCondition);
	}

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.cycleErrorMessage = cycleErrorMessage;
	exports.NoFragmentCycles = NoFragmentCycles;

	var _error = __webpack_require__(8);

	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	function cycleErrorMessage(fragName, spreadNames) {
	  var via = spreadNames.length ? ' via ' + spreadNames.join(', ') : '';
	  return 'Cannot spread fragment "' + fragName + '" within itself' + via + '.';
	}

	function NoFragmentCycles(context) {
	  // Tracks already visited fragments to maintain O(N) and to ensure that cycles
	  // are not redundantly reported.
	  var visitedFrags = Object.create(null);

	  // Array of AST nodes used to produce meaningful errors
	  var spreadPath = [];

	  // Position in the spread path
	  var spreadPathIndexByName = Object.create(null);

	  return {
	    OperationDefinition: function OperationDefinition() {
	      return false;
	    },
	    FragmentDefinition: function FragmentDefinition(node) {
	      if (!visitedFrags[node.name.value]) {
	        detectCycleRecursive(node);
	      }
	      return false;
	    }
	  };

	  // This does a straight-forward DFS to find cycles.
	  // It does not terminate when a cycle was found but continues to explore
	  // the graph to find all possible cycles.
	  function detectCycleRecursive(fragment) {
	    var fragmentName = fragment.name.value;
	    visitedFrags[fragmentName] = true;

	    var spreadNodes = context.getFragmentSpreads(fragment.selectionSet);
	    if (spreadNodes.length === 0) {
	      return;
	    }

	    spreadPathIndexByName[fragmentName] = spreadPath.length;

	    for (var i = 0; i < spreadNodes.length; i++) {
	      var spreadNode = spreadNodes[i];
	      var spreadName = spreadNode.name.value;
	      var cycleIndex = spreadPathIndexByName[spreadName];

	      if (cycleIndex === undefined) {
	        spreadPath.push(spreadNode);
	        if (!visitedFrags[spreadName]) {
	          var spreadFragment = context.getFragment(spreadName);
	          if (spreadFragment) {
	            detectCycleRecursive(spreadFragment);
	          }
	        }
	        spreadPath.pop();
	      } else {
	        var cyclePath = spreadPath.slice(cycleIndex);
	        context.reportError(new _error.GraphQLError(cycleErrorMessage(spreadName, cyclePath.map(function (s) {
	          return s.name.value;
	        })), cyclePath.concat(spreadNode)));
	      }
	    }

	    spreadPathIndexByName[fragmentName] = undefined;
	  }
	}

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.duplicateVariableMessage = duplicateVariableMessage;
	exports.UniqueVariableNames = UniqueVariableNames;

	var _error = __webpack_require__(8);

	function duplicateVariableMessage(variableName) {
	  return 'There can be only one variable named "' + variableName + '".';
	}

	/**
	 * Unique variable names
	 *
	 * A GraphQL operation is only valid if all its variables are uniquely named.
	 */

	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	function UniqueVariableNames(context) {
	  var knownVariableNames = Object.create(null);
	  return {
	    OperationDefinition: function OperationDefinition() {
	      knownVariableNames = Object.create(null);
	    },
	    VariableDefinition: function VariableDefinition(node) {
	      var variableName = node.variable.name.value;
	      if (knownVariableNames[variableName]) {
	        context.reportError(new _error.GraphQLError(duplicateVariableMessage(variableName), [knownVariableNames[variableName], node.variable.name]));
	      } else {
	        knownVariableNames[variableName] = node.variable.name;
	      }
	    }
	  };
	}

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.undefinedVarMessage = undefinedVarMessage;
	exports.NoUndefinedVariables = NoUndefinedVariables;

	var _error = __webpack_require__(8);

	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	function undefinedVarMessage(varName, opName) {
	  return opName ? 'Variable "$' + varName + '" is not defined by operation "' + opName + '".' : 'Variable "$' + varName + '" is not defined.';
	}

	/**
	 * No undefined variables
	 *
	 * A GraphQL operation is only valid if all variables encountered, both directly
	 * and via fragment spreads, are defined by that operation.
	 */
	function NoUndefinedVariables(context) {
	  var variableNameDefined = Object.create(null);

	  return {
	    OperationDefinition: {
	      enter: function enter() {
	        variableNameDefined = Object.create(null);
	      },
	      leave: function leave(operation) {
	        var usages = context.getRecursiveVariableUsages(operation);

	        usages.forEach(function (_ref) {
	          var node = _ref.node;

	          var varName = node.name.value;
	          if (variableNameDefined[varName] !== true) {
	            context.reportError(new _error.GraphQLError(undefinedVarMessage(varName, operation.name && operation.name.value), [node, operation]));
	          }
	        });
	      }
	    },
	    VariableDefinition: function VariableDefinition(varDefAST) {
	      variableNameDefined[varDefAST.variable.name.value] = true;
	    }
	  };
	}

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.unusedVariableMessage = unusedVariableMessage;
	exports.NoUnusedVariables = NoUnusedVariables;

	var _error = __webpack_require__(8);

	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	function unusedVariableMessage(varName, opName) {
	  return opName ? 'Variable "$' + varName + '" is never used in operation "' + opName + '".' : 'Variable "$' + varName + '" is never used.';
	}

	/**
	 * No unused variables
	 *
	 * A GraphQL operation is only valid if all variables defined by an operation
	 * are used, either directly or within a spread fragment.
	 */
	function NoUnusedVariables(context) {
	  var variableDefs = [];

	  return {
	    OperationDefinition: {
	      enter: function enter() {
	        variableDefs = [];
	      },
	      leave: function leave(operation) {
	        var variableNameUsed = Object.create(null);
	        var usages = context.getRecursiveVariableUsages(operation);
	        var opName = operation.name ? operation.name.value : null;

	        usages.forEach(function (_ref) {
	          var node = _ref.node;

	          variableNameUsed[node.name.value] = true;
	        });

	        variableDefs.forEach(function (variableDef) {
	          var variableName = variableDef.variable.name.value;
	          if (variableNameUsed[variableName] !== true) {
	            context.reportError(new _error.GraphQLError(unusedVariableMessage(variableName, opName), [variableDef]));
	          }
	        });
	      }
	    },
	    VariableDefinition: function VariableDefinition(def) {
	      variableDefs.push(def);
	    }
	  };
	}

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.unknownDirectiveMessage = unknownDirectiveMessage;
	exports.misplacedDirectiveMessage = misplacedDirectiveMessage;
	exports.KnownDirectives = KnownDirectives;

	var _error = __webpack_require__(8);

	var _find = __webpack_require__(30);

	var _find2 = _interopRequireDefault(_find);

	var _kinds = __webpack_require__(15);

	var _directives = __webpack_require__(25);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function unknownDirectiveMessage(directiveName) {
	  return 'Unknown directive "' + directiveName + '".';
	}
	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	function misplacedDirectiveMessage(directiveName, location) {
	  return 'Directive "' + directiveName + '" may not be used on ' + location + '.';
	}

	/**
	 * Known directives
	 *
	 * A GraphQL document is only valid if all `@directives` are known by the
	 * schema and legally positioned.
	 */
	function KnownDirectives(context) {
	  return {
	    Directive: function Directive(node, key, parent, path, ancestors) {
	      var directiveDef = (0, _find2.default)(context.getSchema().getDirectives(), function (def) {
	        return def.name === node.name.value;
	      });
	      if (!directiveDef) {
	        context.reportError(new _error.GraphQLError(unknownDirectiveMessage(node.name.value), [node]));
	        return;
	      }
	      var candidateLocation = getDirectiveLocationForASTPath(ancestors);
	      if (!candidateLocation) {
	        context.reportError(new _error.GraphQLError(misplacedDirectiveMessage(node.name.value, node.type), [node]));
	      } else if (directiveDef.locations.indexOf(candidateLocation) === -1) {
	        context.reportError(new _error.GraphQLError(misplacedDirectiveMessage(node.name.value, candidateLocation), [node]));
	      }
	    }
	  };
	}

	function getDirectiveLocationForASTPath(ancestors) {
	  var appliedTo = ancestors[ancestors.length - 1];
	  switch (appliedTo.kind) {
	    case _kinds.OPERATION_DEFINITION:
	      switch (appliedTo.operation) {
	        case 'query':
	          return _directives.DirectiveLocation.QUERY;
	        case 'mutation':
	          return _directives.DirectiveLocation.MUTATION;
	        case 'subscription':
	          return _directives.DirectiveLocation.SUBSCRIPTION;
	      }
	      break;
	    case _kinds.FIELD:
	      return _directives.DirectiveLocation.FIELD;
	    case _kinds.FRAGMENT_SPREAD:
	      return _directives.DirectiveLocation.FRAGMENT_SPREAD;
	    case _kinds.INLINE_FRAGMENT:
	      return _directives.DirectiveLocation.INLINE_FRAGMENT;
	    case _kinds.FRAGMENT_DEFINITION:
	      return _directives.DirectiveLocation.FRAGMENT_DEFINITION;
	    case _kinds.SCHEMA_DEFINITION:
	      return _directives.DirectiveLocation.SCHEMA;
	    case _kinds.SCALAR_TYPE_DEFINITION:
	      return _directives.DirectiveLocation.SCALAR;
	    case _kinds.OBJECT_TYPE_DEFINITION:
	      return _directives.DirectiveLocation.OBJECT;
	    case _kinds.FIELD_DEFINITION:
	      return _directives.DirectiveLocation.FIELD_DEFINITION;
	    case _kinds.INTERFACE_TYPE_DEFINITION:
	      return _directives.DirectiveLocation.INTERFACE;
	    case _kinds.UNION_TYPE_DEFINITION:
	      return _directives.DirectiveLocation.UNION;
	    case _kinds.ENUM_TYPE_DEFINITION:
	      return _directives.DirectiveLocation.ENUM;
	    case _kinds.ENUM_VALUE_DEFINITION:
	      return _directives.DirectiveLocation.ENUM_VALUE;
	    case _kinds.INPUT_OBJECT_TYPE_DEFINITION:
	      return _directives.DirectiveLocation.INPUT_OBJECT;
	    case _kinds.INPUT_VALUE_DEFINITION:
	      var parentNode = ancestors[ancestors.length - 3];
	      return parentNode.kind === _kinds.INPUT_OBJECT_TYPE_DEFINITION ? _directives.DirectiveLocation.INPUT_FIELD_DEFINITION : _directives.DirectiveLocation.ARGUMENT_DEFINITION;
	  }
	}

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.unknownArgMessage = unknownArgMessage;
	exports.unknownDirectiveArgMessage = unknownDirectiveArgMessage;
	exports.KnownArgumentNames = KnownArgumentNames;

	var _error = __webpack_require__(8);

	var _find = __webpack_require__(30);

	var _find2 = _interopRequireDefault(_find);

	var _invariant = __webpack_require__(19);

	var _invariant2 = _interopRequireDefault(_invariant);

	var _suggestionList = __webpack_require__(38);

	var _suggestionList2 = _interopRequireDefault(_suggestionList);

	var _quotedOrList = __webpack_require__(39);

	var _quotedOrList2 = _interopRequireDefault(_quotedOrList);

	var _kinds = __webpack_require__(15);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function unknownArgMessage(argName, fieldName, type, suggestedArgs) {
	  var message = 'Unknown argument "' + argName + '" on field "' + fieldName + '" of ' + ('type "' + String(type) + '".');
	  if (suggestedArgs.length) {
	    message += ' Did you mean ' + (0, _quotedOrList2.default)(suggestedArgs) + '?';
	  }
	  return message;
	}
	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	function unknownDirectiveArgMessage(argName, directiveName, suggestedArgs) {
	  var message = 'Unknown argument "' + argName + '" on directive "@' + directiveName + '".';
	  if (suggestedArgs.length) {
	    message += ' Did you mean ' + (0, _quotedOrList2.default)(suggestedArgs) + '?';
	  }
	  return message;
	}

	/**
	 * Known argument names
	 *
	 * A GraphQL field is only valid if all supplied arguments are defined by
	 * that field.
	 */
	function KnownArgumentNames(context) {
	  return {
	    Argument: function Argument(node, key, parent, path, ancestors) {
	      var argumentOf = ancestors[ancestors.length - 1];
	      if (argumentOf.kind === _kinds.FIELD) {
	        var fieldDef = context.getFieldDef();
	        if (fieldDef) {
	          var fieldArgDef = (0, _find2.default)(fieldDef.args, function (arg) {
	            return arg.name === node.name.value;
	          });
	          if (!fieldArgDef) {
	            var parentType = context.getParentType();
	            (0, _invariant2.default)(parentType);
	            context.reportError(new _error.GraphQLError(unknownArgMessage(node.name.value, fieldDef.name, parentType.name, (0, _suggestionList2.default)(node.name.value, fieldDef.args.map(function (arg) {
	              return arg.name;
	            }))), [node]));
	          }
	        }
	      } else if (argumentOf.kind === _kinds.DIRECTIVE) {
	        var directive = context.getDirective();
	        if (directive) {
	          var directiveArgDef = (0, _find2.default)(directive.args, function (arg) {
	            return arg.name === node.name.value;
	          });
	          if (!directiveArgDef) {
	            context.reportError(new _error.GraphQLError(unknownDirectiveArgMessage(node.name.value, directive.name, (0, _suggestionList2.default)(node.name.value, directive.args.map(function (arg) {
	              return arg.name;
	            }))), [node]));
	          }
	        }
	      }
	    }
	  };
	}

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.duplicateArgMessage = duplicateArgMessage;
	exports.UniqueArgumentNames = UniqueArgumentNames;

	var _error = __webpack_require__(8);

	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	function duplicateArgMessage(argName) {
	  return 'There can be only one argument named "' + argName + '".';
	}

	/**
	 * Unique argument names
	 *
	 * A GraphQL field or directive is only valid if all supplied arguments are
	 * uniquely named.
	 */
	function UniqueArgumentNames(context) {
	  var knownArgNames = Object.create(null);
	  return {
	    Field: function Field() {
	      knownArgNames = Object.create(null);
	    },
	    Directive: function Directive() {
	      knownArgNames = Object.create(null);
	    },
	    Argument: function Argument(node) {
	      var argName = node.name.value;
	      if (knownArgNames[argName]) {
	        context.reportError(new _error.GraphQLError(duplicateArgMessage(argName), [knownArgNames[argName], node.name]));
	      } else {
	        knownArgNames[argName] = node.name;
	      }
	      return false;
	    }
	  };
	}

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.badValueMessage = badValueMessage;
	exports.ArgumentsOfCorrectType = ArgumentsOfCorrectType;

	var _error = __webpack_require__(8);

	var _printer = __webpack_require__(13);

	var _isValidLiteralValue = __webpack_require__(56);

	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	function badValueMessage(argName, type, value, verboseErrors) {
	  var message = verboseErrors ? '\n' + verboseErrors.join('\n') : '';
	  return 'Argument "' + argName + '" has invalid value ' + value + '.' + message;
	}

	/**
	 * Argument values of correct type
	 *
	 * A GraphQL document is only valid if all field argument literal values are
	 * of the type expected by their position.
	 */
	function ArgumentsOfCorrectType(context) {
	  return {
	    Argument: function Argument(argAST) {
	      var argDef = context.getArgument();
	      if (argDef) {
	        var errors = (0, _isValidLiteralValue.isValidLiteralValue)(argDef.type, argAST.value);
	        if (errors && errors.length > 0) {
	          context.reportError(new _error.GraphQLError(badValueMessage(argAST.name.value, argDef.type, (0, _printer.print)(argAST.value), errors), [argAST.value]));
	        }
	      }
	      return false;
	    }
	  };
	}

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.isValidLiteralValue = isValidLiteralValue;

	var _printer = __webpack_require__(13);

	var _kinds = __webpack_require__(15);

	var _definition = __webpack_require__(22);

	var _invariant = __webpack_require__(19);

	var _invariant2 = _interopRequireDefault(_invariant);

	var _keyMap = __webpack_require__(57);

	var _keyMap2 = _interopRequireDefault(_keyMap);

	var _isNullish = __webpack_require__(23);

	var _isNullish2 = _interopRequireDefault(_isNullish);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Utility for validators which determines if a value literal AST is valid given
	 * an input type.
	 *
	 * Note that this only validates literal values, variables are assumed to
	 * provide values of the correct type.
	 */

	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	function isValidLiteralValue(type, valueAST) {
	  // A value must be provided if the type is non-null.
	  if (type instanceof _definition.GraphQLNonNull) {
	    if (!valueAST) {
	      if (type.ofType.name) {
	        return ['Expected "' + String(type.ofType.name) + '!", found null.'];
	      }
	      return ['Expected non-null value, found null.'];
	    }
	    return isValidLiteralValue(type.ofType, valueAST);
	  }

	  if (!valueAST) {
	    return [];
	  }

	  // This function only tests literals, and assumes variables will provide
	  // values of the correct type.
	  if (valueAST.kind === _kinds.VARIABLE) {
	    return [];
	  }

	  // Lists accept a non-list value as a list of one.
	  if (type instanceof _definition.GraphQLList) {
	    var _ret = function () {
	      var itemType = type.ofType;
	      if (valueAST.kind === _kinds.LIST) {
	        return {
	          v: valueAST.values.reduce(function (acc, itemAST, index) {
	            var errors = isValidLiteralValue(itemType, itemAST);
	            return acc.concat(errors.map(function (error) {
	              return 'In element #' + index + ': ' + error;
	            }));
	          }, [])
	        };
	      }
	      return {
	        v: isValidLiteralValue(itemType, valueAST)
	      };
	    }();

	    if (typeof _ret === "object") return _ret.v;
	  }

	  // Input objects check each defined field and look for undefined fields.
	  if (type instanceof _definition.GraphQLInputObjectType) {
	    var _ret2 = function () {
	      if (valueAST.kind !== _kinds.OBJECT) {
	        return {
	          v: ['Expected "' + type.name + '", found not an object.']
	        };
	      }
	      var fields = type.getFields();

	      var errors = [];

	      // Ensure every provided field is defined.
	      var fieldASTs = valueAST.fields;
	      fieldASTs.forEach(function (providedFieldAST) {
	        if (!fields[providedFieldAST.name.value]) {
	          errors.push('In field "' + providedFieldAST.name.value + '": Unknown field.');
	        }
	      });

	      // Ensure every defined field is valid.
	      var fieldASTMap = (0, _keyMap2.default)(fieldASTs, function (fieldAST) {
	        return fieldAST.name.value;
	      });
	      Object.keys(fields).forEach(function (fieldName) {
	        var result = isValidLiteralValue(fields[fieldName].type, fieldASTMap[fieldName] && fieldASTMap[fieldName].value);
	        errors.push.apply(errors, result.map(function (error) {
	          return 'In field "' + fieldName + '": ' + error;
	        }));
	      });

	      return {
	        v: errors
	      };
	    }();

	    if (typeof _ret2 === "object") return _ret2.v;
	  }

	  (0, _invariant2.default)(type instanceof _definition.GraphQLScalarType || type instanceof _definition.GraphQLEnumType, 'Must be input type');

	  // Scalar/Enum input checks to ensure the type can parse the value to
	  // a non-null value.
	  var parseResult = type.parseLiteral(valueAST);
	  if ((0, _isNullish2.default)(parseResult)) {
	    return ['Expected type "' + type.name + '", found ' + (0, _printer.print)(valueAST) + '.'];
	  }

	  return [];
	}

/***/ },
/* 57 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = keyMap;

	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	/**
	 * Creates a keyed JS object from an array, given a function to produce the keys
	 * for each value in the array.
	 *
	 * This provides a convenient lookup for the array items if the key function
	 * produces unique results.
	 *
	 *     const phoneBook = [
	 *       { name: 'Jon', num: '555-1234' },
	 *       { name: 'Jenny', num: '867-5309' }
	 *     ]
	 *
	 *     // { Jon: { name: 'Jon', num: '555-1234' },
	 *     //   Jenny: { name: 'Jenny', num: '867-5309' } }
	 *     const entriesByName = keyMap(
	 *       phoneBook,
	 *       entry => entry.name
	 *     )
	 *
	 *     // { name: 'Jenny', num: '857-6309' }
	 *     const jennyEntry = entriesByName['Jenny']
	 *
	 */
	function keyMap(list, keyFn) {
	  return list.reduce(function (map, item) {
	    return map[keyFn(item)] = item, map;
	  }, {});
	}

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.missingFieldArgMessage = missingFieldArgMessage;
	exports.missingDirectiveArgMessage = missingDirectiveArgMessage;
	exports.ProvidedNonNullArguments = ProvidedNonNullArguments;

	var _error = __webpack_require__(8);

	var _keyMap = __webpack_require__(57);

	var _keyMap2 = _interopRequireDefault(_keyMap);

	var _definition = __webpack_require__(22);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	function missingFieldArgMessage(fieldName, argName, type) {
	  return 'Field "' + fieldName + '" argument "' + argName + '" of type ' + ('"' + String(type) + '" is required but not provided.');
	}

	function missingDirectiveArgMessage(directiveName, argName, type) {
	  return 'Directive "@' + directiveName + '" argument "' + argName + '" of type ' + ('"' + String(type) + '" is required but not provided.');
	}

	/**
	 * Provided required arguments
	 *
	 * A field or directive is only valid if all required (non-null) field arguments
	 * have been provided.
	 */
	function ProvidedNonNullArguments(context) {
	  return {
	    Field: {
	      // Validate on leave to allow for deeper errors to appear first.
	      leave: function leave(fieldAST) {
	        var fieldDef = context.getFieldDef();
	        if (!fieldDef) {
	          return false;
	        }
	        var argASTs = fieldAST.arguments || [];

	        var argASTMap = (0, _keyMap2.default)(argASTs, function (arg) {
	          return arg.name.value;
	        });
	        fieldDef.args.forEach(function (argDef) {
	          var argAST = argASTMap[argDef.name];
	          if (!argAST && argDef.type instanceof _definition.GraphQLNonNull) {
	            context.reportError(new _error.GraphQLError(missingFieldArgMessage(fieldAST.name.value, argDef.name, argDef.type), [fieldAST]));
	          }
	        });
	      }
	    },

	    Directive: {
	      // Validate on leave to allow for deeper errors to appear first.
	      leave: function leave(directiveAST) {
	        var directiveDef = context.getDirective();
	        if (!directiveDef) {
	          return false;
	        }
	        var argASTs = directiveAST.arguments || [];

	        var argASTMap = (0, _keyMap2.default)(argASTs, function (arg) {
	          return arg.name.value;
	        });
	        directiveDef.args.forEach(function (argDef) {
	          var argAST = argASTMap[argDef.name];
	          if (!argAST && argDef.type instanceof _definition.GraphQLNonNull) {
	            context.reportError(new _error.GraphQLError(missingDirectiveArgMessage(directiveAST.name.value, argDef.name, argDef.type), [directiveAST]));
	          }
	        });
	      }
	    }
	  };
	}

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.defaultForNonNullArgMessage = defaultForNonNullArgMessage;
	exports.badValueForDefaultArgMessage = badValueForDefaultArgMessage;
	exports.DefaultValuesOfCorrectType = DefaultValuesOfCorrectType;

	var _error = __webpack_require__(8);

	var _printer = __webpack_require__(13);

	var _definition = __webpack_require__(22);

	var _isValidLiteralValue = __webpack_require__(56);

	function defaultForNonNullArgMessage(varName, type, guessType) {
	  return 'Variable "$' + varName + '" of type "' + String(type) + '" is required and ' + 'will not use the default value. ' + ('Perhaps you meant to use type "' + String(guessType) + '".');
	}
	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	function badValueForDefaultArgMessage(varName, type, value, verboseErrors) {
	  var message = verboseErrors ? '\n' + verboseErrors.join('\n') : '';
	  return 'Variable "$' + varName + '" of type "' + String(type) + '" has invalid ' + ('default value ' + value + '.' + message);
	}

	/**
	 * Variable default values of correct type
	 *
	 * A GraphQL document is only valid if all variable default values are of the
	 * type expected by their definition.
	 */
	function DefaultValuesOfCorrectType(context) {
	  return {
	    VariableDefinition: function VariableDefinition(varDefAST) {
	      var name = varDefAST.variable.name.value;
	      var defaultValue = varDefAST.defaultValue;
	      var type = context.getInputType();
	      if (type instanceof _definition.GraphQLNonNull && defaultValue) {
	        context.reportError(new _error.GraphQLError(defaultForNonNullArgMessage(name, type, type.ofType), [defaultValue]));
	      }
	      if (type && defaultValue) {
	        var errors = (0, _isValidLiteralValue.isValidLiteralValue)(type, defaultValue);
	        if (errors && errors.length > 0) {
	          context.reportError(new _error.GraphQLError(badValueForDefaultArgMessage(name, type, (0, _printer.print)(defaultValue), errors), [defaultValue]));
	        }
	      }
	      return false;
	    },

	    SelectionSet: function SelectionSet() {
	      return false;
	    },
	    FragmentDefinition: function FragmentDefinition() {
	      return false;
	    }
	  };
	}

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.badVarPosMessage = badVarPosMessage;
	exports.VariablesInAllowedPosition = VariablesInAllowedPosition;

	var _error = __webpack_require__(8);

	var _definition = __webpack_require__(22);

	var _typeComparators = __webpack_require__(31);

	var _typeFromAST = __webpack_require__(33);

	function badVarPosMessage(varName, varType, expectedType) {
	  return 'Variable "$' + varName + '" of type "' + String(varType) + '" used in ' + ('position expecting type "' + String(expectedType) + '".');
	}

	/**
	 * Variables passed to field arguments conform to type
	 */

	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	function VariablesInAllowedPosition(context) {
	  var varDefMap = Object.create(null);

	  return {
	    OperationDefinition: {
	      enter: function enter() {
	        varDefMap = Object.create(null);
	      },
	      leave: function leave(operation) {
	        var usages = context.getRecursiveVariableUsages(operation);

	        usages.forEach(function (_ref) {
	          var node = _ref.node;
	          var type = _ref.type;

	          var varName = node.name.value;
	          var varDef = varDefMap[varName];
	          if (varDef && type) {
	            // A var type is allowed if it is the same or more strict (e.g. is
	            // a subtype of) than the expected type. It can be more strict if
	            // the variable type is non-null when the expected type is nullable.
	            // If both are list types, the variable item type can be more strict
	            // than the expected item type (contravariant).
	            var schema = context.getSchema();
	            var varType = (0, _typeFromAST.typeFromAST)(schema, varDef.type);
	            if (varType && !(0, _typeComparators.isTypeSubTypeOf)(schema, effectiveType(varType, varDef), type)) {
	              context.reportError(new _error.GraphQLError(badVarPosMessage(varName, varType, type), [varDef, node]));
	            }
	          }
	        });
	      }
	    },
	    VariableDefinition: function VariableDefinition(varDefAST) {
	      varDefMap[varDefAST.variable.name.value] = varDefAST;
	    }
	  };
	}

	// If a variable definition has a default value, it's effectively non-null.
	function effectiveType(varType, varDef) {
	  return !varDef.defaultValue || varType instanceof _definition.GraphQLNonNull ? varType : new _definition.GraphQLNonNull(varType);
	}

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.fieldsConflictMessage = fieldsConflictMessage;
	exports.OverlappingFieldsCanBeMerged = OverlappingFieldsCanBeMerged;

	var _error = __webpack_require__(8);

	var _find = __webpack_require__(30);

	var _find2 = _interopRequireDefault(_find);

	var _kinds = __webpack_require__(15);

	var _printer = __webpack_require__(13);

	var _definition = __webpack_require__(22);

	var _typeFromAST = __webpack_require__(33);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	function fieldsConflictMessage(responseName, reason) {
	  return 'Fields "' + responseName + '" conflict because ' + reasonMessage(reason) + '. Use different aliases on the fields to fetch both if this was ' + 'intentional.';
	}

	function reasonMessage(reason) {
	  if (Array.isArray(reason)) {
	    return reason.map(function (_ref) {
	      var responseName = _ref[0];
	      var subreason = _ref[1];
	      return 'subfields "' + responseName + '" conflict because ' + reasonMessage(subreason);
	    }).join(' and ');
	  }
	  return reason;
	}

	/**
	 * Overlapping fields can be merged
	 *
	 * A selection set is only valid if all fields (including spreading any
	 * fragments) either correspond to distinct response names or can be merged
	 * without ambiguity.
	 */
	function OverlappingFieldsCanBeMerged(context) {
	  // A memoization for when two fragments are compared "between" each other for
	  // conflicts. Two fragments may be compared many times, so memoizing this can
	  // dramatically improve the performance of this validator.
	  var comparedFragments = new PairSet();

	  // A cache for the "field map" and list of fragment names found in any given
	  // selection set. Selection sets may be asked for this information multiple
	  // times, so this improves the performance of this validator.
	  var cachedFieldsAndFragmentNames = new Map();

	  return {
	    SelectionSet: function SelectionSet(selectionSet) {
	      var conflicts = findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragments, context.getParentType(), selectionSet);
	      conflicts.forEach(function (_ref2) {
	        var _ref2$ = _ref2[0];
	        var responseName = _ref2$[0];
	        var reason = _ref2$[1];
	        var fields1 = _ref2[1];
	        var fields2 = _ref2[2];
	        return context.reportError(new _error.GraphQLError(fieldsConflictMessage(responseName, reason), fields1.concat(fields2)));
	      });
	    }
	  };
	}
	// Field name and reason.

	// Reason is a string, or a nested list of conflicts.

	// Tuple defining an AST in a context

	// Map of array of those.


	/**
	 * Algorithm:
	 *
	 * Conflicts occur when two fields exist in a query which will produce the same
	 * response name, but represent differing values, thus creating a conflict.
	 * The algorithm below finds all conflicts via making a series of comparisons
	 * between fields. In order to compare as few fields as possible, this makes
	 * a series of comparisons "within" sets of fields and "between" sets of fields.
	 *
	 * Given any selection set, a collection produces both a set of fields by
	 * also including all inline fragments, as well as a list of fragments
	 * referenced by fragment spreads.
	 *
	 * A) Each selection set represented in the document first compares "within" its
	 * collected set of fields, finding any conflicts between every pair of
	 * overlapping fields.
	 * Note: This is the *only time* that a the fields "within" a set are compared
	 * to each other. After this only fields "between" sets are compared.
	 *
	 * B) Also, if any fragment is referenced in a selection set, then a
	 * comparison is made "between" the original set of fields and the
	 * referenced fragment.
	 *
	 * C) Also, if multiple fragments are referenced, then comparisons
	 * are made "between" each referenced fragment.
	 *
	 * D) When comparing "between" a set of fields and a referenced fragment, first
	 * a comparison is made between each field in the original set of fields and
	 * each field in the the referenced set of fields.
	 *
	 * E) Also, if any fragment is referenced in the referenced selection set,
	 * then a comparison is made "between" the original set of fields and the
	 * referenced fragment (recursively referring to step D).
	 *
	 * F) When comparing "between" two fragments, first a comparison is made between
	 * each field in the first referenced set of fields and each field in the the
	 * second referenced set of fields.
	 *
	 * G) Also, any fragments referenced by the first must be compared to the
	 * second, and any fragments referenced by the second must be compared to the
	 * first (recursively referring to step F).
	 *
	 * H) When comparing two fields, if both have selection sets, then a comparison
	 * is made "between" both selection sets, first comparing the set of fields in
	 * the first selection set with the set of fields in the second.
	 *
	 * I) Also, if any fragment is referenced in either selection set, then a
	 * comparison is made "between" the other set of fields and the
	 * referenced fragment.
	 *
	 * J) Also, if two fragments are referenced in both selection sets, then a
	 * comparison is made "between" the two fragments.
	 *
	 */

	// Find all conflicts found "within" a selection set, including those found
	// via spreading in fragments. Called when visiting each SelectionSet in the
	// GraphQL Document.
	function findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragments, parentType, selectionSet) {
	  var conflicts = [];

	  var _getFieldsAndFragment = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet);

	  var fieldMap = _getFieldsAndFragment[0];
	  var fragmentNames = _getFieldsAndFragment[1];

	  // (A) Find find all conflicts "within" the fields of this selection set.
	  // Note: this is the *only place* `collectConflictsWithin` is called.

	  collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, fieldMap);

	  // (B) Then collect conflicts between these fields and those represented by
	  // each spread fragment name found.
	  for (var i = 0; i < fragmentNames.length; i++) {
	    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, false, fieldMap, fragmentNames[i]);
	    // (C) Then compare this fragment with all other fragments found in this
	    // selection set to collect conflicts between fragments spread together.
	    // This compares each item in the list of fragment names to every other item
	    // in that same list (except for itself).
	    for (var j = i + 1; j < fragmentNames.length; j++) {
	      collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, false, fragmentNames[i], fragmentNames[j]);
	    }
	  }
	  return conflicts;
	}

	// Collect all conflicts found between a set of fields and a fragment reference
	// including via spreading in any nested fragments.
	function collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, fieldMap, fragmentName) {
	  var fragment = context.getFragment(fragmentName);
	  if (!fragment) {
	    return;
	  }

	  var _getReferencedFieldsA = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment);

	  var fieldMap2 = _getReferencedFieldsA[0];
	  var fragmentNames2 = _getReferencedFieldsA[1];

	  // (D) First collect any conflicts between the provided collection of fields
	  // and the collection of fields represented by the given fragment.

	  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, fieldMap, fieldMap2);

	  // (E) Then collect any conflicts between the provided collection of fields
	  // and any fragment names found in the given fragment.
	  for (var i = 0; i < fragmentNames2.length; i++) {
	    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, fieldMap, fragmentNames2[i]);
	  }
	}

	// Collect all conflicts found between two fragments, including via spreading in
	// any nested fragments.
	function collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, fragmentName1, fragmentName2) {
	  var fragment1 = context.getFragment(fragmentName1);
	  var fragment2 = context.getFragment(fragmentName2);
	  if (!fragment1 || !fragment2) {
	    return;
	  }

	  // No need to compare a fragment to itself.
	  if (fragment1 === fragment2) {
	    return;
	  }

	  // Memoize so two fragments are not compared for conflicts more than once.
	  if (comparedFragments.has(fragmentName1, fragmentName2, areMutuallyExclusive)) {
	    return;
	  }
	  comparedFragments.add(fragmentName1, fragmentName2, areMutuallyExclusive);

	  var _getReferencedFieldsA2 = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment1);

	  var fieldMap1 = _getReferencedFieldsA2[0];
	  var fragmentNames1 = _getReferencedFieldsA2[1];

	  var _getReferencedFieldsA3 = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment2);

	  var fieldMap2 = _getReferencedFieldsA3[0];
	  var fragmentNames2 = _getReferencedFieldsA3[1];

	  // (F) First, collect all conflicts between these two collections of fields
	  // (not including any nested fragments).

	  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, fieldMap1, fieldMap2);

	  // (G) Then collect conflicts between the first fragment and any nested
	  // fragments spread in the second fragment.
	  for (var j = 0; j < fragmentNames2.length; j++) {
	    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, fragmentName1, fragmentNames2[j]);
	  }

	  // (G) Then collect conflicts between the second fragment and any nested
	  // fragments spread in the first fragment.
	  for (var i = 0; i < fragmentNames1.length; i++) {
	    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, fragmentNames1[i], fragmentName2);
	  }
	}

	// Find all conflicts found between two selection sets, including those found
	// via spreading in fragments. Called when determining if conflicts exist
	// between the sub-fields of two overlapping fields.
	function findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {
	  var conflicts = [];

	  var _getFieldsAndFragment2 = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType1, selectionSet1);

	  var fieldMap1 = _getFieldsAndFragment2[0];
	  var fragmentNames1 = _getFieldsAndFragment2[1];

	  var _getFieldsAndFragment3 = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType2, selectionSet2);

	  var fieldMap2 = _getFieldsAndFragment3[0];
	  var fragmentNames2 = _getFieldsAndFragment3[1];

	  // (H) First, collect all conflicts between these two collections of field.

	  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, fieldMap1, fieldMap2);

	  // (I) Then collect conflicts between the first collection of fields and
	  // those referenced by each fragment name associated with the second.
	  for (var j = 0; j < fragmentNames2.length; j++) {
	    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, fieldMap1, fragmentNames2[j]);
	  }

	  // (I) Then collect conflicts between the second collection of fields and
	  // those referenced by each fragment name associated with the first.
	  for (var i = 0; i < fragmentNames1.length; i++) {
	    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, fieldMap2, fragmentNames1[i]);
	  }

	  // (J) Also collect conflicts between any fragment names by the first and
	  // fragment names by the second. This compares each item in the first set of
	  // names to each item in the second set of names.
	  for (var _i = 0; _i < fragmentNames1.length; _i++) {
	    for (var _j = 0; _j < fragmentNames2.length; _j++) {
	      collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, fragmentNames1[_i], fragmentNames2[_j]);
	    }
	  }
	  return conflicts;
	}

	// Collect all Conflicts "within" one collection of fields.
	function collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, fieldMap) {
	  // A field map is a keyed collection, where each key represents a response
	  // name and the value at that key is a list of all fields which provide that
	  // response name. For every response name, if there are multiple fields, they
	  // must be compared to find a potential conflict.
	  Object.keys(fieldMap).forEach(function (responseName) {
	    var fields = fieldMap[responseName];
	    // This compares every field in the list to every other field in this list
	    // (except to itself). If the list only has one item, nothing needs to
	    // be compared.
	    if (fields.length > 1) {
	      for (var i = 0; i < fields.length; i++) {
	        for (var j = i + 1; j < fields.length; j++) {
	          var conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragments, false, // within one collection is never mutually exclusive
	          responseName, fields[i], fields[j]);
	          if (conflict) {
	            conflicts.push(conflict);
	          }
	        }
	      }
	    }
	  });
	}

	// Collect all Conflicts between two collections of fields. This is similar to,
	// but different from the `collectConflictsWithin` function above. This check
	// assumes that `collectConflictsWithin` has already been called on each
	// provided collection of fields. This is true because this validator traverses
	// each individual selection set.
	function collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {
	  // A field map is a keyed collection, where each key represents a response
	  // name and the value at that key is a list of all fields which provide that
	  // response name. For any response name which appears in both provided field
	  // maps, each field from the first field map must be compared to every field
	  // in the second field map to find potential conflicts.
	  Object.keys(fieldMap1).forEach(function (responseName) {
	    var fields2 = fieldMap2[responseName];
	    if (fields2) {
	      var fields1 = fieldMap1[responseName];
	      for (var i = 0; i < fields1.length; i++) {
	        for (var j = 0; j < fields2.length; j++) {
	          var conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragments, parentFieldsAreMutuallyExclusive, responseName, fields1[i], fields2[j]);
	          if (conflict) {
	            conflicts.push(conflict);
	          }
	        }
	      }
	    }
	  });
	}

	// Determines if there is a conflict between two particular fields, including
	// comparing their sub-fields.
	function findConflict(context, cachedFieldsAndFragmentNames, comparedFragments, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {
	  var parentType1 = field1[0];
	  var ast1 = field1[1];
	  var def1 = field1[2];
	  var parentType2 = field2[0];
	  var ast2 = field2[1];
	  var def2 = field2[2];

	  // If it is known that two fields could not possibly apply at the same
	  // time, due to the parent types, then it is safe to permit them to diverge
	  // in aliased field or arguments used as they will not present any ambiguity
	  // by differing.
	  // It is known that two parent types could never overlap if they are
	  // different Object types. Interface or Union types might overlap - if not
	  // in the current state of the schema, then perhaps in some future version,
	  // thus may not safely diverge.

	  var areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && parentType1 instanceof _definition.GraphQLObjectType && parentType2 instanceof _definition.GraphQLObjectType;

	  // The return type for each field.
	  var type1 = def1 && def1.type;
	  var type2 = def2 && def2.type;

	  if (!areMutuallyExclusive) {
	    // Two aliases must refer to the same field.
	    var name1 = ast1.name.value;
	    var name2 = ast2.name.value;
	    if (name1 !== name2) {
	      return [[responseName, name1 + ' and ' + name2 + ' are different fields'], [ast1], [ast2]];
	    }

	    // Two field calls must have the same arguments.
	    if (!sameArguments(ast1.arguments || [], ast2.arguments || [])) {
	      return [[responseName, 'they have differing arguments'], [ast1], [ast2]];
	    }
	  }

	  if (type1 && type2 && doTypesConflict(type1, type2)) {
	    return [[responseName, 'they return conflicting types ' + String(type1) + ' and ' + String(type2)], [ast1], [ast2]];
	  }

	  // Collect and compare sub-fields. Use the same "visited fragment names" list
	  // for both collections so fields in a fragment reference are never
	  // compared to themselves.
	  var selectionSet1 = ast1.selectionSet;
	  var selectionSet2 = ast2.selectionSet;
	  if (selectionSet1 && selectionSet2) {
	    var conflicts = findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, (0, _definition.getNamedType)(type1), selectionSet1, (0, _definition.getNamedType)(type2), selectionSet2);
	    return subfieldConflicts(conflicts, responseName, ast1, ast2);
	  }
	}

	function sameArguments(arguments1, arguments2) {
	  if (arguments1.length !== arguments2.length) {
	    return false;
	  }
	  return arguments1.every(function (argument1) {
	    var argument2 = (0, _find2.default)(arguments2, function (argument) {
	      return argument.name.value === argument1.name.value;
	    });
	    if (!argument2) {
	      return false;
	    }
	    return sameValue(argument1.value, argument2.value);
	  });
	}

	function sameValue(value1, value2) {
	  return !value1 && !value2 || (0, _printer.print)(value1) === (0, _printer.print)(value2);
	}

	// Two types conflict if both types could not apply to a value simultaneously.
	// Composite types are ignored as their individual field types will be compared
	// later recursively. However List and Non-Null types must match.
	function doTypesConflict(type1, type2) {
	  if (type1 instanceof _definition.GraphQLList) {
	    return type2 instanceof _definition.GraphQLList ? doTypesConflict(type1.ofType, type2.ofType) : true;
	  }
	  if (type2 instanceof _definition.GraphQLList) {
	    return type1 instanceof _definition.GraphQLList ? doTypesConflict(type1.ofType, type2.ofType) : true;
	  }
	  if (type1 instanceof _definition.GraphQLNonNull) {
	    return type2 instanceof _definition.GraphQLNonNull ? doTypesConflict(type1.ofType, type2.ofType) : true;
	  }
	  if (type2 instanceof _definition.GraphQLNonNull) {
	    return type1 instanceof _definition.GraphQLNonNull ? doTypesConflict(type1.ofType, type2.ofType) : true;
	  }
	  if ((0, _definition.isLeafType)(type1) || (0, _definition.isLeafType)(type2)) {
	    return type1 !== type2;
	  }
	  return false;
	}

	// Given a selection set, return the collection of fields (a mapping of response
	// name to field ASTs and definitions) as well as a list of fragment names
	// referenced via fragment spreads.
	function getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {
	  var cached = cachedFieldsAndFragmentNames.get(selectionSet);
	  if (!cached) {
	    var astAndDefs = {};
	    var fragmentNames = {};
	    _collectFieldsAndFragmentNames(context, parentType, selectionSet, astAndDefs, fragmentNames);
	    cached = [astAndDefs, Object.keys(fragmentNames)];
	    cachedFieldsAndFragmentNames.set(selectionSet, cached);
	  }
	  return cached;
	}

	// Given a reference to a fragment, return the represented collection of fields
	// as well as a list of nested fragment names referenced via fragment spreads.
	function getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {
	  // Short-circuit building a type from the AST if possible.
	  var cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);
	  if (cached) {
	    return cached;
	  }

	  var fragmentType = (0, _typeFromAST.typeFromAST)(context.getSchema(), fragment.typeCondition);
	  return getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragmentType, fragment.selectionSet);
	}

	function _collectFieldsAndFragmentNames(context, parentType, selectionSet, astAndDefs, fragmentNames) {
	  for (var i = 0; i < selectionSet.selections.length; i++) {
	    var selection = selectionSet.selections[i];
	    switch (selection.kind) {
	      case _kinds.FIELD:
	        var fieldName = selection.name.value;
	        var fieldDef = void 0;
	        if (parentType instanceof _definition.GraphQLObjectType || parentType instanceof _definition.GraphQLInterfaceType) {
	          fieldDef = parentType.getFields()[fieldName];
	        }
	        var responseName = selection.alias ? selection.alias.value : fieldName;
	        if (!astAndDefs[responseName]) {
	          astAndDefs[responseName] = [];
	        }
	        astAndDefs[responseName].push([parentType, selection, fieldDef]);
	        break;
	      case _kinds.FRAGMENT_SPREAD:
	        fragmentNames[selection.name.value] = true;
	        break;
	      case _kinds.INLINE_FRAGMENT:
	        var typeCondition = selection.typeCondition;
	        var inlineFragmentType = typeCondition ? (0, _typeFromAST.typeFromAST)(context.getSchema(), typeCondition) : parentType;
	        _collectFieldsAndFragmentNames(context, inlineFragmentType, selection.selectionSet, astAndDefs, fragmentNames);
	        break;
	    }
	  }
	}

	// Given a series of Conflicts which occurred between two sub-fields, generate
	// a single Conflict.
	function subfieldConflicts(conflicts, responseName, ast1, ast2) {
	  if (conflicts.length > 0) {
	    return [[responseName, conflicts.map(function (_ref3) {
	      var reason = _ref3[0];
	      return reason;
	    })], conflicts.reduce(function (allFields, _ref4) {
	      var fields1 = _ref4[1];
	      return allFields.concat(fields1);
	    }, [ast1]), conflicts.reduce(function (allFields, _ref5) {
	      var fields2 = _ref5[2];
	      return allFields.concat(fields2);
	    }, [ast2])];
	  }
	}

	/**
	 * A way to keep track of pairs of things when the ordering of the pair does
	 * not matter. We do this by maintaining a sort of double adjacency sets.
	 */

	var PairSet = function () {
	  function PairSet() {
	    _classCallCheck(this, PairSet);

	    this._data = Object.create(null);
	  }

	  PairSet.prototype.has = function has(a, b, areMutuallyExclusive) {
	    var first = this._data[a];
	    var result = first && first[b];
	    if (result === undefined) {
	      return false;
	    }
	    // areMutuallyExclusive being false is a superset of being true,
	    // hence if we want to know if this PairSet "has" these two with no
	    // exclusivity, we have to ensure it was added as such.
	    if (areMutuallyExclusive === false) {
	      return result === false;
	    }
	    return true;
	  };

	  PairSet.prototype.add = function add(a, b, areMutuallyExclusive) {
	    _pairSetAdd(this._data, a, b, areMutuallyExclusive);
	    _pairSetAdd(this._data, b, a, areMutuallyExclusive);
	  };

	  return PairSet;
	}();

	function _pairSetAdd(data, a, b, areMutuallyExclusive) {
	  var map = data[a];
	  if (!map) {
	    map = Object.create(null);
	    data[a] = map;
	  }
	  map[b] = areMutuallyExclusive;
	}

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.duplicateInputFieldMessage = duplicateInputFieldMessage;
	exports.UniqueInputFieldNames = UniqueInputFieldNames;

	var _error = __webpack_require__(8);

	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	function duplicateInputFieldMessage(fieldName) {
	  return 'There can be only one input field named "' + fieldName + '".';
	}

	/**
	 * Unique input field names
	 *
	 * A GraphQL input object value is only valid if all supplied fields are
	 * uniquely named.
	 */
	function UniqueInputFieldNames(context) {
	  var knownNameStack = [];
	  var knownNames = Object.create(null);

	  return {
	    ObjectValue: {
	      enter: function enter() {
	        knownNameStack.push(knownNames);
	        knownNames = Object.create(null);
	      },
	      leave: function leave() {
	        knownNames = knownNameStack.pop();
	      }
	    },
	    ObjectField: function ObjectField(node) {
	      var fieldName = node.name.value;
	      if (knownNames[fieldName]) {
	        context.reportError(new _error.GraphQLError(duplicateInputFieldMessage(fieldName), [knownNames[fieldName], node.name]));
	      } else {
	        knownNames[fieldName] = node.name;
	      }
	      return false;
	    }
	  };
	}

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.execute = execute;

	var _iterall = __webpack_require__(29);

	var _error = __webpack_require__(8);

	var _find = __webpack_require__(30);

	var _find2 = _interopRequireDefault(_find);

	var _invariant = __webpack_require__(19);

	var _invariant2 = _interopRequireDefault(_invariant);

	var _isNullish = __webpack_require__(23);

	var _isNullish2 = _interopRequireDefault(_isNullish);

	var _typeFromAST = __webpack_require__(33);

	var _kinds = __webpack_require__(15);

	var Kind = _interopRequireWildcard(_kinds);

	var _values = __webpack_require__(64);

	var _definition = __webpack_require__(22);

	var _schema = __webpack_require__(21);

	var _introspection = __webpack_require__(27);

	var _directives = __webpack_require__(25);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Implements the "Evaluating requests" section of the GraphQL specification.
	 *
	 * Returns a Promise that will eventually be resolved and never rejected.
	 *
	 * If the arguments to this function do not result in a legal execution context,
	 * a GraphQLError will be thrown immediately explaining the invalid input.
	 */


	/**
	 * Terminology
	 *
	 * "Definitions" are the generic name for top-level statements in the document.
	 * Examples of this include:
	 * 1) Operations (such as a query)
	 * 2) Fragments
	 *
	 * "Operations" are a generic name for requests in the document.
	 * Examples of this include:
	 * 1) query,
	 * 2) mutation
	 *
	 * "Selections" are the definitions that can appear legally and at
	 * single level of the query. These include:
	 * 1) field references e.g "a"
	 * 2) fragment "spreads" e.g. "...c"
	 * 3) inline fragment "spreads" e.g. "...on Type { a }"
	 */

	/**
	 * Data that must be available at all points during query execution.
	 *
	 * Namely, schema of the type system that is currently executing,
	 * and the fragments defined in the query document
	 */


	/**
	 * The result of execution. `data` is the result of executing the
	 * query, `errors` is null if no errors occurred, and is a
	 * non-empty array if an error occurred.
	 */

	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	function execute(schema, documentAST, rootValue, contextValue, variableValues, operationName) {
	  (0, _invariant2.default)(schema, 'Must provide schema');
	  (0, _invariant2.default)(schema instanceof _schema.GraphQLSchema, 'Schema must be an instance of GraphQLSchema. Also ensure that there are ' + 'not multiple versions of GraphQL installed in your node_modules directory.');

	  // Variables, if provided, must be an object.
	  (0, _invariant2.default)(!variableValues || typeof variableValues === 'object', 'Variables must be provided as an Object where each property is a ' + 'variable value. Perhaps look to see if an unparsed JSON string ' + 'was provided.');

	  // If a valid context cannot be created due to incorrect arguments,
	  // this will throw an error.
	  var context = buildExecutionContext(schema, documentAST, rootValue, contextValue, variableValues, operationName);

	  // Return a Promise that will eventually resolve to the data described by
	  // The "Response" section of the GraphQL specification.
	  //
	  // If errors are encountered while executing a GraphQL field, only that
	  // field and its descendants will be omitted, and sibling fields will still
	  // be executed. An execution which encounters errors will still result in a
	  // resolved Promise.
	  return new Promise(function (resolve) {
	    resolve(executeOperation(context, context.operation, rootValue));
	  }).then(undefined, function (error) {
	    // Errors from sub-fields of a NonNull type may propagate to the top level,
	    // at which point we still log the error and null the parent field, which
	    // in this case is the entire response.
	    context.errors.push(error);
	    return null;
	  }).then(function (data) {
	    if (!context.errors.length) {
	      return { data: data };
	    }
	    return { data: data, errors: context.errors };
	  });
	}

	/**
	 * Constructs a ExecutionContext object from the arguments passed to
	 * execute, which we will pass throughout the other execution methods.
	 *
	 * Throws a GraphQLError if a valid execution context cannot be created.
	 */
	function buildExecutionContext(schema, documentAST, rootValue, contextValue, rawVariableValues, operationName) {
	  var errors = [];
	  var operation = void 0;
	  var fragments = Object.create(null);
	  documentAST.definitions.forEach(function (definition) {
	    switch (definition.kind) {
	      case Kind.OPERATION_DEFINITION:
	        if (!operationName && operation) {
	          throw new _error.GraphQLError('Must provide operation name if query contains multiple operations.');
	        }
	        if (!operationName || definition.name && definition.name.value === operationName) {
	          operation = definition;
	        }
	        break;
	      case Kind.FRAGMENT_DEFINITION:
	        fragments[definition.name.value] = definition;
	        break;
	      default:
	        throw new _error.GraphQLError('GraphQL cannot execute a request containing a ' + definition.kind + '.', [definition]);
	    }
	  });
	  if (!operation) {
	    if (operationName) {
	      throw new _error.GraphQLError('Unknown operation named "' + operationName + '".');
	    } else {
	      throw new _error.GraphQLError('Must provide an operation.');
	    }
	  }
	  var variableValues = (0, _values.getVariableValues)(schema, operation.variableDefinitions || [], rawVariableValues || {});

	  return {
	    schema: schema,
	    fragments: fragments,
	    rootValue: rootValue,
	    contextValue: contextValue,
	    operation: operation,
	    variableValues: variableValues,
	    errors: errors
	  };
	}

	/**
	 * Implements the "Evaluating operations" section of the spec.
	 */
	function executeOperation(exeContext, operation, rootValue) {
	  var type = getOperationRootType(exeContext.schema, operation);
	  var fields = collectFields(exeContext, type, operation.selectionSet, Object.create(null), Object.create(null));

	  var path = [];

	  if (operation.operation === 'mutation') {
	    return executeFieldsSerially(exeContext, type, rootValue, path, fields);
	  }
	  return executeFields(exeContext, type, rootValue, path, fields);
	}

	/**
	 * Extracts the root type of the operation from the schema.
	 */
	function getOperationRootType(schema, operation) {
	  switch (operation.operation) {
	    case 'query':
	      return schema.getQueryType();
	    case 'mutation':
	      var mutationType = schema.getMutationType();
	      if (!mutationType) {
	        throw new _error.GraphQLError('Schema is not configured for mutations', [operation]);
	      }
	      return mutationType;
	    case 'subscription':
	      var subscriptionType = schema.getSubscriptionType();
	      if (!subscriptionType) {
	        throw new _error.GraphQLError('Schema is not configured for subscriptions', [operation]);
	      }
	      return subscriptionType;
	    default:
	      throw new _error.GraphQLError('Can only execute queries, mutations and subscriptions', [operation]);
	  }
	}

	/**
	 * Implements the "Evaluating selection sets" section of the spec
	 * for "write" mode.
	 */
	function executeFieldsSerially(exeContext, parentType, sourceValue, path, fields) {
	  return Object.keys(fields).reduce(function (prevPromise, responseName) {
	    return prevPromise.then(function (results) {
	      var fieldASTs = fields[responseName];
	      var fieldPath = path.concat([responseName]);
	      var result = resolveField(exeContext, parentType, sourceValue, fieldASTs, fieldPath);
	      if (result === undefined) {
	        return results;
	      }
	      if (isThenable(result)) {
	        return result.then(function (resolvedResult) {
	          results[responseName] = resolvedResult;
	          return results;
	        });
	      }
	      results[responseName] = result;
	      return results;
	    });
	  }, Promise.resolve({}));
	}

	/**
	 * Implements the "Evaluating selection sets" section of the spec
	 * for "read" mode.
	 */
	function executeFields(exeContext, parentType, sourceValue, path, fields) {
	  var containsPromise = false;

	  var finalResults = Object.keys(fields).reduce(function (results, responseName) {
	    var fieldASTs = fields[responseName];
	    var fieldPath = path.concat([responseName]);
	    var result = resolveField(exeContext, parentType, sourceValue, fieldASTs, fieldPath);
	    if (result === undefined) {
	      return results;
	    }
	    results[responseName] = result;
	    if (isThenable(result)) {
	      containsPromise = true;
	    }
	    return results;
	  }, Object.create(null));

	  // If there are no promises, we can just return the object
	  if (!containsPromise) {
	    return finalResults;
	  }

	  // Otherwise, results is a map from field name to the result
	  // of resolving that field, which is possibly a promise. Return
	  // a promise that will return this same map, but with any
	  // promises replaced with the values they resolved to.
	  return promiseForObject(finalResults);
	}

	/**
	 * Given a selectionSet, adds all of the fields in that selection to
	 * the passed in map of fields, and returns it at the end.
	 *
	 * CollectFields requires the "runtime type" of an object. For a field which
	 * returns and Interface or Union type, the "runtime type" will be the actual
	 * Object type returned by that field.
	 */
	function collectFields(exeContext, runtimeType, selectionSet, fields, visitedFragmentNames) {
	  for (var i = 0; i < selectionSet.selections.length; i++) {
	    var selection = selectionSet.selections[i];
	    switch (selection.kind) {
	      case Kind.FIELD:
	        if (!shouldIncludeNode(exeContext, selection.directives)) {
	          continue;
	        }
	        var _name = getFieldEntryKey(selection);
	        if (!fields[_name]) {
	          fields[_name] = [];
	        }
	        fields[_name].push(selection);
	        break;
	      case Kind.INLINE_FRAGMENT:
	        if (!shouldIncludeNode(exeContext, selection.directives) || !doesFragmentConditionMatch(exeContext, selection, runtimeType)) {
	          continue;
	        }
	        collectFields(exeContext, runtimeType, selection.selectionSet, fields, visitedFragmentNames);
	        break;
	      case Kind.FRAGMENT_SPREAD:
	        var fragName = selection.name.value;
	        if (visitedFragmentNames[fragName] || !shouldIncludeNode(exeContext, selection.directives)) {
	          continue;
	        }
	        visitedFragmentNames[fragName] = true;
	        var fragment = exeContext.fragments[fragName];
	        if (!fragment || !doesFragmentConditionMatch(exeContext, fragment, runtimeType)) {
	          continue;
	        }
	        collectFields(exeContext, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);
	        break;
	    }
	  }
	  return fields;
	}

	/**
	 * Determines if a field should be included based on the @include and @skip
	 * directives, where @skip has higher precidence than @include.
	 */
	function shouldIncludeNode(exeContext, directives) {
	  var skipAST = directives && (0, _find2.default)(directives, function (directive) {
	    return directive.name.value === _directives.GraphQLSkipDirective.name;
	  });
	  if (skipAST) {
	    var _getArgumentValues = (0, _values.getArgumentValues)(_directives.GraphQLSkipDirective.args, skipAST.arguments, exeContext.variableValues);

	    var skipIf = _getArgumentValues.if;

	    if (skipIf === true) {
	      return false;
	    }
	  }

	  var includeAST = directives && (0, _find2.default)(directives, function (directive) {
	    return directive.name.value === _directives.GraphQLIncludeDirective.name;
	  });
	  if (includeAST) {
	    var _getArgumentValues2 = (0, _values.getArgumentValues)(_directives.GraphQLIncludeDirective.args, includeAST.arguments, exeContext.variableValues);

	    var includeIf = _getArgumentValues2.if;

	    if (includeIf === false) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Determines if a fragment is applicable to the given type.
	 */
	function doesFragmentConditionMatch(exeContext, fragment, type) {
	  var typeConditionAST = fragment.typeCondition;
	  if (!typeConditionAST) {
	    return true;
	  }
	  var conditionalType = (0, _typeFromAST.typeFromAST)(exeContext.schema, typeConditionAST);
	  if (conditionalType === type) {
	    return true;
	  }
	  if ((0, _definition.isAbstractType)(conditionalType)) {
	    var abstractType = conditionalType;
	    return exeContext.schema.isPossibleType(abstractType, type);
	  }
	  return false;
	}

	/**
	 * This function transforms a JS object `{[key: string]: Promise<T>}` into
	 * a `Promise<{[key: string]: T}>`
	 *
	 * This is akin to bluebird's `Promise.props`, but implemented only using
	 * `Promise.all` so it will work with any implementation of ES6 promises.
	 */
	function promiseForObject(object) {
	  var keys = Object.keys(object);
	  var valuesAndPromises = keys.map(function (name) {
	    return object[name];
	  });
	  return Promise.all(valuesAndPromises).then(function (values) {
	    return values.reduce(function (resolvedObject, value, i) {
	      resolvedObject[keys[i]] = value;
	      return resolvedObject;
	    }, Object.create(null));
	  });
	}

	/**
	 * Implements the logic to compute the key of a given field's entry
	 */
	function getFieldEntryKey(node) {
	  return node.alias ? node.alias.value : node.name.value;
	}

	/**
	 * Resolves the field on the given source object. In particular, this
	 * figures out the value that the field returns by calling its resolve function,
	 * then calls completeValue to complete promises, serialize scalars, or execute
	 * the sub-selection-set for objects.
	 */
	function resolveField(exeContext, parentType, source, fieldASTs, path) {
	  var fieldAST = fieldASTs[0];
	  var fieldName = fieldAST.name.value;

	  var fieldDef = getFieldDef(exeContext.schema, parentType, fieldName);
	  if (!fieldDef) {
	    return;
	  }

	  var returnType = fieldDef.type;
	  var resolveFn = fieldDef.resolve || defaultResolveFn;

	  // Build a JS object of arguments from the field.arguments AST, using the
	  // variables scope to fulfill any variable references.
	  // TODO: find a way to memoize, in case this field is within a List type.
	  var args = (0, _values.getArgumentValues)(fieldDef.args, fieldAST.arguments, exeContext.variableValues);

	  // The resolve function's optional third argument is a context value that
	  // is provided to every resolve function within an execution. It is commonly
	  // used to represent an authenticated user, or request-specific caches.
	  var context = exeContext.contextValue;

	  // The resolve function's optional fourth argument is a collection of
	  // information about the current execution state.
	  var info = {
	    fieldName: fieldName,
	    fieldASTs: fieldASTs,
	    returnType: returnType,
	    parentType: parentType,
	    path: path,
	    schema: exeContext.schema,
	    fragments: exeContext.fragments,
	    rootValue: exeContext.rootValue,
	    operation: exeContext.operation,
	    variableValues: exeContext.variableValues
	  };

	  // Get the resolve function, regardless of if its result is normal
	  // or abrupt (error).
	  var result = resolveOrError(resolveFn, source, args, context, info);

	  return completeValueCatchingError(exeContext, returnType, fieldASTs, info, path, result);
	}

	// Isolates the "ReturnOrAbrupt" behavior to not de-opt the `resolveField`
	// function. Returns the result of resolveFn or the abrupt-return Error object.
	function resolveOrError(resolveFn, source, args, context, info) {
	  try {
	    return resolveFn(source, args, context, info);
	  } catch (error) {
	    // Sometimes a non-error is thrown, wrap it as an Error for a
	    // consistent interface.
	    return error instanceof Error ? error : new Error(error);
	  }
	}

	// This is a small wrapper around completeValue which detects and logs errors
	// in the execution context.
	function completeValueCatchingError(exeContext, returnType, fieldASTs, info, path, result) {
	  // If the field type is non-nullable, then it is resolved without any
	  // protection from errors, however it still properly locates the error.
	  if (returnType instanceof _definition.GraphQLNonNull) {
	    return completeValueWithLocatedError(exeContext, returnType, fieldASTs, info, path, result);
	  }

	  // Otherwise, error protection is applied, logging the error and resolving
	  // a null value for this field if one is encountered.
	  try {
	    var completed = completeValueWithLocatedError(exeContext, returnType, fieldASTs, info, path, result);
	    if (isThenable(completed)) {
	      // If `completeValueWithLocatedError` returned a rejected promise, log
	      // the rejection error and resolve to null.
	      // Note: we don't rely on a `catch` method, but we do expect "thenable"
	      // to take a second callback for the error case.
	      return completed.then(undefined, function (error) {
	        exeContext.errors.push(error);
	        return Promise.resolve(null);
	      });
	    }
	    return completed;
	  } catch (error) {
	    // If `completeValueWithLocatedError` returned abruptly (threw an error),
	    // log the error and return null.
	    exeContext.errors.push(error);
	    return null;
	  }
	}

	// This is a small wrapper around completeValue which annotates errors with
	// location information.
	function completeValueWithLocatedError(exeContext, returnType, fieldASTs, info, path, result) {
	  try {
	    var completed = completeValue(exeContext, returnType, fieldASTs, info, path, result);
	    if (isThenable(completed)) {
	      return completed.then(undefined, function (error) {
	        return Promise.reject((0, _error.locatedError)(error, fieldASTs, path));
	      });
	    }
	    return completed;
	  } catch (error) {
	    throw (0, _error.locatedError)(error, fieldASTs, path);
	  }
	}

	/**
	 * Implements the instructions for completeValue as defined in the
	 * "Field entries" section of the spec.
	 *
	 * If the field type is Non-Null, then this recursively completes the value
	 * for the inner type. It throws a field error if that completion returns null,
	 * as per the "Nullability" section of the spec.
	 *
	 * If the field type is a List, then this recursively completes the value
	 * for the inner type on each item in the list.
	 *
	 * If the field type is a Scalar or Enum, ensures the completed value is a legal
	 * value of the type by calling the `serialize` method of GraphQL type
	 * definition.
	 *
	 * If the field is an abstract type, determine the runtime type of the value
	 * and then complete based on that type
	 *
	 * Otherwise, the field type expects a sub-selection set, and will complete the
	 * value by evaluating all sub-selections.
	 */
	function completeValue(exeContext, returnType, fieldASTs, info, path, result) {
	  // If result is a Promise, apply-lift over completeValue.
	  if (isThenable(result)) {
	    return result.then(function (resolved) {
	      return completeValue(exeContext, returnType, fieldASTs, info, path, resolved);
	    });
	  }

	  // If result is an Error, throw a located error.
	  if (result instanceof Error) {
	    throw result;
	  }

	  // If field type is NonNull, complete for inner type, and throw field error
	  // if result is null.
	  if (returnType instanceof _definition.GraphQLNonNull) {
	    var completed = completeValue(exeContext, returnType.ofType, fieldASTs, info, path, result);
	    if (completed === null) {
	      throw new Error('Cannot return null for non-nullable field ' + info.parentType.name + '.' + info.fieldName + '.');
	    }
	    return completed;
	  }

	  // If result value is null-ish (null, undefined, or NaN) then return null.
	  if ((0, _isNullish2.default)(result)) {
	    return null;
	  }

	  // If field type is List, complete each item in the list with the inner type
	  if (returnType instanceof _definition.GraphQLList) {
	    return completeListValue(exeContext, returnType, fieldASTs, info, path, result);
	  }

	  // If field type is a leaf type, Scalar or Enum, serialize to a valid value,
	  // returning null if serialization is not possible.
	  if (returnType instanceof _definition.GraphQLScalarType || returnType instanceof _definition.GraphQLEnumType) {
	    return completeLeafValue(returnType, result);
	  }

	  // If field type is an abstract type, Interface or Union, determine the
	  // runtime Object type and complete for that type.
	  if (returnType instanceof _definition.GraphQLInterfaceType || returnType instanceof _definition.GraphQLUnionType) {
	    return completeAbstractValue(exeContext, returnType, fieldASTs, info, path, result);
	  }

	  // If field type is Object, execute and complete all sub-selections.
	  if (returnType instanceof _definition.GraphQLObjectType) {
	    return completeObjectValue(exeContext, returnType, fieldASTs, info, path, result);
	  }

	  // Not reachable. All possible output types have been considered.
	  throw new Error('Cannot complete value of unexpected type "' + String(returnType) + '".');
	}

	/**
	 * Complete a list value by completing each item in the list with the
	 * inner type
	 */
	function completeListValue(exeContext, returnType, fieldASTs, info, path, result) {
	  (0, _invariant2.default)((0, _iterall.isCollection)(result), 'Expected Iterable, but did not find one for field ' + info.parentType.name + '.' + info.fieldName + '.');

	  // This is specified as a simple map, however we're optimizing the path
	  // where the list contains no Promises by avoiding creating another Promise.
	  var itemType = returnType.ofType;
	  var containsPromise = false;
	  var completedResults = [];
	  (0, _iterall.forEach)(result, function (item, index) {
	    // No need to modify the info object containing the path,
	    // since from here on it is not ever accessed by resolver functions.
	    var fieldPath = path.concat([index]);
	    var completedItem = completeValueCatchingError(exeContext, itemType, fieldASTs, info, fieldPath, item);

	    if (!containsPromise && isThenable(completedItem)) {
	      containsPromise = true;
	    }
	    completedResults.push(completedItem);
	  });

	  return containsPromise ? Promise.all(completedResults) : completedResults;
	}

	/**
	 * Complete a Scalar or Enum by serializing to a valid value, returning
	 * null if serialization is not possible.
	 */
	function completeLeafValue(returnType, result) {
	  (0, _invariant2.default)(returnType.serialize, 'Missing serialize method on type');
	  var serializedResult = returnType.serialize(result);
	  if ((0, _isNullish2.default)(serializedResult)) {
	    throw new Error('Expected a value of type "' + String(returnType) + '" but ' + ('received: ' + String(result)));
	  }
	  return serializedResult;
	}

	/**
	 * Complete a value of an abstract type by determining the runtime object type
	 * of that value, then complete the value for that type.
	 */
	function completeAbstractValue(exeContext, returnType, fieldASTs, info, path, result) {
	  var runtimeType = returnType.resolveType ? returnType.resolveType(result, exeContext.contextValue, info) : defaultResolveTypeFn(result, exeContext.contextValue, info, returnType);

	  // If resolveType returns a string, we assume it's a GraphQLObjectType name.
	  if (typeof runtimeType === 'string') {
	    runtimeType = exeContext.schema.getType(runtimeType);
	  }

	  if (!(runtimeType instanceof _definition.GraphQLObjectType)) {
	    throw new _error.GraphQLError('Abstract type ' + returnType.name + ' must resolve to an Object type at ' + ('runtime for field ' + info.parentType.name + '.' + info.fieldName + ' with ') + ('value "' + String(result) + '", received "' + String(runtimeType) + '".'), fieldASTs);
	  }

	  if (!exeContext.schema.isPossibleType(returnType, runtimeType)) {
	    throw new _error.GraphQLError('Runtime Object type "' + runtimeType.name + '" is not a possible type ' + ('for "' + returnType.name + '".'), fieldASTs);
	  }

	  return completeObjectValue(exeContext, runtimeType, fieldASTs, info, path, result);
	}

	/**
	 * Complete an Object value by executing all sub-selections.
	 */
	function completeObjectValue(exeContext, returnType, fieldASTs, info, path, result) {
	  // If there is an isTypeOf predicate function, call it with the
	  // current result. If isTypeOf returns false, then raise an error rather
	  // than continuing execution.
	  if (returnType.isTypeOf && !returnType.isTypeOf(result, exeContext.contextValue, info)) {
	    throw new _error.GraphQLError('Expected value of type "' + returnType.name + '" but got: ' + String(result) + '.', fieldASTs);
	  }

	  // Collect sub-fields to execute to complete this value.
	  var subFieldASTs = Object.create(null);
	  var visitedFragmentNames = Object.create(null);
	  for (var i = 0; i < fieldASTs.length; i++) {
	    var selectionSet = fieldASTs[i].selectionSet;
	    if (selectionSet) {
	      subFieldASTs = collectFields(exeContext, returnType, selectionSet, subFieldASTs, visitedFragmentNames);
	    }
	  }

	  return executeFields(exeContext, returnType, result, path, subFieldASTs);
	}

	/**
	 * If a resolveType function is not given, then a default resolve behavior is
	 * used which tests each possible type for the abstract type by calling
	 * isTypeOf for the object being coerced, returning the first type that matches.
	 */
	function defaultResolveTypeFn(value, context, info, abstractType) {
	  var possibleTypes = info.schema.getPossibleTypes(abstractType);
	  for (var i = 0; i < possibleTypes.length; i++) {
	    var type = possibleTypes[i];
	    if (type.isTypeOf && type.isTypeOf(value, context, info)) {
	      return type;
	    }
	  }
	}

	/**
	 * If a resolve function is not given, then a default resolve behavior is used
	 * which takes the property of the source object of the same name as the field
	 * and returns it as the result, or if it's a function, returns the result
	 * of calling that function while passing along args and context.
	 */
	function defaultResolveFn(source, args, context, _ref) {
	  var fieldName = _ref.fieldName;

	  // ensure source is a value for which property access is acceptable.
	  if (typeof source === 'object' || typeof source === 'function') {
	    var property = source[fieldName];
	    if (typeof property === 'function') {
	      return source[fieldName](args, context);
	    }
	    return property;
	  }
	}

	/**
	 * Checks to see if this object acts like a Promise, i.e. has a "then"
	 * function.
	 */
	function isThenable(value) {
	  return typeof value === 'object' && value !== null && typeof value.then === 'function';
	}

	/**
	 * This method looks up the field on the given type defintion.
	 * It has special casing for the two introspection fields, __schema
	 * and __typename. __typename is special because it can always be
	 * queried as a field, even in situations where no other fields
	 * are allowed, like on a Union. __schema could get automatically
	 * added to the query type, but that would require mutating type
	 * definitions, which would cause issues.
	 */
	function getFieldDef(schema, parentType, fieldName) {
	  if (fieldName === _introspection.SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {
	    return _introspection.SchemaMetaFieldDef;
	  } else if (fieldName === _introspection.TypeMetaFieldDef.name && schema.getQueryType() === parentType) {
	    return _introspection.TypeMetaFieldDef;
	  } else if (fieldName === _introspection.TypeNameMetaFieldDef.name) {
	    return _introspection.TypeNameMetaFieldDef;
	  }
	  return parentType.getFields()[fieldName];
	}

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.getVariableValues = getVariableValues;
	exports.getArgumentValues = getArgumentValues;

	var _iterall = __webpack_require__(29);

	var _error = __webpack_require__(8);

	var _invariant = __webpack_require__(19);

	var _invariant2 = _interopRequireDefault(_invariant);

	var _isNullish = __webpack_require__(23);

	var _isNullish2 = _interopRequireDefault(_isNullish);

	var _keyMap = __webpack_require__(57);

	var _keyMap2 = _interopRequireDefault(_keyMap);

	var _typeFromAST = __webpack_require__(33);

	var _valueFromAST = __webpack_require__(65);

	var _isValidJSValue = __webpack_require__(66);

	var _printer = __webpack_require__(13);

	var _definition = __webpack_require__(22);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Prepares an object map of variableValues of the correct type based on the
	 * provided variable definitions and arbitrary input. If the input cannot be
	 * parsed to match the variable definitions, a GraphQLError will be thrown.
	 */

	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	function getVariableValues(schema, definitionASTs, inputs) {
	  return definitionASTs.reduce(function (values, defAST) {
	    var varName = defAST.variable.name.value;
	    values[varName] = getVariableValue(schema, defAST, inputs[varName]);
	    return values;
	  }, {});
	}

	/**
	 * Prepares an object map of argument values given a list of argument
	 * definitions and list of argument AST nodes.
	 */
	function getArgumentValues(argDefs, argASTs, variableValues) {
	  if (!argDefs || !argASTs) {
	    return {};
	  }
	  var argASTMap = (0, _keyMap2.default)(argASTs, function (arg) {
	    return arg.name.value;
	  });
	  return argDefs.reduce(function (result, argDef) {
	    var name = argDef.name;
	    var valueAST = argASTMap[name] ? argASTMap[name].value : null;
	    var value = (0, _valueFromAST.valueFromAST)(valueAST, argDef.type, variableValues);
	    if ((0, _isNullish2.default)(value)) {
	      value = argDef.defaultValue;
	    }
	    if (!(0, _isNullish2.default)(value)) {
	      result[name] = value;
	    }
	    return result;
	  }, {});
	}

	/**
	 * Given a variable definition, and any value of input, return a value which
	 * adheres to the variable definition, or throw an error.
	 */
	function getVariableValue(schema, definitionAST, input) {
	  var type = (0, _typeFromAST.typeFromAST)(schema, definitionAST.type);
	  var variable = definitionAST.variable;
	  if (!type || !(0, _definition.isInputType)(type)) {
	    throw new _error.GraphQLError('Variable "$' + variable.name.value + '" expected value of type ' + ('"' + (0, _printer.print)(definitionAST.type) + '" which cannot be used as an input type.'), [definitionAST]);
	  }
	  var inputType = type;
	  var errors = (0, _isValidJSValue.isValidJSValue)(input, inputType);
	  if (!errors.length) {
	    if ((0, _isNullish2.default)(input)) {
	      var defaultValue = definitionAST.defaultValue;
	      if (defaultValue) {
	        return (0, _valueFromAST.valueFromAST)(defaultValue, inputType);
	      }
	    }
	    return coerceValue(inputType, input);
	  }
	  if ((0, _isNullish2.default)(input)) {
	    throw new _error.GraphQLError('Variable "$' + variable.name.value + '" of required type ' + ('"' + (0, _printer.print)(definitionAST.type) + '" was not provided.'), [definitionAST]);
	  }
	  var message = errors ? '\n' + errors.join('\n') : '';
	  throw new _error.GraphQLError('Variable "$' + variable.name.value + '" got invalid value ' + (JSON.stringify(input) + '.' + message), [definitionAST]);
	}

	/**
	 * Given a type and any value, return a runtime value coerced to match the type.
	 */
	function coerceValue(type, value) {
	  // Ensure flow knows that we treat function params as const.
	  var _value = value;

	  if (type instanceof _definition.GraphQLNonNull) {
	    // Note: we're not checking that the result of coerceValue is non-null.
	    // We only call this function after calling isValidJSValue.
	    return coerceValue(type.ofType, _value);
	  }

	  if ((0, _isNullish2.default)(_value)) {
	    return null;
	  }

	  if (type instanceof _definition.GraphQLList) {
	    var _ret = function () {
	      var itemType = type.ofType;
	      if ((0, _iterall.isCollection)(_value)) {
	        var _ret2 = function () {
	          var coercedValues = [];
	          (0, _iterall.forEach)(_value, function (item) {
	            coercedValues.push(coerceValue(itemType, item));
	          });
	          return {
	            v: {
	              v: coercedValues
	            }
	          };
	        }();

	        if (typeof _ret2 === "object") return _ret2.v;
	      }
	      return {
	        v: [coerceValue(itemType, _value)]
	      };
	    }();

	    if (typeof _ret === "object") return _ret.v;
	  }

	  if (type instanceof _definition.GraphQLInputObjectType) {
	    var _ret3 = function () {
	      if (typeof _value !== 'object' || _value === null) {
	        return {
	          v: null
	        };
	      }
	      var fields = type.getFields();
	      return {
	        v: Object.keys(fields).reduce(function (obj, fieldName) {
	          var field = fields[fieldName];
	          var fieldValue = coerceValue(field.type, _value[fieldName]);
	          if ((0, _isNullish2.default)(fieldValue)) {
	            fieldValue = field.defaultValue;
	          }
	          if (!(0, _isNullish2.default)(fieldValue)) {
	            obj[fieldName] = fieldValue;
	          }
	          return obj;
	        }, {})
	      };
	    }();

	    if (typeof _ret3 === "object") return _ret3.v;
	  }

	  (0, _invariant2.default)(type instanceof _definition.GraphQLScalarType || type instanceof _definition.GraphQLEnumType, 'Must be input type');

	  var parsed = type.parseValue(_value);
	  if (!(0, _isNullish2.default)(parsed)) {
	    return parsed;
	  }
	}

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.valueFromAST = valueFromAST;

	var _keyMap = __webpack_require__(57);

	var _keyMap2 = _interopRequireDefault(_keyMap);

	var _invariant = __webpack_require__(19);

	var _invariant2 = _interopRequireDefault(_invariant);

	var _isNullish = __webpack_require__(23);

	var _isNullish2 = _interopRequireDefault(_isNullish);

	var _kinds = __webpack_require__(15);

	var Kind = _interopRequireWildcard(_kinds);

	var _definition = __webpack_require__(22);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Produces a JavaScript value given a GraphQL Value AST.
	 *
	 * A GraphQL type must be provided, which will be used to interpret different
	 * GraphQL Value literals.
	 *
	 * | GraphQL Value        | JSON Value    |
	 * | -------------------- | ------------- |
	 * | Input Object         | Object        |
	 * | List                 | Array         |
	 * | Boolean              | Boolean       |
	 * | String               | String        |
	 * | Int / Float          | Number        |
	 * | Enum Value           | Mixed         |
	 *
	 */
	function valueFromAST(valueAST, type, variables) {
	  if (type instanceof _definition.GraphQLNonNull) {
	    // Note: we're not checking that the result of valueFromAST is non-null.
	    // We're assuming that this query has been validated and the value used
	    // here is of the correct type.
	    return valueFromAST(valueAST, type.ofType, variables);
	  }

	  if (!valueAST) {
	    return null;
	  }

	  if (valueAST.kind === Kind.VARIABLE) {
	    var variableName = valueAST.name.value;
	    if (!variables || !variables.hasOwnProperty(variableName)) {
	      return null;
	    }
	    // Note: we're not doing any checking that this variable is correct. We're
	    // assuming that this query has been validated and the variable usage here
	    // is of the correct type.
	    return variables[variableName];
	  }

	  if (type instanceof _definition.GraphQLList) {
	    var _ret = function () {
	      var itemType = type.ofType;
	      if (valueAST.kind === Kind.LIST) {
	        return {
	          v: valueAST.values.map(function (itemAST) {
	            return valueFromAST(itemAST, itemType, variables);
	          })
	        };
	      }
	      return {
	        v: [valueFromAST(valueAST, itemType, variables)]
	      };
	    }();

	    if (typeof _ret === "object") return _ret.v;
	  }

	  if (type instanceof _definition.GraphQLInputObjectType) {
	    var _ret2 = function () {
	      if (valueAST.kind !== Kind.OBJECT) {
	        return {
	          v: null
	        };
	      }
	      var fields = type.getFields();
	      var fieldASTs = (0, _keyMap2.default)(valueAST.fields, function (field) {
	        return field.name.value;
	      });
	      return {
	        v: Object.keys(fields).reduce(function (obj, fieldName) {
	          var field = fields[fieldName];
	          var fieldAST = fieldASTs[fieldName];
	          var fieldValue = valueFromAST(fieldAST && fieldAST.value, field.type, variables);
	          if ((0, _isNullish2.default)(fieldValue)) {
	            fieldValue = field.defaultValue;
	          }
	          if (!(0, _isNullish2.default)(fieldValue)) {
	            obj[fieldName] = fieldValue;
	          }
	          return obj;
	        }, {})
	      };
	    }();

	    if (typeof _ret2 === "object") return _ret2.v;
	  }

	  (0, _invariant2.default)(type instanceof _definition.GraphQLScalarType || type instanceof _definition.GraphQLEnumType, 'Must be input type');

	  var parsed = type.parseLiteral(valueAST);
	  if (!(0, _isNullish2.default)(parsed)) {
	    return parsed;
	  }
	}
	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.isValidJSValue = isValidJSValue;

	var _iterall = __webpack_require__(29);

	var _invariant = __webpack_require__(19);

	var _invariant2 = _interopRequireDefault(_invariant);

	var _isNullish = __webpack_require__(23);

	var _isNullish2 = _interopRequireDefault(_isNullish);

	var _definition = __webpack_require__(22);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Given a JavaScript value and a GraphQL type, determine if the value will be
	 * accepted for that type. This is primarily useful for validating the
	 * runtime values of query variables.
	 */

	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	function isValidJSValue(value, type) {
	  // A value must be provided if the type is non-null.
	  if (type instanceof _definition.GraphQLNonNull) {
	    if ((0, _isNullish2.default)(value)) {
	      if (type.ofType.name) {
	        return ['Expected "' + String(type.ofType.name) + '!", found null.'];
	      }
	      return ['Expected non-null value, found null.'];
	    }
	    return isValidJSValue(value, type.ofType);
	  }

	  if ((0, _isNullish2.default)(value)) {
	    return [];
	  }

	  // Lists accept a non-list value as a list of one.
	  if (type instanceof _definition.GraphQLList) {
	    var _ret = function () {
	      var itemType = type.ofType;
	      if ((0, _iterall.isCollection)(value)) {
	        var _ret2 = function () {
	          var errors = [];
	          (0, _iterall.forEach)(value, function (item, index) {
	            errors.push.apply(errors, isValidJSValue(item, itemType).map(function (error) {
	              return 'In element #' + index + ': ' + error;
	            }));
	          });
	          return {
	            v: {
	              v: errors
	            }
	          };
	        }();

	        if (typeof _ret2 === "object") return _ret2.v;
	      }
	      return {
	        v: isValidJSValue(value, itemType)
	      };
	    }();

	    if (typeof _ret === "object") return _ret.v;
	  }

	  // Input objects check each defined field.
	  if (type instanceof _definition.GraphQLInputObjectType) {
	    var _ret3 = function () {
	      if (typeof value !== 'object' || value === null) {
	        return {
	          v: ['Expected "' + type.name + '", found not an object.']
	        };
	      }
	      var fields = type.getFields();

	      var errors = [];

	      // Ensure every provided field is defined.
	      Object.keys(value).forEach(function (providedField) {
	        if (!fields[providedField]) {
	          errors.push('In field "' + providedField + '": Unknown field.');
	        }
	      });

	      // Ensure every defined field is valid.
	      Object.keys(fields).forEach(function (fieldName) {
	        var newErrors = isValidJSValue(value[fieldName], fields[fieldName].type);
	        errors.push.apply(errors, newErrors.map(function (error) {
	          return 'In field "' + fieldName + '": ' + error;
	        }));
	      });

	      return {
	        v: errors
	      };
	    }();

	    if (typeof _ret3 === "object") return _ret3.v;
	  }

	  (0, _invariant2.default)(type instanceof _definition.GraphQLScalarType || type instanceof _definition.GraphQLEnumType, 'Must be input type');

	  // Scalar/Enum input checks to ensure the type can parse the value to
	  // a non-null value.
	  var parseResult = type.parseValue(value);
	  if ((0, _isNullish2.default)(parseResult)) {
	    return ['Expected type "' + type.name + '", found ' + JSON.stringify(value) + '.'];
	  }

	  return [];
	}

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _schema = __webpack_require__(21);

	Object.defineProperty(exports, 'GraphQLSchema', {
	  enumerable: true,
	  get: function get() {
	    return _schema.GraphQLSchema;
	  }
	});

	var _definition = __webpack_require__(22);

	Object.defineProperty(exports, 'isType', {
	  enumerable: true,
	  get: function get() {
	    return _definition.isType;
	  }
	});
	Object.defineProperty(exports, 'isInputType', {
	  enumerable: true,
	  get: function get() {
	    return _definition.isInputType;
	  }
	});
	Object.defineProperty(exports, 'isOutputType', {
	  enumerable: true,
	  get: function get() {
	    return _definition.isOutputType;
	  }
	});
	Object.defineProperty(exports, 'isLeafType', {
	  enumerable: true,
	  get: function get() {
	    return _definition.isLeafType;
	  }
	});
	Object.defineProperty(exports, 'isCompositeType', {
	  enumerable: true,
	  get: function get() {
	    return _definition.isCompositeType;
	  }
	});
	Object.defineProperty(exports, 'isAbstractType', {
	  enumerable: true,
	  get: function get() {
	    return _definition.isAbstractType;
	  }
	});
	Object.defineProperty(exports, 'getNullableType', {
	  enumerable: true,
	  get: function get() {
	    return _definition.getNullableType;
	  }
	});
	Object.defineProperty(exports, 'getNamedType', {
	  enumerable: true,
	  get: function get() {
	    return _definition.getNamedType;
	  }
	});
	Object.defineProperty(exports, 'GraphQLScalarType', {
	  enumerable: true,
	  get: function get() {
	    return _definition.GraphQLScalarType;
	  }
	});
	Object.defineProperty(exports, 'GraphQLObjectType', {
	  enumerable: true,
	  get: function get() {
	    return _definition.GraphQLObjectType;
	  }
	});
	Object.defineProperty(exports, 'GraphQLInterfaceType', {
	  enumerable: true,
	  get: function get() {
	    return _definition.GraphQLInterfaceType;
	  }
	});
	Object.defineProperty(exports, 'GraphQLUnionType', {
	  enumerable: true,
	  get: function get() {
	    return _definition.GraphQLUnionType;
	  }
	});
	Object.defineProperty(exports, 'GraphQLEnumType', {
	  enumerable: true,
	  get: function get() {
	    return _definition.GraphQLEnumType;
	  }
	});
	Object.defineProperty(exports, 'GraphQLInputObjectType', {
	  enumerable: true,
	  get: function get() {
	    return _definition.GraphQLInputObjectType;
	  }
	});
	Object.defineProperty(exports, 'GraphQLList', {
	  enumerable: true,
	  get: function get() {
	    return _definition.GraphQLList;
	  }
	});
	Object.defineProperty(exports, 'GraphQLNonNull', {
	  enumerable: true,
	  get: function get() {
	    return _definition.GraphQLNonNull;
	  }
	});

	var _directives = __webpack_require__(25);

	Object.defineProperty(exports, 'DirectiveLocation', {
	  enumerable: true,
	  get: function get() {
	    return _directives.DirectiveLocation;
	  }
	});
	Object.defineProperty(exports, 'GraphQLDirective', {
	  enumerable: true,
	  get: function get() {
	    return _directives.GraphQLDirective;
	  }
	});
	Object.defineProperty(exports, 'specifiedDirectives', {
	  enumerable: true,
	  get: function get() {
	    return _directives.specifiedDirectives;
	  }
	});
	Object.defineProperty(exports, 'GraphQLIncludeDirective', {
	  enumerable: true,
	  get: function get() {
	    return _directives.GraphQLIncludeDirective;
	  }
	});
	Object.defineProperty(exports, 'GraphQLSkipDirective', {
	  enumerable: true,
	  get: function get() {
	    return _directives.GraphQLSkipDirective;
	  }
	});
	Object.defineProperty(exports, 'GraphQLDeprecatedDirective', {
	  enumerable: true,
	  get: function get() {
	    return _directives.GraphQLDeprecatedDirective;
	  }
	});
	Object.defineProperty(exports, 'DEFAULT_DEPRECATION_REASON', {
	  enumerable: true,
	  get: function get() {
	    return _directives.DEFAULT_DEPRECATION_REASON;
	  }
	});

	var _scalars = __webpack_require__(26);

	Object.defineProperty(exports, 'GraphQLInt', {
	  enumerable: true,
	  get: function get() {
	    return _scalars.GraphQLInt;
	  }
	});
	Object.defineProperty(exports, 'GraphQLFloat', {
	  enumerable: true,
	  get: function get() {
	    return _scalars.GraphQLFloat;
	  }
	});
	Object.defineProperty(exports, 'GraphQLString', {
	  enumerable: true,
	  get: function get() {
	    return _scalars.GraphQLString;
	  }
	});
	Object.defineProperty(exports, 'GraphQLBoolean', {
	  enumerable: true,
	  get: function get() {
	    return _scalars.GraphQLBoolean;
	  }
	});
	Object.defineProperty(exports, 'GraphQLID', {
	  enumerable: true,
	  get: function get() {
	    return _scalars.GraphQLID;
	  }
	});

	var _introspection = __webpack_require__(27);

	Object.defineProperty(exports, 'TypeKind', {
	  enumerable: true,
	  get: function get() {
	    return _introspection.TypeKind;
	  }
	});
	Object.defineProperty(exports, '__Schema', {
	  enumerable: true,
	  get: function get() {
	    return _introspection.__Schema;
	  }
	});
	Object.defineProperty(exports, '__Directive', {
	  enumerable: true,
	  get: function get() {
	    return _introspection.__Directive;
	  }
	});
	Object.defineProperty(exports, '__DirectiveLocation', {
	  enumerable: true,
	  get: function get() {
	    return _introspection.__DirectiveLocation;
	  }
	});
	Object.defineProperty(exports, '__Type', {
	  enumerable: true,
	  get: function get() {
	    return _introspection.__Type;
	  }
	});
	Object.defineProperty(exports, '__Field', {
	  enumerable: true,
	  get: function get() {
	    return _introspection.__Field;
	  }
	});
	Object.defineProperty(exports, '__InputValue', {
	  enumerable: true,
	  get: function get() {
	    return _introspection.__InputValue;
	  }
	});
	Object.defineProperty(exports, '__EnumValue', {
	  enumerable: true,
	  get: function get() {
	    return _introspection.__EnumValue;
	  }
	});
	Object.defineProperty(exports, '__TypeKind', {
	  enumerable: true,
	  get: function get() {
	    return _introspection.__TypeKind;
	  }
	});
	Object.defineProperty(exports, 'SchemaMetaFieldDef', {
	  enumerable: true,
	  get: function get() {
	    return _introspection.SchemaMetaFieldDef;
	  }
	});
	Object.defineProperty(exports, 'TypeMetaFieldDef', {
	  enumerable: true,
	  get: function get() {
	    return _introspection.TypeMetaFieldDef;
	  }
	});
	Object.defineProperty(exports, 'TypeNameMetaFieldDef', {
	  enumerable: true,
	  get: function get() {
	    return _introspection.TypeNameMetaFieldDef;
	  }
	});

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _execute = __webpack_require__(63);

	Object.defineProperty(exports, 'execute', {
	  enumerable: true,
	  get: function get() {
	    return _execute.execute;
	  }
	});

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _validate = __webpack_require__(20);

	Object.defineProperty(exports, 'validate', {
	  enumerable: true,
	  get: function get() {
	    return _validate.validate;
	  }
	});

	var _specifiedRules = __webpack_require__(34);

	Object.defineProperty(exports, 'specifiedRules', {
	  enumerable: true,
	  get: function get() {
	    return _specifiedRules.specifiedRules;
	  }
	});

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _introspectionQuery = __webpack_require__(71);

	Object.defineProperty(exports, 'introspectionQuery', {
	  enumerable: true,
	  get: function get() {
	    return _introspectionQuery.introspectionQuery;
	  }
	});

	var _getOperationAST = __webpack_require__(72);

	Object.defineProperty(exports, 'getOperationAST', {
	  enumerable: true,
	  get: function get() {
	    return _getOperationAST.getOperationAST;
	  }
	});

	var _buildClientSchema = __webpack_require__(73);

	Object.defineProperty(exports, 'buildClientSchema', {
	  enumerable: true,
	  get: function get() {
	    return _buildClientSchema.buildClientSchema;
	  }
	});

	var _buildASTSchema = __webpack_require__(75);

	Object.defineProperty(exports, 'buildASTSchema', {
	  enumerable: true,
	  get: function get() {
	    return _buildASTSchema.buildASTSchema;
	  }
	});
	Object.defineProperty(exports, 'buildSchema', {
	  enumerable: true,
	  get: function get() {
	    return _buildASTSchema.buildSchema;
	  }
	});

	var _extendSchema = __webpack_require__(76);

	Object.defineProperty(exports, 'extendSchema', {
	  enumerable: true,
	  get: function get() {
	    return _extendSchema.extendSchema;
	  }
	});

	var _schemaPrinter = __webpack_require__(77);

	Object.defineProperty(exports, 'printSchema', {
	  enumerable: true,
	  get: function get() {
	    return _schemaPrinter.printSchema;
	  }
	});
	Object.defineProperty(exports, 'printIntrospectionSchema', {
	  enumerable: true,
	  get: function get() {
	    return _schemaPrinter.printIntrospectionSchema;
	  }
	});

	var _typeFromAST = __webpack_require__(33);

	Object.defineProperty(exports, 'typeFromAST', {
	  enumerable: true,
	  get: function get() {
	    return _typeFromAST.typeFromAST;
	  }
	});

	var _valueFromAST = __webpack_require__(65);

	Object.defineProperty(exports, 'valueFromAST', {
	  enumerable: true,
	  get: function get() {
	    return _valueFromAST.valueFromAST;
	  }
	});

	var _astFromValue = __webpack_require__(28);

	Object.defineProperty(exports, 'astFromValue', {
	  enumerable: true,
	  get: function get() {
	    return _astFromValue.astFromValue;
	  }
	});

	var _TypeInfo = __webpack_require__(32);

	Object.defineProperty(exports, 'TypeInfo', {
	  enumerable: true,
	  get: function get() {
	    return _TypeInfo.TypeInfo;
	  }
	});

	var _isValidJSValue = __webpack_require__(66);

	Object.defineProperty(exports, 'isValidJSValue', {
	  enumerable: true,
	  get: function get() {
	    return _isValidJSValue.isValidJSValue;
	  }
	});

	var _isValidLiteralValue = __webpack_require__(56);

	Object.defineProperty(exports, 'isValidLiteralValue', {
	  enumerable: true,
	  get: function get() {
	    return _isValidLiteralValue.isValidLiteralValue;
	  }
	});

	var _concatAST = __webpack_require__(78);

	Object.defineProperty(exports, 'concatAST', {
	  enumerable: true,
	  get: function get() {
	    return _concatAST.concatAST;
	  }
	});

	var _separateOperations = __webpack_require__(79);

	Object.defineProperty(exports, 'separateOperations', {
	  enumerable: true,
	  get: function get() {
	    return _separateOperations.separateOperations;
	  }
	});

	var _typeComparators = __webpack_require__(31);

	Object.defineProperty(exports, 'isEqualType', {
	  enumerable: true,
	  get: function get() {
	    return _typeComparators.isEqualType;
	  }
	});
	Object.defineProperty(exports, 'isTypeSubTypeOf', {
	  enumerable: true,
	  get: function get() {
	    return _typeComparators.isTypeSubTypeOf;
	  }
	});
	Object.defineProperty(exports, 'doTypesOverlap', {
	  enumerable: true,
	  get: function get() {
	    return _typeComparators.doTypesOverlap;
	  }
	});

	var _assertValidName = __webpack_require__(24);

	Object.defineProperty(exports, 'assertValidName', {
	  enumerable: true,
	  get: function get() {
	    return _assertValidName.assertValidName;
	  }
	});

	var _findBreakingChanges = __webpack_require__(80);

	Object.defineProperty(exports, 'findBreakingChanges', {
	  enumerable: true,
	  get: function get() {
	    return _findBreakingChanges.findBreakingChanges;
	  }
	});

/***/ },
/* 71 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var introspectionQuery = exports.introspectionQuery = '\n  query IntrospectionQuery {\n    __schema {\n      queryType { name }\n      mutationType { name }\n      subscriptionType { name }\n      types {\n        ...FullType\n      }\n      directives {\n        name\n        description\n        locations\n        args {\n          ...InputValue\n        }\n      }\n    }\n  }\n\n  fragment FullType on __Type {\n    kind\n    name\n    description\n    fields(includeDeprecated: true) {\n      name\n      description\n      args {\n        ...InputValue\n      }\n      type {\n        ...TypeRef\n      }\n      isDeprecated\n      deprecationReason\n    }\n    inputFields {\n      ...InputValue\n    }\n    interfaces {\n      ...TypeRef\n    }\n    enumValues(includeDeprecated: true) {\n      name\n      description\n      isDeprecated\n      deprecationReason\n    }\n    possibleTypes {\n      ...TypeRef\n    }\n  }\n\n  fragment InputValue on __InputValue {\n    name\n    description\n    type { ...TypeRef }\n    defaultValue\n  }\n\n  fragment TypeRef on __Type {\n    kind\n    name\n    ofType {\n      kind\n      name\n      ofType {\n        kind\n        name\n        ofType {\n          kind\n          name\n          ofType {\n            kind\n            name\n            ofType {\n              kind\n              name\n              ofType {\n                kind\n                name\n                ofType {\n                  kind\n                  name\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n';
	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.getOperationAST = getOperationAST;

	var _kinds = __webpack_require__(15);

	/**
	 * Returns an operation AST given a document AST and optionally an operation
	 * name. If a name is not provided, an operation is only returned if only one is
	 * provided in the document.
	 */
	function getOperationAST(documentAST, operationName) {
	  var operation = null;
	  for (var i = 0; i < documentAST.definitions.length; i++) {
	    var definition = documentAST.definitions[i];
	    if (definition.kind === _kinds.OPERATION_DEFINITION) {
	      if (!operationName) {
	        // If no operation name was provided, only return an Operation if there
	        // is one defined in the document. Upon encountering the second, return
	        // null.
	        if (operation) {
	          return null;
	        }
	        operation = definition;
	      } else if (definition.name && definition.name.value === operationName) {
	        return definition;
	      }
	    }
	  }
	  return operation;
	}
	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.buildClientSchema = buildClientSchema;

	var _invariant = __webpack_require__(19);

	var _invariant2 = _interopRequireDefault(_invariant);

	var _keyMap = __webpack_require__(57);

	var _keyMap2 = _interopRequireDefault(_keyMap);

	var _keyValMap = __webpack_require__(74);

	var _keyValMap2 = _interopRequireDefault(_keyValMap);

	var _valueFromAST = __webpack_require__(65);

	var _parser = __webpack_require__(7);

	var _schema = __webpack_require__(21);

	var _definition = __webpack_require__(22);

	var _introspection = __webpack_require__(27);

	var _scalars = __webpack_require__(26);

	var _directives = __webpack_require__(25);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Build a GraphQLSchema for use by client tools.
	 *
	 * Given the result of a client running the introspection query, creates and
	 * returns a GraphQLSchema instance which can be then used with all graphql-js
	 * tools, but cannot be used to execute a query, as introspection does not
	 * represent the "resolver", "parse" or "serialize" functions or any other
	 * server-internal mechanisms.
	 */
	function buildClientSchema(introspection) {

	  // Get the schema from the introspection result.
	  var schemaIntrospection = introspection.__schema;

	  // Converts the list of types into a keyMap based on the type names.
	  var typeIntrospectionMap = (0, _keyMap2.default)(schemaIntrospection.types, function (type) {
	    return type.name;
	  });

	  // A cache to use to store the actual GraphQLType definition objects by name.
	  // Initialize to the GraphQL built in scalars. All functions below are inline
	  // so that this type def cache is within the scope of the closure.
	  var typeDefCache = {
	    String: _scalars.GraphQLString,
	    Int: _scalars.GraphQLInt,
	    Float: _scalars.GraphQLFloat,
	    Boolean: _scalars.GraphQLBoolean,
	    ID: _scalars.GraphQLID,
	    __Schema: _introspection.__Schema,
	    __Directive: _introspection.__Directive,
	    __DirectiveLocation: _introspection.__DirectiveLocation,
	    __Type: _introspection.__Type,
	    __Field: _introspection.__Field,
	    __InputValue: _introspection.__InputValue,
	    __EnumValue: _introspection.__EnumValue,
	    __TypeKind: _introspection.__TypeKind
	  };

	  // Given a type reference in introspection, return the GraphQLType instance.
	  // preferring cached instances before building new instances.
	  function getType(typeRef) {
	    if (typeRef.kind === _introspection.TypeKind.LIST) {
	      var itemRef = typeRef.ofType;
	      if (!itemRef) {
	        throw new Error('Decorated type deeper than introspection query.');
	      }
	      return new _definition.GraphQLList(getType(itemRef));
	    }
	    if (typeRef.kind === _introspection.TypeKind.NON_NULL) {
	      var nullableRef = typeRef.ofType;
	      if (!nullableRef) {
	        throw new Error('Decorated type deeper than introspection query.');
	      }
	      var nullableType = getType(nullableRef);
	      (0, _invariant2.default)(!(nullableType instanceof _definition.GraphQLNonNull), 'No nesting nonnull.');
	      return new _definition.GraphQLNonNull(nullableType);
	    }
	    return getNamedType(typeRef.name);
	  }

	  function getNamedType(typeName) {
	    if (typeDefCache[typeName]) {
	      return typeDefCache[typeName];
	    }
	    var typeIntrospection = typeIntrospectionMap[typeName];
	    if (!typeIntrospection) {
	      throw new Error('Invalid or incomplete schema, unknown type: ' + typeName + '. Ensure ' + 'that a full introspection query is used in order to build a ' + 'client schema.');
	    }
	    var typeDef = buildType(typeIntrospection);
	    typeDefCache[typeName] = typeDef;
	    return typeDef;
	  }

	  function getInputType(typeRef) {
	    var type = getType(typeRef);
	    (0, _invariant2.default)((0, _definition.isInputType)(type), 'Introspection must provide input type for arguments.');
	    return type;
	  }

	  function getOutputType(typeRef) {
	    var type = getType(typeRef);
	    (0, _invariant2.default)((0, _definition.isOutputType)(type), 'Introspection must provide output type for fields.');
	    return type;
	  }

	  function getObjectType(typeRef) {
	    var type = getType(typeRef);
	    (0, _invariant2.default)(type instanceof _definition.GraphQLObjectType, 'Introspection must provide object type for possibleTypes.');
	    return type;
	  }

	  function getInterfaceType(typeRef) {
	    var type = getType(typeRef);
	    (0, _invariant2.default)(type instanceof _definition.GraphQLInterfaceType, 'Introspection must provide interface type for interfaces.');
	    return type;
	  }

	  // Given a type's introspection result, construct the correct
	  // GraphQLType instance.
	  function buildType(type) {
	    switch (type.kind) {
	      case _introspection.TypeKind.SCALAR:
	        return buildScalarDef(type);
	      case _introspection.TypeKind.OBJECT:
	        return buildObjectDef(type);
	      case _introspection.TypeKind.INTERFACE:
	        return buildInterfaceDef(type);
	      case _introspection.TypeKind.UNION:
	        return buildUnionDef(type);
	      case _introspection.TypeKind.ENUM:
	        return buildEnumDef(type);
	      case _introspection.TypeKind.INPUT_OBJECT:
	        return buildInputObjectDef(type);
	      default:
	        throw new Error('Invalid or incomplete schema, unknown kind: ' + type.kind + '. Ensure ' + 'that a full introspection query is used in order to build a ' + 'client schema.');
	    }
	  }

	  function buildScalarDef(scalarIntrospection) {
	    return new _definition.GraphQLScalarType({
	      name: scalarIntrospection.name,
	      description: scalarIntrospection.description,
	      serialize: function serialize(id) {
	        return id;
	      },
	      // Note: validation calls the parse functions to determine if a
	      // literal value is correct. Returning null would cause use of custom
	      // scalars to always fail validation. Returning false causes them to
	      // always pass validation.
	      parseValue: function parseValue() {
	        return false;
	      },
	      parseLiteral: function parseLiteral() {
	        return false;
	      }
	    });
	  }

	  function buildObjectDef(objectIntrospection) {
	    return new _definition.GraphQLObjectType({
	      name: objectIntrospection.name,
	      description: objectIntrospection.description,
	      interfaces: objectIntrospection.interfaces.map(getInterfaceType),
	      fields: function fields() {
	        return buildFieldDefMap(objectIntrospection);
	      }
	    });
	  }

	  function buildInterfaceDef(interfaceIntrospection) {
	    return new _definition.GraphQLInterfaceType({
	      name: interfaceIntrospection.name,
	      description: interfaceIntrospection.description,
	      fields: function fields() {
	        return buildFieldDefMap(interfaceIntrospection);
	      },
	      resolveType: cannotExecuteClientSchema
	    });
	  }

	  function buildUnionDef(unionIntrospection) {
	    return new _definition.GraphQLUnionType({
	      name: unionIntrospection.name,
	      description: unionIntrospection.description,
	      types: unionIntrospection.possibleTypes.map(getObjectType),
	      resolveType: cannotExecuteClientSchema
	    });
	  }

	  function buildEnumDef(enumIntrospection) {
	    return new _definition.GraphQLEnumType({
	      name: enumIntrospection.name,
	      description: enumIntrospection.description,
	      values: (0, _keyValMap2.default)(enumIntrospection.enumValues, function (valueIntrospection) {
	        return valueIntrospection.name;
	      }, function (valueIntrospection) {
	        return {
	          description: valueIntrospection.description,
	          deprecationReason: valueIntrospection.deprecationReason
	        };
	      })
	    });
	  }

	  function buildInputObjectDef(inputObjectIntrospection) {
	    return new _definition.GraphQLInputObjectType({
	      name: inputObjectIntrospection.name,
	      description: inputObjectIntrospection.description,
	      fields: function fields() {
	        return buildInputValueDefMap(inputObjectIntrospection.inputFields);
	      }
	    });
	  }

	  function buildFieldDefMap(typeIntrospection) {
	    return (0, _keyValMap2.default)(typeIntrospection.fields, function (fieldIntrospection) {
	      return fieldIntrospection.name;
	    }, function (fieldIntrospection) {
	      return {
	        description: fieldIntrospection.description,
	        deprecationReason: fieldIntrospection.deprecationReason,
	        type: getOutputType(fieldIntrospection.type),
	        args: buildInputValueDefMap(fieldIntrospection.args)
	      };
	    });
	  }

	  function buildInputValueDefMap(inputValueIntrospections) {
	    return (0, _keyValMap2.default)(inputValueIntrospections, function (inputValue) {
	      return inputValue.name;
	    }, buildInputValue);
	  }

	  function buildInputValue(inputValueIntrospection) {
	    var type = getInputType(inputValueIntrospection.type);
	    var defaultValue = inputValueIntrospection.defaultValue ? (0, _valueFromAST.valueFromAST)((0, _parser.parseValue)(inputValueIntrospection.defaultValue), type) : null;
	    return {
	      name: inputValueIntrospection.name,
	      description: inputValueIntrospection.description,
	      type: type,
	      defaultValue: defaultValue
	    };
	  }

	  function buildDirective(directiveIntrospection) {
	    // Support deprecated `on****` fields for building `locations`, as this
	    // is used by GraphiQL which may need to support outdated servers.
	    var locations = directiveIntrospection.locations ? directiveIntrospection.locations.slice() : [].concat(!directiveIntrospection.onField ? [] : [_directives.DirectiveLocation.FIELD], !directiveIntrospection.onOperation ? [] : [_directives.DirectiveLocation.QUERY, _directives.DirectiveLocation.MUTATION, _directives.DirectiveLocation.SUBSCRIPTION], !directiveIntrospection.onFragment ? [] : [_directives.DirectiveLocation.FRAGMENT_DEFINITION, _directives.DirectiveLocation.FRAGMENT_SPREAD, _directives.DirectiveLocation.INLINE_FRAGMENT]);
	    return new _directives.GraphQLDirective({
	      name: directiveIntrospection.name,
	      description: directiveIntrospection.description,
	      locations: locations,
	      args: buildInputValueDefMap(directiveIntrospection.args)
	    });
	  }

	  // Iterate through all types, getting the type definition for each, ensuring
	  // that any type not directly referenced by a field will get created.
	  var types = schemaIntrospection.types.map(function (typeIntrospection) {
	    return getNamedType(typeIntrospection.name);
	  });

	  // Get the root Query, Mutation, and Subscription types.
	  var queryType = getObjectType(schemaIntrospection.queryType);

	  var mutationType = schemaIntrospection.mutationType ? getObjectType(schemaIntrospection.mutationType) : null;

	  var subscriptionType = schemaIntrospection.subscriptionType ? getObjectType(schemaIntrospection.subscriptionType) : null;

	  // Get the directives supported by Introspection, assuming empty-set if
	  // directives were not queried for.
	  var directives = schemaIntrospection.directives ? schemaIntrospection.directives.map(buildDirective) : [];

	  // Then produce and return a Schema with these types.
	  return new _schema.GraphQLSchema({
	    query: queryType,
	    mutation: mutationType,
	    subscription: subscriptionType,
	    types: types,
	    directives: directives
	  });
	}
	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	function cannotExecuteClientSchema() {
	  throw new Error('Client Schema cannot use Interface or Union types for execution.');
	}

/***/ },
/* 74 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = keyValMap;

	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	/**
	 * Creates a keyed JS object from an array, given a function to produce the keys
	 * and a function to produce the values from each item in the array.
	 *
	 *     const phoneBook = [
	 *       { name: 'Jon', num: '555-1234' },
	 *       { name: 'Jenny', num: '867-5309' }
	 *     ]
	 *
	 *     // { Jon: '555-1234', Jenny: '867-5309' }
	 *     const phonesByName = keyValMap(
	 *       phoneBook,
	 *       entry => entry.name,
	 *       entry => entry.num
	 *     )
	 *
	 */
	function keyValMap(list, keyFn, valFn) {
	  return list.reduce(function (map, item) {
	    return map[keyFn(item)] = valFn(item), map;
	  }, {});
	}

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.buildASTSchema = buildASTSchema;
	exports.getDescription = getDescription;
	exports.buildSchema = buildSchema;

	var _find = __webpack_require__(30);

	var _find2 = _interopRequireDefault(_find);

	var _invariant = __webpack_require__(19);

	var _invariant2 = _interopRequireDefault(_invariant);

	var _keyValMap = __webpack_require__(74);

	var _keyValMap2 = _interopRequireDefault(_keyValMap);

	var _valueFromAST = __webpack_require__(65);

	var _lexer = __webpack_require__(12);

	var _parser = __webpack_require__(7);

	var _values = __webpack_require__(64);

	var _kinds = __webpack_require__(15);

	var _schema = __webpack_require__(21);

	var _scalars = __webpack_require__(26);

	var _definition = __webpack_require__(22);

	var _directives = __webpack_require__(25);

	var _introspection = __webpack_require__(27);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function buildWrappedType(innerType, inputTypeAST) {
	  if (inputTypeAST.kind === _kinds.LIST_TYPE) {
	    return new _definition.GraphQLList(buildWrappedType(innerType, inputTypeAST.type));
	  }
	  if (inputTypeAST.kind === _kinds.NON_NULL_TYPE) {
	    var wrappedType = buildWrappedType(innerType, inputTypeAST.type);
	    (0, _invariant2.default)(!(wrappedType instanceof _definition.GraphQLNonNull), 'No nesting nonnull.');
	    return new _definition.GraphQLNonNull(wrappedType);
	  }
	  return innerType;
	}
	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	function getNamedTypeAST(typeAST) {
	  var namedType = typeAST;
	  while (namedType.kind === _kinds.LIST_TYPE || namedType.kind === _kinds.NON_NULL_TYPE) {
	    namedType = namedType.type;
	  }
	  return namedType;
	}

	/**
	 * This takes the ast of a schema document produced by the parse function in
	 * src/language/parser.js.
	 *
	 * If no schema definition is provided, then it will look for types named Query
	 * and Mutation.
	 *
	 * Given that AST it constructs a GraphQLSchema. The resulting schema
	 * has no resolve methods, so execution will use default resolvers.
	 */
	function buildASTSchema(ast) {
	  if (!ast || ast.kind !== _kinds.DOCUMENT) {
	    throw new Error('Must provide a document ast.');
	  }

	  var schemaDef = void 0;

	  var typeDefs = [];
	  var astMap = Object.create(null);
	  var directiveDefs = [];
	  for (var i = 0; i < ast.definitions.length; i++) {
	    var d = ast.definitions[i];
	    switch (d.kind) {
	      case _kinds.SCHEMA_DEFINITION:
	        if (schemaDef) {
	          throw new Error('Must provide only one schema definition.');
	        }
	        schemaDef = d;
	        break;
	      case _kinds.SCALAR_TYPE_DEFINITION:
	      case _kinds.OBJECT_TYPE_DEFINITION:
	      case _kinds.INTERFACE_TYPE_DEFINITION:
	      case _kinds.ENUM_TYPE_DEFINITION:
	      case _kinds.UNION_TYPE_DEFINITION:
	      case _kinds.INPUT_OBJECT_TYPE_DEFINITION:
	        typeDefs.push(d);
	        astMap[d.name.value] = d;
	        break;
	      case _kinds.DIRECTIVE_DEFINITION:
	        directiveDefs.push(d);
	        break;
	    }
	  }

	  var queryTypeName = void 0;
	  var mutationTypeName = void 0;
	  var subscriptionTypeName = void 0;
	  if (schemaDef) {
	    schemaDef.operationTypes.forEach(function (operationType) {
	      var typeName = operationType.type.name.value;
	      if (operationType.operation === 'query') {
	        if (queryTypeName) {
	          throw new Error('Must provide only one query type in schema.');
	        }
	        if (!astMap[typeName]) {
	          throw new Error('Specified query type "' + typeName + '" not found in document.');
	        }
	        queryTypeName = typeName;
	      } else if (operationType.operation === 'mutation') {
	        if (mutationTypeName) {
	          throw new Error('Must provide only one mutation type in schema.');
	        }
	        if (!astMap[typeName]) {
	          throw new Error('Specified mutation type "' + typeName + '" not found in document.');
	        }
	        mutationTypeName = typeName;
	      } else if (operationType.operation === 'subscription') {
	        if (subscriptionTypeName) {
	          throw new Error('Must provide only one subscription type in schema.');
	        }
	        if (!astMap[typeName]) {
	          throw new Error('Specified subscription type "' + typeName + '" not found in document.');
	        }
	        subscriptionTypeName = typeName;
	      }
	    });
	  } else {
	    if (astMap.Query) {
	      queryTypeName = 'Query';
	    }
	    if (astMap.Mutation) {
	      mutationTypeName = 'Mutation';
	    }
	    if (astMap.Subscription) {
	      subscriptionTypeName = 'Subscription';
	    }
	  }

	  if (!queryTypeName) {
	    throw new Error('Must provide schema definition with query type or a type named Query.');
	  }

	  var innerTypeMap = {
	    String: _scalars.GraphQLString,
	    Int: _scalars.GraphQLInt,
	    Float: _scalars.GraphQLFloat,
	    Boolean: _scalars.GraphQLBoolean,
	    ID: _scalars.GraphQLID,
	    __Schema: _introspection.__Schema,
	    __Directive: _introspection.__Directive,
	    __DirectiveLocation: _introspection.__DirectiveLocation,
	    __Type: _introspection.__Type,
	    __Field: _introspection.__Field,
	    __InputValue: _introspection.__InputValue,
	    __EnumValue: _introspection.__EnumValue,
	    __TypeKind: _introspection.__TypeKind
	  };

	  var types = typeDefs.map(function (def) {
	    return typeDefNamed(def.name.value);
	  });

	  var directives = directiveDefs.map(getDirective);

	  // If specified directives were not explicitly declared, add them.
	  if (!directives.some(function (directive) {
	    return directive.name === 'skip';
	  })) {
	    directives.push(_directives.GraphQLSkipDirective);
	  }

	  if (!directives.some(function (directive) {
	    return directive.name === 'include';
	  })) {
	    directives.push(_directives.GraphQLIncludeDirective);
	  }

	  if (!directives.some(function (directive) {
	    return directive.name === 'deprecated';
	  })) {
	    directives.push(_directives.GraphQLDeprecatedDirective);
	  }

	  return new _schema.GraphQLSchema({
	    query: getObjectType(astMap[queryTypeName]),
	    mutation: mutationTypeName ? getObjectType(astMap[mutationTypeName]) : null,
	    subscription: subscriptionTypeName ? getObjectType(astMap[subscriptionTypeName]) : null,
	    types: types,
	    directives: directives
	  });

	  function getDirective(directiveAST) {
	    return new _directives.GraphQLDirective({
	      name: directiveAST.name.value,
	      description: getDescription(directiveAST),
	      locations: directiveAST.locations.map(function (node) {
	        return node.value;
	      }),
	      args: directiveAST.arguments && makeInputValues(directiveAST.arguments)
	    });
	  }

	  function getObjectType(typeAST) {
	    var type = typeDefNamed(typeAST.name.value);
	    (0, _invariant2.default)(type instanceof _definition.GraphQLObjectType, 'AST must provide object type.');
	    return type;
	  }

	  function produceType(typeAST) {
	    var typeName = getNamedTypeAST(typeAST).name.value;
	    var typeDef = typeDefNamed(typeName);
	    return buildWrappedType(typeDef, typeAST);
	  }

	  function produceInputType(typeAST) {
	    var type = produceType(typeAST);
	    (0, _invariant2.default)((0, _definition.isInputType)(type), 'Expected Input type.');
	    return type;
	  }

	  function produceOutputType(typeAST) {
	    var type = produceType(typeAST);
	    (0, _invariant2.default)((0, _definition.isOutputType)(type), 'Expected Output type.');
	    return type;
	  }

	  function produceObjectType(typeAST) {
	    var type = produceType(typeAST);
	    (0, _invariant2.default)(type instanceof _definition.GraphQLObjectType, 'Expected Object type.');
	    return type;
	  }

	  function produceInterfaceType(typeAST) {
	    var type = produceType(typeAST);
	    (0, _invariant2.default)(type instanceof _definition.GraphQLInterfaceType, 'Expected Object type.');
	    return type;
	  }

	  function typeDefNamed(typeName) {
	    if (innerTypeMap[typeName]) {
	      return innerTypeMap[typeName];
	    }

	    if (!astMap[typeName]) {
	      throw new Error('Type "' + typeName + '" not found in document.');
	    }

	    var innerTypeDef = makeSchemaDef(astMap[typeName]);
	    if (!innerTypeDef) {
	      throw new Error('Nothing constructed for "' + typeName + '".');
	    }
	    innerTypeMap[typeName] = innerTypeDef;
	    return innerTypeDef;
	  }

	  function makeSchemaDef(def) {
	    if (!def) {
	      throw new Error('def must be defined');
	    }
	    switch (def.kind) {
	      case _kinds.OBJECT_TYPE_DEFINITION:
	        return makeTypeDef(def);
	      case _kinds.INTERFACE_TYPE_DEFINITION:
	        return makeInterfaceDef(def);
	      case _kinds.ENUM_TYPE_DEFINITION:
	        return makeEnumDef(def);
	      case _kinds.UNION_TYPE_DEFINITION:
	        return makeUnionDef(def);
	      case _kinds.SCALAR_TYPE_DEFINITION:
	        return makeScalarDef(def);
	      case _kinds.INPUT_OBJECT_TYPE_DEFINITION:
	        return makeInputObjectDef(def);
	      default:
	        throw new Error('Type kind "' + def.kind + '" not supported.');
	    }
	  }

	  function makeTypeDef(def) {
	    var typeName = def.name.value;
	    return new _definition.GraphQLObjectType({
	      name: typeName,
	      description: getDescription(def),
	      fields: function fields() {
	        return makeFieldDefMap(def);
	      },
	      interfaces: function interfaces() {
	        return makeImplementedInterfaces(def);
	      }
	    });
	  }

	  function makeFieldDefMap(def) {
	    return (0, _keyValMap2.default)(def.fields, function (field) {
	      return field.name.value;
	    }, function (field) {
	      return {
	        type: produceOutputType(field.type),
	        description: getDescription(field),
	        args: makeInputValues(field.arguments),
	        deprecationReason: getDeprecationReason(field.directives)
	      };
	    });
	  }

	  function makeImplementedInterfaces(def) {
	    return def.interfaces && def.interfaces.map(function (iface) {
	      return produceInterfaceType(iface);
	    });
	  }

	  function makeInputValues(values) {
	    return (0, _keyValMap2.default)(values, function (value) {
	      return value.name.value;
	    }, function (value) {
	      var type = produceInputType(value.type);
	      return {
	        type: type,
	        description: getDescription(value),
	        defaultValue: (0, _valueFromAST.valueFromAST)(value.defaultValue, type)
	      };
	    });
	  }

	  function makeInterfaceDef(def) {
	    var typeName = def.name.value;
	    return new _definition.GraphQLInterfaceType({
	      name: typeName,
	      description: getDescription(def),
	      fields: function fields() {
	        return makeFieldDefMap(def);
	      },
	      resolveType: cannotExecuteSchema
	    });
	  }

	  function makeEnumDef(def) {
	    var enumType = new _definition.GraphQLEnumType({
	      name: def.name.value,
	      description: getDescription(def),
	      values: (0, _keyValMap2.default)(def.values, function (enumValue) {
	        return enumValue.name.value;
	      }, function (enumValue) {
	        return {
	          description: getDescription(enumValue),
	          deprecationReason: getDeprecationReason(enumValue.directives)
	        };
	      })
	    });

	    return enumType;
	  }

	  function makeUnionDef(def) {
	    return new _definition.GraphQLUnionType({
	      name: def.name.value,
	      description: getDescription(def),
	      types: def.types.map(function (t) {
	        return produceObjectType(t);
	      }),
	      resolveType: cannotExecuteSchema
	    });
	  }

	  function makeScalarDef(def) {
	    return new _definition.GraphQLScalarType({
	      name: def.name.value,
	      description: getDescription(def),
	      serialize: function serialize() {
	        return null;
	      },
	      // Note: validation calls the parse functions to determine if a
	      // literal value is correct. Returning null would cause use of custom
	      // scalars to always fail validation. Returning false causes them to
	      // always pass validation.
	      parseValue: function parseValue() {
	        return false;
	      },
	      parseLiteral: function parseLiteral() {
	        return false;
	      }
	    });
	  }

	  function makeInputObjectDef(def) {
	    return new _definition.GraphQLInputObjectType({
	      name: def.name.value,
	      description: getDescription(def),
	      fields: function fields() {
	        return makeInputValues(def.fields);
	      }
	    });
	  }
	}

	function getDeprecationReason(directives) {
	  var deprecatedAST = directives && (0, _find2.default)(directives, function (directive) {
	    return directive.name.value === _directives.GraphQLDeprecatedDirective.name;
	  });
	  if (!deprecatedAST) {
	    return;
	  }

	  var _getArgumentValues = (0, _values.getArgumentValues)(_directives.GraphQLDeprecatedDirective.args, deprecatedAST.arguments);

	  var reason = _getArgumentValues.reason;

	  return reason;
	}

	/**
	 * Given an ast node, returns its string description based on a contiguous
	 * block full-line of comments preceding it.
	 */
	function getDescription(node) {
	  var loc = node.loc;
	  if (!loc) {
	    return;
	  }
	  var comments = [];
	  var minSpaces = void 0;
	  var token = loc.startToken.prev;
	  while (token && token.kind === _lexer.TokenKind.COMMENT && token.next && token.prev && token.line + 1 === token.next.line && token.line !== token.prev.line) {
	    var value = String(token.value);
	    var spaces = leadingSpaces(value);
	    if (minSpaces === undefined || spaces < minSpaces) {
	      minSpaces = spaces;
	    }
	    comments.push(value);
	    token = token.prev;
	  }
	  return comments.reverse().map(function (comment) {
	    return comment.slice(minSpaces);
	  }).join('\n');
	}

	/**
	 * A helper function to build a GraphQLSchema directly from a source
	 * document.
	 */
	function buildSchema(source) {
	  return buildASTSchema((0, _parser.parse)(source));
	}

	// Count the number of spaces on the starting side of a string.
	function leadingSpaces(str) {
	  var i = 0;
	  for (; i < str.length; i++) {
	    if (str[i] !== ' ') {
	      break;
	    }
	  }
	  return i;
	}

	function cannotExecuteSchema() {
	  throw new Error('Generated Schema cannot use Interface or Union types for execution.');
	}

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.extendSchema = extendSchema;

	var _invariant = __webpack_require__(19);

	var _invariant2 = _interopRequireDefault(_invariant);

	var _keyMap = __webpack_require__(57);

	var _keyMap2 = _interopRequireDefault(_keyMap);

	var _keyValMap = __webpack_require__(74);

	var _keyValMap2 = _interopRequireDefault(_keyValMap);

	var _buildASTSchema = __webpack_require__(75);

	var _valueFromAST = __webpack_require__(65);

	var _GraphQLError = __webpack_require__(9);

	var _schema = __webpack_require__(21);

	var _definition = __webpack_require__(22);

	var _directives = __webpack_require__(25);

	var _introspection = __webpack_require__(27);

	var _scalars = __webpack_require__(26);

	var _kinds = __webpack_require__(15);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Produces a new schema given an existing schema and a document which may
	 * contain GraphQL type extensions and definitions. The original schema will
	 * remain unaltered.
	 *
	 * Because a schema represents a graph of references, a schema cannot be
	 * extended without effectively making an entire copy. We do not know until it's
	 * too late if subgraphs remain unchanged.
	 *
	 * This algorithm copies the provided schema, applying extensions while
	 * producing the copy. The original schema remains unaltered.
	 */

	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	function extendSchema(schema, documentAST) {
	  (0, _invariant2.default)(schema instanceof _schema.GraphQLSchema, 'Must provide valid GraphQLSchema');

	  (0, _invariant2.default)(documentAST && documentAST.kind === _kinds.DOCUMENT, 'Must provide valid Document AST');

	  // Collect the type definitions and extensions found in the document.
	  var typeDefinitionMap = {};
	  var typeExtensionsMap = {};

	  // New directives and types are separate because a directives and types can
	  // have the same name. For example, a type named "skip".
	  var directiveDefinitions = [];

	  for (var i = 0; i < documentAST.definitions.length; i++) {
	    var def = documentAST.definitions[i];
	    switch (def.kind) {
	      case _kinds.OBJECT_TYPE_DEFINITION:
	      case _kinds.INTERFACE_TYPE_DEFINITION:
	      case _kinds.ENUM_TYPE_DEFINITION:
	      case _kinds.UNION_TYPE_DEFINITION:
	      case _kinds.SCALAR_TYPE_DEFINITION:
	      case _kinds.INPUT_OBJECT_TYPE_DEFINITION:
	        // Sanity check that none of the defined types conflict with the
	        // schema's existing types.
	        var typeName = def.name.value;
	        if (schema.getType(typeName)) {
	          throw new _GraphQLError.GraphQLError('Type "' + typeName + '" already exists in the schema. It cannot also ' + 'be defined in this type definition.', [def]);
	        }
	        typeDefinitionMap[typeName] = def;
	        break;
	      case _kinds.TYPE_EXTENSION_DEFINITION:
	        // Sanity check that this type extension exists within the
	        // schema's existing types.
	        var extendedTypeName = def.definition.name.value;
	        var existingType = schema.getType(extendedTypeName);
	        if (!existingType) {
	          throw new _GraphQLError.GraphQLError('Cannot extend type "' + extendedTypeName + '" because it does not ' + 'exist in the existing schema.', [def.definition]);
	        }
	        if (!(existingType instanceof _definition.GraphQLObjectType)) {
	          throw new _GraphQLError.GraphQLError('Cannot extend non-object type "' + extendedTypeName + '".', [def.definition]);
	        }
	        var extensions = typeExtensionsMap[extendedTypeName];
	        if (extensions) {
	          extensions.push(def);
	        } else {
	          extensions = [def];
	        }
	        typeExtensionsMap[extendedTypeName] = extensions;
	        break;
	      case _kinds.DIRECTIVE_DEFINITION:
	        var directiveName = def.name.value;
	        var existingDirective = schema.getDirective(directiveName);
	        if (existingDirective) {
	          throw new _GraphQLError.GraphQLError('Directive "' + directiveName + '" already exists in the schema. It ' + 'cannot be redefined.', [def]);
	        }
	        directiveDefinitions.push(def);
	        break;
	    }
	  }

	  // If this document contains no new types, extensions, or directives then
	  // return the same unmodified GraphQLSchema instance.
	  if (Object.keys(typeExtensionsMap).length === 0 && Object.keys(typeDefinitionMap).length === 0 && directiveDefinitions.length === 0) {
	    return schema;
	  }

	  // A cache to use to store the actual GraphQLType definition objects by name.
	  // Initialize to the GraphQL built in scalars and introspection types. All
	  // functions below are inline so that this type def cache is within the scope
	  // of the closure.
	  var typeDefCache = {
	    String: _scalars.GraphQLString,
	    Int: _scalars.GraphQLInt,
	    Float: _scalars.GraphQLFloat,
	    Boolean: _scalars.GraphQLBoolean,
	    ID: _scalars.GraphQLID,
	    __Schema: _introspection.__Schema,
	    __Directive: _introspection.__Directive,
	    __DirectiveLocation: _introspection.__DirectiveLocation,
	    __Type: _introspection.__Type,
	    __Field: _introspection.__Field,
	    __InputValue: _introspection.__InputValue,
	    __EnumValue: _introspection.__EnumValue,
	    __TypeKind: _introspection.__TypeKind
	  };

	  // Get the root Query, Mutation, and Subscription object types.
	  var queryType = getTypeFromDef(schema.getQueryType());

	  var existingMutationType = schema.getMutationType();
	  var mutationType = existingMutationType ? getTypeFromDef(existingMutationType) : null;

	  var existingSubscriptionType = schema.getSubscriptionType();
	  var subscriptionType = existingSubscriptionType ? getTypeFromDef(existingSubscriptionType) : null;

	  // Iterate through all types, getting the type definition for each, ensuring
	  // that any type not directly referenced by a field will get created.
	  var typeMap = schema.getTypeMap();
	  var types = Object.keys(typeMap).map(function (typeName) {
	    return getTypeFromDef(typeMap[typeName]);
	  });

	  // Do the same with new types, appending to the list of defined types.
	  Object.keys(typeDefinitionMap).forEach(function (typeName) {
	    types.push(getTypeFromAST(typeDefinitionMap[typeName]));
	  });

	  // Then produce and return a Schema with these types.
	  return new _schema.GraphQLSchema({
	    query: queryType,
	    mutation: mutationType,
	    subscription: subscriptionType,
	    types: types,
	    directives: getMergedDirectives()
	  });

	  // Below are functions used for producing this schema that have closed over
	  // this scope and have access to the schema, cache, and newly defined types.

	  function getMergedDirectives() {
	    var existingDirectives = schema.getDirectives();
	    (0, _invariant2.default)(existingDirectives, 'schema must have default directives');

	    var newDirectives = directiveDefinitions.map(function (directiveAST) {
	      return getDirective(directiveAST);
	    });
	    return existingDirectives.concat(newDirectives);
	  }

	  function getTypeFromDef(typeDef) {
	    var type = _getNamedType(typeDef.name);
	    (0, _invariant2.default)(type, 'Missing type from schema');
	    return type;
	  }

	  function getTypeFromAST(astNode) {
	    var type = _getNamedType(astNode.name.value);
	    if (!type) {
	      throw new _GraphQLError.GraphQLError('Unknown type: "' + astNode.name.value + '". Ensure that this type exists ' + 'either in the original schema, or is added in a type definition.', [astNode]);
	    }
	    return type;
	  }

	  function getObjectTypeFromAST(astNode) {
	    var type = getTypeFromAST(astNode);
	    (0, _invariant2.default)(type instanceof _definition.GraphQLObjectType, 'Must be Object type.');
	    return type;
	  }

	  function getInterfaceTypeFromAST(astNode) {
	    var type = getTypeFromAST(astNode);
	    (0, _invariant2.default)(type instanceof _definition.GraphQLInterfaceType, 'Must be Interface type.');
	    return type;
	  }

	  function getInputTypeFromAST(astNode) {
	    var type = getTypeFromAST(astNode);
	    (0, _invariant2.default)((0, _definition.isInputType)(type), 'Must be Input type.');
	    return type;
	  }

	  function getOutputTypeFromAST(astNode) {
	    var type = getTypeFromAST(astNode);
	    (0, _invariant2.default)((0, _definition.isOutputType)(type), 'Must be Output type.');
	    return type;
	  }

	  // Given a name, returns a type from either the existing schema or an
	  // added type.
	  function _getNamedType(typeName) {
	    var cachedTypeDef = typeDefCache[typeName];
	    if (cachedTypeDef) {
	      return cachedTypeDef;
	    }

	    var existingType = schema.getType(typeName);
	    if (existingType) {
	      var typeDef = extendType(existingType);
	      typeDefCache[typeName] = typeDef;
	      return typeDef;
	    }

	    var typeAST = typeDefinitionMap[typeName];
	    if (typeAST) {
	      var _typeDef = buildType(typeAST);
	      typeDefCache[typeName] = _typeDef;
	      return _typeDef;
	    }
	  }

	  // Given a type's introspection result, construct the correct
	  // GraphQLType instance.
	  function extendType(type) {
	    if (type instanceof _definition.GraphQLObjectType) {
	      return extendObjectType(type);
	    }
	    if (type instanceof _definition.GraphQLInterfaceType) {
	      return extendInterfaceType(type);
	    }
	    if (type instanceof _definition.GraphQLUnionType) {
	      return extendUnionType(type);
	    }
	    return type;
	  }

	  function extendObjectType(type) {
	    return new _definition.GraphQLObjectType({
	      name: type.name,
	      description: type.description,
	      interfaces: function interfaces() {
	        return extendImplementedInterfaces(type);
	      },
	      fields: function fields() {
	        return extendFieldMap(type);
	      },
	      isTypeOf: type.isTypeOf
	    });
	  }

	  function extendInterfaceType(type) {
	    return new _definition.GraphQLInterfaceType({
	      name: type.name,
	      description: type.description,
	      fields: function fields() {
	        return extendFieldMap(type);
	      },
	      resolveType: type.resolveType
	    });
	  }

	  function extendUnionType(type) {
	    return new _definition.GraphQLUnionType({
	      name: type.name,
	      description: type.description,
	      types: type.getTypes().map(getTypeFromDef),
	      resolveType: type.resolveType
	    });
	  }

	  function extendImplementedInterfaces(type) {
	    var interfaces = type.getInterfaces().map(getTypeFromDef);

	    // If there are any extensions to the interfaces, apply those here.
	    var extensions = typeExtensionsMap[type.name];
	    if (extensions) {
	      extensions.forEach(function (extension) {
	        extension.definition.interfaces.forEach(function (namedType) {
	          var interfaceName = namedType.name.value;
	          if (interfaces.some(function (def) {
	            return def.name === interfaceName;
	          })) {
	            throw new _GraphQLError.GraphQLError('Type "' + type.name + '" already implements "' + interfaceName + '". ' + 'It cannot also be implemented in this type extension.', [namedType]);
	          }
	          interfaces.push(getInterfaceTypeFromAST(namedType));
	        });
	      });
	    }

	    return interfaces;
	  }

	  function extendFieldMap(type) {
	    var newFieldMap = {};
	    var oldFieldMap = type.getFields();
	    Object.keys(oldFieldMap).forEach(function (fieldName) {
	      var field = oldFieldMap[fieldName];
	      newFieldMap[fieldName] = {
	        description: field.description,
	        deprecationReason: field.deprecationReason,
	        type: extendFieldType(field.type),
	        args: (0, _keyMap2.default)(field.args, function (arg) {
	          return arg.name;
	        }),
	        resolve: field.resolve
	      };
	    });

	    // If there are any extensions to the fields, apply those here.
	    var extensions = typeExtensionsMap[type.name];
	    if (extensions) {
	      extensions.forEach(function (extension) {
	        extension.definition.fields.forEach(function (field) {
	          var fieldName = field.name.value;
	          if (oldFieldMap[fieldName]) {
	            throw new _GraphQLError.GraphQLError('Field "' + type.name + '.' + fieldName + '" already exists in the ' + 'schema. It cannot also be defined in this type extension.', [field]);
	          }
	          newFieldMap[fieldName] = {
	            description: (0, _buildASTSchema.getDescription)(field),
	            type: buildOutputFieldType(field.type),
	            args: buildInputValues(field.arguments)
	          };
	        });
	      });
	    }

	    return newFieldMap;
	  }

	  function extendFieldType(typeDef) {
	    if (typeDef instanceof _definition.GraphQLList) {
	      return new _definition.GraphQLList(extendFieldType(typeDef.ofType));
	    }
	    if (typeDef instanceof _definition.GraphQLNonNull) {
	      return new _definition.GraphQLNonNull(extendFieldType(typeDef.ofType));
	    }
	    return getTypeFromDef(typeDef);
	  }

	  function buildType(typeAST) {
	    switch (typeAST.kind) {
	      case _kinds.OBJECT_TYPE_DEFINITION:
	        return buildObjectType(typeAST);
	      case _kinds.INTERFACE_TYPE_DEFINITION:
	        return buildInterfaceType(typeAST);
	      case _kinds.UNION_TYPE_DEFINITION:
	        return buildUnionType(typeAST);
	      case _kinds.SCALAR_TYPE_DEFINITION:
	        return buildScalarType(typeAST);
	      case _kinds.ENUM_TYPE_DEFINITION:
	        return buildEnumType(typeAST);
	      case _kinds.INPUT_OBJECT_TYPE_DEFINITION:
	        return buildInputObjectType(typeAST);
	    }
	    throw new TypeError('Unknown type kind ' + typeAST.kind);
	  }

	  function buildObjectType(typeAST) {
	    return new _definition.GraphQLObjectType({
	      name: typeAST.name.value,
	      description: (0, _buildASTSchema.getDescription)(typeAST),
	      interfaces: function interfaces() {
	        return buildImplementedInterfaces(typeAST);
	      },
	      fields: function fields() {
	        return buildFieldMap(typeAST);
	      }
	    });
	  }

	  function buildInterfaceType(typeAST) {
	    return new _definition.GraphQLInterfaceType({
	      name: typeAST.name.value,
	      description: (0, _buildASTSchema.getDescription)(typeAST),
	      fields: function fields() {
	        return buildFieldMap(typeAST);
	      },
	      resolveType: cannotExecuteExtendedSchema
	    });
	  }

	  function buildUnionType(typeAST) {
	    return new _definition.GraphQLUnionType({
	      name: typeAST.name.value,
	      description: (0, _buildASTSchema.getDescription)(typeAST),
	      types: typeAST.types.map(getObjectTypeFromAST),
	      resolveType: cannotExecuteExtendedSchema
	    });
	  }

	  function buildScalarType(typeAST) {
	    return new _definition.GraphQLScalarType({
	      name: typeAST.name.value,
	      description: (0, _buildASTSchema.getDescription)(typeAST),
	      serialize: function serialize(id) {
	        return id;
	      },
	      // Note: validation calls the parse functions to determine if a
	      // literal value is correct. Returning null would cause use of custom
	      // scalars to always fail validation. Returning false causes them to
	      // always pass validation.
	      parseValue: function parseValue() {
	        return false;
	      },
	      parseLiteral: function parseLiteral() {
	        return false;
	      }
	    });
	  }

	  function buildEnumType(typeAST) {
	    return new _definition.GraphQLEnumType({
	      name: typeAST.name.value,
	      description: (0, _buildASTSchema.getDescription)(typeAST),
	      values: (0, _keyValMap2.default)(typeAST.values, function (v) {
	        return v.name.value;
	      }, function () {
	        return {};
	      })
	    });
	  }

	  function buildInputObjectType(typeAST) {
	    return new _definition.GraphQLInputObjectType({
	      name: typeAST.name.value,
	      description: (0, _buildASTSchema.getDescription)(typeAST),
	      fields: function fields() {
	        return buildInputValues(typeAST.fields);
	      }
	    });
	  }

	  function getDirective(directiveAST) {
	    return new _directives.GraphQLDirective({
	      name: directiveAST.name.value,
	      locations: directiveAST.locations.map(function (node) {
	        return node.value;
	      }),
	      args: directiveAST.arguments && buildInputValues(directiveAST.arguments)
	    });
	  }

	  function buildImplementedInterfaces(typeAST) {
	    return typeAST.interfaces && typeAST.interfaces.map(getInterfaceTypeFromAST);
	  }

	  function buildFieldMap(typeAST) {
	    return (0, _keyValMap2.default)(typeAST.fields, function (field) {
	      return field.name.value;
	    }, function (field) {
	      return {
	        type: buildOutputFieldType(field.type),
	        description: (0, _buildASTSchema.getDescription)(field),
	        args: buildInputValues(field.arguments)
	      };
	    });
	  }

	  function buildInputValues(values) {
	    return (0, _keyValMap2.default)(values, function (value) {
	      return value.name.value;
	    }, function (value) {
	      var type = buildInputFieldType(value.type);
	      return {
	        type: type,
	        description: (0, _buildASTSchema.getDescription)(value),
	        defaultValue: (0, _valueFromAST.valueFromAST)(value.defaultValue, type)
	      };
	    });
	  }

	  function buildInputFieldType(typeAST) {
	    if (typeAST.kind === _kinds.LIST_TYPE) {
	      return new _definition.GraphQLList(buildInputFieldType(typeAST.type));
	    }
	    if (typeAST.kind === _kinds.NON_NULL_TYPE) {
	      var nullableType = buildInputFieldType(typeAST.type);
	      (0, _invariant2.default)(!(nullableType instanceof _definition.GraphQLNonNull), 'Must be nullable');
	      return new _definition.GraphQLNonNull(nullableType);
	    }
	    return getInputTypeFromAST(typeAST);
	  }

	  function buildOutputFieldType(typeAST) {
	    if (typeAST.kind === _kinds.LIST_TYPE) {
	      return new _definition.GraphQLList(buildOutputFieldType(typeAST.type));
	    }
	    if (typeAST.kind === _kinds.NON_NULL_TYPE) {
	      var nullableType = buildOutputFieldType(typeAST.type);
	      (0, _invariant2.default)(!(nullableType instanceof _definition.GraphQLNonNull), 'Must be nullable');
	      return new _definition.GraphQLNonNull(nullableType);
	    }
	    return getOutputTypeFromAST(typeAST);
	  }
	}

	function cannotExecuteExtendedSchema() {
	  throw new Error('Extended Schema cannot use Interface or Union types for execution.');
	}

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.printSchema = printSchema;
	exports.printIntrospectionSchema = printIntrospectionSchema;

	var _invariant = __webpack_require__(19);

	var _invariant2 = _interopRequireDefault(_invariant);

	var _isNullish = __webpack_require__(23);

	var _isNullish2 = _interopRequireDefault(_isNullish);

	var _astFromValue = __webpack_require__(28);

	var _printer = __webpack_require__(13);

	var _definition = __webpack_require__(22);

	var _scalars = __webpack_require__(26);

	var _directives = __webpack_require__(25);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function printSchema(schema) {
	  return printFilteredSchema(schema, function (n) {
	    return !isSpecDirective(n);
	  }, isDefinedType);
	}
	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	function printIntrospectionSchema(schema) {
	  return printFilteredSchema(schema, isSpecDirective, isIntrospectionType);
	}

	function isSpecDirective(directiveName) {
	  return directiveName === 'skip' || directiveName === 'include' || directiveName === 'deprecated';
	}

	function isDefinedType(typename) {
	  return !isIntrospectionType(typename) && !isBuiltInScalar(typename);
	}

	function isIntrospectionType(typename) {
	  return typename.indexOf('__') === 0;
	}

	function isBuiltInScalar(typename) {
	  return typename === 'String' || typename === 'Boolean' || typename === 'Int' || typename === 'Float' || typename === 'ID';
	}

	function printFilteredSchema(schema, directiveFilter, typeFilter) {
	  var directives = schema.getDirectives().filter(function (directive) {
	    return directiveFilter(directive.name);
	  });
	  var typeMap = schema.getTypeMap();
	  var types = Object.keys(typeMap).filter(typeFilter).sort(function (name1, name2) {
	    return name1.localeCompare(name2);
	  }).map(function (typeName) {
	    return typeMap[typeName];
	  });

	  return [printSchemaDefinition(schema)].concat(directives.map(printDirective), types.map(printType)).filter(Boolean).join('\n\n') + '\n';
	}

	function printSchemaDefinition(schema) {
	  if (isSchemaOfCommonNames(schema)) {
	    return;
	  }

	  var operationTypes = [];

	  var queryType = schema.getQueryType();
	  if (queryType) {
	    operationTypes.push('  query: ' + queryType.name);
	  }

	  var mutationType = schema.getMutationType();
	  if (mutationType) {
	    operationTypes.push('  mutation: ' + mutationType.name);
	  }

	  var subscriptionType = schema.getSubscriptionType();
	  if (subscriptionType) {
	    operationTypes.push('  subscription: ' + subscriptionType.name);
	  }

	  return 'schema {\n' + operationTypes.join('\n') + '\n}';
	}

	/**
	 * GraphQL schema define root types for each type of operation. These types are
	 * the same as any other type and can be named in any manner, however there is
	 * a common naming convention:
	 *
	 *   schema {
	 *     query: Query
	 *     mutation: Mutation
	 *   }
	 *
	 * When using this naming convention, the schema description can be omitted.
	 */
	function isSchemaOfCommonNames(schema) {
	  var queryType = schema.getQueryType();
	  if (queryType && queryType.name !== 'Query') {
	    return false;
	  }

	  var mutationType = schema.getMutationType();
	  if (mutationType && mutationType.name !== 'Mutation') {
	    return false;
	  }

	  var subscriptionType = schema.getSubscriptionType();
	  if (subscriptionType && subscriptionType.name !== 'Subscription') {
	    return false;
	  }

	  return true;
	}

	function printType(type) {
	  if (type instanceof _definition.GraphQLScalarType) {
	    return printScalar(type);
	  } else if (type instanceof _definition.GraphQLObjectType) {
	    return printObject(type);
	  } else if (type instanceof _definition.GraphQLInterfaceType) {
	    return printInterface(type);
	  } else if (type instanceof _definition.GraphQLUnionType) {
	    return printUnion(type);
	  } else if (type instanceof _definition.GraphQLEnumType) {
	    return printEnum(type);
	  }
	  (0, _invariant2.default)(type instanceof _definition.GraphQLInputObjectType);
	  return printInputObject(type);
	}

	function printScalar(type) {
	  return printDescription(type) + ('scalar ' + type.name);
	}

	function printObject(type) {
	  var interfaces = type.getInterfaces();
	  var implementedInterfaces = interfaces.length ? ' implements ' + interfaces.map(function (i) {
	    return i.name;
	  }).join(', ') : '';
	  return printDescription(type) + ('type ' + type.name + implementedInterfaces + ' {\n') + printFields(type) + '\n' + '}';
	}

	function printInterface(type) {
	  return printDescription(type) + ('interface ' + type.name + ' {\n') + printFields(type) + '\n' + '}';
	}

	function printUnion(type) {
	  return printDescription(type) + ('union ' + type.name + ' = ' + type.getTypes().join(' | '));
	}

	function printEnum(type) {
	  return printDescription(type) + ('enum ' + type.name + ' {\n') + printEnumValues(type.getValues()) + '\n' + '}';
	}

	function printEnumValues(values) {
	  return values.map(function (value, i) {
	    return printDescription(value, '  ', !i) + '  ' + value.name + printDeprecated(value);
	  }).join('\n');
	}

	function printInputObject(type) {
	  var fieldMap = type.getFields();
	  var fields = Object.keys(fieldMap).map(function (fieldName) {
	    return fieldMap[fieldName];
	  });
	  return printDescription(type) + ('input ' + type.name + ' {\n') + fields.map(function (f, i) {
	    return printDescription(f, '  ', !i) + '  ' + printInputValue(f);
	  }).join('\n') + '\n' + '}';
	}

	function printFields(type) {
	  var fieldMap = type.getFields();
	  var fields = Object.keys(fieldMap).map(function (fieldName) {
	    return fieldMap[fieldName];
	  });
	  return fields.map(function (f, i) {
	    return printDescription(f, '  ', !i) + '  ' + f.name + printArgs(f.args, '  ') + ': ' + String(f.type) + printDeprecated(f);
	  }).join('\n');
	}

	function printArgs(args) {
	  var indentation = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];

	  if (args.length === 0) {
	    return '';
	  }

	  // If every arg does not have a description, print them on one line.
	  if (args.every(function (arg) {
	    return !arg.description;
	  })) {
	    return '(' + args.map(printInputValue).join(', ') + ')';
	  }

	  return '(\n' + args.map(function (arg, i) {
	    return printDescription(arg, '  ' + indentation, !i) + '  ' + indentation + printInputValue(arg);
	  }).join('\n') + '\n' + indentation + ')';
	}

	function printInputValue(arg) {
	  var argDecl = arg.name + ': ' + String(arg.type);
	  if (!(0, _isNullish2.default)(arg.defaultValue)) {
	    argDecl += ' = ' + (0, _printer.print)((0, _astFromValue.astFromValue)(arg.defaultValue, arg.type));
	  }
	  return argDecl;
	}

	function printDirective(directive) {
	  return printDescription(directive) + 'directive @' + directive.name + printArgs(directive.args) + ' on ' + directive.locations.join(' | ');
	}

	function printDeprecated(fieldOrEnumVal) {
	  var reason = fieldOrEnumVal.deprecationReason;
	  if ((0, _isNullish2.default)(reason)) {
	    return '';
	  }
	  if (reason === '' || reason === _directives.DEFAULT_DEPRECATION_REASON) {
	    return ' @deprecated';
	  }
	  return ' @deprecated(reason: ' + (0, _printer.print)((0, _astFromValue.astFromValue)(reason, _scalars.GraphQLString)) + ')';
	}

	function printDescription(def) {
	  var indentation = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];
	  var firstInBlock = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];

	  if (!def.description) {
	    return '';
	  }
	  var lines = def.description.split('\n');
	  var description = indentation && !firstInBlock ? '\n' : '';
	  for (var i = 0; i < lines.length; i++) {
	    if (lines[i] === '') {
	      description += indentation + '#\n';
	    } else {
	      // For > 120 character long lines, cut at space boundaries into sublines
	      // of ~80 chars.
	      var sublines = breakLine(lines[i], 120 - indentation.length);
	      for (var j = 0; j < sublines.length; j++) {
	        description += indentation + '# ' + sublines[j] + '\n';
	      }
	    }
	  }
	  return description;
	}

	function breakLine(line, len) {
	  if (line.length < len + 5) {
	    return [line];
	  }
	  var parts = line.split(new RegExp('((?: |^).{15,' + (len - 40) + '}(?= |$))'));
	  if (parts.length < 4) {
	    return [line];
	  }
	  var sublines = [parts[0] + parts[1] + parts[2]];
	  for (var i = 3; i < parts.length; i += 2) {
	    sublines.push(parts[i].slice(1) + parts[i + 1]);
	  }
	  return sublines;
	}

/***/ },
/* 78 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.concatAST = concatAST;


	/**
	 * Provided a collection of ASTs, presumably each from different files,
	 * concatenate the ASTs together into batched AST, useful for validating many
	 * GraphQL source files which together represent one conceptual application.
	 */
	function concatAST(asts) {
	  var batchDefinitions = [];
	  for (var i = 0; i < asts.length; i++) {
	    var definitions = asts[i].definitions;
	    for (var j = 0; j < definitions.length; j++) {
	      batchDefinitions.push(definitions[j]);
	    }
	  }
	  return {
	    kind: 'Document',
	    definitions: batchDefinitions
	  };
	}
	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.separateOperations = separateOperations;

	var _visitor = __webpack_require__(14);

	/**
	 * separateOperations accepts a single AST document which may contain many
	 * operations and fragments and returns a collection of AST documents each of
	 * which contains a single operation as well the fragment definitions it
	 * refers to.
	 */
	function separateOperations(documentAST) {

	  var operations = [];
	  var depGraph = Object.create(null);
	  var fromName = void 0;

	  // Populate the list of operations and build a dependency graph.
	  (0, _visitor.visit)(documentAST, {
	    OperationDefinition: function OperationDefinition(node) {
	      operations.push(node);
	      fromName = opName(node);
	    },
	    FragmentDefinition: function FragmentDefinition(node) {
	      fromName = node.name.value;
	    },
	    FragmentSpread: function FragmentSpread(node) {
	      var toName = node.name.value;
	      (depGraph[fromName] || (depGraph[fromName] = Object.create(null)))[toName] = true;
	    }
	  });

	  // For each operation, produce a new synthesized AST which includes only what
	  // is necessary for completing that operation.
	  var separatedDocumentASTs = Object.create(null);
	  operations.forEach(function (operation) {
	    var operationName = opName(operation);
	    var dependencies = Object.create(null);
	    collectTransitiveDependencies(dependencies, depGraph, operationName);

	    separatedDocumentASTs[operationName] = {
	      kind: 'Document',
	      definitions: documentAST.definitions.filter(function (def) {
	        return def === operation || def.kind === 'FragmentDefinition' && dependencies[def.name.value];
	      })
	    };
	  });

	  return separatedDocumentASTs;
	}
	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	// Provides the empty string for anonymous operations.
	function opName(operation) {
	  return operation.name ? operation.name.value : '';
	}

	// From a dependency graph, collects a list of transitive dependencies by
	// recursing through a dependency graph.
	function collectTransitiveDependencies(collected, depGraph, fromName) {
	  var immediateDeps = depGraph[fromName];
	  if (immediateDeps) {
	    Object.keys(immediateDeps).forEach(function (toName) {
	      if (!collected[toName]) {
	        collected[toName] = true;
	        collectTransitiveDependencies(collected, depGraph, toName);
	      }
	    });
	  }
	}

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.BreakingChangeType = undefined;
	exports.findBreakingChanges = findBreakingChanges;
	exports.findRemovedTypes = findRemovedTypes;
	exports.findTypesThatChangedKind = findTypesThatChangedKind;
	exports.findFieldsThatChangedType = findFieldsThatChangedType;
	exports.findTypesRemovedFromUnions = findTypesRemovedFromUnions;
	exports.findValuesRemovedFromEnums = findValuesRemovedFromEnums;

	var _definition = __webpack_require__(22);

	var _schema = __webpack_require__(21);

	/**
	 *  Copyright (c) 2016, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	var BreakingChangeType = exports.BreakingChangeType = {
	  FIELD_CHANGED_KIND: 'FIELD_CHANGED_KIND',
	  FIELD_REMOVED: 'FIELD_REMOVED',
	  TYPE_CHANGED_KIND: 'TYPE_CHANGED_KIND',
	  TYPE_REMOVED: 'TYPE_REMOVED',
	  TYPE_REMOVED_FROM_UNION: 'TYPE_REMOVED_FROM_UNION',
	  VALUE_REMOVED_FROM_ENUM: 'VALUE_REMOVED_FROM_ENUM'
	};

	/**
	 * Given two schemas, returns an Array containing descriptions of all the types
	 * of breaking changes covered by the other functions down below.
	 */
	function findBreakingChanges(oldSchema, newSchema) {
	  return [].concat(findRemovedTypes(oldSchema, newSchema), findTypesThatChangedKind(oldSchema, newSchema), findFieldsThatChangedType(oldSchema, newSchema), findTypesRemovedFromUnions(oldSchema, newSchema), findValuesRemovedFromEnums(oldSchema, newSchema));
	}

	/**
	 * Given two schemas, returns an Array containing descriptions of any breaking
	 * changes in the newSchema related to removing an entire type.
	 */
	function findRemovedTypes(oldSchema, newSchema) {
	  var oldTypeMap = oldSchema.getTypeMap();
	  var newTypeMap = newSchema.getTypeMap();

	  var breakingChanges = [];
	  Object.keys(oldTypeMap).forEach(function (typeName) {
	    if (!newTypeMap[typeName]) {
	      breakingChanges.push({
	        type: BreakingChangeType.TYPE_REMOVED,
	        description: typeName + ' was removed.'
	      });
	    }
	  });
	  return breakingChanges;
	}

	/**
	 * Given two schemas, returns an Array containing descriptions of any breaking
	 * changes in the newSchema related to changing the type of a type.
	 */
	function findTypesThatChangedKind(oldSchema, newSchema) {
	  var oldTypeMap = oldSchema.getTypeMap();
	  var newTypeMap = newSchema.getTypeMap();

	  var breakingChanges = [];
	  Object.keys(oldTypeMap).forEach(function (typeName) {
	    if (!newTypeMap[typeName]) {
	      return;
	    }
	    var oldType = oldTypeMap[typeName];
	    var newType = newTypeMap[typeName];
	    if (!(oldType instanceof newType.constructor)) {
	      breakingChanges.push({
	        type: BreakingChangeType.TYPE_CHANGED_KIND,
	        description: typeName + ' changed from ' + (typeKindName(oldType) + ' to ' + typeKindName(newType) + '.')
	      });
	    }
	  });
	  return breakingChanges;
	}

	function typeKindName(type) {
	  if (type instanceof _definition.GraphQLScalarType) {
	    return 'a Scalar type';
	  }
	  if (type instanceof _definition.GraphQLObjectType) {
	    return 'an Object type';
	  }
	  if (type instanceof _definition.GraphQLInterfaceType) {
	    return 'an Interface type';
	  }
	  if (type instanceof _definition.GraphQLUnionType) {
	    return 'a Union type';
	  }
	  if (type instanceof _definition.GraphQLEnumType) {
	    return 'an Enum type';
	  }
	  if (type instanceof _definition.GraphQLInputObjectType) {
	    return 'an Input type';
	  }
	  throw new TypeError('Unknown type ' + type.constructor.name);
	}

	/**
	 * Given two schemas, returns an Array containing descriptions of any breaking
	 * changes in the newSchema related to the fields on a type. This includes if
	 * a field has been removed from a type or if a field has changed type.
	 */
	function findFieldsThatChangedType(oldSchema, newSchema) {
	  var oldTypeMap = oldSchema.getTypeMap();
	  var newTypeMap = newSchema.getTypeMap();

	  var breakingFieldChanges = [];
	  Object.keys(oldTypeMap).forEach(function (typeName) {
	    var oldType = oldTypeMap[typeName];
	    var newType = newTypeMap[typeName];
	    if (!(oldType instanceof _definition.GraphQLObjectType || oldType instanceof _definition.GraphQLInterfaceType || oldType instanceof _definition.GraphQLInputObjectType) || !(newType instanceof oldType.constructor)) {
	      return;
	    }

	    var oldTypeFieldsDef = oldType.getFields();
	    var newTypeFieldsDef = newType.getFields();
	    Object.keys(oldTypeFieldsDef).forEach(function (fieldName) {
	      // Check if the field is missing on the type in the new schema.
	      if (!(fieldName in newTypeFieldsDef)) {
	        breakingFieldChanges.push({
	          type: BreakingChangeType.FIELD_REMOVED,
	          description: typeName + '.' + fieldName + ' was removed.'
	        });
	      } else {
	        // Check if the field's type has changed in the new schema.
	        var oldFieldType = (0, _definition.getNamedType)(oldTypeFieldsDef[fieldName].type);
	        var newFieldType = (0, _definition.getNamedType)(newTypeFieldsDef[fieldName].type);
	        if (oldFieldType && newFieldType && oldFieldType.name !== newFieldType.name) {
	          breakingFieldChanges.push({
	            type: BreakingChangeType.FIELD_CHANGED_KIND,
	            description: typeName + '.' + fieldName + ' changed type from ' + (oldFieldType.name + ' to ' + newFieldType.name + '.')
	          });
	        }
	      }
	    });
	  });
	  return breakingFieldChanges;
	}

	/**
	 * Given two schemas, returns an Array containing descriptions of any breaking
	 * changes in the newSchema related to removing types from a union type.
	 */
	function findTypesRemovedFromUnions(oldSchema, newSchema) {
	  var oldTypeMap = oldSchema.getTypeMap();
	  var newTypeMap = newSchema.getTypeMap();

	  var typesRemovedFromUnion = [];
	  Object.keys(oldTypeMap).forEach(function (typeName) {
	    var oldType = oldTypeMap[typeName];
	    var newType = newTypeMap[typeName];
	    if (!(oldType instanceof _definition.GraphQLUnionType) || !(newType instanceof _definition.GraphQLUnionType)) {
	      return;
	    }
	    var typeNamesInNewUnion = Object.create(null);
	    newType.getTypes().forEach(function (type) {
	      typeNamesInNewUnion[type.name] = true;
	    });
	    oldType.getTypes().forEach(function (type) {
	      if (!typeNamesInNewUnion[type.name]) {
	        typesRemovedFromUnion.push({
	          type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,
	          description: type.name + ' was removed from union type ' + typeName + '.'
	        });
	      }
	    });
	  });
	  return typesRemovedFromUnion;
	}

	/**
	 * Given two schemas, returns an Array containing descriptions of any breaking
	 * changes in the newSchema related to removing values from an enum type.
	 */
	function findValuesRemovedFromEnums(oldSchema, newSchema) {
	  var oldTypeMap = oldSchema.getTypeMap();
	  var newTypeMap = newSchema.getTypeMap();

	  var valuesRemovedFromEnums = [];
	  Object.keys(oldTypeMap).forEach(function (typeName) {
	    var oldType = oldTypeMap[typeName];
	    var newType = newTypeMap[typeName];
	    if (!(oldType instanceof _definition.GraphQLEnumType) || !(newType instanceof _definition.GraphQLEnumType)) {
	      return;
	    }
	    var valuesInNewEnum = Object.create(null);
	    newType.getValues().forEach(function (value) {
	      valuesInNewEnum[value.name] = true;
	    });
	    oldType.getValues().forEach(function (value) {
	      if (!valuesInNewEnum[value.name]) {
	        valuesRemovedFromEnums.push({
	          type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,
	          description: value.name + ' was removed from enum type ' + typeName + '.'
	        });
	      }
	    });
	  });
	  return valuesRemovedFromEnums;
	}

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module) {/**
	 * @license
	 * lodash <https://lodash.com/>
	 * Copyright JS Foundation and other contributors <https://js.foundation/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */
	;(function() {

	  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
	  var undefined;

	  /** Used as the semantic version number. */
	  var VERSION = '4.16.6';

	  /** Used as the size to enable large array optimizations. */
	  var LARGE_ARRAY_SIZE = 200;

	  /** Error message constants. */
	  var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://github.com/es-shims.',
	      FUNC_ERROR_TEXT = 'Expected a function';

	  /** Used to stand-in for `undefined` hash values. */
	  var HASH_UNDEFINED = '__lodash_hash_undefined__';

	  /** Used as the maximum memoize cache size. */
	  var MAX_MEMOIZE_SIZE = 500;

	  /** Used as the internal argument placeholder. */
	  var PLACEHOLDER = '__lodash_placeholder__';

	  /** Used to compose bitmasks for function metadata. */
	  var BIND_FLAG = 1,
	      BIND_KEY_FLAG = 2,
	      CURRY_BOUND_FLAG = 4,
	      CURRY_FLAG = 8,
	      CURRY_RIGHT_FLAG = 16,
	      PARTIAL_FLAG = 32,
	      PARTIAL_RIGHT_FLAG = 64,
	      ARY_FLAG = 128,
	      REARG_FLAG = 256,
	      FLIP_FLAG = 512;

	  /** Used to compose bitmasks for comparison styles. */
	  var UNORDERED_COMPARE_FLAG = 1,
	      PARTIAL_COMPARE_FLAG = 2;

	  /** Used as default options for `_.truncate`. */
	  var DEFAULT_TRUNC_LENGTH = 30,
	      DEFAULT_TRUNC_OMISSION = '...';

	  /** Used to detect hot functions by number of calls within a span of milliseconds. */
	  var HOT_COUNT = 800,
	      HOT_SPAN = 16;

	  /** Used to indicate the type of lazy iteratees. */
	  var LAZY_FILTER_FLAG = 1,
	      LAZY_MAP_FLAG = 2,
	      LAZY_WHILE_FLAG = 3;

	  /** Used as references for various `Number` constants. */
	  var INFINITY = 1 / 0,
	      MAX_SAFE_INTEGER = 9007199254740991,
	      MAX_INTEGER = 1.7976931348623157e+308,
	      NAN = 0 / 0;

	  /** Used as references for the maximum length and index of an array. */
	  var MAX_ARRAY_LENGTH = 4294967295,
	      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
	      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

	  /** Used to associate wrap methods with their bit flags. */
	  var wrapFlags = [
	    ['ary', ARY_FLAG],
	    ['bind', BIND_FLAG],
	    ['bindKey', BIND_KEY_FLAG],
	    ['curry', CURRY_FLAG],
	    ['curryRight', CURRY_RIGHT_FLAG],
	    ['flip', FLIP_FLAG],
	    ['partial', PARTIAL_FLAG],
	    ['partialRight', PARTIAL_RIGHT_FLAG],
	    ['rearg', REARG_FLAG]
	  ];

	  /** `Object#toString` result references. */
	  var argsTag = '[object Arguments]',
	      arrayTag = '[object Array]',
	      asyncTag = '[object AsyncFunction]',
	      boolTag = '[object Boolean]',
	      dateTag = '[object Date]',
	      domExcTag = '[object DOMException]',
	      errorTag = '[object Error]',
	      funcTag = '[object Function]',
	      genTag = '[object GeneratorFunction]',
	      mapTag = '[object Map]',
	      numberTag = '[object Number]',
	      nullTag = '[object Null]',
	      objectTag = '[object Object]',
	      promiseTag = '[object Promise]',
	      proxyTag = '[object Proxy]',
	      regexpTag = '[object RegExp]',
	      setTag = '[object Set]',
	      stringTag = '[object String]',
	      symbolTag = '[object Symbol]',
	      undefinedTag = '[object Undefined]',
	      weakMapTag = '[object WeakMap]',
	      weakSetTag = '[object WeakSet]';

	  var arrayBufferTag = '[object ArrayBuffer]',
	      dataViewTag = '[object DataView]',
	      float32Tag = '[object Float32Array]',
	      float64Tag = '[object Float64Array]',
	      int8Tag = '[object Int8Array]',
	      int16Tag = '[object Int16Array]',
	      int32Tag = '[object Int32Array]',
	      uint8Tag = '[object Uint8Array]',
	      uint8ClampedTag = '[object Uint8ClampedArray]',
	      uint16Tag = '[object Uint16Array]',
	      uint32Tag = '[object Uint32Array]';

	  /** Used to match empty string literals in compiled template source. */
	  var reEmptyStringLeading = /\b__p \+= '';/g,
	      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
	      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

	  /** Used to match HTML entities and HTML characters. */
	  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
	      reUnescapedHtml = /[&<>"']/g,
	      reHasEscapedHtml = RegExp(reEscapedHtml.source),
	      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

	  /** Used to match template delimiters. */
	  var reEscape = /<%-([\s\S]+?)%>/g,
	      reEvaluate = /<%([\s\S]+?)%>/g,
	      reInterpolate = /<%=([\s\S]+?)%>/g;

	  /** Used to match property names within property paths. */
	  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
	      reIsPlainProp = /^\w*$/,
	      reLeadingDot = /^\./,
	      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

	  /**
	   * Used to match `RegExp`
	   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	   */
	  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
	      reHasRegExpChar = RegExp(reRegExpChar.source);

	  /** Used to match leading and trailing whitespace. */
	  var reTrim = /^\s+|\s+$/g,
	      reTrimStart = /^\s+/,
	      reTrimEnd = /\s+$/;

	  /** Used to match wrap detail comments. */
	  var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
	      reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
	      reSplitDetails = /,? & /;

	  /** Used to match words composed of alphanumeric characters. */
	  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

	  /** Used to match backslashes in property paths. */
	  var reEscapeChar = /\\(\\)?/g;

	  /**
	   * Used to match
	   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
	   */
	  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

	  /** Used to match `RegExp` flags from their coerced string values. */
	  var reFlags = /\w*$/;

	  /** Used to detect bad signed hexadecimal string values. */
	  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

	  /** Used to detect binary string values. */
	  var reIsBinary = /^0b[01]+$/i;

	  /** Used to detect host constructors (Safari). */
	  var reIsHostCtor = /^\[object .+?Constructor\]$/;

	  /** Used to detect octal string values. */
	  var reIsOctal = /^0o[0-7]+$/i;

	  /** Used to detect unsigned integer values. */
	  var reIsUint = /^(?:0|[1-9]\d*)$/;

	  /** Used to match Latin Unicode letters (excluding mathematical operators). */
	  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

	  /** Used to ensure capturing order of template delimiters. */
	  var reNoMatch = /($^)/;

	  /** Used to match unescaped characters in compiled string literals. */
	  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

	  /** Used to compose unicode character classes. */
	  var rsAstralRange = '\\ud800-\\udfff',
	      rsComboMarksRange = '\\u0300-\\u036f\\ufe20-\\ufe23',
	      rsComboSymbolsRange = '\\u20d0-\\u20f0',
	      rsDingbatRange = '\\u2700-\\u27bf',
	      rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
	      rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
	      rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
	      rsPunctuationRange = '\\u2000-\\u206f',
	      rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
	      rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
	      rsVarRange = '\\ufe0e\\ufe0f',
	      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

	  /** Used to compose unicode capture groups. */
	  var rsApos = "['\u2019]",
	      rsAstral = '[' + rsAstralRange + ']',
	      rsBreak = '[' + rsBreakRange + ']',
	      rsCombo = '[' + rsComboMarksRange + rsComboSymbolsRange + ']',
	      rsDigits = '\\d+',
	      rsDingbat = '[' + rsDingbatRange + ']',
	      rsLower = '[' + rsLowerRange + ']',
	      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
	      rsFitz = '\\ud83c[\\udffb-\\udfff]',
	      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
	      rsNonAstral = '[^' + rsAstralRange + ']',
	      rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
	      rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
	      rsUpper = '[' + rsUpperRange + ']',
	      rsZWJ = '\\u200d';

	  /** Used to compose unicode regexes. */
	  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
	      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
	      rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
	      rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
	      reOptMod = rsModifier + '?',
	      rsOptVar = '[' + rsVarRange + ']?',
	      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
	      rsOrdLower = '\\d*(?:(?:1st|2nd|3rd|(?![123])\\dth)\\b)',
	      rsOrdUpper = '\\d*(?:(?:1ST|2ND|3RD|(?![123])\\dTH)\\b)',
	      rsSeq = rsOptVar + reOptMod + rsOptJoin,
	      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
	      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

	  /** Used to match apostrophes. */
	  var reApos = RegExp(rsApos, 'g');

	  /**
	   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
	   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
	   */
	  var reComboMark = RegExp(rsCombo, 'g');

	  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
	  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

	  /** Used to match complex or compound words. */
	  var reUnicodeWord = RegExp([
	    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
	    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
	    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
	    rsUpper + '+' + rsOptContrUpper,
	    rsOrdUpper,
	    rsOrdLower,
	    rsDigits,
	    rsEmoji
	  ].join('|'), 'g');

	  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
	  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + ']');

	  /** Used to detect strings that need a more robust regexp to match words. */
	  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

	  /** Used to assign default `context` object properties. */
	  var contextProps = [
	    'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',
	    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',
	    'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',
	    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
	    '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'
	  ];

	  /** Used to make template sourceURLs easier to identify. */
	  var templateCounter = -1;

	  /** Used to identify `toStringTag` values of typed arrays. */
	  var typedArrayTags = {};
	  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	  typedArrayTags[uint32Tag] = true;
	  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
	  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
	  typedArrayTags[errorTag] = typedArrayTags[funcTag] =
	  typedArrayTags[mapTag] = typedArrayTags[numberTag] =
	  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
	  typedArrayTags[setTag] = typedArrayTags[stringTag] =
	  typedArrayTags[weakMapTag] = false;

	  /** Used to identify `toStringTag` values supported by `_.clone`. */
	  var cloneableTags = {};
	  cloneableTags[argsTag] = cloneableTags[arrayTag] =
	  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
	  cloneableTags[boolTag] = cloneableTags[dateTag] =
	  cloneableTags[float32Tag] = cloneableTags[float64Tag] =
	  cloneableTags[int8Tag] = cloneableTags[int16Tag] =
	  cloneableTags[int32Tag] = cloneableTags[mapTag] =
	  cloneableTags[numberTag] = cloneableTags[objectTag] =
	  cloneableTags[regexpTag] = cloneableTags[setTag] =
	  cloneableTags[stringTag] = cloneableTags[symbolTag] =
	  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
	  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
	  cloneableTags[errorTag] = cloneableTags[funcTag] =
	  cloneableTags[weakMapTag] = false;

	  /** Used to map Latin Unicode letters to basic Latin letters. */
	  var deburredLetters = {
	    // Latin-1 Supplement block.
	    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
	    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
	    '\xc7': 'C',  '\xe7': 'c',
	    '\xd0': 'D',  '\xf0': 'd',
	    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
	    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
	    '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
	    '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
	    '\xd1': 'N',  '\xf1': 'n',
	    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
	    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
	    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
	    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
	    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
	    '\xc6': 'Ae', '\xe6': 'ae',
	    '\xde': 'Th', '\xfe': 'th',
	    '\xdf': 'ss',
	    // Latin Extended-A block.
	    '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
	    '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
	    '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
	    '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
	    '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
	    '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
	    '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
	    '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
	    '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
	    '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
	    '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
	    '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
	    '\u0134': 'J',  '\u0135': 'j',
	    '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
	    '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
	    '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
	    '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
	    '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
	    '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
	    '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
	    '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
	    '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
	    '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
	    '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
	    '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
	    '\u0163': 't',  '\u0165': 't', '\u0167': 't',
	    '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
	    '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
	    '\u0174': 'W',  '\u0175': 'w',
	    '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
	    '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
	    '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
	    '\u0132': 'IJ', '\u0133': 'ij',
	    '\u0152': 'Oe', '\u0153': 'oe',
	    '\u0149': "'n", '\u017f': 's'
	  };

	  /** Used to map characters to HTML entities. */
	  var htmlEscapes = {
	    '&': '&amp;',
	    '<': '&lt;',
	    '>': '&gt;',
	    '"': '&quot;',
	    "'": '&#39;'
	  };

	  /** Used to map HTML entities to characters. */
	  var htmlUnescapes = {
	    '&amp;': '&',
	    '&lt;': '<',
	    '&gt;': '>',
	    '&quot;': '"',
	    '&#39;': "'"
	  };

	  /** Used to escape characters for inclusion in compiled string literals. */
	  var stringEscapes = {
	    '\\': '\\',
	    "'": "'",
	    '\n': 'n',
	    '\r': 'r',
	    '\u2028': 'u2028',
	    '\u2029': 'u2029'
	  };

	  /** Built-in method references without a dependency on `root`. */
	  var freeParseFloat = parseFloat,
	      freeParseInt = parseInt;

	  /** Detect free variable `global` from Node.js. */
	  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

	  /** Detect free variable `self`. */
	  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	  /** Used as a reference to the global object. */
	  var root = freeGlobal || freeSelf || Function('return this')();

	  /** Detect free variable `exports`. */
	  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

	  /** Detect free variable `module`. */
	  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

	  /** Detect the popular CommonJS extension `module.exports`. */
	  var moduleExports = freeModule && freeModule.exports === freeExports;

	  /** Detect free variable `process` from Node.js. */
	  var freeProcess = moduleExports && freeGlobal.process;

	  /** Used to access faster Node.js helpers. */
	  var nodeUtil = (function() {
	    try {
	      return freeProcess && freeProcess.binding('util');
	    } catch (e) {}
	  }());

	  /* Node.js helper references. */
	  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
	      nodeIsDate = nodeUtil && nodeUtil.isDate,
	      nodeIsMap = nodeUtil && nodeUtil.isMap,
	      nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
	      nodeIsSet = nodeUtil && nodeUtil.isSet,
	      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

	  /*--------------------------------------------------------------------------*/

	  /**
	   * Adds the key-value `pair` to `map`.
	   *
	   * @private
	   * @param {Object} map The map to modify.
	   * @param {Array} pair The key-value pair to add.
	   * @returns {Object} Returns `map`.
	   */
	  function addMapEntry(map, pair) {
	    // Don't return `map.set` because it's not chainable in IE 11.
	    map.set(pair[0], pair[1]);
	    return map;
	  }

	  /**
	   * Adds `value` to `set`.
	   *
	   * @private
	   * @param {Object} set The set to modify.
	   * @param {*} value The value to add.
	   * @returns {Object} Returns `set`.
	   */
	  function addSetEntry(set, value) {
	    // Don't return `set.add` because it's not chainable in IE 11.
	    set.add(value);
	    return set;
	  }

	  /**
	   * A faster alternative to `Function#apply`, this function invokes `func`
	   * with the `this` binding of `thisArg` and the arguments of `args`.
	   *
	   * @private
	   * @param {Function} func The function to invoke.
	   * @param {*} thisArg The `this` binding of `func`.
	   * @param {Array} args The arguments to invoke `func` with.
	   * @returns {*} Returns the result of `func`.
	   */
	  function apply(func, thisArg, args) {
	    switch (args.length) {
	      case 0: return func.call(thisArg);
	      case 1: return func.call(thisArg, args[0]);
	      case 2: return func.call(thisArg, args[0], args[1]);
	      case 3: return func.call(thisArg, args[0], args[1], args[2]);
	    }
	    return func.apply(thisArg, args);
	  }

	  /**
	   * A specialized version of `baseAggregator` for arrays.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} setter The function to set `accumulator` values.
	   * @param {Function} iteratee The iteratee to transform keys.
	   * @param {Object} accumulator The initial aggregated object.
	   * @returns {Function} Returns `accumulator`.
	   */
	  function arrayAggregator(array, setter, iteratee, accumulator) {
	    var index = -1,
	        length = array == null ? 0 : array.length;

	    while (++index < length) {
	      var value = array[index];
	      setter(accumulator, value, iteratee(value), array);
	    }
	    return accumulator;
	  }

	  /**
	   * A specialized version of `_.forEach` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {Array} Returns `array`.
	   */
	  function arrayEach(array, iteratee) {
	    var index = -1,
	        length = array == null ? 0 : array.length;

	    while (++index < length) {
	      if (iteratee(array[index], index, array) === false) {
	        break;
	      }
	    }
	    return array;
	  }

	  /**
	   * A specialized version of `_.forEachRight` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {Array} Returns `array`.
	   */
	  function arrayEachRight(array, iteratee) {
	    var length = array == null ? 0 : array.length;

	    while (length--) {
	      if (iteratee(array[length], length, array) === false) {
	        break;
	      }
	    }
	    return array;
	  }

	  /**
	   * A specialized version of `_.every` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} predicate The function invoked per iteration.
	   * @returns {boolean} Returns `true` if all elements pass the predicate check,
	   *  else `false`.
	   */
	  function arrayEvery(array, predicate) {
	    var index = -1,
	        length = array == null ? 0 : array.length;

	    while (++index < length) {
	      if (!predicate(array[index], index, array)) {
	        return false;
	      }
	    }
	    return true;
	  }

	  /**
	   * A specialized version of `_.filter` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} predicate The function invoked per iteration.
	   * @returns {Array} Returns the new filtered array.
	   */
	  function arrayFilter(array, predicate) {
	    var index = -1,
	        length = array == null ? 0 : array.length,
	        resIndex = 0,
	        result = [];

	    while (++index < length) {
	      var value = array[index];
	      if (predicate(value, index, array)) {
	        result[resIndex++] = value;
	      }
	    }
	    return result;
	  }

	  /**
	   * A specialized version of `_.includes` for arrays without support for
	   * specifying an index to search from.
	   *
	   * @private
	   * @param {Array} [array] The array to inspect.
	   * @param {*} target The value to search for.
	   * @returns {boolean} Returns `true` if `target` is found, else `false`.
	   */
	  function arrayIncludes(array, value) {
	    var length = array == null ? 0 : array.length;
	    return !!length && baseIndexOf(array, value, 0) > -1;
	  }

	  /**
	   * This function is like `arrayIncludes` except that it accepts a comparator.
	   *
	   * @private
	   * @param {Array} [array] The array to inspect.
	   * @param {*} target The value to search for.
	   * @param {Function} comparator The comparator invoked per element.
	   * @returns {boolean} Returns `true` if `target` is found, else `false`.
	   */
	  function arrayIncludesWith(array, value, comparator) {
	    var index = -1,
	        length = array == null ? 0 : array.length;

	    while (++index < length) {
	      if (comparator(value, array[index])) {
	        return true;
	      }
	    }
	    return false;
	  }

	  /**
	   * A specialized version of `_.map` for arrays without support for iteratee
	   * shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {Array} Returns the new mapped array.
	   */
	  function arrayMap(array, iteratee) {
	    var index = -1,
	        length = array == null ? 0 : array.length,
	        result = Array(length);

	    while (++index < length) {
	      result[index] = iteratee(array[index], index, array);
	    }
	    return result;
	  }

	  /**
	   * Appends the elements of `values` to `array`.
	   *
	   * @private
	   * @param {Array} array The array to modify.
	   * @param {Array} values The values to append.
	   * @returns {Array} Returns `array`.
	   */
	  function arrayPush(array, values) {
	    var index = -1,
	        length = values.length,
	        offset = array.length;

	    while (++index < length) {
	      array[offset + index] = values[index];
	    }
	    return array;
	  }

	  /**
	   * A specialized version of `_.reduce` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @param {*} [accumulator] The initial value.
	   * @param {boolean} [initAccum] Specify using the first element of `array` as
	   *  the initial value.
	   * @returns {*} Returns the accumulated value.
	   */
	  function arrayReduce(array, iteratee, accumulator, initAccum) {
	    var index = -1,
	        length = array == null ? 0 : array.length;

	    if (initAccum && length) {
	      accumulator = array[++index];
	    }
	    while (++index < length) {
	      accumulator = iteratee(accumulator, array[index], index, array);
	    }
	    return accumulator;
	  }

	  /**
	   * A specialized version of `_.reduceRight` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @param {*} [accumulator] The initial value.
	   * @param {boolean} [initAccum] Specify using the last element of `array` as
	   *  the initial value.
	   * @returns {*} Returns the accumulated value.
	   */
	  function arrayReduceRight(array, iteratee, accumulator, initAccum) {
	    var length = array == null ? 0 : array.length;
	    if (initAccum && length) {
	      accumulator = array[--length];
	    }
	    while (length--) {
	      accumulator = iteratee(accumulator, array[length], length, array);
	    }
	    return accumulator;
	  }

	  /**
	   * A specialized version of `_.some` for arrays without support for iteratee
	   * shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} predicate The function invoked per iteration.
	   * @returns {boolean} Returns `true` if any element passes the predicate check,
	   *  else `false`.
	   */
	  function arraySome(array, predicate) {
	    var index = -1,
	        length = array == null ? 0 : array.length;

	    while (++index < length) {
	      if (predicate(array[index], index, array)) {
	        return true;
	      }
	    }
	    return false;
	  }

	  /**
	   * Gets the size of an ASCII `string`.
	   *
	   * @private
	   * @param {string} string The string inspect.
	   * @returns {number} Returns the string size.
	   */
	  var asciiSize = baseProperty('length');

	  /**
	   * Converts an ASCII `string` to an array.
	   *
	   * @private
	   * @param {string} string The string to convert.
	   * @returns {Array} Returns the converted array.
	   */
	  function asciiToArray(string) {
	    return string.split('');
	  }

	  /**
	   * Splits an ASCII `string` into an array of its words.
	   *
	   * @private
	   * @param {string} The string to inspect.
	   * @returns {Array} Returns the words of `string`.
	   */
	  function asciiWords(string) {
	    return string.match(reAsciiWord) || [];
	  }

	  /**
	   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
	   * without support for iteratee shorthands, which iterates over `collection`
	   * using `eachFunc`.
	   *
	   * @private
	   * @param {Array|Object} collection The collection to inspect.
	   * @param {Function} predicate The function invoked per iteration.
	   * @param {Function} eachFunc The function to iterate over `collection`.
	   * @returns {*} Returns the found element or its key, else `undefined`.
	   */
	  function baseFindKey(collection, predicate, eachFunc) {
	    var result;
	    eachFunc(collection, function(value, key, collection) {
	      if (predicate(value, key, collection)) {
	        result = key;
	        return false;
	      }
	    });
	    return result;
	  }

	  /**
	   * The base implementation of `_.findIndex` and `_.findLastIndex` without
	   * support for iteratee shorthands.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {Function} predicate The function invoked per iteration.
	   * @param {number} fromIndex The index to search from.
	   * @param {boolean} [fromRight] Specify iterating from right to left.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function baseFindIndex(array, predicate, fromIndex, fromRight) {
	    var length = array.length,
	        index = fromIndex + (fromRight ? 1 : -1);

	    while ((fromRight ? index-- : ++index < length)) {
	      if (predicate(array[index], index, array)) {
	        return index;
	      }
	    }
	    return -1;
	  }

	  /**
	   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {*} value The value to search for.
	   * @param {number} fromIndex The index to search from.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function baseIndexOf(array, value, fromIndex) {
	    return value === value
	      ? strictIndexOf(array, value, fromIndex)
	      : baseFindIndex(array, baseIsNaN, fromIndex);
	  }

	  /**
	   * This function is like `baseIndexOf` except that it accepts a comparator.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {*} value The value to search for.
	   * @param {number} fromIndex The index to search from.
	   * @param {Function} comparator The comparator invoked per element.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function baseIndexOfWith(array, value, fromIndex, comparator) {
	    var index = fromIndex - 1,
	        length = array.length;

	    while (++index < length) {
	      if (comparator(array[index], value)) {
	        return index;
	      }
	    }
	    return -1;
	  }

	  /**
	   * The base implementation of `_.isNaN` without support for number objects.
	   *
	   * @private
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
	   */
	  function baseIsNaN(value) {
	    return value !== value;
	  }

	  /**
	   * The base implementation of `_.mean` and `_.meanBy` without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} array The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {number} Returns the mean.
	   */
	  function baseMean(array, iteratee) {
	    var length = array == null ? 0 : array.length;
	    return length ? (baseSum(array, iteratee) / length) : NAN;
	  }

	  /**
	   * The base implementation of `_.property` without support for deep paths.
	   *
	   * @private
	   * @param {string} key The key of the property to get.
	   * @returns {Function} Returns the new accessor function.
	   */
	  function baseProperty(key) {
	    return function(object) {
	      return object == null ? undefined : object[key];
	    };
	  }

	  /**
	   * The base implementation of `_.propertyOf` without support for deep paths.
	   *
	   * @private
	   * @param {Object} object The object to query.
	   * @returns {Function} Returns the new accessor function.
	   */
	  function basePropertyOf(object) {
	    return function(key) {
	      return object == null ? undefined : object[key];
	    };
	  }

	  /**
	   * The base implementation of `_.reduce` and `_.reduceRight`, without support
	   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
	   *
	   * @private
	   * @param {Array|Object} collection The collection to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @param {*} accumulator The initial value.
	   * @param {boolean} initAccum Specify using the first or last element of
	   *  `collection` as the initial value.
	   * @param {Function} eachFunc The function to iterate over `collection`.
	   * @returns {*} Returns the accumulated value.
	   */
	  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
	    eachFunc(collection, function(value, index, collection) {
	      accumulator = initAccum
	        ? (initAccum = false, value)
	        : iteratee(accumulator, value, index, collection);
	    });
	    return accumulator;
	  }

	  /**
	   * The base implementation of `_.sortBy` which uses `comparer` to define the
	   * sort order of `array` and replaces criteria objects with their corresponding
	   * values.
	   *
	   * @private
	   * @param {Array} array The array to sort.
	   * @param {Function} comparer The function to define sort order.
	   * @returns {Array} Returns `array`.
	   */
	  function baseSortBy(array, comparer) {
	    var length = array.length;

	    array.sort(comparer);
	    while (length--) {
	      array[length] = array[length].value;
	    }
	    return array;
	  }

	  /**
	   * The base implementation of `_.sum` and `_.sumBy` without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} array The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {number} Returns the sum.
	   */
	  function baseSum(array, iteratee) {
	    var result,
	        index = -1,
	        length = array.length;

	    while (++index < length) {
	      var current = iteratee(array[index]);
	      if (current !== undefined) {
	        result = result === undefined ? current : (result + current);
	      }
	    }
	    return result;
	  }

	  /**
	   * The base implementation of `_.times` without support for iteratee shorthands
	   * or max array length checks.
	   *
	   * @private
	   * @param {number} n The number of times to invoke `iteratee`.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {Array} Returns the array of results.
	   */
	  function baseTimes(n, iteratee) {
	    var index = -1,
	        result = Array(n);

	    while (++index < n) {
	      result[index] = iteratee(index);
	    }
	    return result;
	  }

	  /**
	   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
	   * of key-value pairs for `object` corresponding to the property names of `props`.
	   *
	   * @private
	   * @param {Object} object The object to query.
	   * @param {Array} props The property names to get values for.
	   * @returns {Object} Returns the key-value pairs.
	   */
	  function baseToPairs(object, props) {
	    return arrayMap(props, function(key) {
	      return [key, object[key]];
	    });
	  }

	  /**
	   * The base implementation of `_.unary` without support for storing metadata.
	   *
	   * @private
	   * @param {Function} func The function to cap arguments for.
	   * @returns {Function} Returns the new capped function.
	   */
	  function baseUnary(func) {
	    return function(value) {
	      return func(value);
	    };
	  }

	  /**
	   * The base implementation of `_.values` and `_.valuesIn` which creates an
	   * array of `object` property values corresponding to the property names
	   * of `props`.
	   *
	   * @private
	   * @param {Object} object The object to query.
	   * @param {Array} props The property names to get values for.
	   * @returns {Object} Returns the array of property values.
	   */
	  function baseValues(object, props) {
	    return arrayMap(props, function(key) {
	      return object[key];
	    });
	  }

	  /**
	   * Checks if a `cache` value for `key` exists.
	   *
	   * @private
	   * @param {Object} cache The cache to query.
	   * @param {string} key The key of the entry to check.
	   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	   */
	  function cacheHas(cache, key) {
	    return cache.has(key);
	  }

	  /**
	   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
	   * that is not found in the character symbols.
	   *
	   * @private
	   * @param {Array} strSymbols The string symbols to inspect.
	   * @param {Array} chrSymbols The character symbols to find.
	   * @returns {number} Returns the index of the first unmatched string symbol.
	   */
	  function charsStartIndex(strSymbols, chrSymbols) {
	    var index = -1,
	        length = strSymbols.length;

	    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
	    return index;
	  }

	  /**
	   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
	   * that is not found in the character symbols.
	   *
	   * @private
	   * @param {Array} strSymbols The string symbols to inspect.
	   * @param {Array} chrSymbols The character symbols to find.
	   * @returns {number} Returns the index of the last unmatched string symbol.
	   */
	  function charsEndIndex(strSymbols, chrSymbols) {
	    var index = strSymbols.length;

	    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
	    return index;
	  }

	  /**
	   * Gets the number of `placeholder` occurrences in `array`.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {*} placeholder The placeholder to search for.
	   * @returns {number} Returns the placeholder count.
	   */
	  function countHolders(array, placeholder) {
	    var length = array.length,
	        result = 0;

	    while (length--) {
	      if (array[length] === placeholder) {
	        ++result;
	      }
	    }
	    return result;
	  }

	  /**
	   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
	   * letters to basic Latin letters.
	   *
	   * @private
	   * @param {string} letter The matched letter to deburr.
	   * @returns {string} Returns the deburred letter.
	   */
	  var deburrLetter = basePropertyOf(deburredLetters);

	  /**
	   * Used by `_.escape` to convert characters to HTML entities.
	   *
	   * @private
	   * @param {string} chr The matched character to escape.
	   * @returns {string} Returns the escaped character.
	   */
	  var escapeHtmlChar = basePropertyOf(htmlEscapes);

	  /**
	   * Used by `_.template` to escape characters for inclusion in compiled string literals.
	   *
	   * @private
	   * @param {string} chr The matched character to escape.
	   * @returns {string} Returns the escaped character.
	   */
	  function escapeStringChar(chr) {
	    return '\\' + stringEscapes[chr];
	  }

	  /**
	   * Gets the value at `key` of `object`.
	   *
	   * @private
	   * @param {Object} [object] The object to query.
	   * @param {string} key The key of the property to get.
	   * @returns {*} Returns the property value.
	   */
	  function getValue(object, key) {
	    return object == null ? undefined : object[key];
	  }

	  /**
	   * Checks if `string` contains Unicode symbols.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
	   */
	  function hasUnicode(string) {
	    return reHasUnicode.test(string);
	  }

	  /**
	   * Checks if `string` contains a word composed of Unicode symbols.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @returns {boolean} Returns `true` if a word is found, else `false`.
	   */
	  function hasUnicodeWord(string) {
	    return reHasUnicodeWord.test(string);
	  }

	  /**
	   * Converts `iterator` to an array.
	   *
	   * @private
	   * @param {Object} iterator The iterator to convert.
	   * @returns {Array} Returns the converted array.
	   */
	  function iteratorToArray(iterator) {
	    var data,
	        result = [];

	    while (!(data = iterator.next()).done) {
	      result.push(data.value);
	    }
	    return result;
	  }

	  /**
	   * Converts `map` to its key-value pairs.
	   *
	   * @private
	   * @param {Object} map The map to convert.
	   * @returns {Array} Returns the key-value pairs.
	   */
	  function mapToArray(map) {
	    var index = -1,
	        result = Array(map.size);

	    map.forEach(function(value, key) {
	      result[++index] = [key, value];
	    });
	    return result;
	  }

	  /**
	   * Creates a unary function that invokes `func` with its argument transformed.
	   *
	   * @private
	   * @param {Function} func The function to wrap.
	   * @param {Function} transform The argument transform.
	   * @returns {Function} Returns the new function.
	   */
	  function overArg(func, transform) {
	    return function(arg) {
	      return func(transform(arg));
	    };
	  }

	  /**
	   * Replaces all `placeholder` elements in `array` with an internal placeholder
	   * and returns an array of their indexes.
	   *
	   * @private
	   * @param {Array} array The array to modify.
	   * @param {*} placeholder The placeholder to replace.
	   * @returns {Array} Returns the new array of placeholder indexes.
	   */
	  function replaceHolders(array, placeholder) {
	    var index = -1,
	        length = array.length,
	        resIndex = 0,
	        result = [];

	    while (++index < length) {
	      var value = array[index];
	      if (value === placeholder || value === PLACEHOLDER) {
	        array[index] = PLACEHOLDER;
	        result[resIndex++] = index;
	      }
	    }
	    return result;
	  }

	  /**
	   * Converts `set` to an array of its values.
	   *
	   * @private
	   * @param {Object} set The set to convert.
	   * @returns {Array} Returns the values.
	   */
	  function setToArray(set) {
	    var index = -1,
	        result = Array(set.size);

	    set.forEach(function(value) {
	      result[++index] = value;
	    });
	    return result;
	  }

	  /**
	   * Converts `set` to its value-value pairs.
	   *
	   * @private
	   * @param {Object} set The set to convert.
	   * @returns {Array} Returns the value-value pairs.
	   */
	  function setToPairs(set) {
	    var index = -1,
	        result = Array(set.size);

	    set.forEach(function(value) {
	      result[++index] = [value, value];
	    });
	    return result;
	  }

	  /**
	   * A specialized version of `_.indexOf` which performs strict equality
	   * comparisons of values, i.e. `===`.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {*} value The value to search for.
	   * @param {number} fromIndex The index to search from.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function strictIndexOf(array, value, fromIndex) {
	    var index = fromIndex - 1,
	        length = array.length;

	    while (++index < length) {
	      if (array[index] === value) {
	        return index;
	      }
	    }
	    return -1;
	  }

	  /**
	   * A specialized version of `_.lastIndexOf` which performs strict equality
	   * comparisons of values, i.e. `===`.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {*} value The value to search for.
	   * @param {number} fromIndex The index to search from.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function strictLastIndexOf(array, value, fromIndex) {
	    var index = fromIndex + 1;
	    while (index--) {
	      if (array[index] === value) {
	        return index;
	      }
	    }
	    return index;
	  }

	  /**
	   * Gets the number of symbols in `string`.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @returns {number} Returns the string size.
	   */
	  function stringSize(string) {
	    return hasUnicode(string)
	      ? unicodeSize(string)
	      : asciiSize(string);
	  }

	  /**
	   * Converts `string` to an array.
	   *
	   * @private
	   * @param {string} string The string to convert.
	   * @returns {Array} Returns the converted array.
	   */
	  function stringToArray(string) {
	    return hasUnicode(string)
	      ? unicodeToArray(string)
	      : asciiToArray(string);
	  }

	  /**
	   * Used by `_.unescape` to convert HTML entities to characters.
	   *
	   * @private
	   * @param {string} chr The matched character to unescape.
	   * @returns {string} Returns the unescaped character.
	   */
	  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);

	  /**
	   * Gets the size of a Unicode `string`.
	   *
	   * @private
	   * @param {string} string The string inspect.
	   * @returns {number} Returns the string size.
	   */
	  function unicodeSize(string) {
	    var result = reUnicode.lastIndex = 0;
	    while (reUnicode.test(string)) {
	      ++result;
	    }
	    return result;
	  }

	  /**
	   * Converts a Unicode `string` to an array.
	   *
	   * @private
	   * @param {string} string The string to convert.
	   * @returns {Array} Returns the converted array.
	   */
	  function unicodeToArray(string) {
	    return string.match(reUnicode) || [];
	  }

	  /**
	   * Splits a Unicode `string` into an array of its words.
	   *
	   * @private
	   * @param {string} The string to inspect.
	   * @returns {Array} Returns the words of `string`.
	   */
	  function unicodeWords(string) {
	    return string.match(reUnicodeWord) || [];
	  }

	  /*--------------------------------------------------------------------------*/

	  /**
	   * Create a new pristine `lodash` function using the `context` object.
	   *
	   * @static
	   * @memberOf _
	   * @since 1.1.0
	   * @category Util
	   * @param {Object} [context=root] The context object.
	   * @returns {Function} Returns a new `lodash` function.
	   * @example
	   *
	   * _.mixin({ 'foo': _.constant('foo') });
	   *
	   * var lodash = _.runInContext();
	   * lodash.mixin({ 'bar': lodash.constant('bar') });
	   *
	   * _.isFunction(_.foo);
	   * // => true
	   * _.isFunction(_.bar);
	   * // => false
	   *
	   * lodash.isFunction(lodash.foo);
	   * // => false
	   * lodash.isFunction(lodash.bar);
	   * // => true
	   *
	   * // Create a suped-up `defer` in Node.js.
	   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
	   */
	  var runInContext = (function runInContext(context) {
	    context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));

	    /** Built-in constructor references. */
	    var Array = context.Array,
	        Date = context.Date,
	        Error = context.Error,
	        Function = context.Function,
	        Math = context.Math,
	        Object = context.Object,
	        RegExp = context.RegExp,
	        String = context.String,
	        TypeError = context.TypeError;

	    /** Used for built-in method references. */
	    var arrayProto = Array.prototype,
	        funcProto = Function.prototype,
	        objectProto = Object.prototype;

	    /** Used to detect overreaching core-js shims. */
	    var coreJsData = context['__core-js_shared__'];

	    /** Used to resolve the decompiled source of functions. */
	    var funcToString = funcProto.toString;

	    /** Used to check objects for own properties. */
	    var hasOwnProperty = objectProto.hasOwnProperty;

	    /** Used to generate unique IDs. */
	    var idCounter = 0;

	    /** Used to detect methods masquerading as native. */
	    var maskSrcKey = (function() {
	      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	      return uid ? ('Symbol(src)_1.' + uid) : '';
	    }());

	    /**
	     * Used to resolve the
	     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	     * of values.
	     */
	    var nativeObjectToString = objectProto.toString;

	    /** Used to infer the `Object` constructor. */
	    var objectCtorString = funcToString.call(Object);

	    /** Used to restore the original `_` reference in `_.noConflict`. */
	    var oldDash = root._;

	    /** Used to detect if a method is native. */
	    var reIsNative = RegExp('^' +
	      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
	      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	    );

	    /** Built-in value references. */
	    var Buffer = moduleExports ? context.Buffer : undefined,
	        Symbol = context.Symbol,
	        Uint8Array = context.Uint8Array,
	        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
	        getPrototype = overArg(Object.getPrototypeOf, Object),
	        objectCreate = Object.create,
	        propertyIsEnumerable = objectProto.propertyIsEnumerable,
	        splice = arrayProto.splice,
	        spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,
	        symIterator = Symbol ? Symbol.iterator : undefined,
	        symToStringTag = Symbol ? Symbol.toStringTag : undefined;

	    var defineProperty = (function() {
	      try {
	        var func = getNative(Object, 'defineProperty');
	        func({}, '', {});
	        return func;
	      } catch (e) {}
	    }());

	    /** Mocked built-ins. */
	    var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
	        ctxNow = Date && Date.now !== root.Date.now && Date.now,
	        ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;

	    /* Built-in method references for those with the same name as other `lodash` methods. */
	    var nativeCeil = Math.ceil,
	        nativeFloor = Math.floor,
	        nativeGetSymbols = Object.getOwnPropertySymbols,
	        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
	        nativeIsFinite = context.isFinite,
	        nativeJoin = arrayProto.join,
	        nativeKeys = overArg(Object.keys, Object),
	        nativeMax = Math.max,
	        nativeMin = Math.min,
	        nativeNow = Date.now,
	        nativeParseInt = context.parseInt,
	        nativeRandom = Math.random,
	        nativeReverse = arrayProto.reverse;

	    /* Built-in method references that are verified to be native. */
	    var DataView = getNative(context, 'DataView'),
	        Map = getNative(context, 'Map'),
	        Promise = getNative(context, 'Promise'),
	        Set = getNative(context, 'Set'),
	        WeakMap = getNative(context, 'WeakMap'),
	        nativeCreate = getNative(Object, 'create');

	    /** Used to store function metadata. */
	    var metaMap = WeakMap && new WeakMap;

	    /** Used to lookup unminified function names. */
	    var realNames = {};

	    /** Used to detect maps, sets, and weakmaps. */
	    var dataViewCtorString = toSource(DataView),
	        mapCtorString = toSource(Map),
	        promiseCtorString = toSource(Promise),
	        setCtorString = toSource(Set),
	        weakMapCtorString = toSource(WeakMap);

	    /** Used to convert symbols to primitives and strings. */
	    var symbolProto = Symbol ? Symbol.prototype : undefined,
	        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
	        symbolToString = symbolProto ? symbolProto.toString : undefined;

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a `lodash` object which wraps `value` to enable implicit method
	     * chain sequences. Methods that operate on and return arrays, collections,
	     * and functions can be chained together. Methods that retrieve a single value
	     * or may return a primitive value will automatically end the chain sequence
	     * and return the unwrapped value. Otherwise, the value must be unwrapped
	     * with `_#value`.
	     *
	     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
	     * enabled using `_.chain`.
	     *
	     * The execution of chained methods is lazy, that is, it's deferred until
	     * `_#value` is implicitly or explicitly called.
	     *
	     * Lazy evaluation allows several methods to support shortcut fusion.
	     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
	     * the creation of intermediate arrays and can greatly reduce the number of
	     * iteratee executions. Sections of a chain sequence qualify for shortcut
	     * fusion if the section is applied to an array of at least `200` elements
	     * and any iteratees accept only one argument. The heuristic for whether a
	     * section qualifies for shortcut fusion is subject to change.
	     *
	     * Chaining is supported in custom builds as long as the `_#value` method is
	     * directly or indirectly included in the build.
	     *
	     * In addition to lodash methods, wrappers have `Array` and `String` methods.
	     *
	     * The wrapper `Array` methods are:
	     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
	     *
	     * The wrapper `String` methods are:
	     * `replace` and `split`
	     *
	     * The wrapper methods that support shortcut fusion are:
	     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
	     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
	     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
	     *
	     * The chainable wrapper methods are:
	     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
	     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
	     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
	     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
	     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
	     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
	     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
	     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
	     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
	     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
	     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
	     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
	     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
	     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
	     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
	     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
	     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
	     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
	     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
	     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
	     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
	     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
	     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
	     * `zipObject`, `zipObjectDeep`, and `zipWith`
	     *
	     * The wrapper methods that are **not** chainable by default are:
	     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
	     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
	     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
	     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
	     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
	     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
	     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
	     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
	     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
	     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
	     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
	     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
	     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
	     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
	     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
	     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
	     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
	     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
	     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
	     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
	     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
	     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
	     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
	     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
	     * `upperFirst`, `value`, and `words`
	     *
	     * @name _
	     * @constructor
	     * @category Seq
	     * @param {*} value The value to wrap in a `lodash` instance.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var wrapped = _([1, 2, 3]);
	     *
	     * // Returns an unwrapped value.
	     * wrapped.reduce(_.add);
	     * // => 6
	     *
	     * // Returns a wrapped value.
	     * var squares = wrapped.map(square);
	     *
	     * _.isArray(squares);
	     * // => false
	     *
	     * _.isArray(squares.value());
	     * // => true
	     */
	    function lodash(value) {
	      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
	        if (value instanceof LodashWrapper) {
	          return value;
	        }
	        if (hasOwnProperty.call(value, '__wrapped__')) {
	          return wrapperClone(value);
	        }
	      }
	      return new LodashWrapper(value);
	    }

	    /**
	     * The base implementation of `_.create` without support for assigning
	     * properties to the created object.
	     *
	     * @private
	     * @param {Object} proto The object to inherit from.
	     * @returns {Object} Returns the new object.
	     */
	    var baseCreate = (function() {
	      function object() {}
	      return function(proto) {
	        if (!isObject(proto)) {
	          return {};
	        }
	        if (objectCreate) {
	          return objectCreate(proto);
	        }
	        object.prototype = proto;
	        var result = new object;
	        object.prototype = undefined;
	        return result;
	      };
	    }());

	    /**
	     * The function whose prototype chain sequence wrappers inherit from.
	     *
	     * @private
	     */
	    function baseLodash() {
	      // No operation performed.
	    }

	    /**
	     * The base constructor for creating `lodash` wrapper objects.
	     *
	     * @private
	     * @param {*} value The value to wrap.
	     * @param {boolean} [chainAll] Enable explicit method chain sequences.
	     */
	    function LodashWrapper(value, chainAll) {
	      this.__wrapped__ = value;
	      this.__actions__ = [];
	      this.__chain__ = !!chainAll;
	      this.__index__ = 0;
	      this.__values__ = undefined;
	    }

	    /**
	     * By default, the template delimiters used by lodash are like those in
	     * embedded Ruby (ERB). Change the following template settings to use
	     * alternative delimiters.
	     *
	     * @static
	     * @memberOf _
	     * @type {Object}
	     */
	    lodash.templateSettings = {

	      /**
	       * Used to detect `data` property values to be HTML-escaped.
	       *
	       * @memberOf _.templateSettings
	       * @type {RegExp}
	       */
	      'escape': reEscape,

	      /**
	       * Used to detect code to be evaluated.
	       *
	       * @memberOf _.templateSettings
	       * @type {RegExp}
	       */
	      'evaluate': reEvaluate,

	      /**
	       * Used to detect `data` property values to inject.
	       *
	       * @memberOf _.templateSettings
	       * @type {RegExp}
	       */
	      'interpolate': reInterpolate,

	      /**
	       * Used to reference the data object in the template text.
	       *
	       * @memberOf _.templateSettings
	       * @type {string}
	       */
	      'variable': '',

	      /**
	       * Used to import variables into the compiled template.
	       *
	       * @memberOf _.templateSettings
	       * @type {Object}
	       */
	      'imports': {

	        /**
	         * A reference to the `lodash` function.
	         *
	         * @memberOf _.templateSettings.imports
	         * @type {Function}
	         */
	        '_': lodash
	      }
	    };

	    // Ensure wrappers are instances of `baseLodash`.
	    lodash.prototype = baseLodash.prototype;
	    lodash.prototype.constructor = lodash;

	    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
	    LodashWrapper.prototype.constructor = LodashWrapper;

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
	     *
	     * @private
	     * @constructor
	     * @param {*} value The value to wrap.
	     */
	    function LazyWrapper(value) {
	      this.__wrapped__ = value;
	      this.__actions__ = [];
	      this.__dir__ = 1;
	      this.__filtered__ = false;
	      this.__iteratees__ = [];
	      this.__takeCount__ = MAX_ARRAY_LENGTH;
	      this.__views__ = [];
	    }

	    /**
	     * Creates a clone of the lazy wrapper object.
	     *
	     * @private
	     * @name clone
	     * @memberOf LazyWrapper
	     * @returns {Object} Returns the cloned `LazyWrapper` object.
	     */
	    function lazyClone() {
	      var result = new LazyWrapper(this.__wrapped__);
	      result.__actions__ = copyArray(this.__actions__);
	      result.__dir__ = this.__dir__;
	      result.__filtered__ = this.__filtered__;
	      result.__iteratees__ = copyArray(this.__iteratees__);
	      result.__takeCount__ = this.__takeCount__;
	      result.__views__ = copyArray(this.__views__);
	      return result;
	    }

	    /**
	     * Reverses the direction of lazy iteration.
	     *
	     * @private
	     * @name reverse
	     * @memberOf LazyWrapper
	     * @returns {Object} Returns the new reversed `LazyWrapper` object.
	     */
	    function lazyReverse() {
	      if (this.__filtered__) {
	        var result = new LazyWrapper(this);
	        result.__dir__ = -1;
	        result.__filtered__ = true;
	      } else {
	        result = this.clone();
	        result.__dir__ *= -1;
	      }
	      return result;
	    }

	    /**
	     * Extracts the unwrapped value from its lazy wrapper.
	     *
	     * @private
	     * @name value
	     * @memberOf LazyWrapper
	     * @returns {*} Returns the unwrapped value.
	     */
	    function lazyValue() {
	      var array = this.__wrapped__.value(),
	          dir = this.__dir__,
	          isArr = isArray(array),
	          isRight = dir < 0,
	          arrLength = isArr ? array.length : 0,
	          view = getView(0, arrLength, this.__views__),
	          start = view.start,
	          end = view.end,
	          length = end - start,
	          index = isRight ? end : (start - 1),
	          iteratees = this.__iteratees__,
	          iterLength = iteratees.length,
	          resIndex = 0,
	          takeCount = nativeMin(length, this.__takeCount__);

	      if (!isArr || arrLength < LARGE_ARRAY_SIZE ||
	          (arrLength == length && takeCount == length)) {
	        return baseWrapperValue(array, this.__actions__);
	      }
	      var result = [];

	      outer:
	      while (length-- && resIndex < takeCount) {
	        index += dir;

	        var iterIndex = -1,
	            value = array[index];

	        while (++iterIndex < iterLength) {
	          var data = iteratees[iterIndex],
	              iteratee = data.iteratee,
	              type = data.type,
	              computed = iteratee(value);

	          if (type == LAZY_MAP_FLAG) {
	            value = computed;
	          } else if (!computed) {
	            if (type == LAZY_FILTER_FLAG) {
	              continue outer;
	            } else {
	              break outer;
	            }
	          }
	        }
	        result[resIndex++] = value;
	      }
	      return result;
	    }

	    // Ensure `LazyWrapper` is an instance of `baseLodash`.
	    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
	    LazyWrapper.prototype.constructor = LazyWrapper;

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a hash object.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [entries] The key-value pairs to cache.
	     */
	    function Hash(entries) {
	      var index = -1,
	          length = entries == null ? 0 : entries.length;

	      this.clear();
	      while (++index < length) {
	        var entry = entries[index];
	        this.set(entry[0], entry[1]);
	      }
	    }

	    /**
	     * Removes all key-value entries from the hash.
	     *
	     * @private
	     * @name clear
	     * @memberOf Hash
	     */
	    function hashClear() {
	      this.__data__ = nativeCreate ? nativeCreate(null) : {};
	      this.size = 0;
	    }

	    /**
	     * Removes `key` and its value from the hash.
	     *
	     * @private
	     * @name delete
	     * @memberOf Hash
	     * @param {Object} hash The hash to modify.
	     * @param {string} key The key of the value to remove.
	     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	     */
	    function hashDelete(key) {
	      var result = this.has(key) && delete this.__data__[key];
	      this.size -= result ? 1 : 0;
	      return result;
	    }

	    /**
	     * Gets the hash value for `key`.
	     *
	     * @private
	     * @name get
	     * @memberOf Hash
	     * @param {string} key The key of the value to get.
	     * @returns {*} Returns the entry value.
	     */
	    function hashGet(key) {
	      var data = this.__data__;
	      if (nativeCreate) {
	        var result = data[key];
	        return result === HASH_UNDEFINED ? undefined : result;
	      }
	      return hasOwnProperty.call(data, key) ? data[key] : undefined;
	    }

	    /**
	     * Checks if a hash value for `key` exists.
	     *
	     * @private
	     * @name has
	     * @memberOf Hash
	     * @param {string} key The key of the entry to check.
	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	     */
	    function hashHas(key) {
	      var data = this.__data__;
	      return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
	    }

	    /**
	     * Sets the hash `key` to `value`.
	     *
	     * @private
	     * @name set
	     * @memberOf Hash
	     * @param {string} key The key of the value to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns the hash instance.
	     */
	    function hashSet(key, value) {
	      var data = this.__data__;
	      this.size += this.has(key) ? 0 : 1;
	      data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
	      return this;
	    }

	    // Add methods to `Hash`.
	    Hash.prototype.clear = hashClear;
	    Hash.prototype['delete'] = hashDelete;
	    Hash.prototype.get = hashGet;
	    Hash.prototype.has = hashHas;
	    Hash.prototype.set = hashSet;

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates an list cache object.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [entries] The key-value pairs to cache.
	     */
	    function ListCache(entries) {
	      var index = -1,
	          length = entries == null ? 0 : entries.length;

	      this.clear();
	      while (++index < length) {
	        var entry = entries[index];
	        this.set(entry[0], entry[1]);
	      }
	    }

	    /**
	     * Removes all key-value entries from the list cache.
	     *
	     * @private
	     * @name clear
	     * @memberOf ListCache
	     */
	    function listCacheClear() {
	      this.__data__ = [];
	      this.size = 0;
	    }

	    /**
	     * Removes `key` and its value from the list cache.
	     *
	     * @private
	     * @name delete
	     * @memberOf ListCache
	     * @param {string} key The key of the value to remove.
	     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	     */
	    function listCacheDelete(key) {
	      var data = this.__data__,
	          index = assocIndexOf(data, key);

	      if (index < 0) {
	        return false;
	      }
	      var lastIndex = data.length - 1;
	      if (index == lastIndex) {
	        data.pop();
	      } else {
	        splice.call(data, index, 1);
	      }
	      --this.size;
	      return true;
	    }

	    /**
	     * Gets the list cache value for `key`.
	     *
	     * @private
	     * @name get
	     * @memberOf ListCache
	     * @param {string} key The key of the value to get.
	     * @returns {*} Returns the entry value.
	     */
	    function listCacheGet(key) {
	      var data = this.__data__,
	          index = assocIndexOf(data, key);

	      return index < 0 ? undefined : data[index][1];
	    }

	    /**
	     * Checks if a list cache value for `key` exists.
	     *
	     * @private
	     * @name has
	     * @memberOf ListCache
	     * @param {string} key The key of the entry to check.
	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	     */
	    function listCacheHas(key) {
	      return assocIndexOf(this.__data__, key) > -1;
	    }

	    /**
	     * Sets the list cache `key` to `value`.
	     *
	     * @private
	     * @name set
	     * @memberOf ListCache
	     * @param {string} key The key of the value to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns the list cache instance.
	     */
	    function listCacheSet(key, value) {
	      var data = this.__data__,
	          index = assocIndexOf(data, key);

	      if (index < 0) {
	        ++this.size;
	        data.push([key, value]);
	      } else {
	        data[index][1] = value;
	      }
	      return this;
	    }

	    // Add methods to `ListCache`.
	    ListCache.prototype.clear = listCacheClear;
	    ListCache.prototype['delete'] = listCacheDelete;
	    ListCache.prototype.get = listCacheGet;
	    ListCache.prototype.has = listCacheHas;
	    ListCache.prototype.set = listCacheSet;

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a map cache object to store key-value pairs.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [entries] The key-value pairs to cache.
	     */
	    function MapCache(entries) {
	      var index = -1,
	          length = entries == null ? 0 : entries.length;

	      this.clear();
	      while (++index < length) {
	        var entry = entries[index];
	        this.set(entry[0], entry[1]);
	      }
	    }

	    /**
	     * Removes all key-value entries from the map.
	     *
	     * @private
	     * @name clear
	     * @memberOf MapCache
	     */
	    function mapCacheClear() {
	      this.size = 0;
	      this.__data__ = {
	        'hash': new Hash,
	        'map': new (Map || ListCache),
	        'string': new Hash
	      };
	    }

	    /**
	     * Removes `key` and its value from the map.
	     *
	     * @private
	     * @name delete
	     * @memberOf MapCache
	     * @param {string} key The key of the value to remove.
	     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	     */
	    function mapCacheDelete(key) {
	      var result = getMapData(this, key)['delete'](key);
	      this.size -= result ? 1 : 0;
	      return result;
	    }

	    /**
	     * Gets the map value for `key`.
	     *
	     * @private
	     * @name get
	     * @memberOf MapCache
	     * @param {string} key The key of the value to get.
	     * @returns {*} Returns the entry value.
	     */
	    function mapCacheGet(key) {
	      return getMapData(this, key).get(key);
	    }

	    /**
	     * Checks if a map value for `key` exists.
	     *
	     * @private
	     * @name has
	     * @memberOf MapCache
	     * @param {string} key The key of the entry to check.
	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	     */
	    function mapCacheHas(key) {
	      return getMapData(this, key).has(key);
	    }

	    /**
	     * Sets the map `key` to `value`.
	     *
	     * @private
	     * @name set
	     * @memberOf MapCache
	     * @param {string} key The key of the value to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns the map cache instance.
	     */
	    function mapCacheSet(key, value) {
	      var data = getMapData(this, key),
	          size = data.size;

	      data.set(key, value);
	      this.size += data.size == size ? 0 : 1;
	      return this;
	    }

	    // Add methods to `MapCache`.
	    MapCache.prototype.clear = mapCacheClear;
	    MapCache.prototype['delete'] = mapCacheDelete;
	    MapCache.prototype.get = mapCacheGet;
	    MapCache.prototype.has = mapCacheHas;
	    MapCache.prototype.set = mapCacheSet;

	    /*------------------------------------------------------------------------*/

	    /**
	     *
	     * Creates an array cache object to store unique values.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [values] The values to cache.
	     */
	    function SetCache(values) {
	      var index = -1,
	          length = values == null ? 0 : values.length;

	      this.__data__ = new MapCache;
	      while (++index < length) {
	        this.add(values[index]);
	      }
	    }

	    /**
	     * Adds `value` to the array cache.
	     *
	     * @private
	     * @name add
	     * @memberOf SetCache
	     * @alias push
	     * @param {*} value The value to cache.
	     * @returns {Object} Returns the cache instance.
	     */
	    function setCacheAdd(value) {
	      this.__data__.set(value, HASH_UNDEFINED);
	      return this;
	    }

	    /**
	     * Checks if `value` is in the array cache.
	     *
	     * @private
	     * @name has
	     * @memberOf SetCache
	     * @param {*} value The value to search for.
	     * @returns {number} Returns `true` if `value` is found, else `false`.
	     */
	    function setCacheHas(value) {
	      return this.__data__.has(value);
	    }

	    // Add methods to `SetCache`.
	    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
	    SetCache.prototype.has = setCacheHas;

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a stack cache object to store key-value pairs.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [entries] The key-value pairs to cache.
	     */
	    function Stack(entries) {
	      var data = this.__data__ = new ListCache(entries);
	      this.size = data.size;
	    }

	    /**
	     * Removes all key-value entries from the stack.
	     *
	     * @private
	     * @name clear
	     * @memberOf Stack
	     */
	    function stackClear() {
	      this.__data__ = new ListCache;
	      this.size = 0;
	    }

	    /**
	     * Removes `key` and its value from the stack.
	     *
	     * @private
	     * @name delete
	     * @memberOf Stack
	     * @param {string} key The key of the value to remove.
	     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	     */
	    function stackDelete(key) {
	      var data = this.__data__,
	          result = data['delete'](key);

	      this.size = data.size;
	      return result;
	    }

	    /**
	     * Gets the stack value for `key`.
	     *
	     * @private
	     * @name get
	     * @memberOf Stack
	     * @param {string} key The key of the value to get.
	     * @returns {*} Returns the entry value.
	     */
	    function stackGet(key) {
	      return this.__data__.get(key);
	    }

	    /**
	     * Checks if a stack value for `key` exists.
	     *
	     * @private
	     * @name has
	     * @memberOf Stack
	     * @param {string} key The key of the entry to check.
	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	     */
	    function stackHas(key) {
	      return this.__data__.has(key);
	    }

	    /**
	     * Sets the stack `key` to `value`.
	     *
	     * @private
	     * @name set
	     * @memberOf Stack
	     * @param {string} key The key of the value to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns the stack cache instance.
	     */
	    function stackSet(key, value) {
	      var data = this.__data__;
	      if (data instanceof ListCache) {
	        var pairs = data.__data__;
	        if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
	          pairs.push([key, value]);
	          this.size = ++data.size;
	          return this;
	        }
	        data = this.__data__ = new MapCache(pairs);
	      }
	      data.set(key, value);
	      this.size = data.size;
	      return this;
	    }

	    // Add methods to `Stack`.
	    Stack.prototype.clear = stackClear;
	    Stack.prototype['delete'] = stackDelete;
	    Stack.prototype.get = stackGet;
	    Stack.prototype.has = stackHas;
	    Stack.prototype.set = stackSet;

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates an array of the enumerable property names of the array-like `value`.
	     *
	     * @private
	     * @param {*} value The value to query.
	     * @param {boolean} inherited Specify returning inherited property names.
	     * @returns {Array} Returns the array of property names.
	     */
	    function arrayLikeKeys(value, inherited) {
	      var isArr = isArray(value),
	          isArg = !isArr && isArguments(value),
	          isBuff = !isArr && !isArg && isBuffer(value),
	          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
	          skipIndexes = isArr || isArg || isBuff || isType,
	          result = skipIndexes ? baseTimes(value.length, String) : [],
	          length = result.length;

	      for (var key in value) {
	        if ((inherited || hasOwnProperty.call(value, key)) &&
	            !(skipIndexes && (
	               // Safari 9 has enumerable `arguments.length` in strict mode.
	               key == 'length' ||
	               // Node.js 0.10 has enumerable non-index properties on buffers.
	               (isBuff && (key == 'offset' || key == 'parent')) ||
	               // PhantomJS 2 has enumerable non-index properties on typed arrays.
	               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
	               // Skip index properties.
	               isIndex(key, length)
	            ))) {
	          result.push(key);
	        }
	      }
	      return result;
	    }

	    /**
	     * A specialized version of `_.sample` for arrays.
	     *
	     * @private
	     * @param {Array} array The array to sample.
	     * @returns {*} Returns the random element.
	     */
	    function arraySample(array) {
	      var length = array.length;
	      return length ? array[baseRandom(0, length - 1)] : undefined;
	    }

	    /**
	     * A specialized version of `_.sampleSize` for arrays.
	     *
	     * @private
	     * @param {Array} array The array to sample.
	     * @param {number} n The number of elements to sample.
	     * @returns {Array} Returns the random elements.
	     */
	    function arraySampleSize(array, n) {
	      return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
	    }

	    /**
	     * A specialized version of `_.shuffle` for arrays.
	     *
	     * @private
	     * @param {Array} array The array to shuffle.
	     * @returns {Array} Returns the new shuffled array.
	     */
	    function arrayShuffle(array) {
	      return shuffleSelf(copyArray(array));
	    }

	    /**
	     * Used by `_.defaults` to customize its `_.assignIn` use.
	     *
	     * @private
	     * @param {*} objValue The destination value.
	     * @param {*} srcValue The source value.
	     * @param {string} key The key of the property to assign.
	     * @param {Object} object The parent object of `objValue`.
	     * @returns {*} Returns the value to assign.
	     */
	    function assignInDefaults(objValue, srcValue, key, object) {
	      if (objValue === undefined ||
	          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
	        return srcValue;
	      }
	      return objValue;
	    }

	    /**
	     * This function is like `assignValue` except that it doesn't assign
	     * `undefined` values.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {string} key The key of the property to assign.
	     * @param {*} value The value to assign.
	     */
	    function assignMergeValue(object, key, value) {
	      if ((value !== undefined && !eq(object[key], value)) ||
	          (value === undefined && !(key in object))) {
	        baseAssignValue(object, key, value);
	      }
	    }

	    /**
	     * Assigns `value` to `key` of `object` if the existing value is not equivalent
	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {string} key The key of the property to assign.
	     * @param {*} value The value to assign.
	     */
	    function assignValue(object, key, value) {
	      var objValue = object[key];
	      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
	          (value === undefined && !(key in object))) {
	        baseAssignValue(object, key, value);
	      }
	    }

	    /**
	     * Gets the index at which the `key` is found in `array` of key-value pairs.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {*} key The key to search for.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     */
	    function assocIndexOf(array, key) {
	      var length = array.length;
	      while (length--) {
	        if (eq(array[length][0], key)) {
	          return length;
	        }
	      }
	      return -1;
	    }

	    /**
	     * Aggregates elements of `collection` on `accumulator` with keys transformed
	     * by `iteratee` and values set by `setter`.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} setter The function to set `accumulator` values.
	     * @param {Function} iteratee The iteratee to transform keys.
	     * @param {Object} accumulator The initial aggregated object.
	     * @returns {Function} Returns `accumulator`.
	     */
	    function baseAggregator(collection, setter, iteratee, accumulator) {
	      baseEach(collection, function(value, key, collection) {
	        setter(accumulator, value, iteratee(value), collection);
	      });
	      return accumulator;
	    }

	    /**
	     * The base implementation of `_.assign` without support for multiple sources
	     * or `customizer` functions.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @returns {Object} Returns `object`.
	     */
	    function baseAssign(object, source) {
	      return object && copyObject(source, keys(source), object);
	    }

	    /**
	     * The base implementation of `assignValue` and `assignMergeValue` without
	     * value checks.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {string} key The key of the property to assign.
	     * @param {*} value The value to assign.
	     */
	    function baseAssignValue(object, key, value) {
	      if (key == '__proto__' && defineProperty) {
	        defineProperty(object, key, {
	          'configurable': true,
	          'enumerable': true,
	          'value': value,
	          'writable': true
	        });
	      } else {
	        object[key] = value;
	      }
	    }

	    /**
	     * The base implementation of `_.at` without support for individual paths.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {string[]} paths The property paths of elements to pick.
	     * @returns {Array} Returns the picked elements.
	     */
	    function baseAt(object, paths) {
	      var index = -1,
	          length = paths.length,
	          result = Array(length),
	          skip = object == null;

	      while (++index < length) {
	        result[index] = skip ? undefined : get(object, paths[index]);
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.clamp` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {number} number The number to clamp.
	     * @param {number} [lower] The lower bound.
	     * @param {number} upper The upper bound.
	     * @returns {number} Returns the clamped number.
	     */
	    function baseClamp(number, lower, upper) {
	      if (number === number) {
	        if (upper !== undefined) {
	          number = number <= upper ? number : upper;
	        }
	        if (lower !== undefined) {
	          number = number >= lower ? number : lower;
	        }
	      }
	      return number;
	    }

	    /**
	     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
	     * traversed objects.
	     *
	     * @private
	     * @param {*} value The value to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @param {boolean} [isFull] Specify a clone including symbols.
	     * @param {Function} [customizer] The function to customize cloning.
	     * @param {string} [key] The key of `value`.
	     * @param {Object} [object] The parent object of `value`.
	     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
	     * @returns {*} Returns the cloned value.
	     */
	    function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
	      var result;
	      if (customizer) {
	        result = object ? customizer(value, key, object, stack) : customizer(value);
	      }
	      if (result !== undefined) {
	        return result;
	      }
	      if (!isObject(value)) {
	        return value;
	      }
	      var isArr = isArray(value);
	      if (isArr) {
	        result = initCloneArray(value);
	        if (!isDeep) {
	          return copyArray(value, result);
	        }
	      } else {
	        var tag = getTag(value),
	            isFunc = tag == funcTag || tag == genTag;

	        if (isBuffer(value)) {
	          return cloneBuffer(value, isDeep);
	        }
	        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
	          result = initCloneObject(isFunc ? {} : value);
	          if (!isDeep) {
	            return copySymbols(value, baseAssign(result, value));
	          }
	        } else {
	          if (!cloneableTags[tag]) {
	            return object ? value : {};
	          }
	          result = initCloneByTag(value, tag, baseClone, isDeep);
	        }
	      }
	      // Check for circular references and return its corresponding clone.
	      stack || (stack = new Stack);
	      var stacked = stack.get(value);
	      if (stacked) {
	        return stacked;
	      }
	      stack.set(value, result);

	      var props = isArr ? undefined : (isFull ? getAllKeys : keys)(value);
	      arrayEach(props || value, function(subValue, key) {
	        if (props) {
	          key = subValue;
	          subValue = value[key];
	        }
	        // Recursively populate clone (susceptible to call stack limits).
	        assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));
	      });
	      return result;
	    }

	    /**
	     * The base implementation of `_.conforms` which doesn't clone `source`.
	     *
	     * @private
	     * @param {Object} source The object of property predicates to conform to.
	     * @returns {Function} Returns the new spec function.
	     */
	    function baseConforms(source) {
	      var props = keys(source);
	      return function(object) {
	        return baseConformsTo(object, source, props);
	      };
	    }

	    /**
	     * The base implementation of `_.conformsTo` which accepts `props` to check.
	     *
	     * @private
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property predicates to conform to.
	     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
	     */
	    function baseConformsTo(object, source, props) {
	      var length = props.length;
	      if (object == null) {
	        return !length;
	      }
	      object = Object(object);
	      while (length--) {
	        var key = props[length],
	            predicate = source[key],
	            value = object[key];

	        if ((value === undefined && !(key in object)) || !predicate(value)) {
	          return false;
	        }
	      }
	      return true;
	    }

	    /**
	     * The base implementation of `_.delay` and `_.defer` which accepts `args`
	     * to provide to `func`.
	     *
	     * @private
	     * @param {Function} func The function to delay.
	     * @param {number} wait The number of milliseconds to delay invocation.
	     * @param {Array} args The arguments to provide to `func`.
	     * @returns {number|Object} Returns the timer id or timeout object.
	     */
	    function baseDelay(func, wait, args) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      return setTimeout(function() { func.apply(undefined, args); }, wait);
	    }

	    /**
	     * The base implementation of methods like `_.difference` without support
	     * for excluding multiple arrays or iteratee shorthands.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {Array} values The values to exclude.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     */
	    function baseDifference(array, values, iteratee, comparator) {
	      var index = -1,
	          includes = arrayIncludes,
	          isCommon = true,
	          length = array.length,
	          result = [],
	          valuesLength = values.length;

	      if (!length) {
	        return result;
	      }
	      if (iteratee) {
	        values = arrayMap(values, baseUnary(iteratee));
	      }
	      if (comparator) {
	        includes = arrayIncludesWith;
	        isCommon = false;
	      }
	      else if (values.length >= LARGE_ARRAY_SIZE) {
	        includes = cacheHas;
	        isCommon = false;
	        values = new SetCache(values);
	      }
	      outer:
	      while (++index < length) {
	        var value = array[index],
	            computed = iteratee == null ? value : iteratee(value);

	        value = (comparator || value !== 0) ? value : 0;
	        if (isCommon && computed === computed) {
	          var valuesIndex = valuesLength;
	          while (valuesIndex--) {
	            if (values[valuesIndex] === computed) {
	              continue outer;
	            }
	          }
	          result.push(value);
	        }
	        else if (!includes(values, computed, comparator)) {
	          result.push(value);
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.forEach` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array|Object} Returns `collection`.
	     */
	    var baseEach = createBaseEach(baseForOwn);

	    /**
	     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array|Object} Returns `collection`.
	     */
	    var baseEachRight = createBaseEach(baseForOwnRight, true);

	    /**
	     * The base implementation of `_.every` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {boolean} Returns `true` if all elements pass the predicate check,
	     *  else `false`
	     */
	    function baseEvery(collection, predicate) {
	      var result = true;
	      baseEach(collection, function(value, index, collection) {
	        result = !!predicate(value, index, collection);
	        return result;
	      });
	      return result;
	    }

	    /**
	     * The base implementation of methods like `_.max` and `_.min` which accepts a
	     * `comparator` to determine the extremum value.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The iteratee invoked per iteration.
	     * @param {Function} comparator The comparator used to compare values.
	     * @returns {*} Returns the extremum value.
	     */
	    function baseExtremum(array, iteratee, comparator) {
	      var index = -1,
	          length = array.length;

	      while (++index < length) {
	        var value = array[index],
	            current = iteratee(value);

	        if (current != null && (computed === undefined
	              ? (current === current && !isSymbol(current))
	              : comparator(current, computed)
	            )) {
	          var computed = current,
	              result = value;
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.fill` without an iteratee call guard.
	     *
	     * @private
	     * @param {Array} array The array to fill.
	     * @param {*} value The value to fill `array` with.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns `array`.
	     */
	    function baseFill(array, value, start, end) {
	      var length = array.length;

	      start = toInteger(start);
	      if (start < 0) {
	        start = -start > length ? 0 : (length + start);
	      }
	      end = (end === undefined || end > length) ? length : toInteger(end);
	      if (end < 0) {
	        end += length;
	      }
	      end = start > end ? 0 : toLength(end);
	      while (start < end) {
	        array[start++] = value;
	      }
	      return array;
	    }

	    /**
	     * The base implementation of `_.filter` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {Array} Returns the new filtered array.
	     */
	    function baseFilter(collection, predicate) {
	      var result = [];
	      baseEach(collection, function(value, index, collection) {
	        if (predicate(value, index, collection)) {
	          result.push(value);
	        }
	      });
	      return result;
	    }

	    /**
	     * The base implementation of `_.flatten` with support for restricting flattening.
	     *
	     * @private
	     * @param {Array} array The array to flatten.
	     * @param {number} depth The maximum recursion depth.
	     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
	     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
	     * @param {Array} [result=[]] The initial result value.
	     * @returns {Array} Returns the new flattened array.
	     */
	    function baseFlatten(array, depth, predicate, isStrict, result) {
	      var index = -1,
	          length = array.length;

	      predicate || (predicate = isFlattenable);
	      result || (result = []);

	      while (++index < length) {
	        var value = array[index];
	        if (depth > 0 && predicate(value)) {
	          if (depth > 1) {
	            // Recursively flatten arrays (susceptible to call stack limits).
	            baseFlatten(value, depth - 1, predicate, isStrict, result);
	          } else {
	            arrayPush(result, value);
	          }
	        } else if (!isStrict) {
	          result[result.length] = value;
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `baseForOwn` which iterates over `object`
	     * properties returned by `keysFunc` and invokes `iteratee` for each property.
	     * Iteratee functions may exit iteration early by explicitly returning `false`.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {Function} keysFunc The function to get the keys of `object`.
	     * @returns {Object} Returns `object`.
	     */
	    var baseFor = createBaseFor();

	    /**
	     * This function is like `baseFor` except that it iterates over properties
	     * in the opposite order.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {Function} keysFunc The function to get the keys of `object`.
	     * @returns {Object} Returns `object`.
	     */
	    var baseForRight = createBaseFor(true);

	    /**
	     * The base implementation of `_.forOwn` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     */
	    function baseForOwn(object, iteratee) {
	      return object && baseFor(object, iteratee, keys);
	    }

	    /**
	     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     */
	    function baseForOwnRight(object, iteratee) {
	      return object && baseForRight(object, iteratee, keys);
	    }

	    /**
	     * The base implementation of `_.functions` which creates an array of
	     * `object` function property names filtered from `props`.
	     *
	     * @private
	     * @param {Object} object The object to inspect.
	     * @param {Array} props The property names to filter.
	     * @returns {Array} Returns the function names.
	     */
	    function baseFunctions(object, props) {
	      return arrayFilter(props, function(key) {
	        return isFunction(object[key]);
	      });
	    }

	    /**
	     * The base implementation of `_.get` without support for default values.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the property to get.
	     * @returns {*} Returns the resolved value.
	     */
	    function baseGet(object, path) {
	      path = isKey(path, object) ? [path] : castPath(path);

	      var index = 0,
	          length = path.length;

	      while (object != null && index < length) {
	        object = object[toKey(path[index++])];
	      }
	      return (index && index == length) ? object : undefined;
	    }

	    /**
	     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
	     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
	     * symbols of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Function} keysFunc The function to get the keys of `object`.
	     * @param {Function} symbolsFunc The function to get the symbols of `object`.
	     * @returns {Array} Returns the array of property names and symbols.
	     */
	    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
	      var result = keysFunc(object);
	      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
	    }

	    /**
	     * The base implementation of `getTag` without fallbacks for buggy environments.
	     *
	     * @private
	     * @param {*} value The value to query.
	     * @returns {string} Returns the `toStringTag`.
	     */
	    function baseGetTag(value) {
	      if (value == null) {
	        return value === undefined ? undefinedTag : nullTag;
	      }
	      value = Object(value);
	      return (symToStringTag && symToStringTag in value)
	        ? getRawTag(value)
	        : objectToString(value);
	    }

	    /**
	     * The base implementation of `_.gt` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is greater than `other`,
	     *  else `false`.
	     */
	    function baseGt(value, other) {
	      return value > other;
	    }

	    /**
	     * The base implementation of `_.has` without support for deep paths.
	     *
	     * @private
	     * @param {Object} [object] The object to query.
	     * @param {Array|string} key The key to check.
	     * @returns {boolean} Returns `true` if `key` exists, else `false`.
	     */
	    function baseHas(object, key) {
	      return object != null && hasOwnProperty.call(object, key);
	    }

	    /**
	     * The base implementation of `_.hasIn` without support for deep paths.
	     *
	     * @private
	     * @param {Object} [object] The object to query.
	     * @param {Array|string} key The key to check.
	     * @returns {boolean} Returns `true` if `key` exists, else `false`.
	     */
	    function baseHasIn(object, key) {
	      return object != null && key in Object(object);
	    }

	    /**
	     * The base implementation of `_.inRange` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {number} number The number to check.
	     * @param {number} start The start of the range.
	     * @param {number} end The end of the range.
	     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
	     */
	    function baseInRange(number, start, end) {
	      return number >= nativeMin(start, end) && number < nativeMax(start, end);
	    }

	    /**
	     * The base implementation of methods like `_.intersection`, without support
	     * for iteratee shorthands, that accepts an array of arrays to inspect.
	     *
	     * @private
	     * @param {Array} arrays The arrays to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of shared values.
	     */
	    function baseIntersection(arrays, iteratee, comparator) {
	      var includes = comparator ? arrayIncludesWith : arrayIncludes,
	          length = arrays[0].length,
	          othLength = arrays.length,
	          othIndex = othLength,
	          caches = Array(othLength),
	          maxLength = Infinity,
	          result = [];

	      while (othIndex--) {
	        var array = arrays[othIndex];
	        if (othIndex && iteratee) {
	          array = arrayMap(array, baseUnary(iteratee));
	        }
	        maxLength = nativeMin(array.length, maxLength);
	        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
	          ? new SetCache(othIndex && array)
	          : undefined;
	      }
	      array = arrays[0];

	      var index = -1,
	          seen = caches[0];

	      outer:
	      while (++index < length && result.length < maxLength) {
	        var value = array[index],
	            computed = iteratee ? iteratee(value) : value;

	        value = (comparator || value !== 0) ? value : 0;
	        if (!(seen
	              ? cacheHas(seen, computed)
	              : includes(result, computed, comparator)
	            )) {
	          othIndex = othLength;
	          while (--othIndex) {
	            var cache = caches[othIndex];
	            if (!(cache
	                  ? cacheHas(cache, computed)
	                  : includes(arrays[othIndex], computed, comparator))
	                ) {
	              continue outer;
	            }
	          }
	          if (seen) {
	            seen.push(computed);
	          }
	          result.push(value);
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.invert` and `_.invertBy` which inverts
	     * `object` with values transformed by `iteratee` and set by `setter`.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} setter The function to set `accumulator` values.
	     * @param {Function} iteratee The iteratee to transform values.
	     * @param {Object} accumulator The initial inverted object.
	     * @returns {Function} Returns `accumulator`.
	     */
	    function baseInverter(object, setter, iteratee, accumulator) {
	      baseForOwn(object, function(value, key, object) {
	        setter(accumulator, iteratee(value), key, object);
	      });
	      return accumulator;
	    }

	    /**
	     * The base implementation of `_.invoke` without support for individual
	     * method arguments.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the method to invoke.
	     * @param {Array} args The arguments to invoke the method with.
	     * @returns {*} Returns the result of the invoked method.
	     */
	    function baseInvoke(object, path, args) {
	      if (!isKey(path, object)) {
	        path = castPath(path);
	        object = parent(object, path);
	        path = last(path);
	      }
	      var func = object == null ? object : object[toKey(path)];
	      return func == null ? undefined : apply(func, object, args);
	    }

	    /**
	     * The base implementation of `_.isArguments`.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	     */
	    function baseIsArguments(value) {
	      return isObjectLike(value) && baseGetTag(value) == argsTag;
	    }

	    /**
	     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
	     */
	    function baseIsArrayBuffer(value) {
	      return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
	    }

	    /**
	     * The base implementation of `_.isDate` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
	     */
	    function baseIsDate(value) {
	      return isObjectLike(value) && baseGetTag(value) == dateTag;
	    }

	    /**
	     * The base implementation of `_.isEqual` which supports partial comparisons
	     * and tracks traversed objects.
	     *
	     * @private
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @param {Function} [customizer] The function to customize comparisons.
	     * @param {boolean} [bitmask] The bitmask of comparison flags.
	     *  The bitmask may be composed of the following flags:
	     *     1 - Unordered comparison
	     *     2 - Partial comparison
	     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     */
	    function baseIsEqual(value, other, customizer, bitmask, stack) {
	      if (value === other) {
	        return true;
	      }
	      if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
	        return value !== value && other !== other;
	      }
	      return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
	    }

	    /**
	     * A specialized version of `baseIsEqual` for arrays and objects which performs
	     * deep comparisons and tracks traversed objects enabling objects with circular
	     * references to be compared.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Function} [customizer] The function to customize comparisons.
	     * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`
	     *  for more details.
	     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
	      var objIsArr = isArray(object),
	          othIsArr = isArray(other),
	          objTag = arrayTag,
	          othTag = arrayTag;

	      if (!objIsArr) {
	        objTag = getTag(object);
	        objTag = objTag == argsTag ? objectTag : objTag;
	      }
	      if (!othIsArr) {
	        othTag = getTag(other);
	        othTag = othTag == argsTag ? objectTag : othTag;
	      }
	      var objIsObj = objTag == objectTag,
	          othIsObj = othTag == objectTag,
	          isSameTag = objTag == othTag;

	      if (isSameTag && isBuffer(object)) {
	        if (!isBuffer(other)) {
	          return false;
	        }
	        objIsArr = true;
	        objIsObj = false;
	      }
	      if (isSameTag && !objIsObj) {
	        stack || (stack = new Stack);
	        return (objIsArr || isTypedArray(object))
	          ? equalArrays(object, other, equalFunc, customizer, bitmask, stack)
	          : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
	      }
	      if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
	        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
	            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

	        if (objIsWrapped || othIsWrapped) {
	          var objUnwrapped = objIsWrapped ? object.value() : object,
	              othUnwrapped = othIsWrapped ? other.value() : other;

	          stack || (stack = new Stack);
	          return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
	        }
	      }
	      if (!isSameTag) {
	        return false;
	      }
	      stack || (stack = new Stack);
	      return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
	    }

	    /**
	     * The base implementation of `_.isMap` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
	     */
	    function baseIsMap(value) {
	      return isObjectLike(value) && getTag(value) == mapTag;
	    }

	    /**
	     * The base implementation of `_.isMatch` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property values to match.
	     * @param {Array} matchData The property names, values, and compare flags to match.
	     * @param {Function} [customizer] The function to customize comparisons.
	     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	     */
	    function baseIsMatch(object, source, matchData, customizer) {
	      var index = matchData.length,
	          length = index,
	          noCustomizer = !customizer;

	      if (object == null) {
	        return !length;
	      }
	      object = Object(object);
	      while (index--) {
	        var data = matchData[index];
	        if ((noCustomizer && data[2])
	              ? data[1] !== object[data[0]]
	              : !(data[0] in object)
	            ) {
	          return false;
	        }
	      }
	      while (++index < length) {
	        data = matchData[index];
	        var key = data[0],
	            objValue = object[key],
	            srcValue = data[1];

	        if (noCustomizer && data[2]) {
	          if (objValue === undefined && !(key in object)) {
	            return false;
	          }
	        } else {
	          var stack = new Stack;
	          if (customizer) {
	            var result = customizer(objValue, srcValue, key, object, source, stack);
	          }
	          if (!(result === undefined
	                ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack)
	                : result
	              )) {
	            return false;
	          }
	        }
	      }
	      return true;
	    }

	    /**
	     * The base implementation of `_.isNative` without bad shim checks.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a native function,
	     *  else `false`.
	     */
	    function baseIsNative(value) {
	      if (!isObject(value) || isMasked(value)) {
	        return false;
	      }
	      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
	      return pattern.test(toSource(value));
	    }

	    /**
	     * The base implementation of `_.isRegExp` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
	     */
	    function baseIsRegExp(value) {
	      return isObjectLike(value) && baseGetTag(value) == regexpTag;
	    }

	    /**
	     * The base implementation of `_.isSet` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
	     */
	    function baseIsSet(value) {
	      return isObjectLike(value) && getTag(value) == setTag;
	    }

	    /**
	     * The base implementation of `_.isTypedArray` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	     */
	    function baseIsTypedArray(value) {
	      return isObjectLike(value) &&
	        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
	    }

	    /**
	     * The base implementation of `_.iteratee`.
	     *
	     * @private
	     * @param {*} [value=_.identity] The value to convert to an iteratee.
	     * @returns {Function} Returns the iteratee.
	     */
	    function baseIteratee(value) {
	      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
	      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
	      if (typeof value == 'function') {
	        return value;
	      }
	      if (value == null) {
	        return identity;
	      }
	      if (typeof value == 'object') {
	        return isArray(value)
	          ? baseMatchesProperty(value[0], value[1])
	          : baseMatches(value);
	      }
	      return property(value);
	    }

	    /**
	     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     */
	    function baseKeys(object) {
	      if (!isPrototype(object)) {
	        return nativeKeys(object);
	      }
	      var result = [];
	      for (var key in Object(object)) {
	        if (hasOwnProperty.call(object, key) && key != 'constructor') {
	          result.push(key);
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     */
	    function baseKeysIn(object) {
	      if (!isObject(object)) {
	        return nativeKeysIn(object);
	      }
	      var isProto = isPrototype(object),
	          result = [];

	      for (var key in object) {
	        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
	          result.push(key);
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.lt` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is less than `other`,
	     *  else `false`.
	     */
	    function baseLt(value, other) {
	      return value < other;
	    }

	    /**
	     * The base implementation of `_.map` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array} Returns the new mapped array.
	     */
	    function baseMap(collection, iteratee) {
	      var index = -1,
	          result = isArrayLike(collection) ? Array(collection.length) : [];

	      baseEach(collection, function(value, key, collection) {
	        result[++index] = iteratee(value, key, collection);
	      });
	      return result;
	    }

	    /**
	     * The base implementation of `_.matches` which doesn't clone `source`.
	     *
	     * @private
	     * @param {Object} source The object of property values to match.
	     * @returns {Function} Returns the new spec function.
	     */
	    function baseMatches(source) {
	      var matchData = getMatchData(source);
	      if (matchData.length == 1 && matchData[0][2]) {
	        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
	      }
	      return function(object) {
	        return object === source || baseIsMatch(object, source, matchData);
	      };
	    }

	    /**
	     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
	     *
	     * @private
	     * @param {string} path The path of the property to get.
	     * @param {*} srcValue The value to match.
	     * @returns {Function} Returns the new spec function.
	     */
	    function baseMatchesProperty(path, srcValue) {
	      if (isKey(path) && isStrictComparable(srcValue)) {
	        return matchesStrictComparable(toKey(path), srcValue);
	      }
	      return function(object) {
	        var objValue = get(object, path);
	        return (objValue === undefined && objValue === srcValue)
	          ? hasIn(object, path)
	          : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
	      };
	    }

	    /**
	     * The base implementation of `_.merge` without support for multiple sources.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @param {number} srcIndex The index of `source`.
	     * @param {Function} [customizer] The function to customize merged values.
	     * @param {Object} [stack] Tracks traversed source values and their merged
	     *  counterparts.
	     */
	    function baseMerge(object, source, srcIndex, customizer, stack) {
	      if (object === source) {
	        return;
	      }
	      baseFor(source, function(srcValue, key) {
	        if (isObject(srcValue)) {
	          stack || (stack = new Stack);
	          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
	        }
	        else {
	          var newValue = customizer
	            ? customizer(object[key], srcValue, (key + ''), object, source, stack)
	            : undefined;

	          if (newValue === undefined) {
	            newValue = srcValue;
	          }
	          assignMergeValue(object, key, newValue);
	        }
	      }, keysIn);
	    }

	    /**
	     * A specialized version of `baseMerge` for arrays and objects which performs
	     * deep merges and tracks traversed objects enabling objects with circular
	     * references to be merged.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @param {string} key The key of the value to merge.
	     * @param {number} srcIndex The index of `source`.
	     * @param {Function} mergeFunc The function to merge values.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @param {Object} [stack] Tracks traversed source values and their merged
	     *  counterparts.
	     */
	    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
	      var objValue = object[key],
	          srcValue = source[key],
	          stacked = stack.get(srcValue);

	      if (stacked) {
	        assignMergeValue(object, key, stacked);
	        return;
	      }
	      var newValue = customizer
	        ? customizer(objValue, srcValue, (key + ''), object, source, stack)
	        : undefined;

	      var isCommon = newValue === undefined;

	      if (isCommon) {
	        var isArr = isArray(srcValue),
	            isBuff = !isArr && isBuffer(srcValue),
	            isTyped = !isArr && !isBuff && isTypedArray(srcValue);

	        newValue = srcValue;
	        if (isArr || isBuff || isTyped) {
	          if (isArray(objValue)) {
	            newValue = objValue;
	          }
	          else if (isArrayLikeObject(objValue)) {
	            newValue = copyArray(objValue);
	          }
	          else if (isBuff) {
	            isCommon = false;
	            newValue = cloneBuffer(srcValue, true);
	          }
	          else if (isTyped) {
	            isCommon = false;
	            newValue = cloneTypedArray(srcValue, true);
	          }
	          else {
	            newValue = [];
	          }
	        }
	        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
	          newValue = objValue;
	          if (isArguments(objValue)) {
	            newValue = toPlainObject(objValue);
	          }
	          else if (!isObject(objValue) || (srcIndex && isFunction(objValue))) {
	            newValue = initCloneObject(srcValue);
	          }
	        }
	        else {
	          isCommon = false;
	        }
	      }
	      if (isCommon) {
	        // Recursively merge objects and arrays (susceptible to call stack limits).
	        stack.set(srcValue, newValue);
	        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
	        stack['delete'](srcValue);
	      }
	      assignMergeValue(object, key, newValue);
	    }

	    /**
	     * The base implementation of `_.nth` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {Array} array The array to query.
	     * @param {number} n The index of the element to return.
	     * @returns {*} Returns the nth element of `array`.
	     */
	    function baseNth(array, n) {
	      var length = array.length;
	      if (!length) {
	        return;
	      }
	      n += n < 0 ? length : 0;
	      return isIndex(n, length) ? array[n] : undefined;
	    }

	    /**
	     * The base implementation of `_.orderBy` without param guards.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
	     * @param {string[]} orders The sort orders of `iteratees`.
	     * @returns {Array} Returns the new sorted array.
	     */
	    function baseOrderBy(collection, iteratees, orders) {
	      var index = -1;
	      iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(getIteratee()));

	      var result = baseMap(collection, function(value, key, collection) {
	        var criteria = arrayMap(iteratees, function(iteratee) {
	          return iteratee(value);
	        });
	        return { 'criteria': criteria, 'index': ++index, 'value': value };
	      });

	      return baseSortBy(result, function(object, other) {
	        return compareMultiple(object, other, orders);
	      });
	    }

	    /**
	     * The base implementation of `_.pick` without support for individual
	     * property identifiers.
	     *
	     * @private
	     * @param {Object} object The source object.
	     * @param {string[]} props The property identifiers to pick.
	     * @returns {Object} Returns the new object.
	     */
	    function basePick(object, props) {
	      object = Object(object);
	      return basePickBy(object, props, function(value, key) {
	        return key in object;
	      });
	    }

	    /**
	     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Object} object The source object.
	     * @param {string[]} props The property identifiers to pick from.
	     * @param {Function} predicate The function invoked per property.
	     * @returns {Object} Returns the new object.
	     */
	    function basePickBy(object, props, predicate) {
	      var index = -1,
	          length = props.length,
	          result = {};

	      while (++index < length) {
	        var key = props[index],
	            value = object[key];

	        if (predicate(value, key)) {
	          baseAssignValue(result, key, value);
	        }
	      }
	      return result;
	    }

	    /**
	     * A specialized version of `baseProperty` which supports deep paths.
	     *
	     * @private
	     * @param {Array|string} path The path of the property to get.
	     * @returns {Function} Returns the new accessor function.
	     */
	    function basePropertyDeep(path) {
	      return function(object) {
	        return baseGet(object, path);
	      };
	    }

	    /**
	     * The base implementation of `_.pullAllBy` without support for iteratee
	     * shorthands.
	     *
	     * @private
	     * @param {Array} array The array to modify.
	     * @param {Array} values The values to remove.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns `array`.
	     */
	    function basePullAll(array, values, iteratee, comparator) {
	      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
	          index = -1,
	          length = values.length,
	          seen = array;

	      if (array === values) {
	        values = copyArray(values);
	      }
	      if (iteratee) {
	        seen = arrayMap(array, baseUnary(iteratee));
	      }
	      while (++index < length) {
	        var fromIndex = 0,
	            value = values[index],
	            computed = iteratee ? iteratee(value) : value;

	        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
	          if (seen !== array) {
	            splice.call(seen, fromIndex, 1);
	          }
	          splice.call(array, fromIndex, 1);
	        }
	      }
	      return array;
	    }

	    /**
	     * The base implementation of `_.pullAt` without support for individual
	     * indexes or capturing the removed elements.
	     *
	     * @private
	     * @param {Array} array The array to modify.
	     * @param {number[]} indexes The indexes of elements to remove.
	     * @returns {Array} Returns `array`.
	     */
	    function basePullAt(array, indexes) {
	      var length = array ? indexes.length : 0,
	          lastIndex = length - 1;

	      while (length--) {
	        var index = indexes[length];
	        if (length == lastIndex || index !== previous) {
	          var previous = index;
	          if (isIndex(index)) {
	            splice.call(array, index, 1);
	          }
	          else if (!isKey(index, array)) {
	            var path = castPath(index),
	                object = parent(array, path);

	            if (object != null) {
	              delete object[toKey(last(path))];
	            }
	          }
	          else {
	            delete array[toKey(index)];
	          }
	        }
	      }
	      return array;
	    }

	    /**
	     * The base implementation of `_.random` without support for returning
	     * floating-point numbers.
	     *
	     * @private
	     * @param {number} lower The lower bound.
	     * @param {number} upper The upper bound.
	     * @returns {number} Returns the random number.
	     */
	    function baseRandom(lower, upper) {
	      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
	    }

	    /**
	     * The base implementation of `_.range` and `_.rangeRight` which doesn't
	     * coerce arguments.
	     *
	     * @private
	     * @param {number} start The start of the range.
	     * @param {number} end The end of the range.
	     * @param {number} step The value to increment or decrement by.
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Array} Returns the range of numbers.
	     */
	    function baseRange(start, end, step, fromRight) {
	      var index = -1,
	          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
	          result = Array(length);

	      while (length--) {
	        result[fromRight ? length : ++index] = start;
	        start += step;
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.repeat` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {string} string The string to repeat.
	     * @param {number} n The number of times to repeat the string.
	     * @returns {string} Returns the repeated string.
	     */
	    function baseRepeat(string, n) {
	      var result = '';
	      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
	        return result;
	      }
	      // Leverage the exponentiation by squaring algorithm for a faster repeat.
	      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
	      do {
	        if (n % 2) {
	          result += string;
	        }
	        n = nativeFloor(n / 2);
	        if (n) {
	          string += string;
	        }
	      } while (n);

	      return result;
	    }

	    /**
	     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
	     *
	     * @private
	     * @param {Function} func The function to apply a rest parameter to.
	     * @param {number} [start=func.length-1] The start position of the rest parameter.
	     * @returns {Function} Returns the new function.
	     */
	    function baseRest(func, start) {
	      return setToString(overRest(func, start, identity), func + '');
	    }

	    /**
	     * The base implementation of `_.sample`.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to sample.
	     * @returns {*} Returns the random element.
	     */
	    function baseSample(collection) {
	      return arraySample(values(collection));
	    }

	    /**
	     * The base implementation of `_.sampleSize` without param guards.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to sample.
	     * @param {number} n The number of elements to sample.
	     * @returns {Array} Returns the random elements.
	     */
	    function baseSampleSize(collection, n) {
	      var array = values(collection);
	      return shuffleSelf(array, baseClamp(n, 0, array.length));
	    }

	    /**
	     * The base implementation of `_.set`.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to set.
	     * @param {*} value The value to set.
	     * @param {Function} [customizer] The function to customize path creation.
	     * @returns {Object} Returns `object`.
	     */
	    function baseSet(object, path, value, customizer) {
	      if (!isObject(object)) {
	        return object;
	      }
	      path = isKey(path, object) ? [path] : castPath(path);

	      var index = -1,
	          length = path.length,
	          lastIndex = length - 1,
	          nested = object;

	      while (nested != null && ++index < length) {
	        var key = toKey(path[index]),
	            newValue = value;

	        if (index != lastIndex) {
	          var objValue = nested[key];
	          newValue = customizer ? customizer(objValue, key, nested) : undefined;
	          if (newValue === undefined) {
	            newValue = isObject(objValue)
	              ? objValue
	              : (isIndex(path[index + 1]) ? [] : {});
	          }
	        }
	        assignValue(nested, key, newValue);
	        nested = nested[key];
	      }
	      return object;
	    }

	    /**
	     * The base implementation of `setData` without support for hot loop shorting.
	     *
	     * @private
	     * @param {Function} func The function to associate metadata with.
	     * @param {*} data The metadata.
	     * @returns {Function} Returns `func`.
	     */
	    var baseSetData = !metaMap ? identity : function(func, data) {
	      metaMap.set(func, data);
	      return func;
	    };

	    /**
	     * The base implementation of `setToString` without support for hot loop shorting.
	     *
	     * @private
	     * @param {Function} func The function to modify.
	     * @param {Function} string The `toString` result.
	     * @returns {Function} Returns `func`.
	     */
	    var baseSetToString = !defineProperty ? identity : function(func, string) {
	      return defineProperty(func, 'toString', {
	        'configurable': true,
	        'enumerable': false,
	        'value': constant(string),
	        'writable': true
	      });
	    };

	    /**
	     * The base implementation of `_.shuffle`.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to shuffle.
	     * @returns {Array} Returns the new shuffled array.
	     */
	    function baseShuffle(collection) {
	      return shuffleSelf(values(collection));
	    }

	    /**
	     * The base implementation of `_.slice` without an iteratee call guard.
	     *
	     * @private
	     * @param {Array} array The array to slice.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns the slice of `array`.
	     */
	    function baseSlice(array, start, end) {
	      var index = -1,
	          length = array.length;

	      if (start < 0) {
	        start = -start > length ? 0 : (length + start);
	      }
	      end = end > length ? length : end;
	      if (end < 0) {
	        end += length;
	      }
	      length = start > end ? 0 : ((end - start) >>> 0);
	      start >>>= 0;

	      var result = Array(length);
	      while (++index < length) {
	        result[index] = array[index + start];
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.some` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {boolean} Returns `true` if any element passes the predicate check,
	     *  else `false`.
	     */
	    function baseSome(collection, predicate) {
	      var result;

	      baseEach(collection, function(value, index, collection) {
	        result = predicate(value, index, collection);
	        return !result;
	      });
	      return !!result;
	    }

	    /**
	     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
	     * performs a binary search of `array` to determine the index at which `value`
	     * should be inserted into `array` in order to maintain its sort order.
	     *
	     * @private
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {boolean} [retHighest] Specify returning the highest qualified index.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     */
	    function baseSortedIndex(array, value, retHighest) {
	      var low = 0,
	          high = array == null ? low : array.length;

	      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
	        while (low < high) {
	          var mid = (low + high) >>> 1,
	              computed = array[mid];

	          if (computed !== null && !isSymbol(computed) &&
	              (retHighest ? (computed <= value) : (computed < value))) {
	            low = mid + 1;
	          } else {
	            high = mid;
	          }
	        }
	        return high;
	      }
	      return baseSortedIndexBy(array, value, identity, retHighest);
	    }

	    /**
	     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
	     * which invokes `iteratee` for `value` and each element of `array` to compute
	     * their sort ranking. The iteratee is invoked with one argument; (value).
	     *
	     * @private
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function} iteratee The iteratee invoked per element.
	     * @param {boolean} [retHighest] Specify returning the highest qualified index.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     */
	    function baseSortedIndexBy(array, value, iteratee, retHighest) {
	      value = iteratee(value);

	      var low = 0,
	          high = array == null ? 0 : array.length,
	          valIsNaN = value !== value,
	          valIsNull = value === null,
	          valIsSymbol = isSymbol(value),
	          valIsUndefined = value === undefined;

	      while (low < high) {
	        var mid = nativeFloor((low + high) / 2),
	            computed = iteratee(array[mid]),
	            othIsDefined = computed !== undefined,
	            othIsNull = computed === null,
	            othIsReflexive = computed === computed,
	            othIsSymbol = isSymbol(computed);

	        if (valIsNaN) {
	          var setLow = retHighest || othIsReflexive;
	        } else if (valIsUndefined) {
	          setLow = othIsReflexive && (retHighest || othIsDefined);
	        } else if (valIsNull) {
	          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
	        } else if (valIsSymbol) {
	          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
	        } else if (othIsNull || othIsSymbol) {
	          setLow = false;
	        } else {
	          setLow = retHighest ? (computed <= value) : (computed < value);
	        }
	        if (setLow) {
	          low = mid + 1;
	        } else {
	          high = mid;
	        }
	      }
	      return nativeMin(high, MAX_ARRAY_INDEX);
	    }

	    /**
	     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
	     * support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     */
	    function baseSortedUniq(array, iteratee) {
	      var index = -1,
	          length = array.length,
	          resIndex = 0,
	          result = [];

	      while (++index < length) {
	        var value = array[index],
	            computed = iteratee ? iteratee(value) : value;

	        if (!index || !eq(computed, seen)) {
	          var seen = computed;
	          result[resIndex++] = value === 0 ? 0 : value;
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.toNumber` which doesn't ensure correct
	     * conversions of binary, hexadecimal, or octal string values.
	     *
	     * @private
	     * @param {*} value The value to process.
	     * @returns {number} Returns the number.
	     */
	    function baseToNumber(value) {
	      if (typeof value == 'number') {
	        return value;
	      }
	      if (isSymbol(value)) {
	        return NAN;
	      }
	      return +value;
	    }

	    /**
	     * The base implementation of `_.toString` which doesn't convert nullish
	     * values to empty strings.
	     *
	     * @private
	     * @param {*} value The value to process.
	     * @returns {string} Returns the string.
	     */
	    function baseToString(value) {
	      // Exit early for strings to avoid a performance hit in some environments.
	      if (typeof value == 'string') {
	        return value;
	      }
	      if (isArray(value)) {
	        // Recursively convert values (susceptible to call stack limits).
	        return arrayMap(value, baseToString) + '';
	      }
	      if (isSymbol(value)) {
	        return symbolToString ? symbolToString.call(value) : '';
	      }
	      var result = (value + '');
	      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	    }

	    /**
	     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     */
	    function baseUniq(array, iteratee, comparator) {
	      var index = -1,
	          includes = arrayIncludes,
	          length = array.length,
	          isCommon = true,
	          result = [],
	          seen = result;

	      if (comparator) {
	        isCommon = false;
	        includes = arrayIncludesWith;
	      }
	      else if (length >= LARGE_ARRAY_SIZE) {
	        var set = iteratee ? null : createSet(array);
	        if (set) {
	          return setToArray(set);
	        }
	        isCommon = false;
	        includes = cacheHas;
	        seen = new SetCache;
	      }
	      else {
	        seen = iteratee ? [] : result;
	      }
	      outer:
	      while (++index < length) {
	        var value = array[index],
	            computed = iteratee ? iteratee(value) : value;

	        value = (comparator || value !== 0) ? value : 0;
	        if (isCommon && computed === computed) {
	          var seenIndex = seen.length;
	          while (seenIndex--) {
	            if (seen[seenIndex] === computed) {
	              continue outer;
	            }
	          }
	          if (iteratee) {
	            seen.push(computed);
	          }
	          result.push(value);
	        }
	        else if (!includes(seen, computed, comparator)) {
	          if (seen !== result) {
	            seen.push(computed);
	          }
	          result.push(value);
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.unset`.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to unset.
	     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
	     */
	    function baseUnset(object, path) {
	      path = isKey(path, object) ? [path] : castPath(path);
	      object = parent(object, path);

	      var key = toKey(last(path));
	      return !(object != null && hasOwnProperty.call(object, key)) || delete object[key];
	    }

	    /**
	     * The base implementation of `_.update`.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to update.
	     * @param {Function} updater The function to produce the updated value.
	     * @param {Function} [customizer] The function to customize path creation.
	     * @returns {Object} Returns `object`.
	     */
	    function baseUpdate(object, path, updater, customizer) {
	      return baseSet(object, path, updater(baseGet(object, path)), customizer);
	    }

	    /**
	     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
	     * without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array} array The array to query.
	     * @param {Function} predicate The function invoked per iteration.
	     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Array} Returns the slice of `array`.
	     */
	    function baseWhile(array, predicate, isDrop, fromRight) {
	      var length = array.length,
	          index = fromRight ? length : -1;

	      while ((fromRight ? index-- : ++index < length) &&
	        predicate(array[index], index, array)) {}

	      return isDrop
	        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
	        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
	    }

	    /**
	     * The base implementation of `wrapperValue` which returns the result of
	     * performing a sequence of actions on the unwrapped `value`, where each
	     * successive action is supplied the return value of the previous.
	     *
	     * @private
	     * @param {*} value The unwrapped value.
	     * @param {Array} actions Actions to perform to resolve the unwrapped value.
	     * @returns {*} Returns the resolved value.
	     */
	    function baseWrapperValue(value, actions) {
	      var result = value;
	      if (result instanceof LazyWrapper) {
	        result = result.value();
	      }
	      return arrayReduce(actions, function(result, action) {
	        return action.func.apply(action.thisArg, arrayPush([result], action.args));
	      }, result);
	    }

	    /**
	     * The base implementation of methods like `_.xor`, without support for
	     * iteratee shorthands, that accepts an array of arrays to inspect.
	     *
	     * @private
	     * @param {Array} arrays The arrays to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of values.
	     */
	    function baseXor(arrays, iteratee, comparator) {
	      var length = arrays.length;
	      if (length < 2) {
	        return length ? baseUniq(arrays[0]) : [];
	      }
	      var index = -1,
	          result = Array(length);

	      while (++index < length) {
	        var array = arrays[index],
	            othIndex = -1;

	        while (++othIndex < length) {
	          if (othIndex != index) {
	            result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
	          }
	        }
	      }
	      return baseUniq(baseFlatten(result, 1), iteratee, comparator);
	    }

	    /**
	     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
	     *
	     * @private
	     * @param {Array} props The property identifiers.
	     * @param {Array} values The property values.
	     * @param {Function} assignFunc The function to assign values.
	     * @returns {Object} Returns the new object.
	     */
	    function baseZipObject(props, values, assignFunc) {
	      var index = -1,
	          length = props.length,
	          valsLength = values.length,
	          result = {};

	      while (++index < length) {
	        var value = index < valsLength ? values[index] : undefined;
	        assignFunc(result, props[index], value);
	      }
	      return result;
	    }

	    /**
	     * Casts `value` to an empty array if it's not an array like object.
	     *
	     * @private
	     * @param {*} value The value to inspect.
	     * @returns {Array|Object} Returns the cast array-like object.
	     */
	    function castArrayLikeObject(value) {
	      return isArrayLikeObject(value) ? value : [];
	    }

	    /**
	     * Casts `value` to `identity` if it's not a function.
	     *
	     * @private
	     * @param {*} value The value to inspect.
	     * @returns {Function} Returns cast function.
	     */
	    function castFunction(value) {
	      return typeof value == 'function' ? value : identity;
	    }

	    /**
	     * Casts `value` to a path array if it's not one.
	     *
	     * @private
	     * @param {*} value The value to inspect.
	     * @returns {Array} Returns the cast property path array.
	     */
	    function castPath(value) {
	      return isArray(value) ? value : stringToPath(value);
	    }

	    /**
	     * A `baseRest` alias which can be replaced with `identity` by module
	     * replacement plugins.
	     *
	     * @private
	     * @type {Function}
	     * @param {Function} func The function to apply a rest parameter to.
	     * @returns {Function} Returns the new function.
	     */
	    var castRest = baseRest;

	    /**
	     * Casts `array` to a slice if it's needed.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {number} start The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns the cast slice.
	     */
	    function castSlice(array, start, end) {
	      var length = array.length;
	      end = end === undefined ? length : end;
	      return (!start && end >= length) ? array : baseSlice(array, start, end);
	    }

	    /**
	     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
	     *
	     * @private
	     * @param {number|Object} id The timer id or timeout object of the timer to clear.
	     */
	    var clearTimeout = ctxClearTimeout || function(id) {
	      return root.clearTimeout(id);
	    };

	    /**
	     * Creates a clone of  `buffer`.
	     *
	     * @private
	     * @param {Buffer} buffer The buffer to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Buffer} Returns the cloned buffer.
	     */
	    function cloneBuffer(buffer, isDeep) {
	      if (isDeep) {
	        return buffer.slice();
	      }
	      var length = buffer.length,
	          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

	      buffer.copy(result);
	      return result;
	    }

	    /**
	     * Creates a clone of `arrayBuffer`.
	     *
	     * @private
	     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
	     * @returns {ArrayBuffer} Returns the cloned array buffer.
	     */
	    function cloneArrayBuffer(arrayBuffer) {
	      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
	      new Uint8Array(result).set(new Uint8Array(arrayBuffer));
	      return result;
	    }

	    /**
	     * Creates a clone of `dataView`.
	     *
	     * @private
	     * @param {Object} dataView The data view to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Object} Returns the cloned data view.
	     */
	    function cloneDataView(dataView, isDeep) {
	      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
	      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
	    }

	    /**
	     * Creates a clone of `map`.
	     *
	     * @private
	     * @param {Object} map The map to clone.
	     * @param {Function} cloneFunc The function to clone values.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Object} Returns the cloned map.
	     */
	    function cloneMap(map, isDeep, cloneFunc) {
	      var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
	      return arrayReduce(array, addMapEntry, new map.constructor);
	    }

	    /**
	     * Creates a clone of `regexp`.
	     *
	     * @private
	     * @param {Object} regexp The regexp to clone.
	     * @returns {Object} Returns the cloned regexp.
	     */
	    function cloneRegExp(regexp) {
	      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
	      result.lastIndex = regexp.lastIndex;
	      return result;
	    }

	    /**
	     * Creates a clone of `set`.
	     *
	     * @private
	     * @param {Object} set The set to clone.
	     * @param {Function} cloneFunc The function to clone values.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Object} Returns the cloned set.
	     */
	    function cloneSet(set, isDeep, cloneFunc) {
	      var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
	      return arrayReduce(array, addSetEntry, new set.constructor);
	    }

	    /**
	     * Creates a clone of the `symbol` object.
	     *
	     * @private
	     * @param {Object} symbol The symbol object to clone.
	     * @returns {Object} Returns the cloned symbol object.
	     */
	    function cloneSymbol(symbol) {
	      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
	    }

	    /**
	     * Creates a clone of `typedArray`.
	     *
	     * @private
	     * @param {Object} typedArray The typed array to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Object} Returns the cloned typed array.
	     */
	    function cloneTypedArray(typedArray, isDeep) {
	      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
	      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
	    }

	    /**
	     * Compares values to sort them in ascending order.
	     *
	     * @private
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {number} Returns the sort order indicator for `value`.
	     */
	    function compareAscending(value, other) {
	      if (value !== other) {
	        var valIsDefined = value !== undefined,
	            valIsNull = value === null,
	            valIsReflexive = value === value,
	            valIsSymbol = isSymbol(value);

	        var othIsDefined = other !== undefined,
	            othIsNull = other === null,
	            othIsReflexive = other === other,
	            othIsSymbol = isSymbol(other);

	        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
	            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
	            (valIsNull && othIsDefined && othIsReflexive) ||
	            (!valIsDefined && othIsReflexive) ||
	            !valIsReflexive) {
	          return 1;
	        }
	        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
	            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
	            (othIsNull && valIsDefined && valIsReflexive) ||
	            (!othIsDefined && valIsReflexive) ||
	            !othIsReflexive) {
	          return -1;
	        }
	      }
	      return 0;
	    }

	    /**
	     * Used by `_.orderBy` to compare multiple properties of a value to another
	     * and stable sort them.
	     *
	     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
	     * specify an order of "desc" for descending or "asc" for ascending sort order
	     * of corresponding values.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {boolean[]|string[]} orders The order to sort by for each property.
	     * @returns {number} Returns the sort order indicator for `object`.
	     */
	    function compareMultiple(object, other, orders) {
	      var index = -1,
	          objCriteria = object.criteria,
	          othCriteria = other.criteria,
	          length = objCriteria.length,
	          ordersLength = orders.length;

	      while (++index < length) {
	        var result = compareAscending(objCriteria[index], othCriteria[index]);
	        if (result) {
	          if (index >= ordersLength) {
	            return result;
	          }
	          var order = orders[index];
	          return result * (order == 'desc' ? -1 : 1);
	        }
	      }
	      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
	      // that causes it, under certain circumstances, to provide the same value for
	      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
	      // for more details.
	      //
	      // This also ensures a stable sort in V8 and other engines.
	      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
	      return object.index - other.index;
	    }

	    /**
	     * Creates an array that is the composition of partially applied arguments,
	     * placeholders, and provided arguments into a single array of arguments.
	     *
	     * @private
	     * @param {Array} args The provided arguments.
	     * @param {Array} partials The arguments to prepend to those provided.
	     * @param {Array} holders The `partials` placeholder indexes.
	     * @params {boolean} [isCurried] Specify composing for a curried function.
	     * @returns {Array} Returns the new array of composed arguments.
	     */
	    function composeArgs(args, partials, holders, isCurried) {
	      var argsIndex = -1,
	          argsLength = args.length,
	          holdersLength = holders.length,
	          leftIndex = -1,
	          leftLength = partials.length,
	          rangeLength = nativeMax(argsLength - holdersLength, 0),
	          result = Array(leftLength + rangeLength),
	          isUncurried = !isCurried;

	      while (++leftIndex < leftLength) {
	        result[leftIndex] = partials[leftIndex];
	      }
	      while (++argsIndex < holdersLength) {
	        if (isUncurried || argsIndex < argsLength) {
	          result[holders[argsIndex]] = args[argsIndex];
	        }
	      }
	      while (rangeLength--) {
	        result[leftIndex++] = args[argsIndex++];
	      }
	      return result;
	    }

	    /**
	     * This function is like `composeArgs` except that the arguments composition
	     * is tailored for `_.partialRight`.
	     *
	     * @private
	     * @param {Array} args The provided arguments.
	     * @param {Array} partials The arguments to append to those provided.
	     * @param {Array} holders The `partials` placeholder indexes.
	     * @params {boolean} [isCurried] Specify composing for a curried function.
	     * @returns {Array} Returns the new array of composed arguments.
	     */
	    function composeArgsRight(args, partials, holders, isCurried) {
	      var argsIndex = -1,
	          argsLength = args.length,
	          holdersIndex = -1,
	          holdersLength = holders.length,
	          rightIndex = -1,
	          rightLength = partials.length,
	          rangeLength = nativeMax(argsLength - holdersLength, 0),
	          result = Array(rangeLength + rightLength),
	          isUncurried = !isCurried;

	      while (++argsIndex < rangeLength) {
	        result[argsIndex] = args[argsIndex];
	      }
	      var offset = argsIndex;
	      while (++rightIndex < rightLength) {
	        result[offset + rightIndex] = partials[rightIndex];
	      }
	      while (++holdersIndex < holdersLength) {
	        if (isUncurried || argsIndex < argsLength) {
	          result[offset + holders[holdersIndex]] = args[argsIndex++];
	        }
	      }
	      return result;
	    }

	    /**
	     * Copies the values of `source` to `array`.
	     *
	     * @private
	     * @param {Array} source The array to copy values from.
	     * @param {Array} [array=[]] The array to copy values to.
	     * @returns {Array} Returns `array`.
	     */
	    function copyArray(source, array) {
	      var index = -1,
	          length = source.length;

	      array || (array = Array(length));
	      while (++index < length) {
	        array[index] = source[index];
	      }
	      return array;
	    }

	    /**
	     * Copies properties of `source` to `object`.
	     *
	     * @private
	     * @param {Object} source The object to copy properties from.
	     * @param {Array} props The property identifiers to copy.
	     * @param {Object} [object={}] The object to copy properties to.
	     * @param {Function} [customizer] The function to customize copied values.
	     * @returns {Object} Returns `object`.
	     */
	    function copyObject(source, props, object, customizer) {
	      var isNew = !object;
	      object || (object = {});

	      var index = -1,
	          length = props.length;

	      while (++index < length) {
	        var key = props[index];

	        var newValue = customizer
	          ? customizer(object[key], source[key], key, object, source)
	          : undefined;

	        if (newValue === undefined) {
	          newValue = source[key];
	        }
	        if (isNew) {
	          baseAssignValue(object, key, newValue);
	        } else {
	          assignValue(object, key, newValue);
	        }
	      }
	      return object;
	    }

	    /**
	     * Copies own symbol properties of `source` to `object`.
	     *
	     * @private
	     * @param {Object} source The object to copy symbols from.
	     * @param {Object} [object={}] The object to copy symbols to.
	     * @returns {Object} Returns `object`.
	     */
	    function copySymbols(source, object) {
	      return copyObject(source, getSymbols(source), object);
	    }

	    /**
	     * Creates a function like `_.groupBy`.
	     *
	     * @private
	     * @param {Function} setter The function to set accumulator values.
	     * @param {Function} [initializer] The accumulator object initializer.
	     * @returns {Function} Returns the new aggregator function.
	     */
	    function createAggregator(setter, initializer) {
	      return function(collection, iteratee) {
	        var func = isArray(collection) ? arrayAggregator : baseAggregator,
	            accumulator = initializer ? initializer() : {};

	        return func(collection, setter, getIteratee(iteratee, 2), accumulator);
	      };
	    }

	    /**
	     * Creates a function like `_.assign`.
	     *
	     * @private
	     * @param {Function} assigner The function to assign values.
	     * @returns {Function} Returns the new assigner function.
	     */
	    function createAssigner(assigner) {
	      return baseRest(function(object, sources) {
	        var index = -1,
	            length = sources.length,
	            customizer = length > 1 ? sources[length - 1] : undefined,
	            guard = length > 2 ? sources[2] : undefined;

	        customizer = (assigner.length > 3 && typeof customizer == 'function')
	          ? (length--, customizer)
	          : undefined;

	        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
	          customizer = length < 3 ? undefined : customizer;
	          length = 1;
	        }
	        object = Object(object);
	        while (++index < length) {
	          var source = sources[index];
	          if (source) {
	            assigner(object, source, index, customizer);
	          }
	        }
	        return object;
	      });
	    }

	    /**
	     * Creates a `baseEach` or `baseEachRight` function.
	     *
	     * @private
	     * @param {Function} eachFunc The function to iterate over a collection.
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new base function.
	     */
	    function createBaseEach(eachFunc, fromRight) {
	      return function(collection, iteratee) {
	        if (collection == null) {
	          return collection;
	        }
	        if (!isArrayLike(collection)) {
	          return eachFunc(collection, iteratee);
	        }
	        var length = collection.length,
	            index = fromRight ? length : -1,
	            iterable = Object(collection);

	        while ((fromRight ? index-- : ++index < length)) {
	          if (iteratee(iterable[index], index, iterable) === false) {
	            break;
	          }
	        }
	        return collection;
	      };
	    }

	    /**
	     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new base function.
	     */
	    function createBaseFor(fromRight) {
	      return function(object, iteratee, keysFunc) {
	        var index = -1,
	            iterable = Object(object),
	            props = keysFunc(object),
	            length = props.length;

	        while (length--) {
	          var key = props[fromRight ? length : ++index];
	          if (iteratee(iterable[key], key, iterable) === false) {
	            break;
	          }
	        }
	        return object;
	      };
	    }

	    /**
	     * Creates a function that wraps `func` to invoke it with the optional `this`
	     * binding of `thisArg`.
	     *
	     * @private
	     * @param {Function} func The function to wrap.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createBind(func, bitmask, thisArg) {
	      var isBind = bitmask & BIND_FLAG,
	          Ctor = createCtor(func);

	      function wrapper() {
	        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
	        return fn.apply(isBind ? thisArg : this, arguments);
	      }
	      return wrapper;
	    }

	    /**
	     * Creates a function like `_.lowerFirst`.
	     *
	     * @private
	     * @param {string} methodName The name of the `String` case method to use.
	     * @returns {Function} Returns the new case function.
	     */
	    function createCaseFirst(methodName) {
	      return function(string) {
	        string = toString(string);

	        var strSymbols = hasUnicode(string)
	          ? stringToArray(string)
	          : undefined;

	        var chr = strSymbols
	          ? strSymbols[0]
	          : string.charAt(0);

	        var trailing = strSymbols
	          ? castSlice(strSymbols, 1).join('')
	          : string.slice(1);

	        return chr[methodName]() + trailing;
	      };
	    }

	    /**
	     * Creates a function like `_.camelCase`.
	     *
	     * @private
	     * @param {Function} callback The function to combine each word.
	     * @returns {Function} Returns the new compounder function.
	     */
	    function createCompounder(callback) {
	      return function(string) {
	        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
	      };
	    }

	    /**
	     * Creates a function that produces an instance of `Ctor` regardless of
	     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
	     *
	     * @private
	     * @param {Function} Ctor The constructor to wrap.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createCtor(Ctor) {
	      return function() {
	        // Use a `switch` statement to work with class constructors. See
	        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
	        // for more details.
	        var args = arguments;
	        switch (args.length) {
	          case 0: return new Ctor;
	          case 1: return new Ctor(args[0]);
	          case 2: return new Ctor(args[0], args[1]);
	          case 3: return new Ctor(args[0], args[1], args[2]);
	          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
	          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
	          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
	          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
	        }
	        var thisBinding = baseCreate(Ctor.prototype),
	            result = Ctor.apply(thisBinding, args);

	        // Mimic the constructor's `return` behavior.
	        // See https://es5.github.io/#x13.2.2 for more details.
	        return isObject(result) ? result : thisBinding;
	      };
	    }

	    /**
	     * Creates a function that wraps `func` to enable currying.
	     *
	     * @private
	     * @param {Function} func The function to wrap.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @param {number} arity The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createCurry(func, bitmask, arity) {
	      var Ctor = createCtor(func);

	      function wrapper() {
	        var length = arguments.length,
	            args = Array(length),
	            index = length,
	            placeholder = getHolder(wrapper);

	        while (index--) {
	          args[index] = arguments[index];
	        }
	        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
	          ? []
	          : replaceHolders(args, placeholder);

	        length -= holders.length;
	        if (length < arity) {
	          return createRecurry(
	            func, bitmask, createHybrid, wrapper.placeholder, undefined,
	            args, holders, undefined, undefined, arity - length);
	        }
	        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
	        return apply(fn, this, args);
	      }
	      return wrapper;
	    }

	    /**
	     * Creates a `_.find` or `_.findLast` function.
	     *
	     * @private
	     * @param {Function} findIndexFunc The function to find the collection index.
	     * @returns {Function} Returns the new find function.
	     */
	    function createFind(findIndexFunc) {
	      return function(collection, predicate, fromIndex) {
	        var iterable = Object(collection);
	        if (!isArrayLike(collection)) {
	          var iteratee = getIteratee(predicate, 3);
	          collection = keys(collection);
	          predicate = function(key) { return iteratee(iterable[key], key, iterable); };
	        }
	        var index = findIndexFunc(collection, predicate, fromIndex);
	        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
	      };
	    }

	    /**
	     * Creates a `_.flow` or `_.flowRight` function.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new flow function.
	     */
	    function createFlow(fromRight) {
	      return flatRest(function(funcs) {
	        var length = funcs.length,
	            index = length,
	            prereq = LodashWrapper.prototype.thru;

	        if (fromRight) {
	          funcs.reverse();
	        }
	        while (index--) {
	          var func = funcs[index];
	          if (typeof func != 'function') {
	            throw new TypeError(FUNC_ERROR_TEXT);
	          }
	          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
	            var wrapper = new LodashWrapper([], true);
	          }
	        }
	        index = wrapper ? index : length;
	        while (++index < length) {
	          func = funcs[index];

	          var funcName = getFuncName(func),
	              data = funcName == 'wrapper' ? getData(func) : undefined;

	          if (data && isLaziable(data[0]) &&
	                data[1] == (ARY_FLAG | CURRY_FLAG | PARTIAL_FLAG | REARG_FLAG) &&
	                !data[4].length && data[9] == 1
	              ) {
	            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
	          } else {
	            wrapper = (func.length == 1 && isLaziable(func))
	              ? wrapper[funcName]()
	              : wrapper.thru(func);
	          }
	        }
	        return function() {
	          var args = arguments,
	              value = args[0];

	          if (wrapper && args.length == 1 &&
	              isArray(value) && value.length >= LARGE_ARRAY_SIZE) {
	            return wrapper.plant(value).value();
	          }
	          var index = 0,
	              result = length ? funcs[index].apply(this, args) : value;

	          while (++index < length) {
	            result = funcs[index].call(this, result);
	          }
	          return result;
	        };
	      });
	    }

	    /**
	     * Creates a function that wraps `func` to invoke it with optional `this`
	     * binding of `thisArg`, partial application, and currying.
	     *
	     * @private
	     * @param {Function|string} func The function or method name to wrap.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {Array} [partials] The arguments to prepend to those provided to
	     *  the new function.
	     * @param {Array} [holders] The `partials` placeholder indexes.
	     * @param {Array} [partialsRight] The arguments to append to those provided
	     *  to the new function.
	     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
	     * @param {Array} [argPos] The argument positions of the new function.
	     * @param {number} [ary] The arity cap of `func`.
	     * @param {number} [arity] The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
	      var isAry = bitmask & ARY_FLAG,
	          isBind = bitmask & BIND_FLAG,
	          isBindKey = bitmask & BIND_KEY_FLAG,
	          isCurried = bitmask & (CURRY_FLAG | CURRY_RIGHT_FLAG),
	          isFlip = bitmask & FLIP_FLAG,
	          Ctor = isBindKey ? undefined : createCtor(func);

	      function wrapper() {
	        var length = arguments.length,
	            args = Array(length),
	            index = length;

	        while (index--) {
	          args[index] = arguments[index];
	        }
	        if (isCurried) {
	          var placeholder = getHolder(wrapper),
	              holdersCount = countHolders(args, placeholder);
	        }
	        if (partials) {
	          args = composeArgs(args, partials, holders, isCurried);
	        }
	        if (partialsRight) {
	          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
	        }
	        length -= holdersCount;
	        if (isCurried && length < arity) {
	          var newHolders = replaceHolders(args, placeholder);
	          return createRecurry(
	            func, bitmask, createHybrid, wrapper.placeholder, thisArg,
	            args, newHolders, argPos, ary, arity - length
	          );
	        }
	        var thisBinding = isBind ? thisArg : this,
	            fn = isBindKey ? thisBinding[func] : func;

	        length = args.length;
	        if (argPos) {
	          args = reorder(args, argPos);
	        } else if (isFlip && length > 1) {
	          args.reverse();
	        }
	        if (isAry && ary < length) {
	          args.length = ary;
	        }
	        if (this && this !== root && this instanceof wrapper) {
	          fn = Ctor || createCtor(fn);
	        }
	        return fn.apply(thisBinding, args);
	      }
	      return wrapper;
	    }

	    /**
	     * Creates a function like `_.invertBy`.
	     *
	     * @private
	     * @param {Function} setter The function to set accumulator values.
	     * @param {Function} toIteratee The function to resolve iteratees.
	     * @returns {Function} Returns the new inverter function.
	     */
	    function createInverter(setter, toIteratee) {
	      return function(object, iteratee) {
	        return baseInverter(object, setter, toIteratee(iteratee), {});
	      };
	    }

	    /**
	     * Creates a function that performs a mathematical operation on two values.
	     *
	     * @private
	     * @param {Function} operator The function to perform the operation.
	     * @param {number} [defaultValue] The value used for `undefined` arguments.
	     * @returns {Function} Returns the new mathematical operation function.
	     */
	    function createMathOperation(operator, defaultValue) {
	      return function(value, other) {
	        var result;
	        if (value === undefined && other === undefined) {
	          return defaultValue;
	        }
	        if (value !== undefined) {
	          result = value;
	        }
	        if (other !== undefined) {
	          if (result === undefined) {
	            return other;
	          }
	          if (typeof value == 'string' || typeof other == 'string') {
	            value = baseToString(value);
	            other = baseToString(other);
	          } else {
	            value = baseToNumber(value);
	            other = baseToNumber(other);
	          }
	          result = operator(value, other);
	        }
	        return result;
	      };
	    }

	    /**
	     * Creates a function like `_.over`.
	     *
	     * @private
	     * @param {Function} arrayFunc The function to iterate over iteratees.
	     * @returns {Function} Returns the new over function.
	     */
	    function createOver(arrayFunc) {
	      return flatRest(function(iteratees) {
	        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
	        return baseRest(function(args) {
	          var thisArg = this;
	          return arrayFunc(iteratees, function(iteratee) {
	            return apply(iteratee, thisArg, args);
	          });
	        });
	      });
	    }

	    /**
	     * Creates the padding for `string` based on `length`. The `chars` string
	     * is truncated if the number of characters exceeds `length`.
	     *
	     * @private
	     * @param {number} length The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padding for `string`.
	     */
	    function createPadding(length, chars) {
	      chars = chars === undefined ? ' ' : baseToString(chars);

	      var charsLength = chars.length;
	      if (charsLength < 2) {
	        return charsLength ? baseRepeat(chars, length) : chars;
	      }
	      var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
	      return hasUnicode(chars)
	        ? castSlice(stringToArray(result), 0, length).join('')
	        : result.slice(0, length);
	    }

	    /**
	     * Creates a function that wraps `func` to invoke it with the `this` binding
	     * of `thisArg` and `partials` prepended to the arguments it receives.
	     *
	     * @private
	     * @param {Function} func The function to wrap.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @param {*} thisArg The `this` binding of `func`.
	     * @param {Array} partials The arguments to prepend to those provided to
	     *  the new function.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createPartial(func, bitmask, thisArg, partials) {
	      var isBind = bitmask & BIND_FLAG,
	          Ctor = createCtor(func);

	      function wrapper() {
	        var argsIndex = -1,
	            argsLength = arguments.length,
	            leftIndex = -1,
	            leftLength = partials.length,
	            args = Array(leftLength + argsLength),
	            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

	        while (++leftIndex < leftLength) {
	          args[leftIndex] = partials[leftIndex];
	        }
	        while (argsLength--) {
	          args[leftIndex++] = arguments[++argsIndex];
	        }
	        return apply(fn, isBind ? thisArg : this, args);
	      }
	      return wrapper;
	    }

	    /**
	     * Creates a `_.range` or `_.rangeRight` function.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new range function.
	     */
	    function createRange(fromRight) {
	      return function(start, end, step) {
	        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
	          end = step = undefined;
	        }
	        // Ensure the sign of `-0` is preserved.
	        start = toFinite(start);
	        if (end === undefined) {
	          end = start;
	          start = 0;
	        } else {
	          end = toFinite(end);
	        }
	        step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);
	        return baseRange(start, end, step, fromRight);
	      };
	    }

	    /**
	     * Creates a function that performs a relational operation on two values.
	     *
	     * @private
	     * @param {Function} operator The function to perform the operation.
	     * @returns {Function} Returns the new relational operation function.
	     */
	    function createRelationalOperation(operator) {
	      return function(value, other) {
	        if (!(typeof value == 'string' && typeof other == 'string')) {
	          value = toNumber(value);
	          other = toNumber(other);
	        }
	        return operator(value, other);
	      };
	    }

	    /**
	     * Creates a function that wraps `func` to continue currying.
	     *
	     * @private
	     * @param {Function} func The function to wrap.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @param {Function} wrapFunc The function to create the `func` wrapper.
	     * @param {*} placeholder The placeholder value.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {Array} [partials] The arguments to prepend to those provided to
	     *  the new function.
	     * @param {Array} [holders] The `partials` placeholder indexes.
	     * @param {Array} [argPos] The argument positions of the new function.
	     * @param {number} [ary] The arity cap of `func`.
	     * @param {number} [arity] The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
	      var isCurry = bitmask & CURRY_FLAG,
	          newHolders = isCurry ? holders : undefined,
	          newHoldersRight = isCurry ? undefined : holders,
	          newPartials = isCurry ? partials : undefined,
	          newPartialsRight = isCurry ? undefined : partials;

	      bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);
	      bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);

	      if (!(bitmask & CURRY_BOUND_FLAG)) {
	        bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
	      }
	      var newData = [
	        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
	        newHoldersRight, argPos, ary, arity
	      ];

	      var result = wrapFunc.apply(undefined, newData);
	      if (isLaziable(func)) {
	        setData(result, newData);
	      }
	      result.placeholder = placeholder;
	      return setWrapToString(result, func, bitmask);
	    }

	    /**
	     * Creates a function like `_.round`.
	     *
	     * @private
	     * @param {string} methodName The name of the `Math` method to use when rounding.
	     * @returns {Function} Returns the new round function.
	     */
	    function createRound(methodName) {
	      var func = Math[methodName];
	      return function(number, precision) {
	        number = toNumber(number);
	        precision = nativeMin(toInteger(precision), 292);
	        if (precision) {
	          // Shift with exponential notation to avoid floating-point issues.
	          // See [MDN](https://mdn.io/round#Examples) for more details.
	          var pair = (toString(number) + 'e').split('e'),
	              value = func(pair[0] + 'e' + (+pair[1] + precision));

	          pair = (toString(value) + 'e').split('e');
	          return +(pair[0] + 'e' + (+pair[1] - precision));
	        }
	        return func(number);
	      };
	    }

	    /**
	     * Creates a set object of `values`.
	     *
	     * @private
	     * @param {Array} values The values to add to the set.
	     * @returns {Object} Returns the new set.
	     */
	    var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
	      return new Set(values);
	    };

	    /**
	     * Creates a `_.toPairs` or `_.toPairsIn` function.
	     *
	     * @private
	     * @param {Function} keysFunc The function to get the keys of a given object.
	     * @returns {Function} Returns the new pairs function.
	     */
	    function createToPairs(keysFunc) {
	      return function(object) {
	        var tag = getTag(object);
	        if (tag == mapTag) {
	          return mapToArray(object);
	        }
	        if (tag == setTag) {
	          return setToPairs(object);
	        }
	        return baseToPairs(object, keysFunc(object));
	      };
	    }

	    /**
	     * Creates a function that either curries or invokes `func` with optional
	     * `this` binding and partially applied arguments.
	     *
	     * @private
	     * @param {Function|string} func The function or method name to wrap.
	     * @param {number} bitmask The bitmask flags.
	     *  The bitmask may be composed of the following flags:
	     *     1 - `_.bind`
	     *     2 - `_.bindKey`
	     *     4 - `_.curry` or `_.curryRight` of a bound function
	     *     8 - `_.curry`
	     *    16 - `_.curryRight`
	     *    32 - `_.partial`
	     *    64 - `_.partialRight`
	     *   128 - `_.rearg`
	     *   256 - `_.ary`
	     *   512 - `_.flip`
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {Array} [partials] The arguments to be partially applied.
	     * @param {Array} [holders] The `partials` placeholder indexes.
	     * @param {Array} [argPos] The argument positions of the new function.
	     * @param {number} [ary] The arity cap of `func`.
	     * @param {number} [arity] The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
	      var isBindKey = bitmask & BIND_KEY_FLAG;
	      if (!isBindKey && typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      var length = partials ? partials.length : 0;
	      if (!length) {
	        bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
	        partials = holders = undefined;
	      }
	      ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
	      arity = arity === undefined ? arity : toInteger(arity);
	      length -= holders ? holders.length : 0;

	      if (bitmask & PARTIAL_RIGHT_FLAG) {
	        var partialsRight = partials,
	            holdersRight = holders;

	        partials = holders = undefined;
	      }
	      var data = isBindKey ? undefined : getData(func);

	      var newData = [
	        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
	        argPos, ary, arity
	      ];

	      if (data) {
	        mergeData(newData, data);
	      }
	      func = newData[0];
	      bitmask = newData[1];
	      thisArg = newData[2];
	      partials = newData[3];
	      holders = newData[4];
	      arity = newData[9] = newData[9] == null
	        ? (isBindKey ? 0 : func.length)
	        : nativeMax(newData[9] - length, 0);

	      if (!arity && bitmask & (CURRY_FLAG | CURRY_RIGHT_FLAG)) {
	        bitmask &= ~(CURRY_FLAG | CURRY_RIGHT_FLAG);
	      }
	      if (!bitmask || bitmask == BIND_FLAG) {
	        var result = createBind(func, bitmask, thisArg);
	      } else if (bitmask == CURRY_FLAG || bitmask == CURRY_RIGHT_FLAG) {
	        result = createCurry(func, bitmask, arity);
	      } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !holders.length) {
	        result = createPartial(func, bitmask, thisArg, partials);
	      } else {
	        result = createHybrid.apply(undefined, newData);
	      }
	      var setter = data ? baseSetData : setData;
	      return setWrapToString(setter(result, newData), func, bitmask);
	    }

	    /**
	     * A specialized version of `baseIsEqualDeep` for arrays with support for
	     * partial deep comparisons.
	     *
	     * @private
	     * @param {Array} array The array to compare.
	     * @param {Array} other The other array to compare.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Function} customizer The function to customize comparisons.
	     * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
	     *  for more details.
	     * @param {Object} stack Tracks traversed `array` and `other` objects.
	     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	     */
	    function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
	      var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
	          arrLength = array.length,
	          othLength = other.length;

	      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
	        return false;
	      }
	      // Assume cyclic values are equal.
	      var stacked = stack.get(array);
	      if (stacked && stack.get(other)) {
	        return stacked == other;
	      }
	      var index = -1,
	          result = true,
	          seen = (bitmask & UNORDERED_COMPARE_FLAG) ? new SetCache : undefined;

	      stack.set(array, other);
	      stack.set(other, array);

	      // Ignore non-index properties.
	      while (++index < arrLength) {
	        var arrValue = array[index],
	            othValue = other[index];

	        if (customizer) {
	          var compared = isPartial
	            ? customizer(othValue, arrValue, index, other, array, stack)
	            : customizer(arrValue, othValue, index, array, other, stack);
	        }
	        if (compared !== undefined) {
	          if (compared) {
	            continue;
	          }
	          result = false;
	          break;
	        }
	        // Recursively compare arrays (susceptible to call stack limits).
	        if (seen) {
	          if (!arraySome(other, function(othValue, othIndex) {
	                if (!cacheHas(seen, othIndex) &&
	                    (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
	                  return seen.push(othIndex);
	                }
	              })) {
	            result = false;
	            break;
	          }
	        } else if (!(
	              arrValue === othValue ||
	                equalFunc(arrValue, othValue, customizer, bitmask, stack)
	            )) {
	          result = false;
	          break;
	        }
	      }
	      stack['delete'](array);
	      stack['delete'](other);
	      return result;
	    }

	    /**
	     * A specialized version of `baseIsEqualDeep` for comparing objects of
	     * the same `toStringTag`.
	     *
	     * **Note:** This function only supports comparing values with tags of
	     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {string} tag The `toStringTag` of the objects to compare.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Function} customizer The function to customize comparisons.
	     * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
	     *  for more details.
	     * @param {Object} stack Tracks traversed `object` and `other` objects.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
	      switch (tag) {
	        case dataViewTag:
	          if ((object.byteLength != other.byteLength) ||
	              (object.byteOffset != other.byteOffset)) {
	            return false;
	          }
	          object = object.buffer;
	          other = other.buffer;

	        case arrayBufferTag:
	          if ((object.byteLength != other.byteLength) ||
	              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
	            return false;
	          }
	          return true;

	        case boolTag:
	        case dateTag:
	        case numberTag:
	          // Coerce booleans to `1` or `0` and dates to milliseconds.
	          // Invalid dates are coerced to `NaN`.
	          return eq(+object, +other);

	        case errorTag:
	          return object.name == other.name && object.message == other.message;

	        case regexpTag:
	        case stringTag:
	          // Coerce regexes to strings and treat strings, primitives and objects,
	          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
	          // for more details.
	          return object == (other + '');

	        case mapTag:
	          var convert = mapToArray;

	        case setTag:
	          var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
	          convert || (convert = setToArray);

	          if (object.size != other.size && !isPartial) {
	            return false;
	          }
	          // Assume cyclic values are equal.
	          var stacked = stack.get(object);
	          if (stacked) {
	            return stacked == other;
	          }
	          bitmask |= UNORDERED_COMPARE_FLAG;

	          // Recursively compare objects (susceptible to call stack limits).
	          stack.set(object, other);
	          var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
	          stack['delete'](object);
	          return result;

	        case symbolTag:
	          if (symbolValueOf) {
	            return symbolValueOf.call(object) == symbolValueOf.call(other);
	          }
	      }
	      return false;
	    }

	    /**
	     * A specialized version of `baseIsEqualDeep` for objects with support for
	     * partial deep comparisons.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Function} customizer The function to customize comparisons.
	     * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
	     *  for more details.
	     * @param {Object} stack Tracks traversed `object` and `other` objects.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
	      var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
	          objProps = keys(object),
	          objLength = objProps.length,
	          othProps = keys(other),
	          othLength = othProps.length;

	      if (objLength != othLength && !isPartial) {
	        return false;
	      }
	      var index = objLength;
	      while (index--) {
	        var key = objProps[index];
	        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
	          return false;
	        }
	      }
	      // Assume cyclic values are equal.
	      var stacked = stack.get(object);
	      if (stacked && stack.get(other)) {
	        return stacked == other;
	      }
	      var result = true;
	      stack.set(object, other);
	      stack.set(other, object);

	      var skipCtor = isPartial;
	      while (++index < objLength) {
	        key = objProps[index];
	        var objValue = object[key],
	            othValue = other[key];

	        if (customizer) {
	          var compared = isPartial
	            ? customizer(othValue, objValue, key, other, object, stack)
	            : customizer(objValue, othValue, key, object, other, stack);
	        }
	        // Recursively compare objects (susceptible to call stack limits).
	        if (!(compared === undefined
	              ? (objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack))
	              : compared
	            )) {
	          result = false;
	          break;
	        }
	        skipCtor || (skipCtor = key == 'constructor');
	      }
	      if (result && !skipCtor) {
	        var objCtor = object.constructor,
	            othCtor = other.constructor;

	        // Non `Object` object instances with different constructors are not equal.
	        if (objCtor != othCtor &&
	            ('constructor' in object && 'constructor' in other) &&
	            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
	              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	          result = false;
	        }
	      }
	      stack['delete'](object);
	      stack['delete'](other);
	      return result;
	    }

	    /**
	     * A specialized version of `baseRest` which flattens the rest array.
	     *
	     * @private
	     * @param {Function} func The function to apply a rest parameter to.
	     * @returns {Function} Returns the new function.
	     */
	    function flatRest(func) {
	      return setToString(overRest(func, undefined, flatten), func + '');
	    }

	    /**
	     * Creates an array of own enumerable property names and symbols of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names and symbols.
	     */
	    function getAllKeys(object) {
	      return baseGetAllKeys(object, keys, getSymbols);
	    }

	    /**
	     * Creates an array of own and inherited enumerable property names and
	     * symbols of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names and symbols.
	     */
	    function getAllKeysIn(object) {
	      return baseGetAllKeys(object, keysIn, getSymbolsIn);
	    }

	    /**
	     * Gets metadata for `func`.
	     *
	     * @private
	     * @param {Function} func The function to query.
	     * @returns {*} Returns the metadata for `func`.
	     */
	    var getData = !metaMap ? noop : function(func) {
	      return metaMap.get(func);
	    };

	    /**
	     * Gets the name of `func`.
	     *
	     * @private
	     * @param {Function} func The function to query.
	     * @returns {string} Returns the function name.
	     */
	    function getFuncName(func) {
	      var result = (func.name + ''),
	          array = realNames[result],
	          length = hasOwnProperty.call(realNames, result) ? array.length : 0;

	      while (length--) {
	        var data = array[length],
	            otherFunc = data.func;
	        if (otherFunc == null || otherFunc == func) {
	          return data.name;
	        }
	      }
	      return result;
	    }

	    /**
	     * Gets the argument placeholder value for `func`.
	     *
	     * @private
	     * @param {Function} func The function to inspect.
	     * @returns {*} Returns the placeholder value.
	     */
	    function getHolder(func) {
	      var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
	      return object.placeholder;
	    }

	    /**
	     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
	     * this function returns the custom method, otherwise it returns `baseIteratee`.
	     * If arguments are provided, the chosen function is invoked with them and
	     * its result is returned.
	     *
	     * @private
	     * @param {*} [value] The value to convert to an iteratee.
	     * @param {number} [arity] The arity of the created iteratee.
	     * @returns {Function} Returns the chosen function or its result.
	     */
	    function getIteratee() {
	      var result = lodash.iteratee || iteratee;
	      result = result === iteratee ? baseIteratee : result;
	      return arguments.length ? result(arguments[0], arguments[1]) : result;
	    }

	    /**
	     * Gets the data for `map`.
	     *
	     * @private
	     * @param {Object} map The map to query.
	     * @param {string} key The reference key.
	     * @returns {*} Returns the map data.
	     */
	    function getMapData(map, key) {
	      var data = map.__data__;
	      return isKeyable(key)
	        ? data[typeof key == 'string' ? 'string' : 'hash']
	        : data.map;
	    }

	    /**
	     * Gets the property names, values, and compare flags of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the match data of `object`.
	     */
	    function getMatchData(object) {
	      var result = keys(object),
	          length = result.length;

	      while (length--) {
	        var key = result[length],
	            value = object[key];

	        result[length] = [key, value, isStrictComparable(value)];
	      }
	      return result;
	    }

	    /**
	     * Gets the native function at `key` of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {string} key The key of the method to get.
	     * @returns {*} Returns the function if it's native, else `undefined`.
	     */
	    function getNative(object, key) {
	      var value = getValue(object, key);
	      return baseIsNative(value) ? value : undefined;
	    }

	    /**
	     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	     *
	     * @private
	     * @param {*} value The value to query.
	     * @returns {string} Returns the raw `toStringTag`.
	     */
	    function getRawTag(value) {
	      var isOwn = hasOwnProperty.call(value, symToStringTag),
	          tag = value[symToStringTag];

	      try {
	        value[symToStringTag] = undefined;
	        var unmasked = true;
	      } catch (e) {}

	      var result = nativeObjectToString.call(value);
	      if (unmasked) {
	        if (isOwn) {
	          value[symToStringTag] = tag;
	        } else {
	          delete value[symToStringTag];
	        }
	      }
	      return result;
	    }

	    /**
	     * Creates an array of the own enumerable symbol properties of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of symbols.
	     */
	    var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;

	    /**
	     * Creates an array of the own and inherited enumerable symbol properties
	     * of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of symbols.
	     */
	    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
	      var result = [];
	      while (object) {
	        arrayPush(result, getSymbols(object));
	        object = getPrototype(object);
	      }
	      return result;
	    };

	    /**
	     * Gets the `toStringTag` of `value`.
	     *
	     * @private
	     * @param {*} value The value to query.
	     * @returns {string} Returns the `toStringTag`.
	     */
	    var getTag = baseGetTag;

	    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
	    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
	        (Map && getTag(new Map) != mapTag) ||
	        (Promise && getTag(Promise.resolve()) != promiseTag) ||
	        (Set && getTag(new Set) != setTag) ||
	        (WeakMap && getTag(new WeakMap) != weakMapTag)) {
	      getTag = function(value) {
	        var result = baseGetTag(value),
	            Ctor = result == objectTag ? value.constructor : undefined,
	            ctorString = Ctor ? toSource(Ctor) : '';

	        if (ctorString) {
	          switch (ctorString) {
	            case dataViewCtorString: return dataViewTag;
	            case mapCtorString: return mapTag;
	            case promiseCtorString: return promiseTag;
	            case setCtorString: return setTag;
	            case weakMapCtorString: return weakMapTag;
	          }
	        }
	        return result;
	      };
	    }

	    /**
	     * Gets the view, applying any `transforms` to the `start` and `end` positions.
	     *
	     * @private
	     * @param {number} start The start of the view.
	     * @param {number} end The end of the view.
	     * @param {Array} transforms The transformations to apply to the view.
	     * @returns {Object} Returns an object containing the `start` and `end`
	     *  positions of the view.
	     */
	    function getView(start, end, transforms) {
	      var index = -1,
	          length = transforms.length;

	      while (++index < length) {
	        var data = transforms[index],
	            size = data.size;

	        switch (data.type) {
	          case 'drop':      start += size; break;
	          case 'dropRight': end -= size; break;
	          case 'take':      end = nativeMin(end, start + size); break;
	          case 'takeRight': start = nativeMax(start, end - size); break;
	        }
	      }
	      return { 'start': start, 'end': end };
	    }

	    /**
	     * Extracts wrapper details from the `source` body comment.
	     *
	     * @private
	     * @param {string} source The source to inspect.
	     * @returns {Array} Returns the wrapper details.
	     */
	    function getWrapDetails(source) {
	      var match = source.match(reWrapDetails);
	      return match ? match[1].split(reSplitDetails) : [];
	    }

	    /**
	     * Checks if `path` exists on `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path to check.
	     * @param {Function} hasFunc The function to check properties.
	     * @returns {boolean} Returns `true` if `path` exists, else `false`.
	     */
	    function hasPath(object, path, hasFunc) {
	      path = isKey(path, object) ? [path] : castPath(path);

	      var index = -1,
	          length = path.length,
	          result = false;

	      while (++index < length) {
	        var key = toKey(path[index]);
	        if (!(result = object != null && hasFunc(object, key))) {
	          break;
	        }
	        object = object[key];
	      }
	      if (result || ++index != length) {
	        return result;
	      }
	      length = object == null ? 0 : object.length;
	      return !!length && isLength(length) && isIndex(key, length) &&
	        (isArray(object) || isArguments(object));
	    }

	    /**
	     * Initializes an array clone.
	     *
	     * @private
	     * @param {Array} array The array to clone.
	     * @returns {Array} Returns the initialized clone.
	     */
	    function initCloneArray(array) {
	      var length = array.length,
	          result = array.constructor(length);

	      // Add properties assigned by `RegExp#exec`.
	      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
	        result.index = array.index;
	        result.input = array.input;
	      }
	      return result;
	    }

	    /**
	     * Initializes an object clone.
	     *
	     * @private
	     * @param {Object} object The object to clone.
	     * @returns {Object} Returns the initialized clone.
	     */
	    function initCloneObject(object) {
	      return (typeof object.constructor == 'function' && !isPrototype(object))
	        ? baseCreate(getPrototype(object))
	        : {};
	    }

	    /**
	     * Initializes an object clone based on its `toStringTag`.
	     *
	     * **Note:** This function only supports cloning values with tags of
	     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	     *
	     * @private
	     * @param {Object} object The object to clone.
	     * @param {string} tag The `toStringTag` of the object to clone.
	     * @param {Function} cloneFunc The function to clone values.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Object} Returns the initialized clone.
	     */
	    function initCloneByTag(object, tag, cloneFunc, isDeep) {
	      var Ctor = object.constructor;
	      switch (tag) {
	        case arrayBufferTag:
	          return cloneArrayBuffer(object);

	        case boolTag:
	        case dateTag:
	          return new Ctor(+object);

	        case dataViewTag:
	          return cloneDataView(object, isDeep);

	        case float32Tag: case float64Tag:
	        case int8Tag: case int16Tag: case int32Tag:
	        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
	          return cloneTypedArray(object, isDeep);

	        case mapTag:
	          return cloneMap(object, isDeep, cloneFunc);

	        case numberTag:
	        case stringTag:
	          return new Ctor(object);

	        case regexpTag:
	          return cloneRegExp(object);

	        case setTag:
	          return cloneSet(object, isDeep, cloneFunc);

	        case symbolTag:
	          return cloneSymbol(object);
	      }
	    }

	    /**
	     * Inserts wrapper `details` in a comment at the top of the `source` body.
	     *
	     * @private
	     * @param {string} source The source to modify.
	     * @returns {Array} details The details to insert.
	     * @returns {string} Returns the modified source.
	     */
	    function insertWrapDetails(source, details) {
	      var length = details.length;
	      if (!length) {
	        return source;
	      }
	      var lastIndex = length - 1;
	      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
	      details = details.join(length > 2 ? ', ' : ' ');
	      return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
	    }

	    /**
	     * Checks if `value` is a flattenable `arguments` object or array.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
	     */
	    function isFlattenable(value) {
	      return isArray(value) || isArguments(value) ||
	        !!(spreadableSymbol && value && value[spreadableSymbol]);
	    }

	    /**
	     * Checks if `value` is a valid array-like index.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	     */
	    function isIndex(value, length) {
	      length = length == null ? MAX_SAFE_INTEGER : length;
	      return !!length &&
	        (typeof value == 'number' || reIsUint.test(value)) &&
	        (value > -1 && value % 1 == 0 && value < length);
	    }

	    /**
	     * Checks if the given arguments are from an iteratee call.
	     *
	     * @private
	     * @param {*} value The potential iteratee value argument.
	     * @param {*} index The potential iteratee index or key argument.
	     * @param {*} object The potential iteratee object argument.
	     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
	     *  else `false`.
	     */
	    function isIterateeCall(value, index, object) {
	      if (!isObject(object)) {
	        return false;
	      }
	      var type = typeof index;
	      if (type == 'number'
	            ? (isArrayLike(object) && isIndex(index, object.length))
	            : (type == 'string' && index in object)
	          ) {
	        return eq(object[index], value);
	      }
	      return false;
	    }

	    /**
	     * Checks if `value` is a property name and not a property path.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @param {Object} [object] The object to query keys on.
	     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	     */
	    function isKey(value, object) {
	      if (isArray(value)) {
	        return false;
	      }
	      var type = typeof value;
	      if (type == 'number' || type == 'symbol' || type == 'boolean' ||
	          value == null || isSymbol(value)) {
	        return true;
	      }
	      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
	        (object != null && value in Object(object));
	    }

	    /**
	     * Checks if `value` is suitable for use as unique object key.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	     */
	    function isKeyable(value) {
	      var type = typeof value;
	      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	        ? (value !== '__proto__')
	        : (value === null);
	    }

	    /**
	     * Checks if `func` has a lazy counterpart.
	     *
	     * @private
	     * @param {Function} func The function to check.
	     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
	     *  else `false`.
	     */
	    function isLaziable(func) {
	      var funcName = getFuncName(func),
	          other = lodash[funcName];

	      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
	        return false;
	      }
	      if (func === other) {
	        return true;
	      }
	      var data = getData(other);
	      return !!data && func === data[0];
	    }

	    /**
	     * Checks if `func` has its source masked.
	     *
	     * @private
	     * @param {Function} func The function to check.
	     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	     */
	    function isMasked(func) {
	      return !!maskSrcKey && (maskSrcKey in func);
	    }

	    /**
	     * Checks if `func` is capable of being masked.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
	     */
	    var isMaskable = coreJsData ? isFunction : stubFalse;

	    /**
	     * Checks if `value` is likely a prototype object.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	     */
	    function isPrototype(value) {
	      var Ctor = value && value.constructor,
	          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

	      return value === proto;
	    }

	    /**
	     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` if suitable for strict
	     *  equality comparisons, else `false`.
	     */
	    function isStrictComparable(value) {
	      return value === value && !isObject(value);
	    }

	    /**
	     * A specialized version of `matchesProperty` for source values suitable
	     * for strict equality comparisons, i.e. `===`.
	     *
	     * @private
	     * @param {string} key The key of the property to get.
	     * @param {*} srcValue The value to match.
	     * @returns {Function} Returns the new spec function.
	     */
	    function matchesStrictComparable(key, srcValue) {
	      return function(object) {
	        if (object == null) {
	          return false;
	        }
	        return object[key] === srcValue &&
	          (srcValue !== undefined || (key in Object(object)));
	      };
	    }

	    /**
	     * A specialized version of `_.memoize` which clears the memoized function's
	     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
	     *
	     * @private
	     * @param {Function} func The function to have its output memoized.
	     * @returns {Function} Returns the new memoized function.
	     */
	    function memoizeCapped(func) {
	      var result = memoize(func, function(key) {
	        if (cache.size === MAX_MEMOIZE_SIZE) {
	          cache.clear();
	        }
	        return key;
	      });

	      var cache = result.cache;
	      return result;
	    }

	    /**
	     * Merges the function metadata of `source` into `data`.
	     *
	     * Merging metadata reduces the number of wrappers used to invoke a function.
	     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
	     * may be applied regardless of execution order. Methods like `_.ary` and
	     * `_.rearg` modify function arguments, making the order in which they are
	     * executed important, preventing the merging of metadata. However, we make
	     * an exception for a safe combined case where curried functions have `_.ary`
	     * and or `_.rearg` applied.
	     *
	     * @private
	     * @param {Array} data The destination metadata.
	     * @param {Array} source The source metadata.
	     * @returns {Array} Returns `data`.
	     */
	    function mergeData(data, source) {
	      var bitmask = data[1],
	          srcBitmask = source[1],
	          newBitmask = bitmask | srcBitmask,
	          isCommon = newBitmask < (BIND_FLAG | BIND_KEY_FLAG | ARY_FLAG);

	      var isCombo =
	        ((srcBitmask == ARY_FLAG) && (bitmask == CURRY_FLAG)) ||
	        ((srcBitmask == ARY_FLAG) && (bitmask == REARG_FLAG) && (data[7].length <= source[8])) ||
	        ((srcBitmask == (ARY_FLAG | REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == CURRY_FLAG));

	      // Exit early if metadata can't be merged.
	      if (!(isCommon || isCombo)) {
	        return data;
	      }
	      // Use source `thisArg` if available.
	      if (srcBitmask & BIND_FLAG) {
	        data[2] = source[2];
	        // Set when currying a bound function.
	        newBitmask |= bitmask & BIND_FLAG ? 0 : CURRY_BOUND_FLAG;
	      }
	      // Compose partial arguments.
	      var value = source[3];
	      if (value) {
	        var partials = data[3];
	        data[3] = partials ? composeArgs(partials, value, source[4]) : value;
	        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
	      }
	      // Compose partial right arguments.
	      value = source[5];
	      if (value) {
	        partials = data[5];
	        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
	        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
	      }
	      // Use source `argPos` if available.
	      value = source[7];
	      if (value) {
	        data[7] = value;
	      }
	      // Use source `ary` if it's smaller.
	      if (srcBitmask & ARY_FLAG) {
	        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
	      }
	      // Use source `arity` if one is not provided.
	      if (data[9] == null) {
	        data[9] = source[9];
	      }
	      // Use source `func` and merge bitmasks.
	      data[0] = source[0];
	      data[1] = newBitmask;

	      return data;
	    }

	    /**
	     * Used by `_.defaultsDeep` to customize its `_.merge` use.
	     *
	     * @private
	     * @param {*} objValue The destination value.
	     * @param {*} srcValue The source value.
	     * @param {string} key The key of the property to merge.
	     * @param {Object} object The parent object of `objValue`.
	     * @param {Object} source The parent object of `srcValue`.
	     * @param {Object} [stack] Tracks traversed source values and their merged
	     *  counterparts.
	     * @returns {*} Returns the value to assign.
	     */
	    function mergeDefaults(objValue, srcValue, key, object, source, stack) {
	      if (isObject(objValue) && isObject(srcValue)) {
	        // Recursively merge objects and arrays (susceptible to call stack limits).
	        stack.set(srcValue, objValue);
	        baseMerge(objValue, srcValue, undefined, mergeDefaults, stack);
	        stack['delete'](srcValue);
	      }
	      return objValue;
	    }

	    /**
	     * This function is like
	     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	     * except that it includes inherited enumerable properties.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     */
	    function nativeKeysIn(object) {
	      var result = [];
	      if (object != null) {
	        for (var key in Object(object)) {
	          result.push(key);
	        }
	      }
	      return result;
	    }

	    /**
	     * Converts `value` to a string using `Object.prototype.toString`.
	     *
	     * @private
	     * @param {*} value The value to convert.
	     * @returns {string} Returns the converted string.
	     */
	    function objectToString(value) {
	      return nativeObjectToString.call(value);
	    }

	    /**
	     * A specialized version of `baseRest` which transforms the rest array.
	     *
	     * @private
	     * @param {Function} func The function to apply a rest parameter to.
	     * @param {number} [start=func.length-1] The start position of the rest parameter.
	     * @param {Function} transform The rest array transform.
	     * @returns {Function} Returns the new function.
	     */
	    function overRest(func, start, transform) {
	      start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
	      return function() {
	        var args = arguments,
	            index = -1,
	            length = nativeMax(args.length - start, 0),
	            array = Array(length);

	        while (++index < length) {
	          array[index] = args[start + index];
	        }
	        index = -1;
	        var otherArgs = Array(start + 1);
	        while (++index < start) {
	          otherArgs[index] = args[index];
	        }
	        otherArgs[start] = transform(array);
	        return apply(func, this, otherArgs);
	      };
	    }

	    /**
	     * Gets the parent value at `path` of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array} path The path to get the parent value of.
	     * @returns {*} Returns the parent value.
	     */
	    function parent(object, path) {
	      return path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
	    }

	    /**
	     * Reorder `array` according to the specified indexes where the element at
	     * the first index is assigned as the first element, the element at
	     * the second index is assigned as the second element, and so on.
	     *
	     * @private
	     * @param {Array} array The array to reorder.
	     * @param {Array} indexes The arranged array indexes.
	     * @returns {Array} Returns `array`.
	     */
	    function reorder(array, indexes) {
	      var arrLength = array.length,
	          length = nativeMin(indexes.length, arrLength),
	          oldArray = copyArray(array);

	      while (length--) {
	        var index = indexes[length];
	        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
	      }
	      return array;
	    }

	    /**
	     * Sets metadata for `func`.
	     *
	     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
	     * period of time, it will trip its breaker and transition to an identity
	     * function to avoid garbage collection pauses in V8. See
	     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
	     * for more details.
	     *
	     * @private
	     * @param {Function} func The function to associate metadata with.
	     * @param {*} data The metadata.
	     * @returns {Function} Returns `func`.
	     */
	    var setData = shortOut(baseSetData);

	    /**
	     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
	     *
	     * @private
	     * @param {Function} func The function to delay.
	     * @param {number} wait The number of milliseconds to delay invocation.
	     * @returns {number|Object} Returns the timer id or timeout object.
	     */
	    var setTimeout = ctxSetTimeout || function(func, wait) {
	      return root.setTimeout(func, wait);
	    };

	    /**
	     * Sets the `toString` method of `func` to return `string`.
	     *
	     * @private
	     * @param {Function} func The function to modify.
	     * @param {Function} string The `toString` result.
	     * @returns {Function} Returns `func`.
	     */
	    var setToString = shortOut(baseSetToString);

	    /**
	     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
	     * with wrapper details in a comment at the top of the source body.
	     *
	     * @private
	     * @param {Function} wrapper The function to modify.
	     * @param {Function} reference The reference function.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @returns {Function} Returns `wrapper`.
	     */
	    function setWrapToString(wrapper, reference, bitmask) {
	      var source = (reference + '');
	      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
	    }

	    /**
	     * Creates a function that'll short out and invoke `identity` instead
	     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
	     * milliseconds.
	     *
	     * @private
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new shortable function.
	     */
	    function shortOut(func) {
	      var count = 0,
	          lastCalled = 0;

	      return function() {
	        var stamp = nativeNow(),
	            remaining = HOT_SPAN - (stamp - lastCalled);

	        lastCalled = stamp;
	        if (remaining > 0) {
	          if (++count >= HOT_COUNT) {
	            return arguments[0];
	          }
	        } else {
	          count = 0;
	        }
	        return func.apply(undefined, arguments);
	      };
	    }

	    /**
	     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
	     *
	     * @private
	     * @param {Array} array The array to shuffle.
	     * @param {number} [size=array.length] The size of `array`.
	     * @returns {Array} Returns `array`.
	     */
	    function shuffleSelf(array, size) {
	      var index = -1,
	          length = array.length,
	          lastIndex = length - 1;

	      size = size === undefined ? length : size;
	      while (++index < size) {
	        var rand = baseRandom(index, lastIndex),
	            value = array[rand];

	        array[rand] = array[index];
	        array[index] = value;
	      }
	      array.length = size;
	      return array;
	    }

	    /**
	     * Converts `string` to a property path array.
	     *
	     * @private
	     * @param {string} string The string to convert.
	     * @returns {Array} Returns the property path array.
	     */
	    var stringToPath = memoizeCapped(function(string) {
	      string = toString(string);

	      var result = [];
	      if (reLeadingDot.test(string)) {
	        result.push('');
	      }
	      string.replace(rePropName, function(match, number, quote, string) {
	        result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
	      });
	      return result;
	    });

	    /**
	     * Converts `value` to a string key if it's not a string or symbol.
	     *
	     * @private
	     * @param {*} value The value to inspect.
	     * @returns {string|symbol} Returns the key.
	     */
	    function toKey(value) {
	      if (typeof value == 'string' || isSymbol(value)) {
	        return value;
	      }
	      var result = (value + '');
	      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	    }

	    /**
	     * Converts `func` to its source code.
	     *
	     * @private
	     * @param {Function} func The function to convert.
	     * @returns {string} Returns the source code.
	     */
	    function toSource(func) {
	      if (func != null) {
	        try {
	          return funcToString.call(func);
	        } catch (e) {}
	        try {
	          return (func + '');
	        } catch (e) {}
	      }
	      return '';
	    }

	    /**
	     * Updates wrapper `details` based on `bitmask` flags.
	     *
	     * @private
	     * @returns {Array} details The details to modify.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @returns {Array} Returns `details`.
	     */
	    function updateWrapDetails(details, bitmask) {
	      arrayEach(wrapFlags, function(pair) {
	        var value = '_.' + pair[0];
	        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
	          details.push(value);
	        }
	      });
	      return details.sort();
	    }

	    /**
	     * Creates a clone of `wrapper`.
	     *
	     * @private
	     * @param {Object} wrapper The wrapper to clone.
	     * @returns {Object} Returns the cloned wrapper.
	     */
	    function wrapperClone(wrapper) {
	      if (wrapper instanceof LazyWrapper) {
	        return wrapper.clone();
	      }
	      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
	      result.__actions__ = copyArray(wrapper.__actions__);
	      result.__index__  = wrapper.__index__;
	      result.__values__ = wrapper.__values__;
	      return result;
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates an array of elements split into groups the length of `size`.
	     * If `array` can't be split evenly, the final chunk will be the remaining
	     * elements.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to process.
	     * @param {number} [size=1] The length of each chunk
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the new array of chunks.
	     * @example
	     *
	     * _.chunk(['a', 'b', 'c', 'd'], 2);
	     * // => [['a', 'b'], ['c', 'd']]
	     *
	     * _.chunk(['a', 'b', 'c', 'd'], 3);
	     * // => [['a', 'b', 'c'], ['d']]
	     */
	    function chunk(array, size, guard) {
	      if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {
	        size = 1;
	      } else {
	        size = nativeMax(toInteger(size), 0);
	      }
	      var length = array == null ? 0 : array.length;
	      if (!length || size < 1) {
	        return [];
	      }
	      var index = 0,
	          resIndex = 0,
	          result = Array(nativeCeil(length / size));

	      while (index < length) {
	        result[resIndex++] = baseSlice(array, index, (index += size));
	      }
	      return result;
	    }

	    /**
	     * Creates an array with all falsey values removed. The values `false`, `null`,
	     * `0`, `""`, `undefined`, and `NaN` are falsey.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to compact.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.compact([0, 1, false, 2, '', 3]);
	     * // => [1, 2, 3]
	     */
	    function compact(array) {
	      var index = -1,
	          length = array == null ? 0 : array.length,
	          resIndex = 0,
	          result = [];

	      while (++index < length) {
	        var value = array[index];
	        if (value) {
	          result[resIndex++] = value;
	        }
	      }
	      return result;
	    }

	    /**
	     * Creates a new array concatenating `array` with any additional arrays
	     * and/or values.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to concatenate.
	     * @param {...*} [values] The values to concatenate.
	     * @returns {Array} Returns the new concatenated array.
	     * @example
	     *
	     * var array = [1];
	     * var other = _.concat(array, 2, [3], [[4]]);
	     *
	     * console.log(other);
	     * // => [1, 2, 3, [4]]
	     *
	     * console.log(array);
	     * // => [1]
	     */
	    function concat() {
	      var length = arguments.length;
	      if (!length) {
	        return [];
	      }
	      var args = Array(length - 1),
	          array = arguments[0],
	          index = length;

	      while (index--) {
	        args[index - 1] = arguments[index];
	      }
	      return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
	    }

	    /**
	     * Creates an array of `array` values not included in the other given arrays
	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons. The order and references of result values are
	     * determined by the first array.
	     *
	     * **Note:** Unlike `_.pullAll`, this method returns a new array.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {...Array} [values] The values to exclude.
	     * @returns {Array} Returns the new array of filtered values.
	     * @see _.without, _.xor
	     * @example
	     *
	     * _.difference([2, 1], [2, 3]);
	     * // => [1]
	     */
	    var difference = baseRest(function(array, values) {
	      return isArrayLikeObject(array)
	        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
	        : [];
	    });

	    /**
	     * This method is like `_.difference` except that it accepts `iteratee` which
	     * is invoked for each element of `array` and `values` to generate the criterion
	     * by which they're compared. The order and references of result values are
	     * determined by the first array. The iteratee is invoked with one argument:
	     * (value).
	     *
	     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {...Array} [values] The values to exclude.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
	     * // => [1.2]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
	     * // => [{ 'x': 2 }]
	     */
	    var differenceBy = baseRest(function(array, values) {
	      var iteratee = last(values);
	      if (isArrayLikeObject(iteratee)) {
	        iteratee = undefined;
	      }
	      return isArrayLikeObject(array)
	        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))
	        : [];
	    });

	    /**
	     * This method is like `_.difference` except that it accepts `comparator`
	     * which is invoked to compare elements of `array` to `values`. The order and
	     * references of result values are determined by the first array. The comparator
	     * is invoked with two arguments: (arrVal, othVal).
	     *
	     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {...Array} [values] The values to exclude.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
	     *
	     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
	     * // => [{ 'x': 2, 'y': 1 }]
	     */
	    var differenceWith = baseRest(function(array, values) {
	      var comparator = last(values);
	      if (isArrayLikeObject(comparator)) {
	        comparator = undefined;
	      }
	      return isArrayLikeObject(array)
	        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)
	        : [];
	    });

	    /**
	     * Creates a slice of `array` with `n` elements dropped from the beginning.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.5.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to drop.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.drop([1, 2, 3]);
	     * // => [2, 3]
	     *
	     * _.drop([1, 2, 3], 2);
	     * // => [3]
	     *
	     * _.drop([1, 2, 3], 5);
	     * // => []
	     *
	     * _.drop([1, 2, 3], 0);
	     * // => [1, 2, 3]
	     */
	    function drop(array, n, guard) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return [];
	      }
	      n = (guard || n === undefined) ? 1 : toInteger(n);
	      return baseSlice(array, n < 0 ? 0 : n, length);
	    }

	    /**
	     * Creates a slice of `array` with `n` elements dropped from the end.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to drop.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.dropRight([1, 2, 3]);
	     * // => [1, 2]
	     *
	     * _.dropRight([1, 2, 3], 2);
	     * // => [1]
	     *
	     * _.dropRight([1, 2, 3], 5);
	     * // => []
	     *
	     * _.dropRight([1, 2, 3], 0);
	     * // => [1, 2, 3]
	     */
	    function dropRight(array, n, guard) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return [];
	      }
	      n = (guard || n === undefined) ? 1 : toInteger(n);
	      n = length - n;
	      return baseSlice(array, 0, n < 0 ? 0 : n);
	    }

	    /**
	     * Creates a slice of `array` excluding elements dropped from the end.
	     * Elements are dropped until `predicate` returns falsey. The predicate is
	     * invoked with three arguments: (value, index, array).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': true },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': false }
	     * ];
	     *
	     * _.dropRightWhile(users, function(o) { return !o.active; });
	     * // => objects for ['barney']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
	     * // => objects for ['barney', 'fred']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.dropRightWhile(users, ['active', false]);
	     * // => objects for ['barney']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.dropRightWhile(users, 'active');
	     * // => objects for ['barney', 'fred', 'pebbles']
	     */
	    function dropRightWhile(array, predicate) {
	      return (array && array.length)
	        ? baseWhile(array, getIteratee(predicate, 3), true, true)
	        : [];
	    }

	    /**
	     * Creates a slice of `array` excluding elements dropped from the beginning.
	     * Elements are dropped until `predicate` returns falsey. The predicate is
	     * invoked with three arguments: (value, index, array).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': false },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': true }
	     * ];
	     *
	     * _.dropWhile(users, function(o) { return !o.active; });
	     * // => objects for ['pebbles']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.dropWhile(users, { 'user': 'barney', 'active': false });
	     * // => objects for ['fred', 'pebbles']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.dropWhile(users, ['active', false]);
	     * // => objects for ['pebbles']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.dropWhile(users, 'active');
	     * // => objects for ['barney', 'fred', 'pebbles']
	     */
	    function dropWhile(array, predicate) {
	      return (array && array.length)
	        ? baseWhile(array, getIteratee(predicate, 3), true)
	        : [];
	    }

	    /**
	     * Fills elements of `array` with `value` from `start` up to, but not
	     * including, `end`.
	     *
	     * **Note:** This method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.2.0
	     * @category Array
	     * @param {Array} array The array to fill.
	     * @param {*} value The value to fill `array` with.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [1, 2, 3];
	     *
	     * _.fill(array, 'a');
	     * console.log(array);
	     * // => ['a', 'a', 'a']
	     *
	     * _.fill(Array(3), 2);
	     * // => [2, 2, 2]
	     *
	     * _.fill([4, 6, 8, 10], '*', 1, 3);
	     * // => [4, '*', '*', 10]
	     */
	    function fill(array, value, start, end) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return [];
	      }
	      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
	        start = 0;
	        end = length;
	      }
	      return baseFill(array, value, start, end);
	    }

	    /**
	     * This method is like `_.find` except that it returns the index of the first
	     * element `predicate` returns truthy for instead of the element itself.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param {number} [fromIndex=0] The index to search from.
	     * @returns {number} Returns the index of the found element, else `-1`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': false },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': true }
	     * ];
	     *
	     * _.findIndex(users, function(o) { return o.user == 'barney'; });
	     * // => 0
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.findIndex(users, { 'user': 'fred', 'active': false });
	     * // => 1
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.findIndex(users, ['active', false]);
	     * // => 0
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.findIndex(users, 'active');
	     * // => 2
	     */
	    function findIndex(array, predicate, fromIndex) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return -1;
	      }
	      var index = fromIndex == null ? 0 : toInteger(fromIndex);
	      if (index < 0) {
	        index = nativeMax(length + index, 0);
	      }
	      return baseFindIndex(array, getIteratee(predicate, 3), index);
	    }

	    /**
	     * This method is like `_.findIndex` except that it iterates over elements
	     * of `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param {number} [fromIndex=array.length-1] The index to search from.
	     * @returns {number} Returns the index of the found element, else `-1`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': true },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': false }
	     * ];
	     *
	     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
	     * // => 2
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
	     * // => 0
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.findLastIndex(users, ['active', false]);
	     * // => 2
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.findLastIndex(users, 'active');
	     * // => 0
	     */
	    function findLastIndex(array, predicate, fromIndex) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return -1;
	      }
	      var index = length - 1;
	      if (fromIndex !== undefined) {
	        index = toInteger(fromIndex);
	        index = fromIndex < 0
	          ? nativeMax(length + index, 0)
	          : nativeMin(index, length - 1);
	      }
	      return baseFindIndex(array, getIteratee(predicate, 3), index, true);
	    }

	    /**
	     * Flattens `array` a single level deep.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to flatten.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * _.flatten([1, [2, [3, [4]], 5]]);
	     * // => [1, 2, [3, [4]], 5]
	     */
	    function flatten(array) {
	      var length = array == null ? 0 : array.length;
	      return length ? baseFlatten(array, 1) : [];
	    }

	    /**
	     * Recursively flattens `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to flatten.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * _.flattenDeep([1, [2, [3, [4]], 5]]);
	     * // => [1, 2, 3, 4, 5]
	     */
	    function flattenDeep(array) {
	      var length = array == null ? 0 : array.length;
	      return length ? baseFlatten(array, INFINITY) : [];
	    }

	    /**
	     * Recursively flatten `array` up to `depth` times.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.4.0
	     * @category Array
	     * @param {Array} array The array to flatten.
	     * @param {number} [depth=1] The maximum recursion depth.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * var array = [1, [2, [3, [4]], 5]];
	     *
	     * _.flattenDepth(array, 1);
	     * // => [1, 2, [3, [4]], 5]
	     *
	     * _.flattenDepth(array, 2);
	     * // => [1, 2, 3, [4], 5]
	     */
	    function flattenDepth(array, depth) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return [];
	      }
	      depth = depth === undefined ? 1 : toInteger(depth);
	      return baseFlatten(array, depth);
	    }

	    /**
	     * The inverse of `_.toPairs`; this method returns an object composed
	     * from key-value `pairs`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} pairs The key-value pairs.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * _.fromPairs([['a', 1], ['b', 2]]);
	     * // => { 'a': 1, 'b': 2 }
	     */
	    function fromPairs(pairs) {
	      var index = -1,
	          length = pairs == null ? 0 : pairs.length,
	          result = {};

	      while (++index < length) {
	        var pair = pairs[index];
	        result[pair[0]] = pair[1];
	      }
	      return result;
	    }

	    /**
	     * Gets the first element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @alias first
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {*} Returns the first element of `array`.
	     * @example
	     *
	     * _.head([1, 2, 3]);
	     * // => 1
	     *
	     * _.head([]);
	     * // => undefined
	     */
	    function head(array) {
	      return (array && array.length) ? array[0] : undefined;
	    }

	    /**
	     * Gets the index at which the first occurrence of `value` is found in `array`
	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons. If `fromIndex` is negative, it's used as the
	     * offset from the end of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {*} value The value to search for.
	     * @param {number} [fromIndex=0] The index to search from.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.indexOf([1, 2, 1, 2], 2);
	     * // => 1
	     *
	     * // Search from the `fromIndex`.
	     * _.indexOf([1, 2, 1, 2], 2, 2);
	     * // => 3
	     */
	    function indexOf(array, value, fromIndex) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return -1;
	      }
	      var index = fromIndex == null ? 0 : toInteger(fromIndex);
	      if (index < 0) {
	        index = nativeMax(length + index, 0);
	      }
	      return baseIndexOf(array, value, index);
	    }

	    /**
	     * Gets all but the last element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.initial([1, 2, 3]);
	     * // => [1, 2]
	     */
	    function initial(array) {
	      var length = array == null ? 0 : array.length;
	      return length ? baseSlice(array, 0, -1) : [];
	    }

	    /**
	     * Creates an array of unique values that are included in all given arrays
	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons. The order and references of result values are
	     * determined by the first array.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of intersecting values.
	     * @example
	     *
	     * _.intersection([2, 1], [2, 3]);
	     * // => [2]
	     */
	    var intersection = baseRest(function(arrays) {
	      var mapped = arrayMap(arrays, castArrayLikeObject);
	      return (mapped.length && mapped[0] === arrays[0])
	        ? baseIntersection(mapped)
	        : [];
	    });

	    /**
	     * This method is like `_.intersection` except that it accepts `iteratee`
	     * which is invoked for each element of each `arrays` to generate the criterion
	     * by which they're compared. The order and references of result values are
	     * determined by the first array. The iteratee is invoked with one argument:
	     * (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns the new array of intersecting values.
	     * @example
	     *
	     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
	     * // => [2.1]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 1 }]
	     */
	    var intersectionBy = baseRest(function(arrays) {
	      var iteratee = last(arrays),
	          mapped = arrayMap(arrays, castArrayLikeObject);

	      if (iteratee === last(mapped)) {
	        iteratee = undefined;
	      } else {
	        mapped.pop();
	      }
	      return (mapped.length && mapped[0] === arrays[0])
	        ? baseIntersection(mapped, getIteratee(iteratee, 2))
	        : [];
	    });

	    /**
	     * This method is like `_.intersection` except that it accepts `comparator`
	     * which is invoked to compare elements of `arrays`. The order and references
	     * of result values are determined by the first array. The comparator is
	     * invoked with two arguments: (arrVal, othVal).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of intersecting values.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
	     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
	     *
	     * _.intersectionWith(objects, others, _.isEqual);
	     * // => [{ 'x': 1, 'y': 2 }]
	     */
	    var intersectionWith = baseRest(function(arrays) {
	      var comparator = last(arrays),
	          mapped = arrayMap(arrays, castArrayLikeObject);

	      comparator = typeof comparator == 'function' ? comparator : undefined;
	      if (comparator) {
	        mapped.pop();
	      }
	      return (mapped.length && mapped[0] === arrays[0])
	        ? baseIntersection(mapped, undefined, comparator)
	        : [];
	    });

	    /**
	     * Converts all elements in `array` into a string separated by `separator`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to convert.
	     * @param {string} [separator=','] The element separator.
	     * @returns {string} Returns the joined string.
	     * @example
	     *
	     * _.join(['a', 'b', 'c'], '~');
	     * // => 'a~b~c'
	     */
	    function join(array, separator) {
	      return array == null ? '' : nativeJoin.call(array, separator);
	    }

	    /**
	     * Gets the last element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {*} Returns the last element of `array`.
	     * @example
	     *
	     * _.last([1, 2, 3]);
	     * // => 3
	     */
	    function last(array) {
	      var length = array == null ? 0 : array.length;
	      return length ? array[length - 1] : undefined;
	    }

	    /**
	     * This method is like `_.indexOf` except that it iterates over elements of
	     * `array` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {*} value The value to search for.
	     * @param {number} [fromIndex=array.length-1] The index to search from.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.lastIndexOf([1, 2, 1, 2], 2);
	     * // => 3
	     *
	     * // Search from the `fromIndex`.
	     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
	     * // => 1
	     */
	    function lastIndexOf(array, value, fromIndex) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return -1;
	      }
	      var index = length;
	      if (fromIndex !== undefined) {
	        index = toInteger(fromIndex);
	        index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
	      }
	      return value === value
	        ? strictLastIndexOf(array, value, index)
	        : baseFindIndex(array, baseIsNaN, index, true);
	    }

	    /**
	     * Gets the element at index `n` of `array`. If `n` is negative, the nth
	     * element from the end is returned.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.11.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=0] The index of the element to return.
	     * @returns {*} Returns the nth element of `array`.
	     * @example
	     *
	     * var array = ['a', 'b', 'c', 'd'];
	     *
	     * _.nth(array, 1);
	     * // => 'b'
	     *
	     * _.nth(array, -2);
	     * // => 'c';
	     */
	    function nth(array, n) {
	      return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;
	    }

	    /**
	     * Removes all given values from `array` using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
	     * to remove elements from an array by predicate.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {...*} [values] The values to remove.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
	     *
	     * _.pull(array, 'a', 'c');
	     * console.log(array);
	     * // => ['b', 'b']
	     */
	    var pull = baseRest(pullAll);

	    /**
	     * This method is like `_.pull` except that it accepts an array of values to remove.
	     *
	     * **Note:** Unlike `_.difference`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {Array} values The values to remove.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
	     *
	     * _.pullAll(array, ['a', 'c']);
	     * console.log(array);
	     * // => ['b', 'b']
	     */
	    function pullAll(array, values) {
	      return (array && array.length && values && values.length)
	        ? basePullAll(array, values)
	        : array;
	    }

	    /**
	     * This method is like `_.pullAll` except that it accepts `iteratee` which is
	     * invoked for each element of `array` and `values` to generate the criterion
	     * by which they're compared. The iteratee is invoked with one argument: (value).
	     *
	     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {Array} values The values to remove.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
	     *
	     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
	     * console.log(array);
	     * // => [{ 'x': 2 }]
	     */
	    function pullAllBy(array, values, iteratee) {
	      return (array && array.length && values && values.length)
	        ? basePullAll(array, values, getIteratee(iteratee, 2))
	        : array;
	    }

	    /**
	     * This method is like `_.pullAll` except that it accepts `comparator` which
	     * is invoked to compare elements of `array` to `values`. The comparator is
	     * invoked with two arguments: (arrVal, othVal).
	     *
	     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.6.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {Array} values The values to remove.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
	     *
	     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
	     * console.log(array);
	     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
	     */
	    function pullAllWith(array, values, comparator) {
	      return (array && array.length && values && values.length)
	        ? basePullAll(array, values, undefined, comparator)
	        : array;
	    }

	    /**
	     * Removes elements from `array` corresponding to `indexes` and returns an
	     * array of removed elements.
	     *
	     * **Note:** Unlike `_.at`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
	     * @returns {Array} Returns the new array of removed elements.
	     * @example
	     *
	     * var array = ['a', 'b', 'c', 'd'];
	     * var pulled = _.pullAt(array, [1, 3]);
	     *
	     * console.log(array);
	     * // => ['a', 'c']
	     *
	     * console.log(pulled);
	     * // => ['b', 'd']
	     */
	    var pullAt = flatRest(function(array, indexes) {
	      var length = array == null ? 0 : array.length,
	          result = baseAt(array, indexes);

	      basePullAt(array, arrayMap(indexes, function(index) {
	        return isIndex(index, length) ? +index : index;
	      }).sort(compareAscending));

	      return result;
	    });

	    /**
	     * Removes all elements from `array` that `predicate` returns truthy for
	     * and returns an array of the removed elements. The predicate is invoked
	     * with three arguments: (value, index, array).
	     *
	     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
	     * to pull elements from an array by value.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new array of removed elements.
	     * @example
	     *
	     * var array = [1, 2, 3, 4];
	     * var evens = _.remove(array, function(n) {
	     *   return n % 2 == 0;
	     * });
	     *
	     * console.log(array);
	     * // => [1, 3]
	     *
	     * console.log(evens);
	     * // => [2, 4]
	     */
	    function remove(array, predicate) {
	      var result = [];
	      if (!(array && array.length)) {
	        return result;
	      }
	      var index = -1,
	          indexes = [],
	          length = array.length;

	      predicate = getIteratee(predicate, 3);
	      while (++index < length) {
	        var value = array[index];
	        if (predicate(value, index, array)) {
	          result.push(value);
	          indexes.push(index);
	        }
	      }
	      basePullAt(array, indexes);
	      return result;
	    }

	    /**
	     * Reverses `array` so that the first element becomes the last, the second
	     * element becomes the second to last, and so on.
	     *
	     * **Note:** This method mutates `array` and is based on
	     * [`Array#reverse`](https://mdn.io/Array/reverse).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [1, 2, 3];
	     *
	     * _.reverse(array);
	     * // => [3, 2, 1]
	     *
	     * console.log(array);
	     * // => [3, 2, 1]
	     */
	    function reverse(array) {
	      return array == null ? array : nativeReverse.call(array);
	    }

	    /**
	     * Creates a slice of `array` from `start` up to, but not including, `end`.
	     *
	     * **Note:** This method is used instead of
	     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
	     * returned.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to slice.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns the slice of `array`.
	     */
	    function slice(array, start, end) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return [];
	      }
	      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
	        start = 0;
	        end = length;
	      }
	      else {
	        start = start == null ? 0 : toInteger(start);
	        end = end === undefined ? length : toInteger(end);
	      }
	      return baseSlice(array, start, end);
	    }

	    /**
	     * Uses a binary search to determine the lowest index at which `value`
	     * should be inserted into `array` in order to maintain its sort order.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * _.sortedIndex([30, 50], 40);
	     * // => 1
	     */
	    function sortedIndex(array, value) {
	      return baseSortedIndex(array, value);
	    }

	    /**
	     * This method is like `_.sortedIndex` except that it accepts `iteratee`
	     * which is invoked for `value` and each element of `array` to compute their
	     * sort ranking. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * var objects = [{ 'x': 4 }, { 'x': 5 }];
	     *
	     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
	     * // => 0
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
	     * // => 0
	     */
	    function sortedIndexBy(array, value, iteratee) {
	      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
	    }

	    /**
	     * This method is like `_.indexOf` except that it performs a binary
	     * search on a sorted `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {*} value The value to search for.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
	     * // => 1
	     */
	    function sortedIndexOf(array, value) {
	      var length = array == null ? 0 : array.length;
	      if (length) {
	        var index = baseSortedIndex(array, value);
	        if (index < length && eq(array[index], value)) {
	          return index;
	        }
	      }
	      return -1;
	    }

	    /**
	     * This method is like `_.sortedIndex` except that it returns the highest
	     * index at which `value` should be inserted into `array` in order to
	     * maintain its sort order.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
	     * // => 4
	     */
	    function sortedLastIndex(array, value) {
	      return baseSortedIndex(array, value, true);
	    }

	    /**
	     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
	     * which is invoked for `value` and each element of `array` to compute their
	     * sort ranking. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * var objects = [{ 'x': 4 }, { 'x': 5 }];
	     *
	     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
	     * // => 1
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
	     * // => 1
	     */
	    function sortedLastIndexBy(array, value, iteratee) {
	      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
	    }

	    /**
	     * This method is like `_.lastIndexOf` except that it performs a binary
	     * search on a sorted `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {*} value The value to search for.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
	     * // => 3
	     */
	    function sortedLastIndexOf(array, value) {
	      var length = array == null ? 0 : array.length;
	      if (length) {
	        var index = baseSortedIndex(array, value, true) - 1;
	        if (eq(array[index], value)) {
	          return index;
	        }
	      }
	      return -1;
	    }

	    /**
	     * This method is like `_.uniq` except that it's designed and optimized
	     * for sorted arrays.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * _.sortedUniq([1, 1, 2]);
	     * // => [1, 2]
	     */
	    function sortedUniq(array) {
	      return (array && array.length)
	        ? baseSortedUniq(array)
	        : [];
	    }

	    /**
	     * This method is like `_.uniqBy` except that it's designed and optimized
	     * for sorted arrays.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
	     * // => [1.1, 2.3]
	     */
	    function sortedUniqBy(array, iteratee) {
	      return (array && array.length)
	        ? baseSortedUniq(array, getIteratee(iteratee, 2))
	        : [];
	    }

	    /**
	     * Gets all but the first element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.tail([1, 2, 3]);
	     * // => [2, 3]
	     */
	    function tail(array) {
	      var length = array == null ? 0 : array.length;
	      return length ? baseSlice(array, 1, length) : [];
	    }

	    /**
	     * Creates a slice of `array` with `n` elements taken from the beginning.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to take.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.take([1, 2, 3]);
	     * // => [1]
	     *
	     * _.take([1, 2, 3], 2);
	     * // => [1, 2]
	     *
	     * _.take([1, 2, 3], 5);
	     * // => [1, 2, 3]
	     *
	     * _.take([1, 2, 3], 0);
	     * // => []
	     */
	    function take(array, n, guard) {
	      if (!(array && array.length)) {
	        return [];
	      }
	      n = (guard || n === undefined) ? 1 : toInteger(n);
	      return baseSlice(array, 0, n < 0 ? 0 : n);
	    }

	    /**
	     * Creates a slice of `array` with `n` elements taken from the end.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to take.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.takeRight([1, 2, 3]);
	     * // => [3]
	     *
	     * _.takeRight([1, 2, 3], 2);
	     * // => [2, 3]
	     *
	     * _.takeRight([1, 2, 3], 5);
	     * // => [1, 2, 3]
	     *
	     * _.takeRight([1, 2, 3], 0);
	     * // => []
	     */
	    function takeRight(array, n, guard) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return [];
	      }
	      n = (guard || n === undefined) ? 1 : toInteger(n);
	      n = length - n;
	      return baseSlice(array, n < 0 ? 0 : n, length);
	    }

	    /**
	     * Creates a slice of `array` with elements taken from the end. Elements are
	     * taken until `predicate` returns falsey. The predicate is invoked with
	     * three arguments: (value, index, array).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': true },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': false }
	     * ];
	     *
	     * _.takeRightWhile(users, function(o) { return !o.active; });
	     * // => objects for ['fred', 'pebbles']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
	     * // => objects for ['pebbles']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.takeRightWhile(users, ['active', false]);
	     * // => objects for ['fred', 'pebbles']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.takeRightWhile(users, 'active');
	     * // => []
	     */
	    function takeRightWhile(array, predicate) {
	      return (array && array.length)
	        ? baseWhile(array, getIteratee(predicate, 3), false, true)
	        : [];
	    }

	    /**
	     * Creates a slice of `array` with elements taken from the beginning. Elements
	     * are taken until `predicate` returns falsey. The predicate is invoked with
	     * three arguments: (value, index, array).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': false },
	     *   { 'user': 'fred',    'active': false},
	     *   { 'user': 'pebbles', 'active': true }
	     * ];
	     *
	     * _.takeWhile(users, function(o) { return !o.active; });
	     * // => objects for ['barney', 'fred']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.takeWhile(users, { 'user': 'barney', 'active': false });
	     * // => objects for ['barney']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.takeWhile(users, ['active', false]);
	     * // => objects for ['barney', 'fred']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.takeWhile(users, 'active');
	     * // => []
	     */
	    function takeWhile(array, predicate) {
	      return (array && array.length)
	        ? baseWhile(array, getIteratee(predicate, 3))
	        : [];
	    }

	    /**
	     * Creates an array of unique values, in order, from all given arrays using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of combined values.
	     * @example
	     *
	     * _.union([2], [1, 2]);
	     * // => [2, 1]
	     */
	    var union = baseRest(function(arrays) {
	      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
	    });

	    /**
	     * This method is like `_.union` except that it accepts `iteratee` which is
	     * invoked for each element of each `arrays` to generate the criterion by
	     * which uniqueness is computed. Result values are chosen from the first
	     * array in which the value occurs. The iteratee is invoked with one argument:
	     * (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns the new array of combined values.
	     * @example
	     *
	     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
	     * // => [2.1, 1.2]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 1 }, { 'x': 2 }]
	     */
	    var unionBy = baseRest(function(arrays) {
	      var iteratee = last(arrays);
	      if (isArrayLikeObject(iteratee)) {
	        iteratee = undefined;
	      }
	      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
	    });

	    /**
	     * This method is like `_.union` except that it accepts `comparator` which
	     * is invoked to compare elements of `arrays`. Result values are chosen from
	     * the first array in which the value occurs. The comparator is invoked
	     * with two arguments: (arrVal, othVal).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of combined values.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
	     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
	     *
	     * _.unionWith(objects, others, _.isEqual);
	     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
	     */
	    var unionWith = baseRest(function(arrays) {
	      var comparator = last(arrays);
	      comparator = typeof comparator == 'function' ? comparator : undefined;
	      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
	    });

	    /**
	     * Creates a duplicate-free version of an array, using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons, in which only the first occurrence of each element
	     * is kept. The order of result values is determined by the order they occur
	     * in the array.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * _.uniq([2, 1, 2]);
	     * // => [2, 1]
	     */
	    function uniq(array) {
	      return (array && array.length) ? baseUniq(array) : [];
	    }

	    /**
	     * This method is like `_.uniq` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the criterion by which
	     * uniqueness is computed. The order of result values is determined by the
	     * order they occur in the array. The iteratee is invoked with one argument:
	     * (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
	     * // => [2.1, 1.2]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 1 }, { 'x': 2 }]
	     */
	    function uniqBy(array, iteratee) {
	      return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];
	    }

	    /**
	     * This method is like `_.uniq` except that it accepts `comparator` which
	     * is invoked to compare elements of `array`. The order of result values is
	     * determined by the order they occur in the array.The comparator is invoked
	     * with two arguments: (arrVal, othVal).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
	     *
	     * _.uniqWith(objects, _.isEqual);
	     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
	     */
	    function uniqWith(array, comparator) {
	      comparator = typeof comparator == 'function' ? comparator : undefined;
	      return (array && array.length) ? baseUniq(array, undefined, comparator) : [];
	    }

	    /**
	     * This method is like `_.zip` except that it accepts an array of grouped
	     * elements and creates an array regrouping the elements to their pre-zip
	     * configuration.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.2.0
	     * @category Array
	     * @param {Array} array The array of grouped elements to process.
	     * @returns {Array} Returns the new array of regrouped elements.
	     * @example
	     *
	     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
	     * // => [['a', 1, true], ['b', 2, false]]
	     *
	     * _.unzip(zipped);
	     * // => [['a', 'b'], [1, 2], [true, false]]
	     */
	    function unzip(array) {
	      if (!(array && array.length)) {
	        return [];
	      }
	      var length = 0;
	      array = arrayFilter(array, function(group) {
	        if (isArrayLikeObject(group)) {
	          length = nativeMax(group.length, length);
	          return true;
	        }
	      });
	      return baseTimes(length, function(index) {
	        return arrayMap(array, baseProperty(index));
	      });
	    }

	    /**
	     * This method is like `_.unzip` except that it accepts `iteratee` to specify
	     * how regrouped values should be combined. The iteratee is invoked with the
	     * elements of each group: (...group).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.8.0
	     * @category Array
	     * @param {Array} array The array of grouped elements to process.
	     * @param {Function} [iteratee=_.identity] The function to combine
	     *  regrouped values.
	     * @returns {Array} Returns the new array of regrouped elements.
	     * @example
	     *
	     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
	     * // => [[1, 10, 100], [2, 20, 200]]
	     *
	     * _.unzipWith(zipped, _.add);
	     * // => [3, 30, 300]
	     */
	    function unzipWith(array, iteratee) {
	      if (!(array && array.length)) {
	        return [];
	      }
	      var result = unzip(array);
	      if (iteratee == null) {
	        return result;
	      }
	      return arrayMap(result, function(group) {
	        return apply(iteratee, undefined, group);
	      });
	    }

	    /**
	     * Creates an array excluding all given values using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * **Note:** Unlike `_.pull`, this method returns a new array.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {...*} [values] The values to exclude.
	     * @returns {Array} Returns the new array of filtered values.
	     * @see _.difference, _.xor
	     * @example
	     *
	     * _.without([2, 1, 2, 3], 1, 2);
	     * // => [3]
	     */
	    var without = baseRest(function(array, values) {
	      return isArrayLikeObject(array)
	        ? baseDifference(array, values)
	        : [];
	    });

	    /**
	     * Creates an array of unique values that is the
	     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
	     * of the given arrays. The order of result values is determined by the order
	     * they occur in the arrays.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.4.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of filtered values.
	     * @see _.difference, _.without
	     * @example
	     *
	     * _.xor([2, 1], [2, 3]);
	     * // => [1, 3]
	     */
	    var xor = baseRest(function(arrays) {
	      return baseXor(arrayFilter(arrays, isArrayLikeObject));
	    });

	    /**
	     * This method is like `_.xor` except that it accepts `iteratee` which is
	     * invoked for each element of each `arrays` to generate the criterion by
	     * which by which they're compared. The order of result values is determined
	     * by the order they occur in the arrays. The iteratee is invoked with one
	     * argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
	     * // => [1.2, 3.4]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 2 }]
	     */
	    var xorBy = baseRest(function(arrays) {
	      var iteratee = last(arrays);
	      if (isArrayLikeObject(iteratee)) {
	        iteratee = undefined;
	      }
	      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
	    });

	    /**
	     * This method is like `_.xor` except that it accepts `comparator` which is
	     * invoked to compare elements of `arrays`. The order of result values is
	     * determined by the order they occur in the arrays. The comparator is invoked
	     * with two arguments: (arrVal, othVal).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
	     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
	     *
	     * _.xorWith(objects, others, _.isEqual);
	     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
	     */
	    var xorWith = baseRest(function(arrays) {
	      var comparator = last(arrays);
	      comparator = typeof comparator == 'function' ? comparator : undefined;
	      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
	    });

	    /**
	     * Creates an array of grouped elements, the first of which contains the
	     * first elements of the given arrays, the second of which contains the
	     * second elements of the given arrays, and so on.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to process.
	     * @returns {Array} Returns the new array of grouped elements.
	     * @example
	     *
	     * _.zip(['a', 'b'], [1, 2], [true, false]);
	     * // => [['a', 1, true], ['b', 2, false]]
	     */
	    var zip = baseRest(unzip);

	    /**
	     * This method is like `_.fromPairs` except that it accepts two arrays,
	     * one of property identifiers and one of corresponding values.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.4.0
	     * @category Array
	     * @param {Array} [props=[]] The property identifiers.
	     * @param {Array} [values=[]] The property values.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * _.zipObject(['a', 'b'], [1, 2]);
	     * // => { 'a': 1, 'b': 2 }
	     */
	    function zipObject(props, values) {
	      return baseZipObject(props || [], values || [], assignValue);
	    }

	    /**
	     * This method is like `_.zipObject` except that it supports property paths.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.1.0
	     * @category Array
	     * @param {Array} [props=[]] The property identifiers.
	     * @param {Array} [values=[]] The property values.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
	     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
	     */
	    function zipObjectDeep(props, values) {
	      return baseZipObject(props || [], values || [], baseSet);
	    }

	    /**
	     * This method is like `_.zip` except that it accepts `iteratee` to specify
	     * how grouped values should be combined. The iteratee is invoked with the
	     * elements of each group: (...group).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.8.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to process.
	     * @param {Function} [iteratee=_.identity] The function to combine
	     *  grouped values.
	     * @returns {Array} Returns the new array of grouped elements.
	     * @example
	     *
	     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
	     *   return a + b + c;
	     * });
	     * // => [111, 222]
	     */
	    var zipWith = baseRest(function(arrays) {
	      var length = arrays.length,
	          iteratee = length > 1 ? arrays[length - 1] : undefined;

	      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
	      return unzipWith(arrays, iteratee);
	    });

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
	     * chain sequences enabled. The result of such sequences must be unwrapped
	     * with `_#value`.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.3.0
	     * @category Seq
	     * @param {*} value The value to wrap.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36 },
	     *   { 'user': 'fred',    'age': 40 },
	     *   { 'user': 'pebbles', 'age': 1 }
	     * ];
	     *
	     * var youngest = _
	     *   .chain(users)
	     *   .sortBy('age')
	     *   .map(function(o) {
	     *     return o.user + ' is ' + o.age;
	     *   })
	     *   .head()
	     *   .value();
	     * // => 'pebbles is 1'
	     */
	    function chain(value) {
	      var result = lodash(value);
	      result.__chain__ = true;
	      return result;
	    }

	    /**
	     * This method invokes `interceptor` and returns `value`. The interceptor
	     * is invoked with one argument; (value). The purpose of this method is to
	     * "tap into" a method chain sequence in order to modify intermediate results.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Seq
	     * @param {*} value The value to provide to `interceptor`.
	     * @param {Function} interceptor The function to invoke.
	     * @returns {*} Returns `value`.
	     * @example
	     *
	     * _([1, 2, 3])
	     *  .tap(function(array) {
	     *    // Mutate input array.
	     *    array.pop();
	     *  })
	     *  .reverse()
	     *  .value();
	     * // => [2, 1]
	     */
	    function tap(value, interceptor) {
	      interceptor(value);
	      return value;
	    }

	    /**
	     * This method is like `_.tap` except that it returns the result of `interceptor`.
	     * The purpose of this method is to "pass thru" values replacing intermediate
	     * results in a method chain sequence.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Seq
	     * @param {*} value The value to provide to `interceptor`.
	     * @param {Function} interceptor The function to invoke.
	     * @returns {*} Returns the result of `interceptor`.
	     * @example
	     *
	     * _('  abc  ')
	     *  .chain()
	     *  .trim()
	     *  .thru(function(value) {
	     *    return [value];
	     *  })
	     *  .value();
	     * // => ['abc']
	     */
	    function thru(value, interceptor) {
	      return interceptor(value);
	    }

	    /**
	     * This method is the wrapper version of `_.at`.
	     *
	     * @name at
	     * @memberOf _
	     * @since 1.0.0
	     * @category Seq
	     * @param {...(string|string[])} [paths] The property paths of elements to pick.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
	     *
	     * _(object).at(['a[0].b.c', 'a[1]']).value();
	     * // => [3, 4]
	     */
	    var wrapperAt = flatRest(function(paths) {
	      var length = paths.length,
	          start = length ? paths[0] : 0,
	          value = this.__wrapped__,
	          interceptor = function(object) { return baseAt(object, paths); };

	      if (length > 1 || this.__actions__.length ||
	          !(value instanceof LazyWrapper) || !isIndex(start)) {
	        return this.thru(interceptor);
	      }
	      value = value.slice(start, +start + (length ? 1 : 0));
	      value.__actions__.push({
	        'func': thru,
	        'args': [interceptor],
	        'thisArg': undefined
	      });
	      return new LodashWrapper(value, this.__chain__).thru(function(array) {
	        if (length && !array.length) {
	          array.push(undefined);
	        }
	        return array;
	      });
	    });

	    /**
	     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
	     *
	     * @name chain
	     * @memberOf _
	     * @since 0.1.0
	     * @category Seq
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 }
	     * ];
	     *
	     * // A sequence without explicit chaining.
	     * _(users).head();
	     * // => { 'user': 'barney', 'age': 36 }
	     *
	     * // A sequence with explicit chaining.
	     * _(users)
	     *   .chain()
	     *   .head()
	     *   .pick('user')
	     *   .value();
	     * // => { 'user': 'barney' }
	     */
	    function wrapperChain() {
	      return chain(this);
	    }

	    /**
	     * Executes the chain sequence and returns the wrapped result.
	     *
	     * @name commit
	     * @memberOf _
	     * @since 3.2.0
	     * @category Seq
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var array = [1, 2];
	     * var wrapped = _(array).push(3);
	     *
	     * console.log(array);
	     * // => [1, 2]
	     *
	     * wrapped = wrapped.commit();
	     * console.log(array);
	     * // => [1, 2, 3]
	     *
	     * wrapped.last();
	     * // => 3
	     *
	     * console.log(array);
	     * // => [1, 2, 3]
	     */
	    function wrapperCommit() {
	      return new LodashWrapper(this.value(), this.__chain__);
	    }

	    /**
	     * Gets the next value on a wrapped object following the
	     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
	     *
	     * @name next
	     * @memberOf _
	     * @since 4.0.0
	     * @category Seq
	     * @returns {Object} Returns the next iterator value.
	     * @example
	     *
	     * var wrapped = _([1, 2]);
	     *
	     * wrapped.next();
	     * // => { 'done': false, 'value': 1 }
	     *
	     * wrapped.next();
	     * // => { 'done': false, 'value': 2 }
	     *
	     * wrapped.next();
	     * // => { 'done': true, 'value': undefined }
	     */
	    function wrapperNext() {
	      if (this.__values__ === undefined) {
	        this.__values__ = toArray(this.value());
	      }
	      var done = this.__index__ >= this.__values__.length,
	          value = done ? undefined : this.__values__[this.__index__++];

	      return { 'done': done, 'value': value };
	    }

	    /**
	     * Enables the wrapper to be iterable.
	     *
	     * @name Symbol.iterator
	     * @memberOf _
	     * @since 4.0.0
	     * @category Seq
	     * @returns {Object} Returns the wrapper object.
	     * @example
	     *
	     * var wrapped = _([1, 2]);
	     *
	     * wrapped[Symbol.iterator]() === wrapped;
	     * // => true
	     *
	     * Array.from(wrapped);
	     * // => [1, 2]
	     */
	    function wrapperToIterator() {
	      return this;
	    }

	    /**
	     * Creates a clone of the chain sequence planting `value` as the wrapped value.
	     *
	     * @name plant
	     * @memberOf _
	     * @since 3.2.0
	     * @category Seq
	     * @param {*} value The value to plant.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var wrapped = _([1, 2]).map(square);
	     * var other = wrapped.plant([3, 4]);
	     *
	     * other.value();
	     * // => [9, 16]
	     *
	     * wrapped.value();
	     * // => [1, 4]
	     */
	    function wrapperPlant(value) {
	      var result,
	          parent = this;

	      while (parent instanceof baseLodash) {
	        var clone = wrapperClone(parent);
	        clone.__index__ = 0;
	        clone.__values__ = undefined;
	        if (result) {
	          previous.__wrapped__ = clone;
	        } else {
	          result = clone;
	        }
	        var previous = clone;
	        parent = parent.__wrapped__;
	      }
	      previous.__wrapped__ = value;
	      return result;
	    }

	    /**
	     * This method is the wrapper version of `_.reverse`.
	     *
	     * **Note:** This method mutates the wrapped array.
	     *
	     * @name reverse
	     * @memberOf _
	     * @since 0.1.0
	     * @category Seq
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var array = [1, 2, 3];
	     *
	     * _(array).reverse().value()
	     * // => [3, 2, 1]
	     *
	     * console.log(array);
	     * // => [3, 2, 1]
	     */
	    function wrapperReverse() {
	      var value = this.__wrapped__;
	      if (value instanceof LazyWrapper) {
	        var wrapped = value;
	        if (this.__actions__.length) {
	          wrapped = new LazyWrapper(this);
	        }
	        wrapped = wrapped.reverse();
	        wrapped.__actions__.push({
	          'func': thru,
	          'args': [reverse],
	          'thisArg': undefined
	        });
	        return new LodashWrapper(wrapped, this.__chain__);
	      }
	      return this.thru(reverse);
	    }

	    /**
	     * Executes the chain sequence to resolve the unwrapped value.
	     *
	     * @name value
	     * @memberOf _
	     * @since 0.1.0
	     * @alias toJSON, valueOf
	     * @category Seq
	     * @returns {*} Returns the resolved unwrapped value.
	     * @example
	     *
	     * _([1, 2, 3]).value();
	     * // => [1, 2, 3]
	     */
	    function wrapperValue() {
	      return baseWrapperValue(this.__wrapped__, this.__actions__);
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` thru `iteratee`. The corresponding value of
	     * each key is the number of times the key was returned by `iteratee`. The
	     * iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.5.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * _.countBy([6.1, 4.2, 6.3], Math.floor);
	     * // => { '4': 1, '6': 2 }
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.countBy(['one', 'two', 'three'], 'length');
	     * // => { '3': 2, '5': 1 }
	     */
	    var countBy = createAggregator(function(result, value, key) {
	      if (hasOwnProperty.call(result, key)) {
	        ++result[key];
	      } else {
	        baseAssignValue(result, key, 1);
	      }
	    });

	    /**
	     * Checks if `predicate` returns truthy for **all** elements of `collection`.
	     * Iteration is stopped once `predicate` returns falsey. The predicate is
	     * invoked with three arguments: (value, index|key, collection).
	     *
	     * **Note:** This method returns `true` for
	     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
	     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
	     * elements of empty collections.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {boolean} Returns `true` if all elements pass the predicate check,
	     *  else `false`.
	     * @example
	     *
	     * _.every([true, 1, null, 'yes'], Boolean);
	     * // => false
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': false },
	     *   { 'user': 'fred',   'age': 40, 'active': false }
	     * ];
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.every(users, { 'user': 'barney', 'active': false });
	     * // => false
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.every(users, ['active', false]);
	     * // => true
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.every(users, 'active');
	     * // => false
	     */
	    function every(collection, predicate, guard) {
	      var func = isArray(collection) ? arrayEvery : baseEvery;
	      if (guard && isIterateeCall(collection, predicate, guard)) {
	        predicate = undefined;
	      }
	      return func(collection, getIteratee(predicate, 3));
	    }

	    /**
	     * Iterates over elements of `collection`, returning an array of all elements
	     * `predicate` returns truthy for. The predicate is invoked with three
	     * arguments: (value, index|key, collection).
	     *
	     * **Note:** Unlike `_.remove`, this method returns a new array.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new filtered array.
	     * @see _.reject
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': true },
	     *   { 'user': 'fred',   'age': 40, 'active': false }
	     * ];
	     *
	     * _.filter(users, function(o) { return !o.active; });
	     * // => objects for ['fred']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.filter(users, { 'age': 36, 'active': true });
	     * // => objects for ['barney']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.filter(users, ['active', false]);
	     * // => objects for ['fred']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.filter(users, 'active');
	     * // => objects for ['barney']
	     */
	    function filter(collection, predicate) {
	      var func = isArray(collection) ? arrayFilter : baseFilter;
	      return func(collection, getIteratee(predicate, 3));
	    }

	    /**
	     * Iterates over elements of `collection`, returning the first element
	     * `predicate` returns truthy for. The predicate is invoked with three
	     * arguments: (value, index|key, collection).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param {number} [fromIndex=0] The index to search from.
	     * @returns {*} Returns the matched element, else `undefined`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36, 'active': true },
	     *   { 'user': 'fred',    'age': 40, 'active': false },
	     *   { 'user': 'pebbles', 'age': 1,  'active': true }
	     * ];
	     *
	     * _.find(users, function(o) { return o.age < 40; });
	     * // => object for 'barney'
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.find(users, { 'age': 1, 'active': true });
	     * // => object for 'pebbles'
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.find(users, ['active', false]);
	     * // => object for 'fred'
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.find(users, 'active');
	     * // => object for 'barney'
	     */
	    var find = createFind(findIndex);

	    /**
	     * This method is like `_.find` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param {number} [fromIndex=collection.length-1] The index to search from.
	     * @returns {*} Returns the matched element, else `undefined`.
	     * @example
	     *
	     * _.findLast([1, 2, 3, 4], function(n) {
	     *   return n % 2 == 1;
	     * });
	     * // => 3
	     */
	    var findLast = createFind(findLastIndex);

	    /**
	     * Creates a flattened array of values by running each element in `collection`
	     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
	     * with three arguments: (value, index|key, collection).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * function duplicate(n) {
	     *   return [n, n];
	     * }
	     *
	     * _.flatMap([1, 2], duplicate);
	     * // => [1, 1, 2, 2]
	     */
	    function flatMap(collection, iteratee) {
	      return baseFlatten(map(collection, iteratee), 1);
	    }

	    /**
	     * This method is like `_.flatMap` except that it recursively flattens the
	     * mapped results.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.7.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * function duplicate(n) {
	     *   return [[[n, n]]];
	     * }
	     *
	     * _.flatMapDeep([1, 2], duplicate);
	     * // => [1, 1, 2, 2]
	     */
	    function flatMapDeep(collection, iteratee) {
	      return baseFlatten(map(collection, iteratee), INFINITY);
	    }

	    /**
	     * This method is like `_.flatMap` except that it recursively flattens the
	     * mapped results up to `depth` times.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.7.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {number} [depth=1] The maximum recursion depth.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * function duplicate(n) {
	     *   return [[[n, n]]];
	     * }
	     *
	     * _.flatMapDepth([1, 2], duplicate, 2);
	     * // => [[1, 1], [2, 2]]
	     */
	    function flatMapDepth(collection, iteratee, depth) {
	      depth = depth === undefined ? 1 : toInteger(depth);
	      return baseFlatten(map(collection, iteratee), depth);
	    }

	    /**
	     * Iterates over elements of `collection` and invokes `iteratee` for each element.
	     * The iteratee is invoked with three arguments: (value, index|key, collection).
	     * Iteratee functions may exit iteration early by explicitly returning `false`.
	     *
	     * **Note:** As with other "Collections" methods, objects with a "length"
	     * property are iterated like arrays. To avoid this behavior use `_.forIn`
	     * or `_.forOwn` for object iteration.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @alias each
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array|Object} Returns `collection`.
	     * @see _.forEachRight
	     * @example
	     *
	     * _.forEach([1, 2], function(value) {
	     *   console.log(value);
	     * });
	     * // => Logs `1` then `2`.
	     *
	     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
	     */
	    function forEach(collection, iteratee) {
	      var func = isArray(collection) ? arrayEach : baseEach;
	      return func(collection, getIteratee(iteratee, 3));
	    }

	    /**
	     * This method is like `_.forEach` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @alias eachRight
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array|Object} Returns `collection`.
	     * @see _.forEach
	     * @example
	     *
	     * _.forEachRight([1, 2], function(value) {
	     *   console.log(value);
	     * });
	     * // => Logs `2` then `1`.
	     */
	    function forEachRight(collection, iteratee) {
	      var func = isArray(collection) ? arrayEachRight : baseEachRight;
	      return func(collection, getIteratee(iteratee, 3));
	    }

	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` thru `iteratee`. The order of grouped values
	     * is determined by the order they occur in `collection`. The corresponding
	     * value of each key is an array of elements responsible for generating the
	     * key. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
	     * // => { '4': [4.2], '6': [6.1, 6.3] }
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.groupBy(['one', 'two', 'three'], 'length');
	     * // => { '3': ['one', 'two'], '5': ['three'] }
	     */
	    var groupBy = createAggregator(function(result, value, key) {
	      if (hasOwnProperty.call(result, key)) {
	        result[key].push(value);
	      } else {
	        baseAssignValue(result, key, [value]);
	      }
	    });

	    /**
	     * Checks if `value` is in `collection`. If `collection` is a string, it's
	     * checked for a substring of `value`, otherwise
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * is used for equality comparisons. If `fromIndex` is negative, it's used as
	     * the offset from the end of `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to inspect.
	     * @param {*} value The value to search for.
	     * @param {number} [fromIndex=0] The index to search from.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
	     * @returns {boolean} Returns `true` if `value` is found, else `false`.
	     * @example
	     *
	     * _.includes([1, 2, 3], 1);
	     * // => true
	     *
	     * _.includes([1, 2, 3], 1, 2);
	     * // => false
	     *
	     * _.includes({ 'a': 1, 'b': 2 }, 1);
	     * // => true
	     *
	     * _.includes('abcd', 'bc');
	     * // => true
	     */
	    function includes(collection, value, fromIndex, guard) {
	      collection = isArrayLike(collection) ? collection : values(collection);
	      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

	      var length = collection.length;
	      if (fromIndex < 0) {
	        fromIndex = nativeMax(length + fromIndex, 0);
	      }
	      return isString(collection)
	        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
	        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
	    }

	    /**
	     * Invokes the method at `path` of each element in `collection`, returning
	     * an array of the results of each invoked method. Any additional arguments
	     * are provided to each invoked method. If `path` is a function, it's invoked
	     * for, and `this` bound to, each element in `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Array|Function|string} path The path of the method to invoke or
	     *  the function invoked per iteration.
	     * @param {...*} [args] The arguments to invoke each method with.
	     * @returns {Array} Returns the array of results.
	     * @example
	     *
	     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
	     * // => [[1, 5, 7], [1, 2, 3]]
	     *
	     * _.invokeMap([123, 456], String.prototype.split, '');
	     * // => [['1', '2', '3'], ['4', '5', '6']]
	     */
	    var invokeMap = baseRest(function(collection, path, args) {
	      var index = -1,
	          isFunc = typeof path == 'function',
	          isProp = isKey(path),
	          result = isArrayLike(collection) ? Array(collection.length) : [];

	      baseEach(collection, function(value) {
	        var func = isFunc ? path : ((isProp && value != null) ? value[path] : undefined);
	        result[++index] = func ? apply(func, value, args) : baseInvoke(value, path, args);
	      });
	      return result;
	    });

	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` thru `iteratee`. The corresponding value of
	     * each key is the last element responsible for generating the key. The
	     * iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * var array = [
	     *   { 'dir': 'left', 'code': 97 },
	     *   { 'dir': 'right', 'code': 100 }
	     * ];
	     *
	     * _.keyBy(array, function(o) {
	     *   return String.fromCharCode(o.code);
	     * });
	     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
	     *
	     * _.keyBy(array, 'dir');
	     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
	     */
	    var keyBy = createAggregator(function(result, value, key) {
	      baseAssignValue(result, key, value);
	    });

	    /**
	     * Creates an array of values by running each element in `collection` thru
	     * `iteratee`. The iteratee is invoked with three arguments:
	     * (value, index|key, collection).
	     *
	     * Many lodash methods are guarded to work as iteratees for methods like
	     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
	     *
	     * The guarded methods are:
	     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
	     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
	     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
	     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new mapped array.
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * _.map([4, 8], square);
	     * // => [16, 64]
	     *
	     * _.map({ 'a': 4, 'b': 8 }, square);
	     * // => [16, 64] (iteration order is not guaranteed)
	     *
	     * var users = [
	     *   { 'user': 'barney' },
	     *   { 'user': 'fred' }
	     * ];
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.map(users, 'user');
	     * // => ['barney', 'fred']
	     */
	    function map(collection, iteratee) {
	      var func = isArray(collection) ? arrayMap : baseMap;
	      return func(collection, getIteratee(iteratee, 3));
	    }

	    /**
	     * This method is like `_.sortBy` except that it allows specifying the sort
	     * orders of the iteratees to sort by. If `orders` is unspecified, all values
	     * are sorted in ascending order. Otherwise, specify an order of "desc" for
	     * descending or "asc" for ascending sort order of corresponding values.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
	     *  The iteratees to sort by.
	     * @param {string[]} [orders] The sort orders of `iteratees`.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
	     * @returns {Array} Returns the new sorted array.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'fred',   'age': 48 },
	     *   { 'user': 'barney', 'age': 34 },
	     *   { 'user': 'fred',   'age': 40 },
	     *   { 'user': 'barney', 'age': 36 }
	     * ];
	     *
	     * // Sort by `user` in ascending order and by `age` in descending order.
	     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
	     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
	     */
	    function orderBy(collection, iteratees, orders, guard) {
	      if (collection == null) {
	        return [];
	      }
	      if (!isArray(iteratees)) {
	        iteratees = iteratees == null ? [] : [iteratees];
	      }
	      orders = guard ? undefined : orders;
	      if (!isArray(orders)) {
	        orders = orders == null ? [] : [orders];
	      }
	      return baseOrderBy(collection, iteratees, orders);
	    }

	    /**
	     * Creates an array of elements split into two groups, the first of which
	     * contains elements `predicate` returns truthy for, the second of which
	     * contains elements `predicate` returns falsey for. The predicate is
	     * invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the array of grouped elements.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36, 'active': false },
	     *   { 'user': 'fred',    'age': 40, 'active': true },
	     *   { 'user': 'pebbles', 'age': 1,  'active': false }
	     * ];
	     *
	     * _.partition(users, function(o) { return o.active; });
	     * // => objects for [['fred'], ['barney', 'pebbles']]
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.partition(users, { 'age': 1, 'active': false });
	     * // => objects for [['pebbles'], ['barney', 'fred']]
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.partition(users, ['active', false]);
	     * // => objects for [['barney', 'pebbles'], ['fred']]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.partition(users, 'active');
	     * // => objects for [['fred'], ['barney', 'pebbles']]
	     */
	    var partition = createAggregator(function(result, value, key) {
	      result[key ? 0 : 1].push(value);
	    }, function() { return [[], []]; });

	    /**
	     * Reduces `collection` to a value which is the accumulated result of running
	     * each element in `collection` thru `iteratee`, where each successive
	     * invocation is supplied the return value of the previous. If `accumulator`
	     * is not given, the first element of `collection` is used as the initial
	     * value. The iteratee is invoked with four arguments:
	     * (accumulator, value, index|key, collection).
	     *
	     * Many lodash methods are guarded to work as iteratees for methods like
	     * `_.reduce`, `_.reduceRight`, and `_.transform`.
	     *
	     * The guarded methods are:
	     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
	     * and `sortBy`
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The initial value.
	     * @returns {*} Returns the accumulated value.
	     * @see _.reduceRight
	     * @example
	     *
	     * _.reduce([1, 2], function(sum, n) {
	     *   return sum + n;
	     * }, 0);
	     * // => 3
	     *
	     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
	     *   (result[value] || (result[value] = [])).push(key);
	     *   return result;
	     * }, {});
	     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
	     */
	    function reduce(collection, iteratee, accumulator) {
	      var func = isArray(collection) ? arrayReduce : baseReduce,
	          initAccum = arguments.length < 3;

	      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
	    }

	    /**
	     * This method is like `_.reduce` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The initial value.
	     * @returns {*} Returns the accumulated value.
	     * @see _.reduce
	     * @example
	     *
	     * var array = [[0, 1], [2, 3], [4, 5]];
	     *
	     * _.reduceRight(array, function(flattened, other) {
	     *   return flattened.concat(other);
	     * }, []);
	     * // => [4, 5, 2, 3, 0, 1]
	     */
	    function reduceRight(collection, iteratee, accumulator) {
	      var func = isArray(collection) ? arrayReduceRight : baseReduce,
	          initAccum = arguments.length < 3;

	      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
	    }

	    /**
	     * The opposite of `_.filter`; this method returns the elements of `collection`
	     * that `predicate` does **not** return truthy for.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new filtered array.
	     * @see _.filter
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': false },
	     *   { 'user': 'fred',   'age': 40, 'active': true }
	     * ];
	     *
	     * _.reject(users, function(o) { return !o.active; });
	     * // => objects for ['fred']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.reject(users, { 'age': 40, 'active': true });
	     * // => objects for ['barney']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.reject(users, ['active', false]);
	     * // => objects for ['fred']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.reject(users, 'active');
	     * // => objects for ['barney']
	     */
	    function reject(collection, predicate) {
	      var func = isArray(collection) ? arrayFilter : baseFilter;
	      return func(collection, negate(getIteratee(predicate, 3)));
	    }

	    /**
	     * Gets a random element from `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to sample.
	     * @returns {*} Returns the random element.
	     * @example
	     *
	     * _.sample([1, 2, 3, 4]);
	     * // => 2
	     */
	    function sample(collection) {
	      var func = isArray(collection) ? arraySample : baseSample;
	      return func(collection);
	    }

	    /**
	     * Gets `n` random elements at unique keys from `collection` up to the
	     * size of `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to sample.
	     * @param {number} [n=1] The number of elements to sample.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the random elements.
	     * @example
	     *
	     * _.sampleSize([1, 2, 3], 2);
	     * // => [3, 1]
	     *
	     * _.sampleSize([1, 2, 3], 4);
	     * // => [2, 3, 1]
	     */
	    function sampleSize(collection, n, guard) {
	      if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {
	        n = 1;
	      } else {
	        n = toInteger(n);
	      }
	      var func = isArray(collection) ? arraySampleSize : baseSampleSize;
	      return func(collection, n);
	    }

	    /**
	     * Creates an array of shuffled values, using a version of the
	     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to shuffle.
	     * @returns {Array} Returns the new shuffled array.
	     * @example
	     *
	     * _.shuffle([1, 2, 3, 4]);
	     * // => [4, 1, 3, 2]
	     */
	    function shuffle(collection) {
	      var func = isArray(collection) ? arrayShuffle : baseShuffle;
	      return func(collection);
	    }

	    /**
	     * Gets the size of `collection` by returning its length for array-like
	     * values or the number of own enumerable string keyed properties for objects.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to inspect.
	     * @returns {number} Returns the collection size.
	     * @example
	     *
	     * _.size([1, 2, 3]);
	     * // => 3
	     *
	     * _.size({ 'a': 1, 'b': 2 });
	     * // => 2
	     *
	     * _.size('pebbles');
	     * // => 7
	     */
	    function size(collection) {
	      if (collection == null) {
	        return 0;
	      }
	      if (isArrayLike(collection)) {
	        return isString(collection) ? stringSize(collection) : collection.length;
	      }
	      var tag = getTag(collection);
	      if (tag == mapTag || tag == setTag) {
	        return collection.size;
	      }
	      return baseKeys(collection).length;
	    }

	    /**
	     * Checks if `predicate` returns truthy for **any** element of `collection`.
	     * Iteration is stopped once `predicate` returns truthy. The predicate is
	     * invoked with three arguments: (value, index|key, collection).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {boolean} Returns `true` if any element passes the predicate check,
	     *  else `false`.
	     * @example
	     *
	     * _.some([null, 0, 'yes', false], Boolean);
	     * // => true
	     *
	     * var users = [
	     *   { 'user': 'barney', 'active': true },
	     *   { 'user': 'fred',   'active': false }
	     * ];
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.some(users, { 'user': 'barney', 'active': false });
	     * // => false
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.some(users, ['active', false]);
	     * // => true
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.some(users, 'active');
	     * // => true
	     */
	    function some(collection, predicate, guard) {
	      var func = isArray(collection) ? arraySome : baseSome;
	      if (guard && isIterateeCall(collection, predicate, guard)) {
	        predicate = undefined;
	      }
	      return func(collection, getIteratee(predicate, 3));
	    }

	    /**
	     * Creates an array of elements, sorted in ascending order by the results of
	     * running each element in a collection thru each iteratee. This method
	     * performs a stable sort, that is, it preserves the original sort order of
	     * equal elements. The iteratees are invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {...(Function|Function[])} [iteratees=[_.identity]]
	     *  The iteratees to sort by.
	     * @returns {Array} Returns the new sorted array.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'fred',   'age': 48 },
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 },
	     *   { 'user': 'barney', 'age': 34 }
	     * ];
	     *
	     * _.sortBy(users, [function(o) { return o.user; }]);
	     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
	     *
	     * _.sortBy(users, ['user', 'age']);
	     * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
	     */
	    var sortBy = baseRest(function(collection, iteratees) {
	      if (collection == null) {
	        return [];
	      }
	      var length = iteratees.length;
	      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
	        iteratees = [];
	      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
	        iteratees = [iteratees[0]];
	      }
	      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
	    });

	    /*------------------------------------------------------------------------*/

	    /**
	     * Gets the timestamp of the number of milliseconds that have elapsed since
	     * the Unix epoch (1 January 1970 00:00:00 UTC).
	     *
	     * @static
	     * @memberOf _
	     * @since 2.4.0
	     * @category Date
	     * @returns {number} Returns the timestamp.
	     * @example
	     *
	     * _.defer(function(stamp) {
	     *   console.log(_.now() - stamp);
	     * }, _.now());
	     * // => Logs the number of milliseconds it took for the deferred invocation.
	     */
	    var now = ctxNow || function() {
	      return root.Date.now();
	    };

	    /*------------------------------------------------------------------------*/

	    /**
	     * The opposite of `_.before`; this method creates a function that invokes
	     * `func` once it's called `n` or more times.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {number} n The number of calls before `func` is invoked.
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * var saves = ['profile', 'settings'];
	     *
	     * var done = _.after(saves.length, function() {
	     *   console.log('done saving!');
	     * });
	     *
	     * _.forEach(saves, function(type) {
	     *   asyncSave({ 'type': type, 'complete': done });
	     * });
	     * // => Logs 'done saving!' after the two async saves have completed.
	     */
	    function after(n, func) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      n = toInteger(n);
	      return function() {
	        if (--n < 1) {
	          return func.apply(this, arguments);
	        }
	      };
	    }

	    /**
	     * Creates a function that invokes `func`, with up to `n` arguments,
	     * ignoring any additional arguments.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Function
	     * @param {Function} func The function to cap arguments for.
	     * @param {number} [n=func.length] The arity cap.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Function} Returns the new capped function.
	     * @example
	     *
	     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
	     * // => [6, 8, 10]
	     */
	    function ary(func, n, guard) {
	      n = guard ? undefined : n;
	      n = (func && n == null) ? func.length : n;
	      return createWrap(func, ARY_FLAG, undefined, undefined, undefined, undefined, n);
	    }

	    /**
	     * Creates a function that invokes `func`, with the `this` binding and arguments
	     * of the created function, while it's called less than `n` times. Subsequent
	     * calls to the created function return the result of the last `func` invocation.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Function
	     * @param {number} n The number of calls at which `func` is no longer invoked.
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * jQuery(element).on('click', _.before(5, addContactToList));
	     * // => Allows adding up to 4 contacts to the list.
	     */
	    function before(n, func) {
	      var result;
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      n = toInteger(n);
	      return function() {
	        if (--n > 0) {
	          result = func.apply(this, arguments);
	        }
	        if (n <= 1) {
	          func = undefined;
	        }
	        return result;
	      };
	    }

	    /**
	     * Creates a function that invokes `func` with the `this` binding of `thisArg`
	     * and `partials` prepended to the arguments it receives.
	     *
	     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
	     * may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
	     * property of bound functions.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to bind.
	     * @param {*} thisArg The `this` binding of `func`.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new bound function.
	     * @example
	     *
	     * function greet(greeting, punctuation) {
	     *   return greeting + ' ' + this.user + punctuation;
	     * }
	     *
	     * var object = { 'user': 'fred' };
	     *
	     * var bound = _.bind(greet, object, 'hi');
	     * bound('!');
	     * // => 'hi fred!'
	     *
	     * // Bound with placeholders.
	     * var bound = _.bind(greet, object, _, '!');
	     * bound('hi');
	     * // => 'hi fred!'
	     */
	    var bind = baseRest(function(func, thisArg, partials) {
	      var bitmask = BIND_FLAG;
	      if (partials.length) {
	        var holders = replaceHolders(partials, getHolder(bind));
	        bitmask |= PARTIAL_FLAG;
	      }
	      return createWrap(func, bitmask, thisArg, partials, holders);
	    });

	    /**
	     * Creates a function that invokes the method at `object[key]` with `partials`
	     * prepended to the arguments it receives.
	     *
	     * This method differs from `_.bind` by allowing bound functions to reference
	     * methods that may be redefined or don't yet exist. See
	     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
	     * for more details.
	     *
	     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.10.0
	     * @category Function
	     * @param {Object} object The object to invoke the method on.
	     * @param {string} key The key of the method.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new bound function.
	     * @example
	     *
	     * var object = {
	     *   'user': 'fred',
	     *   'greet': function(greeting, punctuation) {
	     *     return greeting + ' ' + this.user + punctuation;
	     *   }
	     * };
	     *
	     * var bound = _.bindKey(object, 'greet', 'hi');
	     * bound('!');
	     * // => 'hi fred!'
	     *
	     * object.greet = function(greeting, punctuation) {
	     *   return greeting + 'ya ' + this.user + punctuation;
	     * };
	     *
	     * bound('!');
	     * // => 'hiya fred!'
	     *
	     * // Bound with placeholders.
	     * var bound = _.bindKey(object, 'greet', _, '!');
	     * bound('hi');
	     * // => 'hiya fred!'
	     */
	    var bindKey = baseRest(function(object, key, partials) {
	      var bitmask = BIND_FLAG | BIND_KEY_FLAG;
	      if (partials.length) {
	        var holders = replaceHolders(partials, getHolder(bindKey));
	        bitmask |= PARTIAL_FLAG;
	      }
	      return createWrap(key, bitmask, object, partials, holders);
	    });

	    /**
	     * Creates a function that accepts arguments of `func` and either invokes
	     * `func` returning its result, if at least `arity` number of arguments have
	     * been provided, or returns a function that accepts the remaining `func`
	     * arguments, and so on. The arity of `func` may be specified if `func.length`
	     * is not sufficient.
	     *
	     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
	     * may be used as a placeholder for provided arguments.
	     *
	     * **Note:** This method doesn't set the "length" property of curried functions.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Function
	     * @param {Function} func The function to curry.
	     * @param {number} [arity=func.length] The arity of `func`.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Function} Returns the new curried function.
	     * @example
	     *
	     * var abc = function(a, b, c) {
	     *   return [a, b, c];
	     * };
	     *
	     * var curried = _.curry(abc);
	     *
	     * curried(1)(2)(3);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2)(3);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2, 3);
	     * // => [1, 2, 3]
	     *
	     * // Curried with placeholders.
	     * curried(1)(_, 3)(2);
	     * // => [1, 2, 3]
	     */
	    function curry(func, arity, guard) {
	      arity = guard ? undefined : arity;
	      var result = createWrap(func, CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
	      result.placeholder = curry.placeholder;
	      return result;
	    }

	    /**
	     * This method is like `_.curry` except that arguments are applied to `func`
	     * in the manner of `_.partialRight` instead of `_.partial`.
	     *
	     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for provided arguments.
	     *
	     * **Note:** This method doesn't set the "length" property of curried functions.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Function
	     * @param {Function} func The function to curry.
	     * @param {number} [arity=func.length] The arity of `func`.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Function} Returns the new curried function.
	     * @example
	     *
	     * var abc = function(a, b, c) {
	     *   return [a, b, c];
	     * };
	     *
	     * var curried = _.curryRight(abc);
	     *
	     * curried(3)(2)(1);
	     * // => [1, 2, 3]
	     *
	     * curried(2, 3)(1);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2, 3);
	     * // => [1, 2, 3]
	     *
	     * // Curried with placeholders.
	     * curried(3)(1, _)(2);
	     * // => [1, 2, 3]
	     */
	    function curryRight(func, arity, guard) {
	      arity = guard ? undefined : arity;
	      var result = createWrap(func, CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
	      result.placeholder = curryRight.placeholder;
	      return result;
	    }

	    /**
	     * Creates a debounced function that delays invoking `func` until after `wait`
	     * milliseconds have elapsed since the last time the debounced function was
	     * invoked. The debounced function comes with a `cancel` method to cancel
	     * delayed `func` invocations and a `flush` method to immediately invoke them.
	     * Provide `options` to indicate whether `func` should be invoked on the
	     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
	     * with the last arguments provided to the debounced function. Subsequent
	     * calls to the debounced function return the result of the last `func`
	     * invocation.
	     *
	     * **Note:** If `leading` and `trailing` options are `true`, `func` is
	     * invoked on the trailing edge of the timeout only if the debounced function
	     * is invoked more than once during the `wait` timeout.
	     *
	     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
	     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
	     *
	     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	     * for details over the differences between `_.debounce` and `_.throttle`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to debounce.
	     * @param {number} [wait=0] The number of milliseconds to delay.
	     * @param {Object} [options={}] The options object.
	     * @param {boolean} [options.leading=false]
	     *  Specify invoking on the leading edge of the timeout.
	     * @param {number} [options.maxWait]
	     *  The maximum time `func` is allowed to be delayed before it's invoked.
	     * @param {boolean} [options.trailing=true]
	     *  Specify invoking on the trailing edge of the timeout.
	     * @returns {Function} Returns the new debounced function.
	     * @example
	     *
	     * // Avoid costly calculations while the window size is in flux.
	     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
	     *
	     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
	     * jQuery(element).on('click', _.debounce(sendMail, 300, {
	     *   'leading': true,
	     *   'trailing': false
	     * }));
	     *
	     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
	     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
	     * var source = new EventSource('/stream');
	     * jQuery(source).on('message', debounced);
	     *
	     * // Cancel the trailing debounced invocation.
	     * jQuery(window).on('popstate', debounced.cancel);
	     */
	    function debounce(func, wait, options) {
	      var lastArgs,
	          lastThis,
	          maxWait,
	          result,
	          timerId,
	          lastCallTime,
	          lastInvokeTime = 0,
	          leading = false,
	          maxing = false,
	          trailing = true;

	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      wait = toNumber(wait) || 0;
	      if (isObject(options)) {
	        leading = !!options.leading;
	        maxing = 'maxWait' in options;
	        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
	        trailing = 'trailing' in options ? !!options.trailing : trailing;
	      }

	      function invokeFunc(time) {
	        var args = lastArgs,
	            thisArg = lastThis;

	        lastArgs = lastThis = undefined;
	        lastInvokeTime = time;
	        result = func.apply(thisArg, args);
	        return result;
	      }

	      function leadingEdge(time) {
	        // Reset any `maxWait` timer.
	        lastInvokeTime = time;
	        // Start the timer for the trailing edge.
	        timerId = setTimeout(timerExpired, wait);
	        // Invoke the leading edge.
	        return leading ? invokeFunc(time) : result;
	      }

	      function remainingWait(time) {
	        var timeSinceLastCall = time - lastCallTime,
	            timeSinceLastInvoke = time - lastInvokeTime,
	            result = wait - timeSinceLastCall;

	        return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
	      }

	      function shouldInvoke(time) {
	        var timeSinceLastCall = time - lastCallTime,
	            timeSinceLastInvoke = time - lastInvokeTime;

	        // Either this is the first call, activity has stopped and we're at the
	        // trailing edge, the system time has gone backwards and we're treating
	        // it as the trailing edge, or we've hit the `maxWait` limit.
	        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
	          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
	      }

	      function timerExpired() {
	        var time = now();
	        if (shouldInvoke(time)) {
	          return trailingEdge(time);
	        }
	        // Restart the timer.
	        timerId = setTimeout(timerExpired, remainingWait(time));
	      }

	      function trailingEdge(time) {
	        timerId = undefined;

	        // Only invoke if we have `lastArgs` which means `func` has been
	        // debounced at least once.
	        if (trailing && lastArgs) {
	          return invokeFunc(time);
	        }
	        lastArgs = lastThis = undefined;
	        return result;
	      }

	      function cancel() {
	        if (timerId !== undefined) {
	          clearTimeout(timerId);
	        }
	        lastInvokeTime = 0;
	        lastArgs = lastCallTime = lastThis = timerId = undefined;
	      }

	      function flush() {
	        return timerId === undefined ? result : trailingEdge(now());
	      }

	      function debounced() {
	        var time = now(),
	            isInvoking = shouldInvoke(time);

	        lastArgs = arguments;
	        lastThis = this;
	        lastCallTime = time;

	        if (isInvoking) {
	          if (timerId === undefined) {
	            return leadingEdge(lastCallTime);
	          }
	          if (maxing) {
	            // Handle invocations in a tight loop.
	            timerId = setTimeout(timerExpired, wait);
	            return invokeFunc(lastCallTime);
	          }
	        }
	        if (timerId === undefined) {
	          timerId = setTimeout(timerExpired, wait);
	        }
	        return result;
	      }
	      debounced.cancel = cancel;
	      debounced.flush = flush;
	      return debounced;
	    }

	    /**
	     * Defers invoking the `func` until the current call stack has cleared. Any
	     * additional arguments are provided to `func` when it's invoked.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to defer.
	     * @param {...*} [args] The arguments to invoke `func` with.
	     * @returns {number} Returns the timer id.
	     * @example
	     *
	     * _.defer(function(text) {
	     *   console.log(text);
	     * }, 'deferred');
	     * // => Logs 'deferred' after one millisecond.
	     */
	    var defer = baseRest(function(func, args) {
	      return baseDelay(func, 1, args);
	    });

	    /**
	     * Invokes `func` after `wait` milliseconds. Any additional arguments are
	     * provided to `func` when it's invoked.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to delay.
	     * @param {number} wait The number of milliseconds to delay invocation.
	     * @param {...*} [args] The arguments to invoke `func` with.
	     * @returns {number} Returns the timer id.
	     * @example
	     *
	     * _.delay(function(text) {
	     *   console.log(text);
	     * }, 1000, 'later');
	     * // => Logs 'later' after one second.
	     */
	    var delay = baseRest(function(func, wait, args) {
	      return baseDelay(func, toNumber(wait) || 0, args);
	    });

	    /**
	     * Creates a function that invokes `func` with arguments reversed.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Function
	     * @param {Function} func The function to flip arguments for.
	     * @returns {Function} Returns the new flipped function.
	     * @example
	     *
	     * var flipped = _.flip(function() {
	     *   return _.toArray(arguments);
	     * });
	     *
	     * flipped('a', 'b', 'c', 'd');
	     * // => ['d', 'c', 'b', 'a']
	     */
	    function flip(func) {
	      return createWrap(func, FLIP_FLAG);
	    }

	    /**
	     * Creates a function that memoizes the result of `func`. If `resolver` is
	     * provided, it determines the cache key for storing the result based on the
	     * arguments provided to the memoized function. By default, the first argument
	     * provided to the memoized function is used as the map cache key. The `func`
	     * is invoked with the `this` binding of the memoized function.
	     *
	     * **Note:** The cache is exposed as the `cache` property on the memoized
	     * function. Its creation may be customized by replacing the `_.memoize.Cache`
	     * constructor with one whose instances implement the
	     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
	     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to have its output memoized.
	     * @param {Function} [resolver] The function to resolve the cache key.
	     * @returns {Function} Returns the new memoized function.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2 };
	     * var other = { 'c': 3, 'd': 4 };
	     *
	     * var values = _.memoize(_.values);
	     * values(object);
	     * // => [1, 2]
	     *
	     * values(other);
	     * // => [3, 4]
	     *
	     * object.a = 2;
	     * values(object);
	     * // => [1, 2]
	     *
	     * // Modify the result cache.
	     * values.cache.set(object, ['a', 'b']);
	     * values(object);
	     * // => ['a', 'b']
	     *
	     * // Replace `_.memoize.Cache`.
	     * _.memoize.Cache = WeakMap;
	     */
	    function memoize(func, resolver) {
	      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      var memoized = function() {
	        var args = arguments,
	            key = resolver ? resolver.apply(this, args) : args[0],
	            cache = memoized.cache;

	        if (cache.has(key)) {
	          return cache.get(key);
	        }
	        var result = func.apply(this, args);
	        memoized.cache = cache.set(key, result) || cache;
	        return result;
	      };
	      memoized.cache = new (memoize.Cache || MapCache);
	      return memoized;
	    }

	    // Expose `MapCache`.
	    memoize.Cache = MapCache;

	    /**
	     * Creates a function that negates the result of the predicate `func`. The
	     * `func` predicate is invoked with the `this` binding and arguments of the
	     * created function.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Function
	     * @param {Function} predicate The predicate to negate.
	     * @returns {Function} Returns the new negated function.
	     * @example
	     *
	     * function isEven(n) {
	     *   return n % 2 == 0;
	     * }
	     *
	     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
	     * // => [1, 3, 5]
	     */
	    function negate(predicate) {
	      if (typeof predicate != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      return function() {
	        var args = arguments;
	        switch (args.length) {
	          case 0: return !predicate.call(this);
	          case 1: return !predicate.call(this, args[0]);
	          case 2: return !predicate.call(this, args[0], args[1]);
	          case 3: return !predicate.call(this, args[0], args[1], args[2]);
	        }
	        return !predicate.apply(this, args);
	      };
	    }

	    /**
	     * Creates a function that is restricted to invoking `func` once. Repeat calls
	     * to the function return the value of the first invocation. The `func` is
	     * invoked with the `this` binding and arguments of the created function.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * var initialize = _.once(createApplication);
	     * initialize();
	     * initialize();
	     * // => `createApplication` is invoked once
	     */
	    function once(func) {
	      return before(2, func);
	    }

	    /**
	     * Creates a function that invokes `func` with its arguments transformed.
	     *
	     * @static
	     * @since 4.0.0
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to wrap.
	     * @param {...(Function|Function[])} [transforms=[_.identity]]
	     *  The argument transforms.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * function doubled(n) {
	     *   return n * 2;
	     * }
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var func = _.overArgs(function(x, y) {
	     *   return [x, y];
	     * }, [square, doubled]);
	     *
	     * func(9, 3);
	     * // => [81, 6]
	     *
	     * func(10, 5);
	     * // => [100, 10]
	     */
	    var overArgs = castRest(function(func, transforms) {
	      transforms = (transforms.length == 1 && isArray(transforms[0]))
	        ? arrayMap(transforms[0], baseUnary(getIteratee()))
	        : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));

	      var funcsLength = transforms.length;
	      return baseRest(function(args) {
	        var index = -1,
	            length = nativeMin(args.length, funcsLength);

	        while (++index < length) {
	          args[index] = transforms[index].call(this, args[index]);
	        }
	        return apply(func, this, args);
	      });
	    });

	    /**
	     * Creates a function that invokes `func` with `partials` prepended to the
	     * arguments it receives. This method is like `_.bind` except it does **not**
	     * alter the `this` binding.
	     *
	     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** This method doesn't set the "length" property of partially
	     * applied functions.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.2.0
	     * @category Function
	     * @param {Function} func The function to partially apply arguments to.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new partially applied function.
	     * @example
	     *
	     * function greet(greeting, name) {
	     *   return greeting + ' ' + name;
	     * }
	     *
	     * var sayHelloTo = _.partial(greet, 'hello');
	     * sayHelloTo('fred');
	     * // => 'hello fred'
	     *
	     * // Partially applied with placeholders.
	     * var greetFred = _.partial(greet, _, 'fred');
	     * greetFred('hi');
	     * // => 'hi fred'
	     */
	    var partial = baseRest(function(func, partials) {
	      var holders = replaceHolders(partials, getHolder(partial));
	      return createWrap(func, PARTIAL_FLAG, undefined, partials, holders);
	    });

	    /**
	     * This method is like `_.partial` except that partially applied arguments
	     * are appended to the arguments it receives.
	     *
	     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** This method doesn't set the "length" property of partially
	     * applied functions.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.0.0
	     * @category Function
	     * @param {Function} func The function to partially apply arguments to.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new partially applied function.
	     * @example
	     *
	     * function greet(greeting, name) {
	     *   return greeting + ' ' + name;
	     * }
	     *
	     * var greetFred = _.partialRight(greet, 'fred');
	     * greetFred('hi');
	     * // => 'hi fred'
	     *
	     * // Partially applied with placeholders.
	     * var sayHelloTo = _.partialRight(greet, 'hello', _);
	     * sayHelloTo('fred');
	     * // => 'hello fred'
	     */
	    var partialRight = baseRest(function(func, partials) {
	      var holders = replaceHolders(partials, getHolder(partialRight));
	      return createWrap(func, PARTIAL_RIGHT_FLAG, undefined, partials, holders);
	    });

	    /**
	     * Creates a function that invokes `func` with arguments arranged according
	     * to the specified `indexes` where the argument value at the first index is
	     * provided as the first argument, the argument value at the second index is
	     * provided as the second argument, and so on.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Function
	     * @param {Function} func The function to rearrange arguments for.
	     * @param {...(number|number[])} indexes The arranged argument indexes.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var rearged = _.rearg(function(a, b, c) {
	     *   return [a, b, c];
	     * }, [2, 0, 1]);
	     *
	     * rearged('b', 'c', 'a')
	     * // => ['a', 'b', 'c']
	     */
	    var rearg = flatRest(function(func, indexes) {
	      return createWrap(func, REARG_FLAG, undefined, undefined, undefined, indexes);
	    });

	    /**
	     * Creates a function that invokes `func` with the `this` binding of the
	     * created function and arguments from `start` and beyond provided as
	     * an array.
	     *
	     * **Note:** This method is based on the
	     * [rest parameter](https://mdn.io/rest_parameters).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Function
	     * @param {Function} func The function to apply a rest parameter to.
	     * @param {number} [start=func.length-1] The start position of the rest parameter.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var say = _.rest(function(what, names) {
	     *   return what + ' ' + _.initial(names).join(', ') +
	     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
	     * });
	     *
	     * say('hello', 'fred', 'barney', 'pebbles');
	     * // => 'hello fred, barney, & pebbles'
	     */
	    function rest(func, start) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      start = start === undefined ? start : toInteger(start);
	      return baseRest(func, start);
	    }

	    /**
	     * Creates a function that invokes `func` with the `this` binding of the
	     * create function and an array of arguments much like
	     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
	     *
	     * **Note:** This method is based on the
	     * [spread operator](https://mdn.io/spread_operator).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.2.0
	     * @category Function
	     * @param {Function} func The function to spread arguments over.
	     * @param {number} [start=0] The start position of the spread.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var say = _.spread(function(who, what) {
	     *   return who + ' says ' + what;
	     * });
	     *
	     * say(['fred', 'hello']);
	     * // => 'fred says hello'
	     *
	     * var numbers = Promise.all([
	     *   Promise.resolve(40),
	     *   Promise.resolve(36)
	     * ]);
	     *
	     * numbers.then(_.spread(function(x, y) {
	     *   return x + y;
	     * }));
	     * // => a Promise of 76
	     */
	    function spread(func, start) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      start = start === undefined ? 0 : nativeMax(toInteger(start), 0);
	      return baseRest(function(args) {
	        var array = args[start],
	            otherArgs = castSlice(args, 0, start);

	        if (array) {
	          arrayPush(otherArgs, array);
	        }
	        return apply(func, this, otherArgs);
	      });
	    }

	    /**
	     * Creates a throttled function that only invokes `func` at most once per
	     * every `wait` milliseconds. The throttled function comes with a `cancel`
	     * method to cancel delayed `func` invocations and a `flush` method to
	     * immediately invoke them. Provide `options` to indicate whether `func`
	     * should be invoked on the leading and/or trailing edge of the `wait`
	     * timeout. The `func` is invoked with the last arguments provided to the
	     * throttled function. Subsequent calls to the throttled function return the
	     * result of the last `func` invocation.
	     *
	     * **Note:** If `leading` and `trailing` options are `true`, `func` is
	     * invoked on the trailing edge of the timeout only if the throttled function
	     * is invoked more than once during the `wait` timeout.
	     *
	     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
	     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
	     *
	     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	     * for details over the differences between `_.throttle` and `_.debounce`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to throttle.
	     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
	     * @param {Object} [options={}] The options object.
	     * @param {boolean} [options.leading=true]
	     *  Specify invoking on the leading edge of the timeout.
	     * @param {boolean} [options.trailing=true]
	     *  Specify invoking on the trailing edge of the timeout.
	     * @returns {Function} Returns the new throttled function.
	     * @example
	     *
	     * // Avoid excessively updating the position while scrolling.
	     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
	     *
	     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
	     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
	     * jQuery(element).on('click', throttled);
	     *
	     * // Cancel the trailing throttled invocation.
	     * jQuery(window).on('popstate', throttled.cancel);
	     */
	    function throttle(func, wait, options) {
	      var leading = true,
	          trailing = true;

	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      if (isObject(options)) {
	        leading = 'leading' in options ? !!options.leading : leading;
	        trailing = 'trailing' in options ? !!options.trailing : trailing;
	      }
	      return debounce(func, wait, {
	        'leading': leading,
	        'maxWait': wait,
	        'trailing': trailing
	      });
	    }

	    /**
	     * Creates a function that accepts up to one argument, ignoring any
	     * additional arguments.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Function
	     * @param {Function} func The function to cap arguments for.
	     * @returns {Function} Returns the new capped function.
	     * @example
	     *
	     * _.map(['6', '8', '10'], _.unary(parseInt));
	     * // => [6, 8, 10]
	     */
	    function unary(func) {
	      return ary(func, 1);
	    }

	    /**
	     * Creates a function that provides `value` to `wrapper` as its first
	     * argument. Any additional arguments provided to the function are appended
	     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
	     * binding of the created function.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {*} value The value to wrap.
	     * @param {Function} [wrapper=identity] The wrapper function.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var p = _.wrap(_.escape, function(func, text) {
	     *   return '<p>' + func(text) + '</p>';
	     * });
	     *
	     * p('fred, barney, & pebbles');
	     * // => '<p>fred, barney, &amp; pebbles</p>'
	     */
	    function wrap(value, wrapper) {
	      return partial(castFunction(wrapper), value);
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Casts `value` as an array if it's not one.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.4.0
	     * @category Lang
	     * @param {*} value The value to inspect.
	     * @returns {Array} Returns the cast array.
	     * @example
	     *
	     * _.castArray(1);
	     * // => [1]
	     *
	     * _.castArray({ 'a': 1 });
	     * // => [{ 'a': 1 }]
	     *
	     * _.castArray('abc');
	     * // => ['abc']
	     *
	     * _.castArray(null);
	     * // => [null]
	     *
	     * _.castArray(undefined);
	     * // => [undefined]
	     *
	     * _.castArray();
	     * // => []
	     *
	     * var array = [1, 2, 3];
	     * console.log(_.castArray(array) === array);
	     * // => true
	     */
	    function castArray() {
	      if (!arguments.length) {
	        return [];
	      }
	      var value = arguments[0];
	      return isArray(value) ? value : [value];
	    }

	    /**
	     * Creates a shallow clone of `value`.
	     *
	     * **Note:** This method is loosely based on the
	     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
	     * and supports cloning arrays, array buffers, booleans, date objects, maps,
	     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
	     * arrays. The own enumerable properties of `arguments` objects are cloned
	     * as plain objects. An empty object is returned for uncloneable values such
	     * as error objects, functions, DOM nodes, and WeakMaps.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to clone.
	     * @returns {*} Returns the cloned value.
	     * @see _.cloneDeep
	     * @example
	     *
	     * var objects = [{ 'a': 1 }, { 'b': 2 }];
	     *
	     * var shallow = _.clone(objects);
	     * console.log(shallow[0] === objects[0]);
	     * // => true
	     */
	    function clone(value) {
	      return baseClone(value, false, true);
	    }

	    /**
	     * This method is like `_.clone` except that it accepts `customizer` which
	     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
	     * cloning is handled by the method instead. The `customizer` is invoked with
	     * up to four arguments; (value [, index|key, object, stack]).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to clone.
	     * @param {Function} [customizer] The function to customize cloning.
	     * @returns {*} Returns the cloned value.
	     * @see _.cloneDeepWith
	     * @example
	     *
	     * function customizer(value) {
	     *   if (_.isElement(value)) {
	     *     return value.cloneNode(false);
	     *   }
	     * }
	     *
	     * var el = _.cloneWith(document.body, customizer);
	     *
	     * console.log(el === document.body);
	     * // => false
	     * console.log(el.nodeName);
	     * // => 'BODY'
	     * console.log(el.childNodes.length);
	     * // => 0
	     */
	    function cloneWith(value, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined;
	      return baseClone(value, false, true, customizer);
	    }

	    /**
	     * This method is like `_.clone` except that it recursively clones `value`.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.0.0
	     * @category Lang
	     * @param {*} value The value to recursively clone.
	     * @returns {*} Returns the deep cloned value.
	     * @see _.clone
	     * @example
	     *
	     * var objects = [{ 'a': 1 }, { 'b': 2 }];
	     *
	     * var deep = _.cloneDeep(objects);
	     * console.log(deep[0] === objects[0]);
	     * // => false
	     */
	    function cloneDeep(value) {
	      return baseClone(value, true, true);
	    }

	    /**
	     * This method is like `_.cloneWith` except that it recursively clones `value`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to recursively clone.
	     * @param {Function} [customizer] The function to customize cloning.
	     * @returns {*} Returns the deep cloned value.
	     * @see _.cloneWith
	     * @example
	     *
	     * function customizer(value) {
	     *   if (_.isElement(value)) {
	     *     return value.cloneNode(true);
	     *   }
	     * }
	     *
	     * var el = _.cloneDeepWith(document.body, customizer);
	     *
	     * console.log(el === document.body);
	     * // => false
	     * console.log(el.nodeName);
	     * // => 'BODY'
	     * console.log(el.childNodes.length);
	     * // => 20
	     */
	    function cloneDeepWith(value, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined;
	      return baseClone(value, true, true, customizer);
	    }

	    /**
	     * Checks if `object` conforms to `source` by invoking the predicate
	     * properties of `source` with the corresponding property values of `object`.
	     *
	     * **Note:** This method is equivalent to `_.conforms` when `source` is
	     * partially applied.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.14.0
	     * @category Lang
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property predicates to conform to.
	     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2 };
	     *
	     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
	     * // => true
	     *
	     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
	     * // => false
	     */
	    function conformsTo(object, source) {
	      return source == null || baseConformsTo(object, source, keys(source));
	    }

	    /**
	     * Performs a
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * comparison between two values to determine if they are equivalent.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     * @example
	     *
	     * var object = { 'a': 1 };
	     * var other = { 'a': 1 };
	     *
	     * _.eq(object, object);
	     * // => true
	     *
	     * _.eq(object, other);
	     * // => false
	     *
	     * _.eq('a', 'a');
	     * // => true
	     *
	     * _.eq('a', Object('a'));
	     * // => false
	     *
	     * _.eq(NaN, NaN);
	     * // => true
	     */
	    function eq(value, other) {
	      return value === other || (value !== value && other !== other);
	    }

	    /**
	     * Checks if `value` is greater than `other`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.9.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is greater than `other`,
	     *  else `false`.
	     * @see _.lt
	     * @example
	     *
	     * _.gt(3, 1);
	     * // => true
	     *
	     * _.gt(3, 3);
	     * // => false
	     *
	     * _.gt(1, 3);
	     * // => false
	     */
	    var gt = createRelationalOperation(baseGt);

	    /**
	     * Checks if `value` is greater than or equal to `other`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.9.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is greater than or equal to
	     *  `other`, else `false`.
	     * @see _.lte
	     * @example
	     *
	     * _.gte(3, 1);
	     * // => true
	     *
	     * _.gte(3, 3);
	     * // => true
	     *
	     * _.gte(1, 3);
	     * // => false
	     */
	    var gte = createRelationalOperation(function(value, other) {
	      return value >= other;
	    });

	    /**
	     * Checks if `value` is likely an `arguments` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	     *  else `false`.
	     * @example
	     *
	     * _.isArguments(function() { return arguments; }());
	     * // => true
	     *
	     * _.isArguments([1, 2, 3]);
	     * // => false
	     */
	    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
	      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
	        !propertyIsEnumerable.call(value, 'callee');
	    };

	    /**
	     * Checks if `value` is classified as an `Array` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	     * @example
	     *
	     * _.isArray([1, 2, 3]);
	     * // => true
	     *
	     * _.isArray(document.body.children);
	     * // => false
	     *
	     * _.isArray('abc');
	     * // => false
	     *
	     * _.isArray(_.noop);
	     * // => false
	     */
	    var isArray = Array.isArray;

	    /**
	     * Checks if `value` is classified as an `ArrayBuffer` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
	     * @example
	     *
	     * _.isArrayBuffer(new ArrayBuffer(2));
	     * // => true
	     *
	     * _.isArrayBuffer(new Array(2));
	     * // => false
	     */
	    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;

	    /**
	     * Checks if `value` is array-like. A value is considered array-like if it's
	     * not a function and has a `value.length` that's an integer greater than or
	     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	     * @example
	     *
	     * _.isArrayLike([1, 2, 3]);
	     * // => true
	     *
	     * _.isArrayLike(document.body.children);
	     * // => true
	     *
	     * _.isArrayLike('abc');
	     * // => true
	     *
	     * _.isArrayLike(_.noop);
	     * // => false
	     */
	    function isArrayLike(value) {
	      return value != null && isLength(value.length) && !isFunction(value);
	    }

	    /**
	     * This method is like `_.isArrayLike` except that it also checks if `value`
	     * is an object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an array-like object,
	     *  else `false`.
	     * @example
	     *
	     * _.isArrayLikeObject([1, 2, 3]);
	     * // => true
	     *
	     * _.isArrayLikeObject(document.body.children);
	     * // => true
	     *
	     * _.isArrayLikeObject('abc');
	     * // => false
	     *
	     * _.isArrayLikeObject(_.noop);
	     * // => false
	     */
	    function isArrayLikeObject(value) {
	      return isObjectLike(value) && isArrayLike(value);
	    }

	    /**
	     * Checks if `value` is classified as a boolean primitive or object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
	     * @example
	     *
	     * _.isBoolean(false);
	     * // => true
	     *
	     * _.isBoolean(null);
	     * // => false
	     */
	    function isBoolean(value) {
	      return value === true || value === false ||
	        (isObjectLike(value) && baseGetTag(value) == boolTag);
	    }

	    /**
	     * Checks if `value` is a buffer.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
	     * @example
	     *
	     * _.isBuffer(new Buffer(2));
	     * // => true
	     *
	     * _.isBuffer(new Uint8Array(2));
	     * // => false
	     */
	    var isBuffer = nativeIsBuffer || stubFalse;

	    /**
	     * Checks if `value` is classified as a `Date` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
	     * @example
	     *
	     * _.isDate(new Date);
	     * // => true
	     *
	     * _.isDate('Mon April 23 2012');
	     * // => false
	     */
	    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;

	    /**
	     * Checks if `value` is likely a DOM element.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
	     * @example
	     *
	     * _.isElement(document.body);
	     * // => true
	     *
	     * _.isElement('<body>');
	     * // => false
	     */
	    function isElement(value) {
	      return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
	    }

	    /**
	     * Checks if `value` is an empty object, collection, map, or set.
	     *
	     * Objects are considered empty if they have no own enumerable string keyed
	     * properties.
	     *
	     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
	     * jQuery-like collections are considered empty if they have a `length` of `0`.
	     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
	     * @example
	     *
	     * _.isEmpty(null);
	     * // => true
	     *
	     * _.isEmpty(true);
	     * // => true
	     *
	     * _.isEmpty(1);
	     * // => true
	     *
	     * _.isEmpty([1, 2, 3]);
	     * // => false
	     *
	     * _.isEmpty({ 'a': 1 });
	     * // => false
	     */
	    function isEmpty(value) {
	      if (value == null) {
	        return true;
	      }
	      if (isArrayLike(value) &&
	          (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
	            isBuffer(value) || isTypedArray(value) || isArguments(value))) {
	        return !value.length;
	      }
	      var tag = getTag(value);
	      if (tag == mapTag || tag == setTag) {
	        return !value.size;
	      }
	      if (isPrototype(value)) {
	        return !baseKeys(value).length;
	      }
	      for (var key in value) {
	        if (hasOwnProperty.call(value, key)) {
	          return false;
	        }
	      }
	      return true;
	    }

	    /**
	     * Performs a deep comparison between two values to determine if they are
	     * equivalent.
	     *
	     * **Note:** This method supports comparing arrays, array buffers, booleans,
	     * date objects, error objects, maps, numbers, `Object` objects, regexes,
	     * sets, strings, symbols, and typed arrays. `Object` objects are compared
	     * by their own, not inherited, enumerable properties. Functions and DOM
	     * nodes are **not** supported.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     * @example
	     *
	     * var object = { 'a': 1 };
	     * var other = { 'a': 1 };
	     *
	     * _.isEqual(object, other);
	     * // => true
	     *
	     * object === other;
	     * // => false
	     */
	    function isEqual(value, other) {
	      return baseIsEqual(value, other);
	    }

	    /**
	     * This method is like `_.isEqual` except that it accepts `customizer` which
	     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
	     * are handled by the method instead. The `customizer` is invoked with up to
	     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @param {Function} [customizer] The function to customize comparisons.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     * @example
	     *
	     * function isGreeting(value) {
	     *   return /^h(?:i|ello)$/.test(value);
	     * }
	     *
	     * function customizer(objValue, othValue) {
	     *   if (isGreeting(objValue) && isGreeting(othValue)) {
	     *     return true;
	     *   }
	     * }
	     *
	     * var array = ['hello', 'goodbye'];
	     * var other = ['hi', 'goodbye'];
	     *
	     * _.isEqualWith(array, other, customizer);
	     * // => true
	     */
	    function isEqualWith(value, other, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined;
	      var result = customizer ? customizer(value, other) : undefined;
	      return result === undefined ? baseIsEqual(value, other, customizer) : !!result;
	    }

	    /**
	     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
	     * `SyntaxError`, `TypeError`, or `URIError` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
	     * @example
	     *
	     * _.isError(new Error);
	     * // => true
	     *
	     * _.isError(Error);
	     * // => false
	     */
	    function isError(value) {
	      if (!isObjectLike(value)) {
	        return false;
	      }
	      var tag = baseGetTag(value);
	      return tag == errorTag || tag == domExcTag ||
	        (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
	    }

	    /**
	     * Checks if `value` is a finite primitive number.
	     *
	     * **Note:** This method is based on
	     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
	     * @example
	     *
	     * _.isFinite(3);
	     * // => true
	     *
	     * _.isFinite(Number.MIN_VALUE);
	     * // => true
	     *
	     * _.isFinite(Infinity);
	     * // => false
	     *
	     * _.isFinite('3');
	     * // => false
	     */
	    function isFinite(value) {
	      return typeof value == 'number' && nativeIsFinite(value);
	    }

	    /**
	     * Checks if `value` is classified as a `Function` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	     * @example
	     *
	     * _.isFunction(_);
	     * // => true
	     *
	     * _.isFunction(/abc/);
	     * // => false
	     */
	    function isFunction(value) {
	      if (!isObject(value)) {
	        return false;
	      }
	      // The use of `Object#toString` avoids issues with the `typeof` operator
	      // in Safari 9 which returns 'object' for typed arrays and other constructors.
	      var tag = baseGetTag(value);
	      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	    }

	    /**
	     * Checks if `value` is an integer.
	     *
	     * **Note:** This method is based on
	     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
	     * @example
	     *
	     * _.isInteger(3);
	     * // => true
	     *
	     * _.isInteger(Number.MIN_VALUE);
	     * // => false
	     *
	     * _.isInteger(Infinity);
	     * // => false
	     *
	     * _.isInteger('3');
	     * // => false
	     */
	    function isInteger(value) {
	      return typeof value == 'number' && value == toInteger(value);
	    }

	    /**
	     * Checks if `value` is a valid array-like length.
	     *
	     * **Note:** This method is loosely based on
	     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	     * @example
	     *
	     * _.isLength(3);
	     * // => true
	     *
	     * _.isLength(Number.MIN_VALUE);
	     * // => false
	     *
	     * _.isLength(Infinity);
	     * // => false
	     *
	     * _.isLength('3');
	     * // => false
	     */
	    function isLength(value) {
	      return typeof value == 'number' &&
	        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	    }

	    /**
	     * Checks if `value` is the
	     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	     * @example
	     *
	     * _.isObject({});
	     * // => true
	     *
	     * _.isObject([1, 2, 3]);
	     * // => true
	     *
	     * _.isObject(_.noop);
	     * // => true
	     *
	     * _.isObject(null);
	     * // => false
	     */
	    function isObject(value) {
	      var type = typeof value;
	      return value != null && (type == 'object' || type == 'function');
	    }

	    /**
	     * Checks if `value` is object-like. A value is object-like if it's not `null`
	     * and has a `typeof` result of "object".
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	     * @example
	     *
	     * _.isObjectLike({});
	     * // => true
	     *
	     * _.isObjectLike([1, 2, 3]);
	     * // => true
	     *
	     * _.isObjectLike(_.noop);
	     * // => false
	     *
	     * _.isObjectLike(null);
	     * // => false
	     */
	    function isObjectLike(value) {
	      return value != null && typeof value == 'object';
	    }

	    /**
	     * Checks if `value` is classified as a `Map` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
	     * @example
	     *
	     * _.isMap(new Map);
	     * // => true
	     *
	     * _.isMap(new WeakMap);
	     * // => false
	     */
	    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

	    /**
	     * Performs a partial deep comparison between `object` and `source` to
	     * determine if `object` contains equivalent property values.
	     *
	     * **Note:** This method is equivalent to `_.matches` when `source` is
	     * partially applied.
	     *
	     * Partial comparisons will match empty array and empty object `source`
	     * values against any array or object value, respectively. See `_.isEqual`
	     * for a list of supported value comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Lang
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property values to match.
	     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2 };
	     *
	     * _.isMatch(object, { 'b': 2 });
	     * // => true
	     *
	     * _.isMatch(object, { 'b': 1 });
	     * // => false
	     */
	    function isMatch(object, source) {
	      return object === source || baseIsMatch(object, source, getMatchData(source));
	    }

	    /**
	     * This method is like `_.isMatch` except that it accepts `customizer` which
	     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
	     * are handled by the method instead. The `customizer` is invoked with five
	     * arguments: (objValue, srcValue, index|key, object, source).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property values to match.
	     * @param {Function} [customizer] The function to customize comparisons.
	     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	     * @example
	     *
	     * function isGreeting(value) {
	     *   return /^h(?:i|ello)$/.test(value);
	     * }
	     *
	     * function customizer(objValue, srcValue) {
	     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
	     *     return true;
	     *   }
	     * }
	     *
	     * var object = { 'greeting': 'hello' };
	     * var source = { 'greeting': 'hi' };
	     *
	     * _.isMatchWith(object, source, customizer);
	     * // => true
	     */
	    function isMatchWith(object, source, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined;
	      return baseIsMatch(object, source, getMatchData(source), customizer);
	    }

	    /**
	     * Checks if `value` is `NaN`.
	     *
	     * **Note:** This method is based on
	     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
	     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
	     * `undefined` and other non-number values.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
	     * @example
	     *
	     * _.isNaN(NaN);
	     * // => true
	     *
	     * _.isNaN(new Number(NaN));
	     * // => true
	     *
	     * isNaN(undefined);
	     * // => true
	     *
	     * _.isNaN(undefined);
	     * // => false
	     */
	    function isNaN(value) {
	      // An `NaN` primitive is the only value that is not equal to itself.
	      // Perform the `toStringTag` check first to avoid errors with some
	      // ActiveX objects in IE.
	      return isNumber(value) && value != +value;
	    }

	    /**
	     * Checks if `value` is a pristine native function.
	     *
	     * **Note:** This method can't reliably detect native functions in the presence
	     * of the core-js package because core-js circumvents this kind of detection.
	     * Despite multiple requests, the core-js maintainer has made it clear: any
	     * attempt to fix the detection will be obstructed. As a result, we're left
	     * with little choice but to throw an error. Unfortunately, this also affects
	     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
	     * which rely on core-js.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a native function,
	     *  else `false`.
	     * @example
	     *
	     * _.isNative(Array.prototype.push);
	     * // => true
	     *
	     * _.isNative(_);
	     * // => false
	     */
	    function isNative(value) {
	      if (isMaskable(value)) {
	        throw new Error(CORE_ERROR_TEXT);
	      }
	      return baseIsNative(value);
	    }

	    /**
	     * Checks if `value` is `null`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
	     * @example
	     *
	     * _.isNull(null);
	     * // => true
	     *
	     * _.isNull(void 0);
	     * // => false
	     */
	    function isNull(value) {
	      return value === null;
	    }

	    /**
	     * Checks if `value` is `null` or `undefined`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
	     * @example
	     *
	     * _.isNil(null);
	     * // => true
	     *
	     * _.isNil(void 0);
	     * // => true
	     *
	     * _.isNil(NaN);
	     * // => false
	     */
	    function isNil(value) {
	      return value == null;
	    }

	    /**
	     * Checks if `value` is classified as a `Number` primitive or object.
	     *
	     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
	     * classified as numbers, use the `_.isFinite` method.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
	     * @example
	     *
	     * _.isNumber(3);
	     * // => true
	     *
	     * _.isNumber(Number.MIN_VALUE);
	     * // => true
	     *
	     * _.isNumber(Infinity);
	     * // => true
	     *
	     * _.isNumber('3');
	     * // => false
	     */
	    function isNumber(value) {
	      return typeof value == 'number' ||
	        (isObjectLike(value) && baseGetTag(value) == numberTag);
	    }

	    /**
	     * Checks if `value` is a plain object, that is, an object created by the
	     * `Object` constructor or one with a `[[Prototype]]` of `null`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.8.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     * }
	     *
	     * _.isPlainObject(new Foo);
	     * // => false
	     *
	     * _.isPlainObject([1, 2, 3]);
	     * // => false
	     *
	     * _.isPlainObject({ 'x': 0, 'y': 0 });
	     * // => true
	     *
	     * _.isPlainObject(Object.create(null));
	     * // => true
	     */
	    function isPlainObject(value) {
	      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
	        return false;
	      }
	      var proto = getPrototype(value);
	      if (proto === null) {
	        return true;
	      }
	      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
	      return typeof Ctor == 'function' && Ctor instanceof Ctor &&
	        funcToString.call(Ctor) == objectCtorString;
	    }

	    /**
	     * Checks if `value` is classified as a `RegExp` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
	     * @example
	     *
	     * _.isRegExp(/abc/);
	     * // => true
	     *
	     * _.isRegExp('/abc/');
	     * // => false
	     */
	    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

	    /**
	     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
	     * double precision number which isn't the result of a rounded unsafe integer.
	     *
	     * **Note:** This method is based on
	     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
	     * @example
	     *
	     * _.isSafeInteger(3);
	     * // => true
	     *
	     * _.isSafeInteger(Number.MIN_VALUE);
	     * // => false
	     *
	     * _.isSafeInteger(Infinity);
	     * // => false
	     *
	     * _.isSafeInteger('3');
	     * // => false
	     */
	    function isSafeInteger(value) {
	      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
	    }

	    /**
	     * Checks if `value` is classified as a `Set` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
	     * @example
	     *
	     * _.isSet(new Set);
	     * // => true
	     *
	     * _.isSet(new WeakSet);
	     * // => false
	     */
	    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

	    /**
	     * Checks if `value` is classified as a `String` primitive or object.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
	     * @example
	     *
	     * _.isString('abc');
	     * // => true
	     *
	     * _.isString(1);
	     * // => false
	     */
	    function isString(value) {
	      return typeof value == 'string' ||
	        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
	    }

	    /**
	     * Checks if `value` is classified as a `Symbol` primitive or object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	     * @example
	     *
	     * _.isSymbol(Symbol.iterator);
	     * // => true
	     *
	     * _.isSymbol('abc');
	     * // => false
	     */
	    function isSymbol(value) {
	      return typeof value == 'symbol' ||
	        (isObjectLike(value) && baseGetTag(value) == symbolTag);
	    }

	    /**
	     * Checks if `value` is classified as a typed array.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	     * @example
	     *
	     * _.isTypedArray(new Uint8Array);
	     * // => true
	     *
	     * _.isTypedArray([]);
	     * // => false
	     */
	    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

	    /**
	     * Checks if `value` is `undefined`.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
	     * @example
	     *
	     * _.isUndefined(void 0);
	     * // => true
	     *
	     * _.isUndefined(null);
	     * // => false
	     */
	    function isUndefined(value) {
	      return value === undefined;
	    }

	    /**
	     * Checks if `value` is classified as a `WeakMap` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
	     * @example
	     *
	     * _.isWeakMap(new WeakMap);
	     * // => true
	     *
	     * _.isWeakMap(new Map);
	     * // => false
	     */
	    function isWeakMap(value) {
	      return isObjectLike(value) && getTag(value) == weakMapTag;
	    }

	    /**
	     * Checks if `value` is classified as a `WeakSet` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
	     * @example
	     *
	     * _.isWeakSet(new WeakSet);
	     * // => true
	     *
	     * _.isWeakSet(new Set);
	     * // => false
	     */
	    function isWeakSet(value) {
	      return isObjectLike(value) && baseGetTag(value) == weakSetTag;
	    }

	    /**
	     * Checks if `value` is less than `other`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.9.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is less than `other`,
	     *  else `false`.
	     * @see _.gt
	     * @example
	     *
	     * _.lt(1, 3);
	     * // => true
	     *
	     * _.lt(3, 3);
	     * // => false
	     *
	     * _.lt(3, 1);
	     * // => false
	     */
	    var lt = createRelationalOperation(baseLt);

	    /**
	     * Checks if `value` is less than or equal to `other`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.9.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is less than or equal to
	     *  `other`, else `false`.
	     * @see _.gte
	     * @example
	     *
	     * _.lte(1, 3);
	     * // => true
	     *
	     * _.lte(3, 3);
	     * // => true
	     *
	     * _.lte(3, 1);
	     * // => false
	     */
	    var lte = createRelationalOperation(function(value, other) {
	      return value <= other;
	    });

	    /**
	     * Converts `value` to an array.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {Array} Returns the converted array.
	     * @example
	     *
	     * _.toArray({ 'a': 1, 'b': 2 });
	     * // => [1, 2]
	     *
	     * _.toArray('abc');
	     * // => ['a', 'b', 'c']
	     *
	     * _.toArray(1);
	     * // => []
	     *
	     * _.toArray(null);
	     * // => []
	     */
	    function toArray(value) {
	      if (!value) {
	        return [];
	      }
	      if (isArrayLike(value)) {
	        return isString(value) ? stringToArray(value) : copyArray(value);
	      }
	      if (symIterator && value[symIterator]) {
	        return iteratorToArray(value[symIterator]());
	      }
	      var tag = getTag(value),
	          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);

	      return func(value);
	    }

	    /**
	     * Converts `value` to a finite number.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.12.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {number} Returns the converted number.
	     * @example
	     *
	     * _.toFinite(3.2);
	     * // => 3.2
	     *
	     * _.toFinite(Number.MIN_VALUE);
	     * // => 5e-324
	     *
	     * _.toFinite(Infinity);
	     * // => 1.7976931348623157e+308
	     *
	     * _.toFinite('3.2');
	     * // => 3.2
	     */
	    function toFinite(value) {
	      if (!value) {
	        return value === 0 ? value : 0;
	      }
	      value = toNumber(value);
	      if (value === INFINITY || value === -INFINITY) {
	        var sign = (value < 0 ? -1 : 1);
	        return sign * MAX_INTEGER;
	      }
	      return value === value ? value : 0;
	    }

	    /**
	     * Converts `value` to an integer.
	     *
	     * **Note:** This method is loosely based on
	     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {number} Returns the converted integer.
	     * @example
	     *
	     * _.toInteger(3.2);
	     * // => 3
	     *
	     * _.toInteger(Number.MIN_VALUE);
	     * // => 0
	     *
	     * _.toInteger(Infinity);
	     * // => 1.7976931348623157e+308
	     *
	     * _.toInteger('3.2');
	     * // => 3
	     */
	    function toInteger(value) {
	      var result = toFinite(value),
	          remainder = result % 1;

	      return result === result ? (remainder ? result - remainder : result) : 0;
	    }

	    /**
	     * Converts `value` to an integer suitable for use as the length of an
	     * array-like object.
	     *
	     * **Note:** This method is based on
	     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {number} Returns the converted integer.
	     * @example
	     *
	     * _.toLength(3.2);
	     * // => 3
	     *
	     * _.toLength(Number.MIN_VALUE);
	     * // => 0
	     *
	     * _.toLength(Infinity);
	     * // => 4294967295
	     *
	     * _.toLength('3.2');
	     * // => 3
	     */
	    function toLength(value) {
	      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
	    }

	    /**
	     * Converts `value` to a number.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to process.
	     * @returns {number} Returns the number.
	     * @example
	     *
	     * _.toNumber(3.2);
	     * // => 3.2
	     *
	     * _.toNumber(Number.MIN_VALUE);
	     * // => 5e-324
	     *
	     * _.toNumber(Infinity);
	     * // => Infinity
	     *
	     * _.toNumber('3.2');
	     * // => 3.2
	     */
	    function toNumber(value) {
	      if (typeof value == 'number') {
	        return value;
	      }
	      if (isSymbol(value)) {
	        return NAN;
	      }
	      if (isObject(value)) {
	        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
	        value = isObject(other) ? (other + '') : other;
	      }
	      if (typeof value != 'string') {
	        return value === 0 ? value : +value;
	      }
	      value = value.replace(reTrim, '');
	      var isBinary = reIsBinary.test(value);
	      return (isBinary || reIsOctal.test(value))
	        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
	        : (reIsBadHex.test(value) ? NAN : +value);
	    }

	    /**
	     * Converts `value` to a plain object flattening inherited enumerable string
	     * keyed properties of `value` to own properties of the plain object.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {Object} Returns the converted plain object.
	     * @example
	     *
	     * function Foo() {
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.assign({ 'a': 1 }, new Foo);
	     * // => { 'a': 1, 'b': 2 }
	     *
	     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
	     * // => { 'a': 1, 'b': 2, 'c': 3 }
	     */
	    function toPlainObject(value) {
	      return copyObject(value, keysIn(value));
	    }

	    /**
	     * Converts `value` to a safe integer. A safe integer can be compared and
	     * represented correctly.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {number} Returns the converted integer.
	     * @example
	     *
	     * _.toSafeInteger(3.2);
	     * // => 3
	     *
	     * _.toSafeInteger(Number.MIN_VALUE);
	     * // => 0
	     *
	     * _.toSafeInteger(Infinity);
	     * // => 9007199254740991
	     *
	     * _.toSafeInteger('3.2');
	     * // => 3
	     */
	    function toSafeInteger(value) {
	      return baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
	    }

	    /**
	     * Converts `value` to a string. An empty string is returned for `null`
	     * and `undefined` values. The sign of `-0` is preserved.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {string} Returns the converted string.
	     * @example
	     *
	     * _.toString(null);
	     * // => ''
	     *
	     * _.toString(-0);
	     * // => '-0'
	     *
	     * _.toString([1, 2, 3]);
	     * // => '1,2,3'
	     */
	    function toString(value) {
	      return value == null ? '' : baseToString(value);
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Assigns own enumerable string keyed properties of source objects to the
	     * destination object. Source objects are applied from left to right.
	     * Subsequent sources overwrite property assignments of previous sources.
	     *
	     * **Note:** This method mutates `object` and is loosely based on
	     * [`Object.assign`](https://mdn.io/Object/assign).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.10.0
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @see _.assignIn
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     * }
	     *
	     * function Bar() {
	     *   this.c = 3;
	     * }
	     *
	     * Foo.prototype.b = 2;
	     * Bar.prototype.d = 4;
	     *
	     * _.assign({ 'a': 0 }, new Foo, new Bar);
	     * // => { 'a': 1, 'c': 3 }
	     */
	    var assign = createAssigner(function(object, source) {
	      if (isPrototype(source) || isArrayLike(source)) {
	        copyObject(source, keys(source), object);
	        return;
	      }
	      for (var key in source) {
	        if (hasOwnProperty.call(source, key)) {
	          assignValue(object, key, source[key]);
	        }
	      }
	    });

	    /**
	     * This method is like `_.assign` except that it iterates over own and
	     * inherited source properties.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @alias extend
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @see _.assign
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     * }
	     *
	     * function Bar() {
	     *   this.c = 3;
	     * }
	     *
	     * Foo.prototype.b = 2;
	     * Bar.prototype.d = 4;
	     *
	     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
	     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
	     */
	    var assignIn = createAssigner(function(object, source) {
	      copyObject(source, keysIn(source), object);
	    });

	    /**
	     * This method is like `_.assignIn` except that it accepts `customizer`
	     * which is invoked to produce the assigned values. If `customizer` returns
	     * `undefined`, assignment is handled by the method instead. The `customizer`
	     * is invoked with five arguments: (objValue, srcValue, key, object, source).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @alias extendWith
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} sources The source objects.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @see _.assignWith
	     * @example
	     *
	     * function customizer(objValue, srcValue) {
	     *   return _.isUndefined(objValue) ? srcValue : objValue;
	     * }
	     *
	     * var defaults = _.partialRight(_.assignInWith, customizer);
	     *
	     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
	     * // => { 'a': 1, 'b': 2 }
	     */
	    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
	      copyObject(source, keysIn(source), object, customizer);
	    });

	    /**
	     * This method is like `_.assign` except that it accepts `customizer`
	     * which is invoked to produce the assigned values. If `customizer` returns
	     * `undefined`, assignment is handled by the method instead. The `customizer`
	     * is invoked with five arguments: (objValue, srcValue, key, object, source).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} sources The source objects.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @see _.assignInWith
	     * @example
	     *
	     * function customizer(objValue, srcValue) {
	     *   return _.isUndefined(objValue) ? srcValue : objValue;
	     * }
	     *
	     * var defaults = _.partialRight(_.assignWith, customizer);
	     *
	     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
	     * // => { 'a': 1, 'b': 2 }
	     */
	    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
	      copyObject(source, keys(source), object, customizer);
	    });

	    /**
	     * Creates an array of values corresponding to `paths` of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.0.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {...(string|string[])} [paths] The property paths of elements to pick.
	     * @returns {Array} Returns the picked values.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
	     *
	     * _.at(object, ['a[0].b.c', 'a[1]']);
	     * // => [3, 4]
	     */
	    var at = flatRest(baseAt);

	    /**
	     * Creates an object that inherits from the `prototype` object. If a
	     * `properties` object is given, its own enumerable string keyed properties
	     * are assigned to the created object.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.3.0
	     * @category Object
	     * @param {Object} prototype The object to inherit from.
	     * @param {Object} [properties] The properties to assign to the object.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * function Shape() {
	     *   this.x = 0;
	     *   this.y = 0;
	     * }
	     *
	     * function Circle() {
	     *   Shape.call(this);
	     * }
	     *
	     * Circle.prototype = _.create(Shape.prototype, {
	     *   'constructor': Circle
	     * });
	     *
	     * var circle = new Circle;
	     * circle instanceof Circle;
	     * // => true
	     *
	     * circle instanceof Shape;
	     * // => true
	     */
	    function create(prototype, properties) {
	      var result = baseCreate(prototype);
	      return properties == null ? result : baseAssign(result, properties);
	    }

	    /**
	     * Assigns own and inherited enumerable string keyed properties of source
	     * objects to the destination object for all destination properties that
	     * resolve to `undefined`. Source objects are applied from left to right.
	     * Once a property is set, additional values of the same property are ignored.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @see _.defaultsDeep
	     * @example
	     *
	     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
	     * // => { 'a': 1, 'b': 2 }
	     */
	    var defaults = baseRest(function(args) {
	      args.push(undefined, assignInDefaults);
	      return apply(assignInWith, undefined, args);
	    });

	    /**
	     * This method is like `_.defaults` except that it recursively assigns
	     * default properties.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.10.0
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @see _.defaults
	     * @example
	     *
	     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
	     * // => { 'a': { 'b': 2, 'c': 3 } }
	     */
	    var defaultsDeep = baseRest(function(args) {
	      args.push(undefined, mergeDefaults);
	      return apply(mergeWith, undefined, args);
	    });

	    /**
	     * This method is like `_.find` except that it returns the key of the first
	     * element `predicate` returns truthy for instead of the element itself.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.1.0
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {string|undefined} Returns the key of the matched element,
	     *  else `undefined`.
	     * @example
	     *
	     * var users = {
	     *   'barney':  { 'age': 36, 'active': true },
	     *   'fred':    { 'age': 40, 'active': false },
	     *   'pebbles': { 'age': 1,  'active': true }
	     * };
	     *
	     * _.findKey(users, function(o) { return o.age < 40; });
	     * // => 'barney' (iteration order is not guaranteed)
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.findKey(users, { 'age': 1, 'active': true });
	     * // => 'pebbles'
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.findKey(users, ['active', false]);
	     * // => 'fred'
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.findKey(users, 'active');
	     * // => 'barney'
	     */
	    function findKey(object, predicate) {
	      return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
	    }

	    /**
	     * This method is like `_.findKey` except that it iterates over elements of
	     * a collection in the opposite order.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {string|undefined} Returns the key of the matched element,
	     *  else `undefined`.
	     * @example
	     *
	     * var users = {
	     *   'barney':  { 'age': 36, 'active': true },
	     *   'fred':    { 'age': 40, 'active': false },
	     *   'pebbles': { 'age': 1,  'active': true }
	     * };
	     *
	     * _.findLastKey(users, function(o) { return o.age < 40; });
	     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.findLastKey(users, { 'age': 36, 'active': true });
	     * // => 'barney'
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.findLastKey(users, ['active', false]);
	     * // => 'fred'
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.findLastKey(users, 'active');
	     * // => 'pebbles'
	     */
	    function findLastKey(object, predicate) {
	      return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
	    }

	    /**
	     * Iterates over own and inherited enumerable string keyed properties of an
	     * object and invokes `iteratee` for each property. The iteratee is invoked
	     * with three arguments: (value, key, object). Iteratee functions may exit
	     * iteration early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.3.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     * @see _.forInRight
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forIn(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
	     */
	    function forIn(object, iteratee) {
	      return object == null
	        ? object
	        : baseFor(object, getIteratee(iteratee, 3), keysIn);
	    }

	    /**
	     * This method is like `_.forIn` except that it iterates over properties of
	     * `object` in the opposite order.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     * @see _.forIn
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forInRight(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
	     */
	    function forInRight(object, iteratee) {
	      return object == null
	        ? object
	        : baseForRight(object, getIteratee(iteratee, 3), keysIn);
	    }

	    /**
	     * Iterates over own enumerable string keyed properties of an object and
	     * invokes `iteratee` for each property. The iteratee is invoked with three
	     * arguments: (value, key, object). Iteratee functions may exit iteration
	     * early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.3.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     * @see _.forOwnRight
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forOwn(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
	     */
	    function forOwn(object, iteratee) {
	      return object && baseForOwn(object, getIteratee(iteratee, 3));
	    }

	    /**
	     * This method is like `_.forOwn` except that it iterates over properties of
	     * `object` in the opposite order.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     * @see _.forOwn
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forOwnRight(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
	     */
	    function forOwnRight(object, iteratee) {
	      return object && baseForOwnRight(object, getIteratee(iteratee, 3));
	    }

	    /**
	     * Creates an array of function property names from own enumerable properties
	     * of `object`.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @returns {Array} Returns the function names.
	     * @see _.functionsIn
	     * @example
	     *
	     * function Foo() {
	     *   this.a = _.constant('a');
	     *   this.b = _.constant('b');
	     * }
	     *
	     * Foo.prototype.c = _.constant('c');
	     *
	     * _.functions(new Foo);
	     * // => ['a', 'b']
	     */
	    function functions(object) {
	      return object == null ? [] : baseFunctions(object, keys(object));
	    }

	    /**
	     * Creates an array of function property names from own and inherited
	     * enumerable properties of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @returns {Array} Returns the function names.
	     * @see _.functions
	     * @example
	     *
	     * function Foo() {
	     *   this.a = _.constant('a');
	     *   this.b = _.constant('b');
	     * }
	     *
	     * Foo.prototype.c = _.constant('c');
	     *
	     * _.functionsIn(new Foo);
	     * // => ['a', 'b', 'c']
	     */
	    function functionsIn(object) {
	      return object == null ? [] : baseFunctions(object, keysIn(object));
	    }

	    /**
	     * Gets the value at `path` of `object`. If the resolved value is
	     * `undefined`, the `defaultValue` is returned in its place.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.7.0
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the property to get.
	     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	     * @returns {*} Returns the resolved value.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	     *
	     * _.get(object, 'a[0].b.c');
	     * // => 3
	     *
	     * _.get(object, ['a', '0', 'b', 'c']);
	     * // => 3
	     *
	     * _.get(object, 'a.b.c', 'default');
	     * // => 'default'
	     */
	    function get(object, path, defaultValue) {
	      var result = object == null ? undefined : baseGet(object, path);
	      return result === undefined ? defaultValue : result;
	    }

	    /**
	     * Checks if `path` is a direct property of `object`.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path to check.
	     * @returns {boolean} Returns `true` if `path` exists, else `false`.
	     * @example
	     *
	     * var object = { 'a': { 'b': 2 } };
	     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
	     *
	     * _.has(object, 'a');
	     * // => true
	     *
	     * _.has(object, 'a.b');
	     * // => true
	     *
	     * _.has(object, ['a', 'b']);
	     * // => true
	     *
	     * _.has(other, 'a');
	     * // => false
	     */
	    function has(object, path) {
	      return object != null && hasPath(object, path, baseHas);
	    }

	    /**
	     * Checks if `path` is a direct or inherited property of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path to check.
	     * @returns {boolean} Returns `true` if `path` exists, else `false`.
	     * @example
	     *
	     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
	     *
	     * _.hasIn(object, 'a');
	     * // => true
	     *
	     * _.hasIn(object, 'a.b');
	     * // => true
	     *
	     * _.hasIn(object, ['a', 'b']);
	     * // => true
	     *
	     * _.hasIn(object, 'b');
	     * // => false
	     */
	    function hasIn(object, path) {
	      return object != null && hasPath(object, path, baseHasIn);
	    }

	    /**
	     * Creates an object composed of the inverted keys and values of `object`.
	     * If `object` contains duplicate values, subsequent values overwrite
	     * property assignments of previous values.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.7.0
	     * @category Object
	     * @param {Object} object The object to invert.
	     * @returns {Object} Returns the new inverted object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2, 'c': 1 };
	     *
	     * _.invert(object);
	     * // => { '1': 'c', '2': 'b' }
	     */
	    var invert = createInverter(function(result, value, key) {
	      result[value] = key;
	    }, constant(identity));

	    /**
	     * This method is like `_.invert` except that the inverted object is generated
	     * from the results of running each element of `object` thru `iteratee`. The
	     * corresponding inverted value of each inverted key is an array of keys
	     * responsible for generating the inverted value. The iteratee is invoked
	     * with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.1.0
	     * @category Object
	     * @param {Object} object The object to invert.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Object} Returns the new inverted object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2, 'c': 1 };
	     *
	     * _.invertBy(object);
	     * // => { '1': ['a', 'c'], '2': ['b'] }
	     *
	     * _.invertBy(object, function(value) {
	     *   return 'group' + value;
	     * });
	     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
	     */
	    var invertBy = createInverter(function(result, value, key) {
	      if (hasOwnProperty.call(result, value)) {
	        result[value].push(key);
	      } else {
	        result[value] = [key];
	      }
	    }, getIteratee);

	    /**
	     * Invokes the method at `path` of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the method to invoke.
	     * @param {...*} [args] The arguments to invoke the method with.
	     * @returns {*} Returns the result of the invoked method.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
	     *
	     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
	     * // => [2, 3]
	     */
	    var invoke = baseRest(baseInvoke);

	    /**
	     * Creates an array of the own enumerable property names of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects. See the
	     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	     * for more details.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.keys(new Foo);
	     * // => ['a', 'b'] (iteration order is not guaranteed)
	     *
	     * _.keys('hi');
	     * // => ['0', '1']
	     */
	    function keys(object) {
	      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
	    }

	    /**
	     * Creates an array of the own and inherited enumerable property names of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.keysIn(new Foo);
	     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	     */
	    function keysIn(object) {
	      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
	    }

	    /**
	     * The opposite of `_.mapValues`; this method creates an object with the
	     * same values as `object` and keys generated by running each own enumerable
	     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
	     * with three arguments: (value, key, object).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.8.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns the new mapped object.
	     * @see _.mapValues
	     * @example
	     *
	     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
	     *   return key + value;
	     * });
	     * // => { 'a1': 1, 'b2': 2 }
	     */
	    function mapKeys(object, iteratee) {
	      var result = {};
	      iteratee = getIteratee(iteratee, 3);

	      baseForOwn(object, function(value, key, object) {
	        baseAssignValue(result, iteratee(value, key, object), value);
	      });
	      return result;
	    }

	    /**
	     * Creates an object with the same keys as `object` and values generated
	     * by running each own enumerable string keyed property of `object` thru
	     * `iteratee`. The iteratee is invoked with three arguments:
	     * (value, key, object).
	     *
	     * @static
	     * @memberOf _
	     * @since 2.4.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns the new mapped object.
	     * @see _.mapKeys
	     * @example
	     *
	     * var users = {
	     *   'fred':    { 'user': 'fred',    'age': 40 },
	     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
	     * };
	     *
	     * _.mapValues(users, function(o) { return o.age; });
	     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.mapValues(users, 'age');
	     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
	     */
	    function mapValues(object, iteratee) {
	      var result = {};
	      iteratee = getIteratee(iteratee, 3);

	      baseForOwn(object, function(value, key, object) {
	        baseAssignValue(result, key, iteratee(value, key, object));
	      });
	      return result;
	    }

	    /**
	     * This method is like `_.assign` except that it recursively merges own and
	     * inherited enumerable string keyed properties of source objects into the
	     * destination object. Source properties that resolve to `undefined` are
	     * skipped if a destination value exists. Array and plain object properties
	     * are merged recursively. Other objects and value types are overridden by
	     * assignment. Source objects are applied from left to right. Subsequent
	     * sources overwrite property assignments of previous sources.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.5.0
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = {
	     *   'a': [{ 'b': 2 }, { 'd': 4 }]
	     * };
	     *
	     * var other = {
	     *   'a': [{ 'c': 3 }, { 'e': 5 }]
	     * };
	     *
	     * _.merge(object, other);
	     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
	     */
	    var merge = createAssigner(function(object, source, srcIndex) {
	      baseMerge(object, source, srcIndex);
	    });

	    /**
	     * This method is like `_.merge` except that it accepts `customizer` which
	     * is invoked to produce the merged values of the destination and source
	     * properties. If `customizer` returns `undefined`, merging is handled by the
	     * method instead. The `customizer` is invoked with six arguments:
	     * (objValue, srcValue, key, object, source, stack).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} sources The source objects.
	     * @param {Function} customizer The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * function customizer(objValue, srcValue) {
	     *   if (_.isArray(objValue)) {
	     *     return objValue.concat(srcValue);
	     *   }
	     * }
	     *
	     * var object = { 'a': [1], 'b': [2] };
	     * var other = { 'a': [3], 'b': [4] };
	     *
	     * _.mergeWith(object, other, customizer);
	     * // => { 'a': [1, 3], 'b': [2, 4] }
	     */
	    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
	      baseMerge(object, source, srcIndex, customizer);
	    });

	    /**
	     * The opposite of `_.pick`; this method creates an object composed of the
	     * own and inherited enumerable string keyed properties of `object` that are
	     * not omitted.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {...(string|string[])} [props] The property identifiers to omit.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': '2', 'c': 3 };
	     *
	     * _.omit(object, ['a', 'c']);
	     * // => { 'b': '2' }
	     */
	    var omit = flatRest(function(object, props) {
	      if (object == null) {
	        return {};
	      }
	      props = arrayMap(props, toKey);
	      return basePick(object, baseDifference(getAllKeysIn(object), props));
	    });

	    /**
	     * The opposite of `_.pickBy`; this method creates an object composed of
	     * the own and inherited enumerable string keyed properties of `object` that
	     * `predicate` doesn't return truthy for. The predicate is invoked with two
	     * arguments: (value, key).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {Function} [predicate=_.identity] The function invoked per property.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': '2', 'c': 3 };
	     *
	     * _.omitBy(object, _.isNumber);
	     * // => { 'b': '2' }
	     */
	    function omitBy(object, predicate) {
	      return pickBy(object, negate(getIteratee(predicate)));
	    }

	    /**
	     * Creates an object composed of the picked `object` properties.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {...(string|string[])} [props] The property identifiers to pick.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': '2', 'c': 3 };
	     *
	     * _.pick(object, ['a', 'c']);
	     * // => { 'a': 1, 'c': 3 }
	     */
	    var pick = flatRest(function(object, props) {
	      return object == null ? {} : basePick(object, arrayMap(props, toKey));
	    });

	    /**
	     * Creates an object composed of the `object` properties `predicate` returns
	     * truthy for. The predicate is invoked with two arguments: (value, key).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {Function} [predicate=_.identity] The function invoked per property.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': '2', 'c': 3 };
	     *
	     * _.pickBy(object, _.isNumber);
	     * // => { 'a': 1, 'c': 3 }
	     */
	    function pickBy(object, predicate) {
	      return object == null ? {} : basePickBy(object, getAllKeysIn(object), getIteratee(predicate));
	    }

	    /**
	     * This method is like `_.get` except that if the resolved value is a
	     * function it's invoked with the `this` binding of its parent object and
	     * its result is returned.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the property to resolve.
	     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	     * @returns {*} Returns the resolved value.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
	     *
	     * _.result(object, 'a[0].b.c1');
	     * // => 3
	     *
	     * _.result(object, 'a[0].b.c2');
	     * // => 4
	     *
	     * _.result(object, 'a[0].b.c3', 'default');
	     * // => 'default'
	     *
	     * _.result(object, 'a[0].b.c3', _.constant('default'));
	     * // => 'default'
	     */
	    function result(object, path, defaultValue) {
	      path = isKey(path, object) ? [path] : castPath(path);

	      var index = -1,
	          length = path.length;

	      // Ensure the loop is entered when path is empty.
	      if (!length) {
	        object = undefined;
	        length = 1;
	      }
	      while (++index < length) {
	        var value = object == null ? undefined : object[toKey(path[index])];
	        if (value === undefined) {
	          index = length;
	          value = defaultValue;
	        }
	        object = isFunction(value) ? value.call(object) : value;
	      }
	      return object;
	    }

	    /**
	     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
	     * it's created. Arrays are created for missing index properties while objects
	     * are created for all other missing properties. Use `_.setWith` to customize
	     * `path` creation.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.7.0
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	     *
	     * _.set(object, 'a[0].b.c', 4);
	     * console.log(object.a[0].b.c);
	     * // => 4
	     *
	     * _.set(object, ['x', '0', 'y', 'z'], 5);
	     * console.log(object.x[0].y.z);
	     * // => 5
	     */
	    function set(object, path, value) {
	      return object == null ? object : baseSet(object, path, value);
	    }

	    /**
	     * This method is like `_.set` except that it accepts `customizer` which is
	     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
	     * path creation is handled by the method instead. The `customizer` is invoked
	     * with three arguments: (nsValue, key, nsObject).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to set.
	     * @param {*} value The value to set.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = {};
	     *
	     * _.setWith(object, '[0][1]', 'a', Object);
	     * // => { '0': { '1': 'a' } }
	     */
	    function setWith(object, path, value, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined;
	      return object == null ? object : baseSet(object, path, value, customizer);
	    }

	    /**
	     * Creates an array of own enumerable string keyed-value pairs for `object`
	     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
	     * entries are returned.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @alias entries
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the key-value pairs.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.toPairs(new Foo);
	     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
	     */
	    var toPairs = createToPairs(keys);

	    /**
	     * Creates an array of own and inherited enumerable string keyed-value pairs
	     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
	     * or set, its entries are returned.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @alias entriesIn
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the key-value pairs.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.toPairsIn(new Foo);
	     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
	     */
	    var toPairsIn = createToPairs(keysIn);

	    /**
	     * An alternative to `_.reduce`; this method transforms `object` to a new
	     * `accumulator` object which is the result of running each of its own
	     * enumerable string keyed properties thru `iteratee`, with each invocation
	     * potentially mutating the `accumulator` object. If `accumulator` is not
	     * provided, a new object with the same `[[Prototype]]` will be used. The
	     * iteratee is invoked with four arguments: (accumulator, value, key, object).
	     * Iteratee functions may exit iteration early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.3.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The custom accumulator value.
	     * @returns {*} Returns the accumulated value.
	     * @example
	     *
	     * _.transform([2, 3, 4], function(result, n) {
	     *   result.push(n *= n);
	     *   return n % 2 == 0;
	     * }, []);
	     * // => [4, 9]
	     *
	     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
	     *   (result[value] || (result[value] = [])).push(key);
	     * }, {});
	     * // => { '1': ['a', 'c'], '2': ['b'] }
	     */
	    function transform(object, iteratee, accumulator) {
	      var isArr = isArray(object),
	          isArrLike = isArr || isBuffer(object) || isTypedArray(object);

	      iteratee = getIteratee(iteratee, 4);
	      if (accumulator == null) {
	        var Ctor = object && object.constructor;
	        if (isArrLike) {
	          accumulator = isArr ? new Ctor : [];
	        }
	        else if (isObject(object)) {
	          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
	        }
	        else {
	          accumulator = {};
	        }
	      }
	      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
	        return iteratee(accumulator, value, index, object);
	      });
	      return accumulator;
	    }

	    /**
	     * Removes the property at `path` of `object`.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to unset.
	     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
	     * _.unset(object, 'a[0].b.c');
	     * // => true
	     *
	     * console.log(object);
	     * // => { 'a': [{ 'b': {} }] };
	     *
	     * _.unset(object, ['a', '0', 'b', 'c']);
	     * // => true
	     *
	     * console.log(object);
	     * // => { 'a': [{ 'b': {} }] };
	     */
	    function unset(object, path) {
	      return object == null ? true : baseUnset(object, path);
	    }

	    /**
	     * This method is like `_.set` except that accepts `updater` to produce the
	     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
	     * is invoked with one argument: (value).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.6.0
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to set.
	     * @param {Function} updater The function to produce the updated value.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	     *
	     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
	     * console.log(object.a[0].b.c);
	     * // => 9
	     *
	     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
	     * console.log(object.x[0].y.z);
	     * // => 0
	     */
	    function update(object, path, updater) {
	      return object == null ? object : baseUpdate(object, path, castFunction(updater));
	    }

	    /**
	     * This method is like `_.update` except that it accepts `customizer` which is
	     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
	     * path creation is handled by the method instead. The `customizer` is invoked
	     * with three arguments: (nsValue, key, nsObject).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.6.0
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to set.
	     * @param {Function} updater The function to produce the updated value.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = {};
	     *
	     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
	     * // => { '0': { '1': 'a' } }
	     */
	    function updateWith(object, path, updater, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined;
	      return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
	    }

	    /**
	     * Creates an array of the own enumerable string keyed property values of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property values.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.values(new Foo);
	     * // => [1, 2] (iteration order is not guaranteed)
	     *
	     * _.values('hi');
	     * // => ['h', 'i']
	     */
	    function values(object) {
	      return object == null ? [] : baseValues(object, keys(object));
	    }

	    /**
	     * Creates an array of the own and inherited enumerable string keyed property
	     * values of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property values.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.valuesIn(new Foo);
	     * // => [1, 2, 3] (iteration order is not guaranteed)
	     */
	    function valuesIn(object) {
	      return object == null ? [] : baseValues(object, keysIn(object));
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Clamps `number` within the inclusive `lower` and `upper` bounds.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Number
	     * @param {number} number The number to clamp.
	     * @param {number} [lower] The lower bound.
	     * @param {number} upper The upper bound.
	     * @returns {number} Returns the clamped number.
	     * @example
	     *
	     * _.clamp(-10, -5, 5);
	     * // => -5
	     *
	     * _.clamp(10, -5, 5);
	     * // => 5
	     */
	    function clamp(number, lower, upper) {
	      if (upper === undefined) {
	        upper = lower;
	        lower = undefined;
	      }
	      if (upper !== undefined) {
	        upper = toNumber(upper);
	        upper = upper === upper ? upper : 0;
	      }
	      if (lower !== undefined) {
	        lower = toNumber(lower);
	        lower = lower === lower ? lower : 0;
	      }
	      return baseClamp(toNumber(number), lower, upper);
	    }

	    /**
	     * Checks if `n` is between `start` and up to, but not including, `end`. If
	     * `end` is not specified, it's set to `start` with `start` then set to `0`.
	     * If `start` is greater than `end` the params are swapped to support
	     * negative ranges.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.3.0
	     * @category Number
	     * @param {number} number The number to check.
	     * @param {number} [start=0] The start of the range.
	     * @param {number} end The end of the range.
	     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
	     * @see _.range, _.rangeRight
	     * @example
	     *
	     * _.inRange(3, 2, 4);
	     * // => true
	     *
	     * _.inRange(4, 8);
	     * // => true
	     *
	     * _.inRange(4, 2);
	     * // => false
	     *
	     * _.inRange(2, 2);
	     * // => false
	     *
	     * _.inRange(1.2, 2);
	     * // => true
	     *
	     * _.inRange(5.2, 4);
	     * // => false
	     *
	     * _.inRange(-3, -2, -6);
	     * // => true
	     */
	    function inRange(number, start, end) {
	      start = toFinite(start);
	      if (end === undefined) {
	        end = start;
	        start = 0;
	      } else {
	        end = toFinite(end);
	      }
	      number = toNumber(number);
	      return baseInRange(number, start, end);
	    }

	    /**
	     * Produces a random number between the inclusive `lower` and `upper` bounds.
	     * If only one argument is provided a number between `0` and the given number
	     * is returned. If `floating` is `true`, or either `lower` or `upper` are
	     * floats, a floating-point number is returned instead of an integer.
	     *
	     * **Note:** JavaScript follows the IEEE-754 standard for resolving
	     * floating-point values which can produce unexpected results.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.7.0
	     * @category Number
	     * @param {number} [lower=0] The lower bound.
	     * @param {number} [upper=1] The upper bound.
	     * @param {boolean} [floating] Specify returning a floating-point number.
	     * @returns {number} Returns the random number.
	     * @example
	     *
	     * _.random(0, 5);
	     * // => an integer between 0 and 5
	     *
	     * _.random(5);
	     * // => also an integer between 0 and 5
	     *
	     * _.random(5, true);
	     * // => a floating-point number between 0 and 5
	     *
	     * _.random(1.2, 5.2);
	     * // => a floating-point number between 1.2 and 5.2
	     */
	    function random(lower, upper, floating) {
	      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
	        upper = floating = undefined;
	      }
	      if (floating === undefined) {
	        if (typeof upper == 'boolean') {
	          floating = upper;
	          upper = undefined;
	        }
	        else if (typeof lower == 'boolean') {
	          floating = lower;
	          lower = undefined;
	        }
	      }
	      if (lower === undefined && upper === undefined) {
	        lower = 0;
	        upper = 1;
	      }
	      else {
	        lower = toFinite(lower);
	        if (upper === undefined) {
	          upper = lower;
	          lower = 0;
	        } else {
	          upper = toFinite(upper);
	        }
	      }
	      if (lower > upper) {
	        var temp = lower;
	        lower = upper;
	        upper = temp;
	      }
	      if (floating || lower % 1 || upper % 1) {
	        var rand = nativeRandom();
	        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
	      }
	      return baseRandom(lower, upper);
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the camel cased string.
	     * @example
	     *
	     * _.camelCase('Foo Bar');
	     * // => 'fooBar'
	     *
	     * _.camelCase('--foo-bar--');
	     * // => 'fooBar'
	     *
	     * _.camelCase('__FOO_BAR__');
	     * // => 'fooBar'
	     */
	    var camelCase = createCompounder(function(result, word, index) {
	      word = word.toLowerCase();
	      return result + (index ? capitalize(word) : word);
	    });

	    /**
	     * Converts the first character of `string` to upper case and the remaining
	     * to lower case.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to capitalize.
	     * @returns {string} Returns the capitalized string.
	     * @example
	     *
	     * _.capitalize('FRED');
	     * // => 'Fred'
	     */
	    function capitalize(string) {
	      return upperFirst(toString(string).toLowerCase());
	    }

	    /**
	     * Deburrs `string` by converting
	     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
	     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
	     * letters to basic Latin letters and removing
	     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to deburr.
	     * @returns {string} Returns the deburred string.
	     * @example
	     *
	     * _.deburr('dj vu');
	     * // => 'deja vu'
	     */
	    function deburr(string) {
	      string = toString(string);
	      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
	    }

	    /**
	     * Checks if `string` ends with the given target string.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to inspect.
	     * @param {string} [target] The string to search for.
	     * @param {number} [position=string.length] The position to search up to.
	     * @returns {boolean} Returns `true` if `string` ends with `target`,
	     *  else `false`.
	     * @example
	     *
	     * _.endsWith('abc', 'c');
	     * // => true
	     *
	     * _.endsWith('abc', 'b');
	     * // => false
	     *
	     * _.endsWith('abc', 'b', 2);
	     * // => true
	     */
	    function endsWith(string, target, position) {
	      string = toString(string);
	      target = baseToString(target);

	      var length = string.length;
	      position = position === undefined
	        ? length
	        : baseClamp(toInteger(position), 0, length);

	      var end = position;
	      position -= target.length;
	      return position >= 0 && string.slice(position, end) == target;
	    }

	    /**
	     * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
	     * corresponding HTML entities.
	     *
	     * **Note:** No other characters are escaped. To escape additional
	     * characters use a third-party library like [_he_](https://mths.be/he).
	     *
	     * Though the ">" character is escaped for symmetry, characters like
	     * ">" and "/" don't need escaping in HTML and have no special meaning
	     * unless they're part of a tag or unquoted attribute value. See
	     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
	     * (under "semi-related fun fact") for more details.
	     *
	     * When working with HTML you should always
	     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
	     * XSS vectors.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to escape.
	     * @returns {string} Returns the escaped string.
	     * @example
	     *
	     * _.escape('fred, barney, & pebbles');
	     * // => 'fred, barney, &amp; pebbles'
	     */
	    function escape(string) {
	      string = toString(string);
	      return (string && reHasUnescapedHtml.test(string))
	        ? string.replace(reUnescapedHtml, escapeHtmlChar)
	        : string;
	    }

	    /**
	     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
	     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to escape.
	     * @returns {string} Returns the escaped string.
	     * @example
	     *
	     * _.escapeRegExp('[lodash](https://lodash.com/)');
	     * // => '\[lodash\]\(https://lodash\.com/\)'
	     */
	    function escapeRegExp(string) {
	      string = toString(string);
	      return (string && reHasRegExpChar.test(string))
	        ? string.replace(reRegExpChar, '\\$&')
	        : string;
	    }

	    /**
	     * Converts `string` to
	     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the kebab cased string.
	     * @example
	     *
	     * _.kebabCase('Foo Bar');
	     * // => 'foo-bar'
	     *
	     * _.kebabCase('fooBar');
	     * // => 'foo-bar'
	     *
	     * _.kebabCase('__FOO_BAR__');
	     * // => 'foo-bar'
	     */
	    var kebabCase = createCompounder(function(result, word, index) {
	      return result + (index ? '-' : '') + word.toLowerCase();
	    });

	    /**
	     * Converts `string`, as space separated words, to lower case.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the lower cased string.
	     * @example
	     *
	     * _.lowerCase('--Foo-Bar--');
	     * // => 'foo bar'
	     *
	     * _.lowerCase('fooBar');
	     * // => 'foo bar'
	     *
	     * _.lowerCase('__FOO_BAR__');
	     * // => 'foo bar'
	     */
	    var lowerCase = createCompounder(function(result, word, index) {
	      return result + (index ? ' ' : '') + word.toLowerCase();
	    });

	    /**
	     * Converts the first character of `string` to lower case.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the converted string.
	     * @example
	     *
	     * _.lowerFirst('Fred');
	     * // => 'fred'
	     *
	     * _.lowerFirst('FRED');
	     * // => 'fRED'
	     */
	    var lowerFirst = createCaseFirst('toLowerCase');

	    /**
	     * Pads `string` on the left and right sides if it's shorter than `length`.
	     * Padding characters are truncated if they can't be evenly divided by `length`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.pad('abc', 8);
	     * // => '  abc   '
	     *
	     * _.pad('abc', 8, '_-');
	     * // => '_-abc_-_'
	     *
	     * _.pad('abc', 3);
	     * // => 'abc'
	     */
	    function pad(string, length, chars) {
	      string = toString(string);
	      length = toInteger(length);

	      var strLength = length ? stringSize(string) : 0;
	      if (!length || strLength >= length) {
	        return string;
	      }
	      var mid = (length - strLength) / 2;
	      return (
	        createPadding(nativeFloor(mid), chars) +
	        string +
	        createPadding(nativeCeil(mid), chars)
	      );
	    }

	    /**
	     * Pads `string` on the right side if it's shorter than `length`. Padding
	     * characters are truncated if they exceed `length`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.padEnd('abc', 6);
	     * // => 'abc   '
	     *
	     * _.padEnd('abc', 6, '_-');
	     * // => 'abc_-_'
	     *
	     * _.padEnd('abc', 3);
	     * // => 'abc'
	     */
	    function padEnd(string, length, chars) {
	      string = toString(string);
	      length = toInteger(length);

	      var strLength = length ? stringSize(string) : 0;
	      return (length && strLength < length)
	        ? (string + createPadding(length - strLength, chars))
	        : string;
	    }

	    /**
	     * Pads `string` on the left side if it's shorter than `length`. Padding
	     * characters are truncated if they exceed `length`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.padStart('abc', 6);
	     * // => '   abc'
	     *
	     * _.padStart('abc', 6, '_-');
	     * // => '_-_abc'
	     *
	     * _.padStart('abc', 3);
	     * // => 'abc'
	     */
	    function padStart(string, length, chars) {
	      string = toString(string);
	      length = toInteger(length);

	      var strLength = length ? stringSize(string) : 0;
	      return (length && strLength < length)
	        ? (createPadding(length - strLength, chars) + string)
	        : string;
	    }

	    /**
	     * Converts `string` to an integer of the specified radix. If `radix` is
	     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
	     * hexadecimal, in which case a `radix` of `16` is used.
	     *
	     * **Note:** This method aligns with the
	     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.1.0
	     * @category String
	     * @param {string} string The string to convert.
	     * @param {number} [radix=10] The radix to interpret `value` by.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {number} Returns the converted integer.
	     * @example
	     *
	     * _.parseInt('08');
	     * // => 8
	     *
	     * _.map(['6', '08', '10'], _.parseInt);
	     * // => [6, 8, 10]
	     */
	    function parseInt(string, radix, guard) {
	      if (guard || radix == null) {
	        radix = 0;
	      } else if (radix) {
	        radix = +radix;
	      }
	      return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
	    }

	    /**
	     * Repeats the given string `n` times.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to repeat.
	     * @param {number} [n=1] The number of times to repeat the string.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {string} Returns the repeated string.
	     * @example
	     *
	     * _.repeat('*', 3);
	     * // => '***'
	     *
	     * _.repeat('abc', 2);
	     * // => 'abcabc'
	     *
	     * _.repeat('abc', 0);
	     * // => ''
	     */
	    function repeat(string, n, guard) {
	      if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {
	        n = 1;
	      } else {
	        n = toInteger(n);
	      }
	      return baseRepeat(toString(string), n);
	    }

	    /**
	     * Replaces matches for `pattern` in `string` with `replacement`.
	     *
	     * **Note:** This method is based on
	     * [`String#replace`](https://mdn.io/String/replace).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to modify.
	     * @param {RegExp|string} pattern The pattern to replace.
	     * @param {Function|string} replacement The match replacement.
	     * @returns {string} Returns the modified string.
	     * @example
	     *
	     * _.replace('Hi Fred', 'Fred', 'Barney');
	     * // => 'Hi Barney'
	     */
	    function replace() {
	      var args = arguments,
	          string = toString(args[0]);

	      return args.length < 3 ? string : string.replace(args[1], args[2]);
	    }

	    /**
	     * Converts `string` to
	     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the snake cased string.
	     * @example
	     *
	     * _.snakeCase('Foo Bar');
	     * // => 'foo_bar'
	     *
	     * _.snakeCase('fooBar');
	     * // => 'foo_bar'
	     *
	     * _.snakeCase('--FOO-BAR--');
	     * // => 'foo_bar'
	     */
	    var snakeCase = createCompounder(function(result, word, index) {
	      return result + (index ? '_' : '') + word.toLowerCase();
	    });

	    /**
	     * Splits `string` by `separator`.
	     *
	     * **Note:** This method is based on
	     * [`String#split`](https://mdn.io/String/split).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to split.
	     * @param {RegExp|string} separator The separator pattern to split by.
	     * @param {number} [limit] The length to truncate results to.
	     * @returns {Array} Returns the string segments.
	     * @example
	     *
	     * _.split('a-b-c', '-', 2);
	     * // => ['a', 'b']
	     */
	    function split(string, separator, limit) {
	      if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
	        separator = limit = undefined;
	      }
	      limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;
	      if (!limit) {
	        return [];
	      }
	      string = toString(string);
	      if (string && (
	            typeof separator == 'string' ||
	            (separator != null && !isRegExp(separator))
	          )) {
	        separator = baseToString(separator);
	        if (!separator && hasUnicode(string)) {
	          return castSlice(stringToArray(string), 0, limit);
	        }
	      }
	      return string.split(separator, limit);
	    }

	    /**
	     * Converts `string` to
	     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.1.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the start cased string.
	     * @example
	     *
	     * _.startCase('--foo-bar--');
	     * // => 'Foo Bar'
	     *
	     * _.startCase('fooBar');
	     * // => 'Foo Bar'
	     *
	     * _.startCase('__FOO_BAR__');
	     * // => 'FOO BAR'
	     */
	    var startCase = createCompounder(function(result, word, index) {
	      return result + (index ? ' ' : '') + upperFirst(word);
	    });

	    /**
	     * Checks if `string` starts with the given target string.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to inspect.
	     * @param {string} [target] The string to search for.
	     * @param {number} [position=0] The position to search from.
	     * @returns {boolean} Returns `true` if `string` starts with `target`,
	     *  else `false`.
	     * @example
	     *
	     * _.startsWith('abc', 'a');
	     * // => true
	     *
	     * _.startsWith('abc', 'b');
	     * // => false
	     *
	     * _.startsWith('abc', 'b', 1);
	     * // => true
	     */
	    function startsWith(string, target, position) {
	      string = toString(string);
	      position = baseClamp(toInteger(position), 0, string.length);
	      target = baseToString(target);
	      return string.slice(position, position + target.length) == target;
	    }

	    /**
	     * Creates a compiled template function that can interpolate data properties
	     * in "interpolate" delimiters, HTML-escape interpolated data properties in
	     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
	     * properties may be accessed as free variables in the template. If a setting
	     * object is given, it takes precedence over `_.templateSettings` values.
	     *
	     * **Note:** In the development build `_.template` utilizes
	     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
	     * for easier debugging.
	     *
	     * For more information on precompiling templates see
	     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
	     *
	     * For more information on Chrome extension sandboxes see
	     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The template string.
	     * @param {Object} [options={}] The options object.
	     * @param {RegExp} [options.escape=_.templateSettings.escape]
	     *  The HTML "escape" delimiter.
	     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
	     *  The "evaluate" delimiter.
	     * @param {Object} [options.imports=_.templateSettings.imports]
	     *  An object to import into the template as free variables.
	     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
	     *  The "interpolate" delimiter.
	     * @param {string} [options.sourceURL='lodash.templateSources[n]']
	     *  The sourceURL of the compiled template.
	     * @param {string} [options.variable='obj']
	     *  The data object variable name.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Function} Returns the compiled template function.
	     * @example
	     *
	     * // Use the "interpolate" delimiter to create a compiled template.
	     * var compiled = _.template('hello <%= user %>!');
	     * compiled({ 'user': 'fred' });
	     * // => 'hello fred!'
	     *
	     * // Use the HTML "escape" delimiter to escape data property values.
	     * var compiled = _.template('<b><%- value %></b>');
	     * compiled({ 'value': '<script>' });
	     * // => '<b>&lt;script&gt;</b>'
	     *
	     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
	     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
	     * compiled({ 'users': ['fred', 'barney'] });
	     * // => '<li>fred</li><li>barney</li>'
	     *
	     * // Use the internal `print` function in "evaluate" delimiters.
	     * var compiled = _.template('<% print("hello " + user); %>!');
	     * compiled({ 'user': 'barney' });
	     * // => 'hello barney!'
	     *
	     * // Use the ES template literal delimiter as an "interpolate" delimiter.
	     * // Disable support by replacing the "interpolate" delimiter.
	     * var compiled = _.template('hello ${ user }!');
	     * compiled({ 'user': 'pebbles' });
	     * // => 'hello pebbles!'
	     *
	     * // Use backslashes to treat delimiters as plain text.
	     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
	     * compiled({ 'value': 'ignored' });
	     * // => '<%- value %>'
	     *
	     * // Use the `imports` option to import `jQuery` as `jq`.
	     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
	     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
	     * compiled({ 'users': ['fred', 'barney'] });
	     * // => '<li>fred</li><li>barney</li>'
	     *
	     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
	     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
	     * compiled(data);
	     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
	     *
	     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
	     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
	     * compiled.source;
	     * // => function(data) {
	     * //   var __t, __p = '';
	     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
	     * //   return __p;
	     * // }
	     *
	     * // Use custom template delimiters.
	     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
	     * var compiled = _.template('hello {{ user }}!');
	     * compiled({ 'user': 'mustache' });
	     * // => 'hello mustache!'
	     *
	     * // Use the `source` property to inline compiled templates for meaningful
	     * // line numbers in error messages and stack traces.
	     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
	     *   var JST = {\
	     *     "main": ' + _.template(mainText).source + '\
	     *   };\
	     * ');
	     */
	    function template(string, options, guard) {
	      // Based on John Resig's `tmpl` implementation
	      // (http://ejohn.org/blog/javascript-micro-templating/)
	      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
	      var settings = lodash.templateSettings;

	      if (guard && isIterateeCall(string, options, guard)) {
	        options = undefined;
	      }
	      string = toString(string);
	      options = assignInWith({}, options, settings, assignInDefaults);

	      var imports = assignInWith({}, options.imports, settings.imports, assignInDefaults),
	          importsKeys = keys(imports),
	          importsValues = baseValues(imports, importsKeys);

	      var isEscaping,
	          isEvaluating,
	          index = 0,
	          interpolate = options.interpolate || reNoMatch,
	          source = "__p += '";

	      // Compile the regexp to match each delimiter.
	      var reDelimiters = RegExp(
	        (options.escape || reNoMatch).source + '|' +
	        interpolate.source + '|' +
	        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
	        (options.evaluate || reNoMatch).source + '|$'
	      , 'g');

	      // Use a sourceURL for easier debugging.
	      var sourceURL = '//# sourceURL=' +
	        ('sourceURL' in options
	          ? options.sourceURL
	          : ('lodash.templateSources[' + (++templateCounter) + ']')
	        ) + '\n';

	      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
	        interpolateValue || (interpolateValue = esTemplateValue);

	        // Escape characters that can't be included in string literals.
	        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

	        // Replace delimiters with snippets.
	        if (escapeValue) {
	          isEscaping = true;
	          source += "' +\n__e(" + escapeValue + ") +\n'";
	        }
	        if (evaluateValue) {
	          isEvaluating = true;
	          source += "';\n" + evaluateValue + ";\n__p += '";
	        }
	        if (interpolateValue) {
	          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
	        }
	        index = offset + match.length;

	        // The JS engine embedded in Adobe products needs `match` returned in
	        // order to produce the correct `offset` value.
	        return match;
	      });

	      source += "';\n";

	      // If `variable` is not specified wrap a with-statement around the generated
	      // code to add the data object to the top of the scope chain.
	      var variable = options.variable;
	      if (!variable) {
	        source = 'with (obj) {\n' + source + '\n}\n';
	      }
	      // Cleanup code by stripping empty strings.
	      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
	        .replace(reEmptyStringMiddle, '$1')
	        .replace(reEmptyStringTrailing, '$1;');

	      // Frame code as the function body.
	      source = 'function(' + (variable || 'obj') + ') {\n' +
	        (variable
	          ? ''
	          : 'obj || (obj = {});\n'
	        ) +
	        "var __t, __p = ''" +
	        (isEscaping
	           ? ', __e = _.escape'
	           : ''
	        ) +
	        (isEvaluating
	          ? ', __j = Array.prototype.join;\n' +
	            "function print() { __p += __j.call(arguments, '') }\n"
	          : ';\n'
	        ) +
	        source +
	        'return __p\n}';

	      var result = attempt(function() {
	        return Function(importsKeys, sourceURL + 'return ' + source)
	          .apply(undefined, importsValues);
	      });

	      // Provide the compiled function's source by its `toString` method or
	      // the `source` property as a convenience for inlining compiled templates.
	      result.source = source;
	      if (isError(result)) {
	        throw result;
	      }
	      return result;
	    }

	    /**
	     * Converts `string`, as a whole, to lower case just like
	     * [String#toLowerCase](https://mdn.io/toLowerCase).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the lower cased string.
	     * @example
	     *
	     * _.toLower('--Foo-Bar--');
	     * // => '--foo-bar--'
	     *
	     * _.toLower('fooBar');
	     * // => 'foobar'
	     *
	     * _.toLower('__FOO_BAR__');
	     * // => '__foo_bar__'
	     */
	    function toLower(value) {
	      return toString(value).toLowerCase();
	    }

	    /**
	     * Converts `string`, as a whole, to upper case just like
	     * [String#toUpperCase](https://mdn.io/toUpperCase).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the upper cased string.
	     * @example
	     *
	     * _.toUpper('--foo-bar--');
	     * // => '--FOO-BAR--'
	     *
	     * _.toUpper('fooBar');
	     * // => 'FOOBAR'
	     *
	     * _.toUpper('__foo_bar__');
	     * // => '__FOO_BAR__'
	     */
	    function toUpper(value) {
	      return toString(value).toUpperCase();
	    }

	    /**
	     * Removes leading and trailing whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trim('  abc  ');
	     * // => 'abc'
	     *
	     * _.trim('-_-abc-_-', '_-');
	     * // => 'abc'
	     *
	     * _.map(['  foo  ', '  bar  '], _.trim);
	     * // => ['foo', 'bar']
	     */
	    function trim(string, chars, guard) {
	      string = toString(string);
	      if (string && (guard || chars === undefined)) {
	        return string.replace(reTrim, '');
	      }
	      if (!string || !(chars = baseToString(chars))) {
	        return string;
	      }
	      var strSymbols = stringToArray(string),
	          chrSymbols = stringToArray(chars),
	          start = charsStartIndex(strSymbols, chrSymbols),
	          end = charsEndIndex(strSymbols, chrSymbols) + 1;

	      return castSlice(strSymbols, start, end).join('');
	    }

	    /**
	     * Removes trailing whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trimEnd('  abc  ');
	     * // => '  abc'
	     *
	     * _.trimEnd('-_-abc-_-', '_-');
	     * // => '-_-abc'
	     */
	    function trimEnd(string, chars, guard) {
	      string = toString(string);
	      if (string && (guard || chars === undefined)) {
	        return string.replace(reTrimEnd, '');
	      }
	      if (!string || !(chars = baseToString(chars))) {
	        return string;
	      }
	      var strSymbols = stringToArray(string),
	          end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;

	      return castSlice(strSymbols, 0, end).join('');
	    }

	    /**
	     * Removes leading whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trimStart('  abc  ');
	     * // => 'abc  '
	     *
	     * _.trimStart('-_-abc-_-', '_-');
	     * // => 'abc-_-'
	     */
	    function trimStart(string, chars, guard) {
	      string = toString(string);
	      if (string && (guard || chars === undefined)) {
	        return string.replace(reTrimStart, '');
	      }
	      if (!string || !(chars = baseToString(chars))) {
	        return string;
	      }
	      var strSymbols = stringToArray(string),
	          start = charsStartIndex(strSymbols, stringToArray(chars));

	      return castSlice(strSymbols, start).join('');
	    }

	    /**
	     * Truncates `string` if it's longer than the given maximum string length.
	     * The last characters of the truncated string are replaced with the omission
	     * string which defaults to "...".
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to truncate.
	     * @param {Object} [options={}] The options object.
	     * @param {number} [options.length=30] The maximum string length.
	     * @param {string} [options.omission='...'] The string to indicate text is omitted.
	     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
	     * @returns {string} Returns the truncated string.
	     * @example
	     *
	     * _.truncate('hi-diddly-ho there, neighborino');
	     * // => 'hi-diddly-ho there, neighbo...'
	     *
	     * _.truncate('hi-diddly-ho there, neighborino', {
	     *   'length': 24,
	     *   'separator': ' '
	     * });
	     * // => 'hi-diddly-ho there,...'
	     *
	     * _.truncate('hi-diddly-ho there, neighborino', {
	     *   'length': 24,
	     *   'separator': /,? +/
	     * });
	     * // => 'hi-diddly-ho there...'
	     *
	     * _.truncate('hi-diddly-ho there, neighborino', {
	     *   'omission': ' [...]'
	     * });
	     * // => 'hi-diddly-ho there, neig [...]'
	     */
	    function truncate(string, options) {
	      var length = DEFAULT_TRUNC_LENGTH,
	          omission = DEFAULT_TRUNC_OMISSION;

	      if (isObject(options)) {
	        var separator = 'separator' in options ? options.separator : separator;
	        length = 'length' in options ? toInteger(options.length) : length;
	        omission = 'omission' in options ? baseToString(options.omission) : omission;
	      }
	      string = toString(string);

	      var strLength = string.length;
	      if (hasUnicode(string)) {
	        var strSymbols = stringToArray(string);
	        strLength = strSymbols.length;
	      }
	      if (length >= strLength) {
	        return string;
	      }
	      var end = length - stringSize(omission);
	      if (end < 1) {
	        return omission;
	      }
	      var result = strSymbols
	        ? castSlice(strSymbols, 0, end).join('')
	        : string.slice(0, end);

	      if (separator === undefined) {
	        return result + omission;
	      }
	      if (strSymbols) {
	        end += (result.length - end);
	      }
	      if (isRegExp(separator)) {
	        if (string.slice(end).search(separator)) {
	          var match,
	              substring = result;

	          if (!separator.global) {
	            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
	          }
	          separator.lastIndex = 0;
	          while ((match = separator.exec(substring))) {
	            var newEnd = match.index;
	          }
	          result = result.slice(0, newEnd === undefined ? end : newEnd);
	        }
	      } else if (string.indexOf(baseToString(separator), end) != end) {
	        var index = result.lastIndexOf(separator);
	        if (index > -1) {
	          result = result.slice(0, index);
	        }
	      }
	      return result + omission;
	    }

	    /**
	     * The inverse of `_.escape`; this method converts the HTML entities
	     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
	     * their corresponding characters.
	     *
	     * **Note:** No other HTML entities are unescaped. To unescape additional
	     * HTML entities use a third-party library like [_he_](https://mths.be/he).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.6.0
	     * @category String
	     * @param {string} [string=''] The string to unescape.
	     * @returns {string} Returns the unescaped string.
	     * @example
	     *
	     * _.unescape('fred, barney, &amp; pebbles');
	     * // => 'fred, barney, & pebbles'
	     */
	    function unescape(string) {
	      string = toString(string);
	      return (string && reHasEscapedHtml.test(string))
	        ? string.replace(reEscapedHtml, unescapeHtmlChar)
	        : string;
	    }

	    /**
	     * Converts `string`, as space separated words, to upper case.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the upper cased string.
	     * @example
	     *
	     * _.upperCase('--foo-bar');
	     * // => 'FOO BAR'
	     *
	     * _.upperCase('fooBar');
	     * // => 'FOO BAR'
	     *
	     * _.upperCase('__foo_bar__');
	     * // => 'FOO BAR'
	     */
	    var upperCase = createCompounder(function(result, word, index) {
	      return result + (index ? ' ' : '') + word.toUpperCase();
	    });

	    /**
	     * Converts the first character of `string` to upper case.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the converted string.
	     * @example
	     *
	     * _.upperFirst('fred');
	     * // => 'Fred'
	     *
	     * _.upperFirst('FRED');
	     * // => 'FRED'
	     */
	    var upperFirst = createCaseFirst('toUpperCase');

	    /**
	     * Splits `string` into an array of its words.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to inspect.
	     * @param {RegExp|string} [pattern] The pattern to match words.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the words of `string`.
	     * @example
	     *
	     * _.words('fred, barney, & pebbles');
	     * // => ['fred', 'barney', 'pebbles']
	     *
	     * _.words('fred, barney, & pebbles', /[^, ]+/g);
	     * // => ['fred', 'barney', '&', 'pebbles']
	     */
	    function words(string, pattern, guard) {
	      string = toString(string);
	      pattern = guard ? undefined : pattern;

	      if (pattern === undefined) {
	        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
	      }
	      return string.match(pattern) || [];
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Attempts to invoke `func`, returning either the result or the caught error
	     * object. Any additional arguments are provided to `func` when it's invoked.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Util
	     * @param {Function} func The function to attempt.
	     * @param {...*} [args] The arguments to invoke `func` with.
	     * @returns {*} Returns the `func` result or error object.
	     * @example
	     *
	     * // Avoid throwing errors for invalid selectors.
	     * var elements = _.attempt(function(selector) {
	     *   return document.querySelectorAll(selector);
	     * }, '>_>');
	     *
	     * if (_.isError(elements)) {
	     *   elements = [];
	     * }
	     */
	    var attempt = baseRest(function(func, args) {
	      try {
	        return apply(func, undefined, args);
	      } catch (e) {
	        return isError(e) ? e : new Error(e);
	      }
	    });

	    /**
	     * Binds methods of an object to the object itself, overwriting the existing
	     * method.
	     *
	     * **Note:** This method doesn't set the "length" property of bound functions.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {Object} object The object to bind and assign the bound methods to.
	     * @param {...(string|string[])} methodNames The object method names to bind.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var view = {
	     *   'label': 'docs',
	     *   'click': function() {
	     *     console.log('clicked ' + this.label);
	     *   }
	     * };
	     *
	     * _.bindAll(view, ['click']);
	     * jQuery(element).on('click', view.click);
	     * // => Logs 'clicked docs' when clicked.
	     */
	    var bindAll = flatRest(function(object, methodNames) {
	      arrayEach(methodNames, function(key) {
	        key = toKey(key);
	        baseAssignValue(object, key, bind(object[key], object));
	      });
	      return object;
	    });

	    /**
	     * Creates a function that iterates over `pairs` and invokes the corresponding
	     * function of the first predicate to return truthy. The predicate-function
	     * pairs are invoked with the `this` binding and arguments of the created
	     * function.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {Array} pairs The predicate-function pairs.
	     * @returns {Function} Returns the new composite function.
	     * @example
	     *
	     * var func = _.cond([
	     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
	     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
	     *   [_.stubTrue,                      _.constant('no match')]
	     * ]);
	     *
	     * func({ 'a': 1, 'b': 2 });
	     * // => 'matches A'
	     *
	     * func({ 'a': 0, 'b': 1 });
	     * // => 'matches B'
	     *
	     * func({ 'a': '1', 'b': '2' });
	     * // => 'no match'
	     */
	    function cond(pairs) {
	      var length = pairs == null ? 0 : pairs.length,
	          toIteratee = getIteratee();

	      pairs = !length ? [] : arrayMap(pairs, function(pair) {
	        if (typeof pair[1] != 'function') {
	          throw new TypeError(FUNC_ERROR_TEXT);
	        }
	        return [toIteratee(pair[0]), pair[1]];
	      });

	      return baseRest(function(args) {
	        var index = -1;
	        while (++index < length) {
	          var pair = pairs[index];
	          if (apply(pair[0], this, args)) {
	            return apply(pair[1], this, args);
	          }
	        }
	      });
	    }

	    /**
	     * Creates a function that invokes the predicate properties of `source` with
	     * the corresponding property values of a given object, returning `true` if
	     * all predicates return truthy, else `false`.
	     *
	     * **Note:** The created function is equivalent to `_.conformsTo` with
	     * `source` partially applied.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {Object} source The object of property predicates to conform to.
	     * @returns {Function} Returns the new spec function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': 2, 'b': 1 },
	     *   { 'a': 1, 'b': 2 }
	     * ];
	     *
	     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
	     * // => [{ 'a': 1, 'b': 2 }]
	     */
	    function conforms(source) {
	      return baseConforms(baseClone(source, true));
	    }

	    /**
	     * Creates a function that returns `value`.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.4.0
	     * @category Util
	     * @param {*} value The value to return from the new function.
	     * @returns {Function} Returns the new constant function.
	     * @example
	     *
	     * var objects = _.times(2, _.constant({ 'a': 1 }));
	     *
	     * console.log(objects);
	     * // => [{ 'a': 1 }, { 'a': 1 }]
	     *
	     * console.log(objects[0] === objects[1]);
	     * // => true
	     */
	    function constant(value) {
	      return function() {
	        return value;
	      };
	    }

	    /**
	     * Checks `value` to determine whether a default value should be returned in
	     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
	     * or `undefined`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.14.0
	     * @category Util
	     * @param {*} value The value to check.
	     * @param {*} defaultValue The default value.
	     * @returns {*} Returns the resolved value.
	     * @example
	     *
	     * _.defaultTo(1, 10);
	     * // => 1
	     *
	     * _.defaultTo(undefined, 10);
	     * // => 10
	     */
	    function defaultTo(value, defaultValue) {
	      return (value == null || value !== value) ? defaultValue : value;
	    }

	    /**
	     * Creates a function that returns the result of invoking the given functions
	     * with the `this` binding of the created function, where each successive
	     * invocation is supplied the return value of the previous.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Util
	     * @param {...(Function|Function[])} [funcs] The functions to invoke.
	     * @returns {Function} Returns the new composite function.
	     * @see _.flowRight
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var addSquare = _.flow([_.add, square]);
	     * addSquare(1, 2);
	     * // => 9
	     */
	    var flow = createFlow();

	    /**
	     * This method is like `_.flow` except that it creates a function that
	     * invokes the given functions from right to left.
	     *
	     * @static
	     * @since 3.0.0
	     * @memberOf _
	     * @category Util
	     * @param {...(Function|Function[])} [funcs] The functions to invoke.
	     * @returns {Function} Returns the new composite function.
	     * @see _.flow
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var addSquare = _.flowRight([square, _.add]);
	     * addSquare(1, 2);
	     * // => 9
	     */
	    var flowRight = createFlow(true);

	    /**
	     * This method returns the first argument it receives.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {*} value Any value.
	     * @returns {*} Returns `value`.
	     * @example
	     *
	     * var object = { 'a': 1 };
	     *
	     * console.log(_.identity(object) === object);
	     * // => true
	     */
	    function identity(value) {
	      return value;
	    }

	    /**
	     * Creates a function that invokes `func` with the arguments of the created
	     * function. If `func` is a property name, the created function returns the
	     * property value for a given element. If `func` is an array or object, the
	     * created function returns `true` for elements that contain the equivalent
	     * source properties, otherwise it returns `false`.
	     *
	     * @static
	     * @since 4.0.0
	     * @memberOf _
	     * @category Util
	     * @param {*} [func=_.identity] The value to convert to a callback.
	     * @returns {Function} Returns the callback.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': true },
	     *   { 'user': 'fred',   'age': 40, 'active': false }
	     * ];
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
	     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.filter(users, _.iteratee(['user', 'fred']));
	     * // => [{ 'user': 'fred', 'age': 40 }]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.map(users, _.iteratee('user'));
	     * // => ['barney', 'fred']
	     *
	     * // Create custom iteratee shorthands.
	     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
	     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
	     *     return func.test(string);
	     *   };
	     * });
	     *
	     * _.filter(['abc', 'def'], /ef/);
	     * // => ['def']
	     */
	    function iteratee(func) {
	      return baseIteratee(typeof func == 'function' ? func : baseClone(func, true));
	    }

	    /**
	     * Creates a function that performs a partial deep comparison between a given
	     * object and `source`, returning `true` if the given object has equivalent
	     * property values, else `false`.
	     *
	     * **Note:** The created function is equivalent to `_.isMatch` with `source`
	     * partially applied.
	     *
	     * Partial comparisons will match empty array and empty object `source`
	     * values against any array or object value, respectively. See `_.isEqual`
	     * for a list of supported value comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Util
	     * @param {Object} source The object of property values to match.
	     * @returns {Function} Returns the new spec function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': 1, 'b': 2, 'c': 3 },
	     *   { 'a': 4, 'b': 5, 'c': 6 }
	     * ];
	     *
	     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
	     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
	     */
	    function matches(source) {
	      return baseMatches(baseClone(source, true));
	    }

	    /**
	     * Creates a function that performs a partial deep comparison between the
	     * value at `path` of a given object to `srcValue`, returning `true` if the
	     * object value is equivalent, else `false`.
	     *
	     * **Note:** Partial comparisons will match empty array and empty object
	     * `srcValue` values against any array or object value, respectively. See
	     * `_.isEqual` for a list of supported value comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.2.0
	     * @category Util
	     * @param {Array|string} path The path of the property to get.
	     * @param {*} srcValue The value to match.
	     * @returns {Function} Returns the new spec function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': 1, 'b': 2, 'c': 3 },
	     *   { 'a': 4, 'b': 5, 'c': 6 }
	     * ];
	     *
	     * _.find(objects, _.matchesProperty('a', 4));
	     * // => { 'a': 4, 'b': 5, 'c': 6 }
	     */
	    function matchesProperty(path, srcValue) {
	      return baseMatchesProperty(path, baseClone(srcValue, true));
	    }

	    /**
	     * Creates a function that invokes the method at `path` of a given object.
	     * Any additional arguments are provided to the invoked method.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.7.0
	     * @category Util
	     * @param {Array|string} path The path of the method to invoke.
	     * @param {...*} [args] The arguments to invoke the method with.
	     * @returns {Function} Returns the new invoker function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': { 'b': _.constant(2) } },
	     *   { 'a': { 'b': _.constant(1) } }
	     * ];
	     *
	     * _.map(objects, _.method('a.b'));
	     * // => [2, 1]
	     *
	     * _.map(objects, _.method(['a', 'b']));
	     * // => [2, 1]
	     */
	    var method = baseRest(function(path, args) {
	      return function(object) {
	        return baseInvoke(object, path, args);
	      };
	    });

	    /**
	     * The opposite of `_.method`; this method creates a function that invokes
	     * the method at a given path of `object`. Any additional arguments are
	     * provided to the invoked method.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.7.0
	     * @category Util
	     * @param {Object} object The object to query.
	     * @param {...*} [args] The arguments to invoke the method with.
	     * @returns {Function} Returns the new invoker function.
	     * @example
	     *
	     * var array = _.times(3, _.constant),
	     *     object = { 'a': array, 'b': array, 'c': array };
	     *
	     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
	     * // => [2, 0]
	     *
	     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
	     * // => [2, 0]
	     */
	    var methodOf = baseRest(function(object, args) {
	      return function(path) {
	        return baseInvoke(object, path, args);
	      };
	    });

	    /**
	     * Adds all own enumerable string keyed function properties of a source
	     * object to the destination object. If `object` is a function, then methods
	     * are added to its prototype as well.
	     *
	     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
	     * avoid conflicts caused by modifying the original.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {Function|Object} [object=lodash] The destination object.
	     * @param {Object} source The object of functions to add.
	     * @param {Object} [options={}] The options object.
	     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
	     * @returns {Function|Object} Returns `object`.
	     * @example
	     *
	     * function vowels(string) {
	     *   return _.filter(string, function(v) {
	     *     return /[aeiou]/i.test(v);
	     *   });
	     * }
	     *
	     * _.mixin({ 'vowels': vowels });
	     * _.vowels('fred');
	     * // => ['e']
	     *
	     * _('fred').vowels().value();
	     * // => ['e']
	     *
	     * _.mixin({ 'vowels': vowels }, { 'chain': false });
	     * _('fred').vowels();
	     * // => ['e']
	     */
	    function mixin(object, source, options) {
	      var props = keys(source),
	          methodNames = baseFunctions(source, props);

	      if (options == null &&
	          !(isObject(source) && (methodNames.length || !props.length))) {
	        options = source;
	        source = object;
	        object = this;
	        methodNames = baseFunctions(source, keys(source));
	      }
	      var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
	          isFunc = isFunction(object);

	      arrayEach(methodNames, function(methodName) {
	        var func = source[methodName];
	        object[methodName] = func;
	        if (isFunc) {
	          object.prototype[methodName] = function() {
	            var chainAll = this.__chain__;
	            if (chain || chainAll) {
	              var result = object(this.__wrapped__),
	                  actions = result.__actions__ = copyArray(this.__actions__);

	              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
	              result.__chain__ = chainAll;
	              return result;
	            }
	            return func.apply(object, arrayPush([this.value()], arguments));
	          };
	        }
	      });

	      return object;
	    }

	    /**
	     * Reverts the `_` variable to its previous value and returns a reference to
	     * the `lodash` function.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @returns {Function} Returns the `lodash` function.
	     * @example
	     *
	     * var lodash = _.noConflict();
	     */
	    function noConflict() {
	      if (root._ === this) {
	        root._ = oldDash;
	      }
	      return this;
	    }

	    /**
	     * This method returns `undefined`.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.3.0
	     * @category Util
	     * @example
	     *
	     * _.times(2, _.noop);
	     * // => [undefined, undefined]
	     */
	    function noop() {
	      // No operation performed.
	    }

	    /**
	     * Creates a function that gets the argument at index `n`. If `n` is negative,
	     * the nth argument from the end is returned.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {number} [n=0] The index of the argument to return.
	     * @returns {Function} Returns the new pass-thru function.
	     * @example
	     *
	     * var func = _.nthArg(1);
	     * func('a', 'b', 'c', 'd');
	     * // => 'b'
	     *
	     * var func = _.nthArg(-2);
	     * func('a', 'b', 'c', 'd');
	     * // => 'c'
	     */
	    function nthArg(n) {
	      n = toInteger(n);
	      return baseRest(function(args) {
	        return baseNth(args, n);
	      });
	    }

	    /**
	     * Creates a function that invokes `iteratees` with the arguments it receives
	     * and returns their results.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {...(Function|Function[])} [iteratees=[_.identity]]
	     *  The iteratees to invoke.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var func = _.over([Math.max, Math.min]);
	     *
	     * func(1, 2, 3, 4);
	     * // => [4, 1]
	     */
	    var over = createOver(arrayMap);

	    /**
	     * Creates a function that checks if **all** of the `predicates` return
	     * truthy when invoked with the arguments it receives.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {...(Function|Function[])} [predicates=[_.identity]]
	     *  The predicates to check.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var func = _.overEvery([Boolean, isFinite]);
	     *
	     * func('1');
	     * // => true
	     *
	     * func(null);
	     * // => false
	     *
	     * func(NaN);
	     * // => false
	     */
	    var overEvery = createOver(arrayEvery);

	    /**
	     * Creates a function that checks if **any** of the `predicates` return
	     * truthy when invoked with the arguments it receives.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {...(Function|Function[])} [predicates=[_.identity]]
	     *  The predicates to check.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var func = _.overSome([Boolean, isFinite]);
	     *
	     * func('1');
	     * // => true
	     *
	     * func(null);
	     * // => true
	     *
	     * func(NaN);
	     * // => false
	     */
	    var overSome = createOver(arraySome);

	    /**
	     * Creates a function that returns the value at `path` of a given object.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.4.0
	     * @category Util
	     * @param {Array|string} path The path of the property to get.
	     * @returns {Function} Returns the new accessor function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': { 'b': 2 } },
	     *   { 'a': { 'b': 1 } }
	     * ];
	     *
	     * _.map(objects, _.property('a.b'));
	     * // => [2, 1]
	     *
	     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
	     * // => [1, 2]
	     */
	    function property(path) {
	      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
	    }

	    /**
	     * The opposite of `_.property`; this method creates a function that returns
	     * the value at a given path of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Util
	     * @param {Object} object The object to query.
	     * @returns {Function} Returns the new accessor function.
	     * @example
	     *
	     * var array = [0, 1, 2],
	     *     object = { 'a': array, 'b': array, 'c': array };
	     *
	     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
	     * // => [2, 0]
	     *
	     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
	     * // => [2, 0]
	     */
	    function propertyOf(object) {
	      return function(path) {
	        return object == null ? undefined : baseGet(object, path);
	      };
	    }

	    /**
	     * Creates an array of numbers (positive and/or negative) progressing from
	     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
	     * `start` is specified without an `end` or `step`. If `end` is not specified,
	     * it's set to `start` with `start` then set to `0`.
	     *
	     * **Note:** JavaScript follows the IEEE-754 standard for resolving
	     * floating-point values which can produce unexpected results.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {number} [start=0] The start of the range.
	     * @param {number} end The end of the range.
	     * @param {number} [step=1] The value to increment or decrement by.
	     * @returns {Array} Returns the range of numbers.
	     * @see _.inRange, _.rangeRight
	     * @example
	     *
	     * _.range(4);
	     * // => [0, 1, 2, 3]
	     *
	     * _.range(-4);
	     * // => [0, -1, -2, -3]
	     *
	     * _.range(1, 5);
	     * // => [1, 2, 3, 4]
	     *
	     * _.range(0, 20, 5);
	     * // => [0, 5, 10, 15]
	     *
	     * _.range(0, -4, -1);
	     * // => [0, -1, -2, -3]
	     *
	     * _.range(1, 4, 0);
	     * // => [1, 1, 1]
	     *
	     * _.range(0);
	     * // => []
	     */
	    var range = createRange();

	    /**
	     * This method is like `_.range` except that it populates values in
	     * descending order.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {number} [start=0] The start of the range.
	     * @param {number} end The end of the range.
	     * @param {number} [step=1] The value to increment or decrement by.
	     * @returns {Array} Returns the range of numbers.
	     * @see _.inRange, _.range
	     * @example
	     *
	     * _.rangeRight(4);
	     * // => [3, 2, 1, 0]
	     *
	     * _.rangeRight(-4);
	     * // => [-3, -2, -1, 0]
	     *
	     * _.rangeRight(1, 5);
	     * // => [4, 3, 2, 1]
	     *
	     * _.rangeRight(0, 20, 5);
	     * // => [15, 10, 5, 0]
	     *
	     * _.rangeRight(0, -4, -1);
	     * // => [-3, -2, -1, 0]
	     *
	     * _.rangeRight(1, 4, 0);
	     * // => [1, 1, 1]
	     *
	     * _.rangeRight(0);
	     * // => []
	     */
	    var rangeRight = createRange(true);

	    /**
	     * This method returns a new empty array.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.13.0
	     * @category Util
	     * @returns {Array} Returns the new empty array.
	     * @example
	     *
	     * var arrays = _.times(2, _.stubArray);
	     *
	     * console.log(arrays);
	     * // => [[], []]
	     *
	     * console.log(arrays[0] === arrays[1]);
	     * // => false
	     */
	    function stubArray() {
	      return [];
	    }

	    /**
	     * This method returns `false`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.13.0
	     * @category Util
	     * @returns {boolean} Returns `false`.
	     * @example
	     *
	     * _.times(2, _.stubFalse);
	     * // => [false, false]
	     */
	    function stubFalse() {
	      return false;
	    }

	    /**
	     * This method returns a new empty object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.13.0
	     * @category Util
	     * @returns {Object} Returns the new empty object.
	     * @example
	     *
	     * var objects = _.times(2, _.stubObject);
	     *
	     * console.log(objects);
	     * // => [{}, {}]
	     *
	     * console.log(objects[0] === objects[1]);
	     * // => false
	     */
	    function stubObject() {
	      return {};
	    }

	    /**
	     * This method returns an empty string.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.13.0
	     * @category Util
	     * @returns {string} Returns the empty string.
	     * @example
	     *
	     * _.times(2, _.stubString);
	     * // => ['', '']
	     */
	    function stubString() {
	      return '';
	    }

	    /**
	     * This method returns `true`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.13.0
	     * @category Util
	     * @returns {boolean} Returns `true`.
	     * @example
	     *
	     * _.times(2, _.stubTrue);
	     * // => [true, true]
	     */
	    function stubTrue() {
	      return true;
	    }

	    /**
	     * Invokes the iteratee `n` times, returning an array of the results of
	     * each invocation. The iteratee is invoked with one argument; (index).
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {number} n The number of times to invoke `iteratee`.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the array of results.
	     * @example
	     *
	     * _.times(3, String);
	     * // => ['0', '1', '2']
	     *
	     *  _.times(4, _.constant(0));
	     * // => [0, 0, 0, 0]
	     */
	    function times(n, iteratee) {
	      n = toInteger(n);
	      if (n < 1 || n > MAX_SAFE_INTEGER) {
	        return [];
	      }
	      var index = MAX_ARRAY_LENGTH,
	          length = nativeMin(n, MAX_ARRAY_LENGTH);

	      iteratee = getIteratee(iteratee);
	      n -= MAX_ARRAY_LENGTH;

	      var result = baseTimes(length, iteratee);
	      while (++index < n) {
	        iteratee(index);
	      }
	      return result;
	    }

	    /**
	     * Converts `value` to a property path array.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {*} value The value to convert.
	     * @returns {Array} Returns the new property path array.
	     * @example
	     *
	     * _.toPath('a.b.c');
	     * // => ['a', 'b', 'c']
	     *
	     * _.toPath('a[0].b.c');
	     * // => ['a', '0', 'b', 'c']
	     */
	    function toPath(value) {
	      if (isArray(value)) {
	        return arrayMap(value, toKey);
	      }
	      return isSymbol(value) ? [value] : copyArray(stringToPath(value));
	    }

	    /**
	     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {string} [prefix=''] The value to prefix the ID with.
	     * @returns {string} Returns the unique ID.
	     * @example
	     *
	     * _.uniqueId('contact_');
	     * // => 'contact_104'
	     *
	     * _.uniqueId();
	     * // => '105'
	     */
	    function uniqueId(prefix) {
	      var id = ++idCounter;
	      return toString(prefix) + id;
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Adds two numbers.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.4.0
	     * @category Math
	     * @param {number} augend The first number in an addition.
	     * @param {number} addend The second number in an addition.
	     * @returns {number} Returns the total.
	     * @example
	     *
	     * _.add(6, 4);
	     * // => 10
	     */
	    var add = createMathOperation(function(augend, addend) {
	      return augend + addend;
	    }, 0);

	    /**
	     * Computes `number` rounded up to `precision`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.10.0
	     * @category Math
	     * @param {number} number The number to round up.
	     * @param {number} [precision=0] The precision to round up to.
	     * @returns {number} Returns the rounded up number.
	     * @example
	     *
	     * _.ceil(4.006);
	     * // => 5
	     *
	     * _.ceil(6.004, 2);
	     * // => 6.01
	     *
	     * _.ceil(6040, -2);
	     * // => 6100
	     */
	    var ceil = createRound('ceil');

	    /**
	     * Divide two numbers.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.7.0
	     * @category Math
	     * @param {number} dividend The first number in a division.
	     * @param {number} divisor The second number in a division.
	     * @returns {number} Returns the quotient.
	     * @example
	     *
	     * _.divide(6, 4);
	     * // => 1.5
	     */
	    var divide = createMathOperation(function(dividend, divisor) {
	      return dividend / divisor;
	    }, 1);

	    /**
	     * Computes `number` rounded down to `precision`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.10.0
	     * @category Math
	     * @param {number} number The number to round down.
	     * @param {number} [precision=0] The precision to round down to.
	     * @returns {number} Returns the rounded down number.
	     * @example
	     *
	     * _.floor(4.006);
	     * // => 4
	     *
	     * _.floor(0.046, 2);
	     * // => 0.04
	     *
	     * _.floor(4060, -2);
	     * // => 4000
	     */
	    var floor = createRound('floor');

	    /**
	     * Computes the maximum value of `array`. If `array` is empty or falsey,
	     * `undefined` is returned.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @returns {*} Returns the maximum value.
	     * @example
	     *
	     * _.max([4, 2, 8, 6]);
	     * // => 8
	     *
	     * _.max([]);
	     * // => undefined
	     */
	    function max(array) {
	      return (array && array.length)
	        ? baseExtremum(array, identity, baseGt)
	        : undefined;
	    }

	    /**
	     * This method is like `_.max` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the criterion by which
	     * the value is ranked. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {*} Returns the maximum value.
	     * @example
	     *
	     * var objects = [{ 'n': 1 }, { 'n': 2 }];
	     *
	     * _.maxBy(objects, function(o) { return o.n; });
	     * // => { 'n': 2 }
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.maxBy(objects, 'n');
	     * // => { 'n': 2 }
	     */
	    function maxBy(array, iteratee) {
	      return (array && array.length)
	        ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)
	        : undefined;
	    }

	    /**
	     * Computes the mean of the values in `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @returns {number} Returns the mean.
	     * @example
	     *
	     * _.mean([4, 2, 8, 6]);
	     * // => 5
	     */
	    function mean(array) {
	      return baseMean(array, identity);
	    }

	    /**
	     * This method is like `_.mean` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the value to be averaged.
	     * The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.7.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {number} Returns the mean.
	     * @example
	     *
	     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
	     *
	     * _.meanBy(objects, function(o) { return o.n; });
	     * // => 5
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.meanBy(objects, 'n');
	     * // => 5
	     */
	    function meanBy(array, iteratee) {
	      return baseMean(array, getIteratee(iteratee, 2));
	    }

	    /**
	     * Computes the minimum value of `array`. If `array` is empty or falsey,
	     * `undefined` is returned.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @returns {*} Returns the minimum value.
	     * @example
	     *
	     * _.min([4, 2, 8, 6]);
	     * // => 2
	     *
	     * _.min([]);
	     * // => undefined
	     */
	    function min(array) {
	      return (array && array.length)
	        ? baseExtremum(array, identity, baseLt)
	        : undefined;
	    }

	    /**
	     * This method is like `_.min` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the criterion by which
	     * the value is ranked. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {*} Returns the minimum value.
	     * @example
	     *
	     * var objects = [{ 'n': 1 }, { 'n': 2 }];
	     *
	     * _.minBy(objects, function(o) { return o.n; });
	     * // => { 'n': 1 }
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.minBy(objects, 'n');
	     * // => { 'n': 1 }
	     */
	    function minBy(array, iteratee) {
	      return (array && array.length)
	        ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)
	        : undefined;
	    }

	    /**
	     * Multiply two numbers.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.7.0
	     * @category Math
	     * @param {number} multiplier The first number in a multiplication.
	     * @param {number} multiplicand The second number in a multiplication.
	     * @returns {number} Returns the product.
	     * @example
	     *
	     * _.multiply(6, 4);
	     * // => 24
	     */
	    var multiply = createMathOperation(function(multiplier, multiplicand) {
	      return multiplier * multiplicand;
	    }, 1);

	    /**
	     * Computes `number` rounded to `precision`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.10.0
	     * @category Math
	     * @param {number} number The number to round.
	     * @param {number} [precision=0] The precision to round to.
	     * @returns {number} Returns the rounded number.
	     * @example
	     *
	     * _.round(4.006);
	     * // => 4
	     *
	     * _.round(4.006, 2);
	     * // => 4.01
	     *
	     * _.round(4060, -2);
	     * // => 4100
	     */
	    var round = createRound('round');

	    /**
	     * Subtract two numbers.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Math
	     * @param {number} minuend The first number in a subtraction.
	     * @param {number} subtrahend The second number in a subtraction.
	     * @returns {number} Returns the difference.
	     * @example
	     *
	     * _.subtract(6, 4);
	     * // => 2
	     */
	    var subtract = createMathOperation(function(minuend, subtrahend) {
	      return minuend - subtrahend;
	    }, 0);

	    /**
	     * Computes the sum of the values in `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.4.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @returns {number} Returns the sum.
	     * @example
	     *
	     * _.sum([4, 2, 8, 6]);
	     * // => 20
	     */
	    function sum(array) {
	      return (array && array.length)
	        ? baseSum(array, identity)
	        : 0;
	    }

	    /**
	     * This method is like `_.sum` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the value to be summed.
	     * The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {number} Returns the sum.
	     * @example
	     *
	     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
	     *
	     * _.sumBy(objects, function(o) { return o.n; });
	     * // => 20
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.sumBy(objects, 'n');
	     * // => 20
	     */
	    function sumBy(array, iteratee) {
	      return (array && array.length)
	        ? baseSum(array, getIteratee(iteratee, 2))
	        : 0;
	    }

	    /*------------------------------------------------------------------------*/

	    // Add methods that return wrapped values in chain sequences.
	    lodash.after = after;
	    lodash.ary = ary;
	    lodash.assign = assign;
	    lodash.assignIn = assignIn;
	    lodash.assignInWith = assignInWith;
	    lodash.assignWith = assignWith;
	    lodash.at = at;
	    lodash.before = before;
	    lodash.bind = bind;
	    lodash.bindAll = bindAll;
	    lodash.bindKey = bindKey;
	    lodash.castArray = castArray;
	    lodash.chain = chain;
	    lodash.chunk = chunk;
	    lodash.compact = compact;
	    lodash.concat = concat;
	    lodash.cond = cond;
	    lodash.conforms = conforms;
	    lodash.constant = constant;
	    lodash.countBy = countBy;
	    lodash.create = create;
	    lodash.curry = curry;
	    lodash.curryRight = curryRight;
	    lodash.debounce = debounce;
	    lodash.defaults = defaults;
	    lodash.defaultsDeep = defaultsDeep;
	    lodash.defer = defer;
	    lodash.delay = delay;
	    lodash.difference = difference;
	    lodash.differenceBy = differenceBy;
	    lodash.differenceWith = differenceWith;
	    lodash.drop = drop;
	    lodash.dropRight = dropRight;
	    lodash.dropRightWhile = dropRightWhile;
	    lodash.dropWhile = dropWhile;
	    lodash.fill = fill;
	    lodash.filter = filter;
	    lodash.flatMap = flatMap;
	    lodash.flatMapDeep = flatMapDeep;
	    lodash.flatMapDepth = flatMapDepth;
	    lodash.flatten = flatten;
	    lodash.flattenDeep = flattenDeep;
	    lodash.flattenDepth = flattenDepth;
	    lodash.flip = flip;
	    lodash.flow = flow;
	    lodash.flowRight = flowRight;
	    lodash.fromPairs = fromPairs;
	    lodash.functions = functions;
	    lodash.functionsIn = functionsIn;
	    lodash.groupBy = groupBy;
	    lodash.initial = initial;
	    lodash.intersection = intersection;
	    lodash.intersectionBy = intersectionBy;
	    lodash.intersectionWith = intersectionWith;
	    lodash.invert = invert;
	    lodash.invertBy = invertBy;
	    lodash.invokeMap = invokeMap;
	    lodash.iteratee = iteratee;
	    lodash.keyBy = keyBy;
	    lodash.keys = keys;
	    lodash.keysIn = keysIn;
	    lodash.map = map;
	    lodash.mapKeys = mapKeys;
	    lodash.mapValues = mapValues;
	    lodash.matches = matches;
	    lodash.matchesProperty = matchesProperty;
	    lodash.memoize = memoize;
	    lodash.merge = merge;
	    lodash.mergeWith = mergeWith;
	    lodash.method = method;
	    lodash.methodOf = methodOf;
	    lodash.mixin = mixin;
	    lodash.negate = negate;
	    lodash.nthArg = nthArg;
	    lodash.omit = omit;
	    lodash.omitBy = omitBy;
	    lodash.once = once;
	    lodash.orderBy = orderBy;
	    lodash.over = over;
	    lodash.overArgs = overArgs;
	    lodash.overEvery = overEvery;
	    lodash.overSome = overSome;
	    lodash.partial = partial;
	    lodash.partialRight = partialRight;
	    lodash.partition = partition;
	    lodash.pick = pick;
	    lodash.pickBy = pickBy;
	    lodash.property = property;
	    lodash.propertyOf = propertyOf;
	    lodash.pull = pull;
	    lodash.pullAll = pullAll;
	    lodash.pullAllBy = pullAllBy;
	    lodash.pullAllWith = pullAllWith;
	    lodash.pullAt = pullAt;
	    lodash.range = range;
	    lodash.rangeRight = rangeRight;
	    lodash.rearg = rearg;
	    lodash.reject = reject;
	    lodash.remove = remove;
	    lodash.rest = rest;
	    lodash.reverse = reverse;
	    lodash.sampleSize = sampleSize;
	    lodash.set = set;
	    lodash.setWith = setWith;
	    lodash.shuffle = shuffle;
	    lodash.slice = slice;
	    lodash.sortBy = sortBy;
	    lodash.sortedUniq = sortedUniq;
	    lodash.sortedUniqBy = sortedUniqBy;
	    lodash.split = split;
	    lodash.spread = spread;
	    lodash.tail = tail;
	    lodash.take = take;
	    lodash.takeRight = takeRight;
	    lodash.takeRightWhile = takeRightWhile;
	    lodash.takeWhile = takeWhile;
	    lodash.tap = tap;
	    lodash.throttle = throttle;
	    lodash.thru = thru;
	    lodash.toArray = toArray;
	    lodash.toPairs = toPairs;
	    lodash.toPairsIn = toPairsIn;
	    lodash.toPath = toPath;
	    lodash.toPlainObject = toPlainObject;
	    lodash.transform = transform;
	    lodash.unary = unary;
	    lodash.union = union;
	    lodash.unionBy = unionBy;
	    lodash.unionWith = unionWith;
	    lodash.uniq = uniq;
	    lodash.uniqBy = uniqBy;
	    lodash.uniqWith = uniqWith;
	    lodash.unset = unset;
	    lodash.unzip = unzip;
	    lodash.unzipWith = unzipWith;
	    lodash.update = update;
	    lodash.updateWith = updateWith;
	    lodash.values = values;
	    lodash.valuesIn = valuesIn;
	    lodash.without = without;
	    lodash.words = words;
	    lodash.wrap = wrap;
	    lodash.xor = xor;
	    lodash.xorBy = xorBy;
	    lodash.xorWith = xorWith;
	    lodash.zip = zip;
	    lodash.zipObject = zipObject;
	    lodash.zipObjectDeep = zipObjectDeep;
	    lodash.zipWith = zipWith;

	    // Add aliases.
	    lodash.entries = toPairs;
	    lodash.entriesIn = toPairsIn;
	    lodash.extend = assignIn;
	    lodash.extendWith = assignInWith;

	    // Add methods to `lodash.prototype`.
	    mixin(lodash, lodash);

	    /*------------------------------------------------------------------------*/

	    // Add methods that return unwrapped values in chain sequences.
	    lodash.add = add;
	    lodash.attempt = attempt;
	    lodash.camelCase = camelCase;
	    lodash.capitalize = capitalize;
	    lodash.ceil = ceil;
	    lodash.clamp = clamp;
	    lodash.clone = clone;
	    lodash.cloneDeep = cloneDeep;
	    lodash.cloneDeepWith = cloneDeepWith;
	    lodash.cloneWith = cloneWith;
	    lodash.conformsTo = conformsTo;
	    lodash.deburr = deburr;
	    lodash.defaultTo = defaultTo;
	    lodash.divide = divide;
	    lodash.endsWith = endsWith;
	    lodash.eq = eq;
	    lodash.escape = escape;
	    lodash.escapeRegExp = escapeRegExp;
	    lodash.every = every;
	    lodash.find = find;
	    lodash.findIndex = findIndex;
	    lodash.findKey = findKey;
	    lodash.findLast = findLast;
	    lodash.findLastIndex = findLastIndex;
	    lodash.findLastKey = findLastKey;
	    lodash.floor = floor;
	    lodash.forEach = forEach;
	    lodash.forEachRight = forEachRight;
	    lodash.forIn = forIn;
	    lodash.forInRight = forInRight;
	    lodash.forOwn = forOwn;
	    lodash.forOwnRight = forOwnRight;
	    lodash.get = get;
	    lodash.gt = gt;
	    lodash.gte = gte;
	    lodash.has = has;
	    lodash.hasIn = hasIn;
	    lodash.head = head;
	    lodash.identity = identity;
	    lodash.includes = includes;
	    lodash.indexOf = indexOf;
	    lodash.inRange = inRange;
	    lodash.invoke = invoke;
	    lodash.isArguments = isArguments;
	    lodash.isArray = isArray;
	    lodash.isArrayBuffer = isArrayBuffer;
	    lodash.isArrayLike = isArrayLike;
	    lodash.isArrayLikeObject = isArrayLikeObject;
	    lodash.isBoolean = isBoolean;
	    lodash.isBuffer = isBuffer;
	    lodash.isDate = isDate;
	    lodash.isElement = isElement;
	    lodash.isEmpty = isEmpty;
	    lodash.isEqual = isEqual;
	    lodash.isEqualWith = isEqualWith;
	    lodash.isError = isError;
	    lodash.isFinite = isFinite;
	    lodash.isFunction = isFunction;
	    lodash.isInteger = isInteger;
	    lodash.isLength = isLength;
	    lodash.isMap = isMap;
	    lodash.isMatch = isMatch;
	    lodash.isMatchWith = isMatchWith;
	    lodash.isNaN = isNaN;
	    lodash.isNative = isNative;
	    lodash.isNil = isNil;
	    lodash.isNull = isNull;
	    lodash.isNumber = isNumber;
	    lodash.isObject = isObject;
	    lodash.isObjectLike = isObjectLike;
	    lodash.isPlainObject = isPlainObject;
	    lodash.isRegExp = isRegExp;
	    lodash.isSafeInteger = isSafeInteger;
	    lodash.isSet = isSet;
	    lodash.isString = isString;
	    lodash.isSymbol = isSymbol;
	    lodash.isTypedArray = isTypedArray;
	    lodash.isUndefined = isUndefined;
	    lodash.isWeakMap = isWeakMap;
	    lodash.isWeakSet = isWeakSet;
	    lodash.join = join;
	    lodash.kebabCase = kebabCase;
	    lodash.last = last;
	    lodash.lastIndexOf = lastIndexOf;
	    lodash.lowerCase = lowerCase;
	    lodash.lowerFirst = lowerFirst;
	    lodash.lt = lt;
	    lodash.lte = lte;
	    lodash.max = max;
	    lodash.maxBy = maxBy;
	    lodash.mean = mean;
	    lodash.meanBy = meanBy;
	    lodash.min = min;
	    lodash.minBy = minBy;
	    lodash.stubArray = stubArray;
	    lodash.stubFalse = stubFalse;
	    lodash.stubObject = stubObject;
	    lodash.stubString = stubString;
	    lodash.stubTrue = stubTrue;
	    lodash.multiply = multiply;
	    lodash.nth = nth;
	    lodash.noConflict = noConflict;
	    lodash.noop = noop;
	    lodash.now = now;
	    lodash.pad = pad;
	    lodash.padEnd = padEnd;
	    lodash.padStart = padStart;
	    lodash.parseInt = parseInt;
	    lodash.random = random;
	    lodash.reduce = reduce;
	    lodash.reduceRight = reduceRight;
	    lodash.repeat = repeat;
	    lodash.replace = replace;
	    lodash.result = result;
	    lodash.round = round;
	    lodash.runInContext = runInContext;
	    lodash.sample = sample;
	    lodash.size = size;
	    lodash.snakeCase = snakeCase;
	    lodash.some = some;
	    lodash.sortedIndex = sortedIndex;
	    lodash.sortedIndexBy = sortedIndexBy;
	    lodash.sortedIndexOf = sortedIndexOf;
	    lodash.sortedLastIndex = sortedLastIndex;
	    lodash.sortedLastIndexBy = sortedLastIndexBy;
	    lodash.sortedLastIndexOf = sortedLastIndexOf;
	    lodash.startCase = startCase;
	    lodash.startsWith = startsWith;
	    lodash.subtract = subtract;
	    lodash.sum = sum;
	    lodash.sumBy = sumBy;
	    lodash.template = template;
	    lodash.times = times;
	    lodash.toFinite = toFinite;
	    lodash.toInteger = toInteger;
	    lodash.toLength = toLength;
	    lodash.toLower = toLower;
	    lodash.toNumber = toNumber;
	    lodash.toSafeInteger = toSafeInteger;
	    lodash.toString = toString;
	    lodash.toUpper = toUpper;
	    lodash.trim = trim;
	    lodash.trimEnd = trimEnd;
	    lodash.trimStart = trimStart;
	    lodash.truncate = truncate;
	    lodash.unescape = unescape;
	    lodash.uniqueId = uniqueId;
	    lodash.upperCase = upperCase;
	    lodash.upperFirst = upperFirst;

	    // Add aliases.
	    lodash.each = forEach;
	    lodash.eachRight = forEachRight;
	    lodash.first = head;

	    mixin(lodash, (function() {
	      var source = {};
	      baseForOwn(lodash, function(func, methodName) {
	        if (!hasOwnProperty.call(lodash.prototype, methodName)) {
	          source[methodName] = func;
	        }
	      });
	      return source;
	    }()), { 'chain': false });

	    /*------------------------------------------------------------------------*/

	    /**
	     * The semantic version number.
	     *
	     * @static
	     * @memberOf _
	     * @type {string}
	     */
	    lodash.VERSION = VERSION;

	    // Assign default placeholders.
	    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
	      lodash[methodName].placeholder = lodash;
	    });

	    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
	    arrayEach(['drop', 'take'], function(methodName, index) {
	      LazyWrapper.prototype[methodName] = function(n) {
	        var filtered = this.__filtered__;
	        if (filtered && !index) {
	          return new LazyWrapper(this);
	        }
	        n = n === undefined ? 1 : nativeMax(toInteger(n), 0);

	        var result = this.clone();
	        if (filtered) {
	          result.__takeCount__ = nativeMin(n, result.__takeCount__);
	        } else {
	          result.__views__.push({
	            'size': nativeMin(n, MAX_ARRAY_LENGTH),
	            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
	          });
	        }
	        return result;
	      };

	      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
	        return this.reverse()[methodName](n).reverse();
	      };
	    });

	    // Add `LazyWrapper` methods that accept an `iteratee` value.
	    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
	      var type = index + 1,
	          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;

	      LazyWrapper.prototype[methodName] = function(iteratee) {
	        var result = this.clone();
	        result.__iteratees__.push({
	          'iteratee': getIteratee(iteratee, 3),
	          'type': type
	        });
	        result.__filtered__ = result.__filtered__ || isFilter;
	        return result;
	      };
	    });

	    // Add `LazyWrapper` methods for `_.head` and `_.last`.
	    arrayEach(['head', 'last'], function(methodName, index) {
	      var takeName = 'take' + (index ? 'Right' : '');

	      LazyWrapper.prototype[methodName] = function() {
	        return this[takeName](1).value()[0];
	      };
	    });

	    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
	    arrayEach(['initial', 'tail'], function(methodName, index) {
	      var dropName = 'drop' + (index ? '' : 'Right');

	      LazyWrapper.prototype[methodName] = function() {
	        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
	      };
	    });

	    LazyWrapper.prototype.compact = function() {
	      return this.filter(identity);
	    };

	    LazyWrapper.prototype.find = function(predicate) {
	      return this.filter(predicate).head();
	    };

	    LazyWrapper.prototype.findLast = function(predicate) {
	      return this.reverse().find(predicate);
	    };

	    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
	      if (typeof path == 'function') {
	        return new LazyWrapper(this);
	      }
	      return this.map(function(value) {
	        return baseInvoke(value, path, args);
	      });
	    });

	    LazyWrapper.prototype.reject = function(predicate) {
	      return this.filter(negate(getIteratee(predicate)));
	    };

	    LazyWrapper.prototype.slice = function(start, end) {
	      start = toInteger(start);

	      var result = this;
	      if (result.__filtered__ && (start > 0 || end < 0)) {
	        return new LazyWrapper(result);
	      }
	      if (start < 0) {
	        result = result.takeRight(-start);
	      } else if (start) {
	        result = result.drop(start);
	      }
	      if (end !== undefined) {
	        end = toInteger(end);
	        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
	      }
	      return result;
	    };

	    LazyWrapper.prototype.takeRightWhile = function(predicate) {
	      return this.reverse().takeWhile(predicate).reverse();
	    };

	    LazyWrapper.prototype.toArray = function() {
	      return this.take(MAX_ARRAY_LENGTH);
	    };

	    // Add `LazyWrapper` methods to `lodash.prototype`.
	    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
	      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
	          isTaker = /^(?:head|last)$/.test(methodName),
	          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],
	          retUnwrapped = isTaker || /^find/.test(methodName);

	      if (!lodashFunc) {
	        return;
	      }
	      lodash.prototype[methodName] = function() {
	        var value = this.__wrapped__,
	            args = isTaker ? [1] : arguments,
	            isLazy = value instanceof LazyWrapper,
	            iteratee = args[0],
	            useLazy = isLazy || isArray(value);

	        var interceptor = function(value) {
	          var result = lodashFunc.apply(lodash, arrayPush([value], args));
	          return (isTaker && chainAll) ? result[0] : result;
	        };

	        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
	          // Avoid lazy use if the iteratee has a "length" value other than `1`.
	          isLazy = useLazy = false;
	        }
	        var chainAll = this.__chain__,
	            isHybrid = !!this.__actions__.length,
	            isUnwrapped = retUnwrapped && !chainAll,
	            onlyLazy = isLazy && !isHybrid;

	        if (!retUnwrapped && useLazy) {
	          value = onlyLazy ? value : new LazyWrapper(this);
	          var result = func.apply(value, args);
	          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
	          return new LodashWrapper(result, chainAll);
	        }
	        if (isUnwrapped && onlyLazy) {
	          return func.apply(this, args);
	        }
	        result = this.thru(interceptor);
	        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
	      };
	    });

	    // Add `Array` methods to `lodash.prototype`.
	    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
	      var func = arrayProto[methodName],
	          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
	          retUnwrapped = /^(?:pop|shift)$/.test(methodName);

	      lodash.prototype[methodName] = function() {
	        var args = arguments;
	        if (retUnwrapped && !this.__chain__) {
	          var value = this.value();
	          return func.apply(isArray(value) ? value : [], args);
	        }
	        return this[chainName](function(value) {
	          return func.apply(isArray(value) ? value : [], args);
	        });
	      };
	    });

	    // Map minified method names to their real names.
	    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
	      var lodashFunc = lodash[methodName];
	      if (lodashFunc) {
	        var key = (lodashFunc.name + ''),
	            names = realNames[key] || (realNames[key] = []);

	        names.push({ 'name': methodName, 'func': lodashFunc });
	      }
	    });

	    realNames[createHybrid(undefined, BIND_KEY_FLAG).name] = [{
	      'name': 'wrapper',
	      'func': undefined
	    }];

	    // Add methods to `LazyWrapper`.
	    LazyWrapper.prototype.clone = lazyClone;
	    LazyWrapper.prototype.reverse = lazyReverse;
	    LazyWrapper.prototype.value = lazyValue;

	    // Add chain sequence methods to the `lodash` wrapper.
	    lodash.prototype.at = wrapperAt;
	    lodash.prototype.chain = wrapperChain;
	    lodash.prototype.commit = wrapperCommit;
	    lodash.prototype.next = wrapperNext;
	    lodash.prototype.plant = wrapperPlant;
	    lodash.prototype.reverse = wrapperReverse;
	    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

	    // Add lazy aliases.
	    lodash.prototype.first = lodash.prototype.head;

	    if (symIterator) {
	      lodash.prototype[symIterator] = wrapperToIterator;
	    }
	    return lodash;
	  });

	  /*--------------------------------------------------------------------------*/

	  // Export lodash.
	  var _ = runInContext();

	  // Some AMD build optimizers, like r.js, check for condition patterns like:
	  if (true) {
	    // Expose Lodash on the global object to prevent errors when Lodash is
	    // loaded by a script tag in the presence of an AMD loader.
	    // See http://requirejs.org/docs/errors.html#mismatch for more details.
	    // Use `_.noConflict` to remove Lodash from the global object.
	    root._ = _;

	    // Define as an anonymous module so, through path mapping, it can be
	    // referenced as the "underscore" module.
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
	      return _;
	    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	  // Check for `exports` after `define` in case a build optimizer adds it.
	  else if (freeModule) {
	    // Export for Node.js.
	    (freeModule.exports = _)._ = _;
	    // Export for CommonJS support.
	    freeExports._ = _;
	  }
	  else {
	    // Export to the global object.
	    root._ = _;
	  }
	}.call(this));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(82)(module)))

/***/ },
/* 82 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 83 */
/***/ function(module, exports) {

	/*
	    Deprecated Decorator v0.1
	    https://github.com/vilic/deprecated-decorator
	*/
	"use strict";
	/** @internal */
	exports.options = {
	    getWarner: undefined
	};
	function createWarner(type, name, alternative, version, url) {
	    var warnedPositions = {};
	    return function () {
	        var stack = (new Error()).stack || '';
	        var at = (stack.match(/(?:\s+at\s.+){2}\s+at\s(.+)/) || [undefined, ''])[1];
	        if (/\)$/.test(at)) {
	            at = at.match(/[^(]+(?=\)$)/)[0];
	        }
	        else {
	            at = at.trim();
	        }
	        if (at in warnedPositions) {
	            return;
	        }
	        warnedPositions[at] = true;
	        var message;
	        switch (type) {
	            case 'class':
	                message = 'Class';
	                break;
	            case 'property':
	                message = 'Property';
	                break;
	            case 'method':
	                message = 'Method';
	                break;
	            case 'function':
	                message = 'Function';
	                break;
	        }
	        message += " `" + name + "` has been deprecated";
	        if (version) {
	            message += " since version " + version;
	        }
	        if (alternative) {
	            message += ", use `" + alternative + "` instead";
	        }
	        message += '.';
	        if (at) {
	            message += "\n    at " + at;
	        }
	        if (url) {
	            message += "\nCheck out " + url + " for more information.";
	        }
	        console.warn(message);
	    };
	}
	function decorateProperty(type, name, descriptor, alternative, version, url) {
	    var warner = (exports.options.getWarner || createWarner)(type, name, alternative, version, url);
	    descriptor = descriptor || {
	        writable: true,
	        enumerable: false,
	        configurable: true
	    };
	    var deprecatedDescriptor = {
	        enumerable: descriptor.enumerable,
	        configurable: descriptor.configurable
	    };
	    if (descriptor.get || descriptor.set) {
	        if (descriptor.get) {
	            deprecatedDescriptor.get = function () {
	                warner();
	                return descriptor.get.call(this);
	            };
	        }
	        if (descriptor.set) {
	            deprecatedDescriptor.set = function (value) {
	                warner();
	                return descriptor.set.call(this, value);
	            };
	        }
	    }
	    else {
	        var propertyValue_1 = descriptor.value;
	        deprecatedDescriptor.get = function () {
	            warner();
	            return propertyValue_1;
	        };
	        if (descriptor.writable) {
	            deprecatedDescriptor.set = function (value) {
	                warner();
	                propertyValue_1 = value;
	            };
	        }
	    }
	    return deprecatedDescriptor;
	}
	function decorateFunction(type, target, alternative, version, url) {
	    var name = target.name;
	    var warner = (exports.options.getWarner || createWarner)(type, name, alternative, version, url);
	    var fn = function () {
	        warner();
	        return target.apply(this, arguments);
	    };
	    for (var _i = 0, _a = Object.getOwnPropertyNames(target); _i < _a.length; _i++) {
	        var propertyName = _a[_i];
	        var descriptor = Object.getOwnPropertyDescriptor(target, propertyName);
	        if (descriptor.writable) {
	            fn[propertyName] = target[propertyName];
	        }
	        else if (descriptor.configurable) {
	            Object.defineProperty(fn, propertyName, descriptor);
	        }
	    }
	    return fn;
	}
	function deprecated() {
	    var args = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        args[_i - 0] = arguments[_i];
	    }
	    var fn = args[args.length - 1];
	    if (typeof fn === 'function') {
	        fn = args.pop();
	    }
	    else {
	        fn = undefined;
	    }
	    var options = args[0];
	    var alternative;
	    var version;
	    var url;
	    if (typeof options === 'string') {
	        alternative = options;
	        version = args[1];
	        url = args[2];
	    }
	    else if (options) {
	        (alternative = options.alternative, version = options.version, url = options.url, options);
	    }
	    if (fn) {
	        return decorateFunction('function', fn, alternative, version, url);
	    }
	    return function (target, name, descriptor) {
	        if (typeof name === 'string') {
	            var type = descriptor && typeof descriptor.value === 'function' ?
	                'method' : 'property';
	            return decorateProperty(type, name, descriptor, alternative, version, url);
	        }
	        else if (typeof target === 'function') {
	            var constructor = decorateFunction('class', target, alternative, version, url);
	            var className = target.name;
	            for (var _i = 0, _a = Object.getOwnPropertyNames(constructor); _i < _a.length; _i++) {
	                var propertyName = _a[_i];
	                var descriptor_1 = Object.getOwnPropertyDescriptor(constructor, propertyName);
	                descriptor_1 = decorateProperty('class', className, descriptor_1, alternative, version, url);
	                if (descriptor_1.writable) {
	                    constructor[propertyName] = target[propertyName];
	                }
	                else if (descriptor_1.configurable) {
	                    Object.defineProperty(constructor, propertyName, descriptor_1);
	                }
	            }
	            return constructor;
	        }
	    };
	}
	exports.deprecated = deprecated;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = deprecated;
	//# sourceMappingURL=index.js.map

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var graphql_1 = __webpack_require__(4);
	var graphql_2 = __webpack_require__(4);
	var uuid = __webpack_require__(85);
	var schemaGenerator_1 = __webpack_require__(3);
	// This function wraps addMockFunctionsToSchema for more convenience
	function mockServer(schema, mocks, preserveResolvers) {
	    if (preserveResolvers === void 0) { preserveResolvers = false; }
	    var mySchema;
	    if (!(schema instanceof graphql_1.GraphQLSchema)) {
	        // TODO: provide useful error messages here if this fails
	        mySchema = schemaGenerator_1.buildSchemaFromTypeDefinitions(schema);
	    }
	    else {
	        mySchema = schema;
	    }
	    addMockFunctionsToSchema({ schema: mySchema, mocks: mocks, preserveResolvers: preserveResolvers });
	    return { query: function (query, vars) { return graphql_2.graphql(mySchema, query, {}, {}, vars); } };
	}
	exports.mockServer = mockServer;
	// TODO allow providing a seed such that lengths of list could be deterministic
	// this could be done by using casual to get a random list length if the casual
	// object is global.
	function addMockFunctionsToSchema(_a) {
	    var schema = _a.schema, _b = _a.mocks, mocks = _b === void 0 ? {} : _b, _c = _a.preserveResolvers, preserveResolvers = _c === void 0 ? false : _c;
	    function isObject(thing) {
	        return thing === Object(thing) && !Array.isArray(thing);
	    }
	    if (!schema) {
	        // XXX should we check that schema is an instance of GraphQLSchema?
	        throw new Error('Must provide schema to mock');
	    }
	    if (!isObject(mocks)) {
	        throw new Error('mocks must be of type Object');
	    }
	    // use Map internally, because that API is nicer.
	    var mockFunctionMap = new Map();
	    Object.keys(mocks).forEach(function (typeName) {
	        mockFunctionMap.set(typeName, mocks[typeName]);
	    });
	    mockFunctionMap.forEach(function (mockFunction, mockTypeName) {
	        if (typeof mockFunction !== 'function') {
	            throw new Error("mockFunctionMap[" + mockTypeName + "] must be a function");
	        }
	    });
	    var defaultMockMap = new Map();
	    defaultMockMap.set('Int', function () { return Math.round(Math.random() * 200) - 100; });
	    defaultMockMap.set('Float', function () { return (Math.random() * 200) - 100; });
	    defaultMockMap.set('String', function () { return 'Hello World'; });
	    defaultMockMap.set('Boolean', function () { return Math.random() > 0.5; });
	    defaultMockMap.set('ID', function () { return uuid.v4(); });
	    function mergeObjects(a, b) {
	        return Object.assign(a, b);
	    }
	    function copyOwnPropsIfNotPresent(target, source) {
	        Object.getOwnPropertyNames(source).forEach(function (prop) {
	            if (!Object.getOwnPropertyDescriptor(target, prop)) {
	                Object.defineProperty(target, prop, Object.getOwnPropertyDescriptor(source, prop));
	            }
	        });
	    }
	    function copyOwnProps(target) {
	        var sources = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            sources[_i - 1] = arguments[_i];
	        }
	        sources.forEach(function (source) {
	            var chain = source;
	            while (chain) {
	                copyOwnPropsIfNotPresent(target, chain);
	                chain = Object.getPrototypeOf(chain);
	            }
	        });
	        return target;
	    }
	    // returns a random element from that ary
	    function getRandomElement(ary) {
	        var sample = Math.floor(Math.random() * ary.length);
	        return ary[sample];
	    }
	    // takes either an object or a (possibly nested) array
	    // and completes the customMock object with any fields
	    // defined on genericMock
	    // only merges objects or arrays. Scalars are returned as is
	    function mergeMocks(genericMockFunction, customMock) {
	        if (Array.isArray(customMock)) {
	            return customMock.map(function (el) { return mergeMocks(genericMockFunction, el); });
	        }
	        if (isObject(customMock)) {
	            return mergeObjects(genericMockFunction(), customMock);
	        }
	        return customMock;
	    }
	    function getResolveType(namedFieldType) {
	        if ((namedFieldType instanceof graphql_1.GraphQLInterfaceType) ||
	            (namedFieldType instanceof graphql_1.GraphQLUnionType)) {
	            return namedFieldType.resolveType;
	        }
	        else {
	            return undefined;
	        }
	    }
	    function assignResolveType(type) {
	        var fieldType = graphql_1.getNullableType(type);
	        var namedFieldType = graphql_1.getNamedType(fieldType);
	        var oldResolveType = getResolveType(namedFieldType);
	        if (preserveResolvers && oldResolveType && oldResolveType.length) {
	            return;
	        }
	        if (namedFieldType instanceof graphql_1.GraphQLUnionType ||
	            namedFieldType instanceof graphql_1.GraphQLInterfaceType) {
	            // the default `resolveType` always returns null. We add a fallback
	            // resolution that works with how unions and interface are mocked
	            namedFieldType.resolveType = function (data, context, info) {
	                return info.schema.getType(data.typename);
	            };
	        }
	    }
	    var mockType = function mockType(type, typeName, fieldName) {
	        // order of precendence for mocking:
	        // 1. if the object passed in already has fieldName, just use that
	        // --> if it's a function, that becomes your resolver
	        // --> if it's a value, the mock resolver will return that
	        // 2. if the nullableType is a list, recurse
	        // 2. if there's a mock defined for this typeName, that will be used
	        // 3. if there's no mock defined, use the default mocks for this type
	        return function (root, args, context, info) {
	            // nullability doesn't matter for the purpose of mocking.
	            var fieldType = graphql_1.getNullableType(type);
	            var namedFieldType = graphql_1.getNamedType(fieldType);
	            if (root && typeof root[fieldName] !== 'undefined') {
	                var result = void 0;
	                // if we're here, the field is already defined
	                if (typeof root[fieldName] === 'function') {
	                    result = root[fieldName](root, args, context, info);
	                    if (result instanceof MockList) {
	                        result = result.mock(root, args, context, info, fieldType, mockType);
	                    }
	                }
	                else {
	                    result = root[fieldName];
	                }
	                // Now we merge the result with the default mock for this type.
	                // This allows overriding defaults while writing very little code.
	                if (mockFunctionMap.has(namedFieldType.name)) {
	                    result = mergeMocks(mockFunctionMap.get(namedFieldType.name).bind(null, root, args, context, info), result);
	                }
	                return result;
	            }
	            if (fieldType instanceof graphql_1.GraphQLList) {
	                return [mockType(fieldType.ofType)(root, args, context, info),
	                    mockType(fieldType.ofType)(root, args, context, info)];
	            }
	            if (mockFunctionMap.has(fieldType.name)) {
	                // the object passed doesn't have this field, so we apply the default mock
	                return mockFunctionMap.get(fieldType.name)(root, args, context, info);
	            }
	            if (fieldType instanceof graphql_1.GraphQLObjectType) {
	                // objects don't return actual data, we only need to mock scalars!
	                return {};
	            }
	            // TODO mocking Interface and Union types will require determining the
	            // resolve type before passing it on.
	            // XXX we recommend a generic way for resolve type here, which is defining
	            // typename on the object.
	            if (fieldType instanceof graphql_1.GraphQLUnionType) {
	                var randomType = getRandomElement(fieldType.getTypes());
	                return Object.assign({ typename: randomType }, mockType(randomType)(root, args, context, info));
	            }
	            if (fieldType instanceof graphql_1.GraphQLInterfaceType) {
	                var possibleTypes = schema.getPossibleTypes(fieldType);
	                var randomType = getRandomElement(possibleTypes);
	                return Object.assign({ typename: randomType }, mockType(randomType)(root, args, context, info));
	            }
	            if (fieldType instanceof graphql_1.GraphQLEnumType) {
	                return getRandomElement(fieldType.getValues()).value;
	            }
	            if (defaultMockMap.has(fieldType.name)) {
	                return defaultMockMap.get(fieldType.name)(root, args, context, info);
	            }
	            // if we get to here, we don't have a value, and we don't have a mock for this type,
	            // we could return undefined, but that would be hard to debug, so we throw instead.
	            // however, we returning it instead of throwing it, so preserveResolvers can handle the failures.
	            return Error("No mock defined for type \"" + fieldType.name + "\"");
	        };
	    };
	    schemaGenerator_1.forEachField(schema, function (field, typeName, fieldName) {
	        assignResolveType(field.type);
	        var mockResolver;
	        // we have to handle the root mutation and root query types differently,
	        // because no resolver is called at the root.
	        /* istanbul ignore next: Must provide schema definition with query type or a type named Query. */
	        var isOnQueryType = schema.getQueryType() ? (schema.getQueryType().name === typeName) : false;
	        var isOnMutationType = schema.getMutationType() ? (schema.getMutationType().name === typeName) : false;
	        if (isOnQueryType || isOnMutationType) {
	            if (mockFunctionMap.has(typeName)) {
	                var rootMock_1 = mockFunctionMap.get(typeName);
	                // XXX: BUG in here, need to provide proper signature for rootMock.
	                if (rootMock_1(undefined, {}, {}, {})[fieldName]) {
	                    // TODO: assert that it's a function
	                    mockResolver = function (root, args, context, info) {
	                        var updatedRoot = root || {}; // TODO: should we clone instead?
	                        updatedRoot[fieldName] = rootMock_1(root, args, context, info)[fieldName];
	                        // XXX this is a bit of a hack to still use mockType, which
	                        // lets you mock lists etc. as well
	                        // otherwise we could just set field.resolve to rootMock()[fieldName]
	                        // it's like pretending there was a resolve function that ran before
	                        // the root resolve function.
	                        return mockType(field.type, typeName, fieldName)(updatedRoot, args, context, info);
	                    };
	                }
	            }
	        }
	        if (!mockResolver) {
	            mockResolver = mockType(field.type, typeName, fieldName);
	        }
	        if (!preserveResolvers || !field.resolve) {
	            field.resolve = mockResolver;
	        }
	        else {
	            var oldResolver_1 = field.resolve;
	            field.resolve = function (rootObject, args, context, info) { return Promise.all([
	                mockResolver(rootObject, args, context, info),
	                oldResolver_1(rootObject, args, context, info),
	            ]).then(function (values) {
	                var mockedValue = values[0], resolvedValue = values[1];
	                // In case we couldn't mock
	                if (mockedValue instanceof Error) {
	                    // only if value was not resolved, populate the error.
	                    if (undefined === resolvedValue) {
	                        throw mockedValue;
	                    }
	                    return resolvedValue;
	                }
	                if (isObject(mockedValue) && isObject(resolvedValue)) {
	                    // Object.assign() won't do here, as we need to all properties, including
	                    // the non-enumerable ones and defined using Object.defineProperty
	                    return copyOwnProps({}, resolvedValue, mockedValue);
	                }
	                return (undefined !== resolvedValue) ? resolvedValue : mockedValue;
	            }); };
	        }
	    });
	}
	exports.addMockFunctionsToSchema = addMockFunctionsToSchema;
	var MockList = (function () {
	    // wrappedFunction can return another MockList or a value
	    function MockList(len, wrappedFunction) {
	        this.len = len;
	        if (typeof wrappedFunction !== 'undefined') {
	            if (typeof wrappedFunction !== 'function') {
	                throw new Error('Second argument to MockList must be a function or undefined');
	            }
	            this.wrappedFunction = wrappedFunction;
	        }
	    }
	    MockList.prototype.mock = function (root, args, context, info, fieldType, mockTypeFunc) {
	        var arr;
	        if (Array.isArray(this.len)) {
	            arr = new Array(this.randint(this.len[0], this.len[1]));
	        }
	        else {
	            arr = new Array(this.len);
	        }
	        for (var i = 0; i < arr.length; i++) {
	            if (typeof this.wrappedFunction === 'function') {
	                var res = this.wrappedFunction(root, args, context, info);
	                if (res instanceof MockList) {
	                    var nullableType = graphql_1.getNullableType(fieldType.ofType);
	                    arr[i] = res.mock(root, args, context, info, nullableType, mockTypeFunc);
	                }
	                else {
	                    arr[i] = res;
	                }
	            }
	            else {
	                arr[i] = mockTypeFunc(fieldType.ofType)(root, args, context, info);
	            }
	        }
	        return arr;
	    };
	    MockList.prototype.randint = function (low, high) {
	        return Math.floor((Math.random() * ((high - low) + 1)) + low);
	    };
	    return MockList;
	}());
	exports.MockList = MockList;
	//# sourceMappingURL=mock.js.map

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;//     uuid.js
	//
	//     Copyright (c) 2010-2012 Robert Kieffer
	//     MIT License - http://opensource.org/licenses/mit-license.php

	/*global window, require, define */
	(function(_window) {
	  'use strict';

	  // Unique ID creation requires a high quality random # generator.  We feature
	  // detect to determine the best RNG source, normalizing to a function that
	  // returns 128-bits of randomness, since that's what's usually required
	  var _rng, _mathRNG, _nodeRNG, _whatwgRNG, _previousRoot;

	  function setupBrowser() {
	    // Allow for MSIE11 msCrypto
	    var _crypto = _window.crypto || _window.msCrypto;

	    if (!_rng && _crypto && _crypto.getRandomValues) {
	      // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto
	      //
	      // Moderately fast, high quality
	      try {
	        var _rnds8 = new Uint8Array(16);
	        _whatwgRNG = _rng = function whatwgRNG() {
	          _crypto.getRandomValues(_rnds8);
	          return _rnds8;
	        };
	        _rng();
	      } catch(e) {}
	    }

	    if (!_rng) {
	      // Math.random()-based (RNG)
	      //
	      // If all else fails, use Math.random().  It's fast, but is of unspecified
	      // quality.
	      var  _rnds = new Array(16);
	      _mathRNG = _rng = function() {
	        for (var i = 0, r; i < 16; i++) {
	          if ((i & 0x03) === 0) { r = Math.random() * 0x100000000; }
	          _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
	        }

	        return _rnds;
	      };
	      if ('undefined' !== typeof console && console.warn) {
	        console.warn("[SECURITY] node-uuid: crypto not usable, falling back to insecure Math.random()");
	      }
	    }
	  }

	  function setupNode() {
	    // Node.js crypto-based RNG - http://nodejs.org/docs/v0.6.2/api/crypto.html
	    //
	    // Moderately fast, high quality
	    if (true) {
	      try {
	        var _rb = __webpack_require__(86).randomBytes;
	        _nodeRNG = _rng = _rb && function() {return _rb(16);};
	        _rng();
	      } catch(e) {}
	    }
	  }

	  if (_window) {
	    setupBrowser();
	  } else {
	    setupNode();
	  }

	  // Buffer class to use
	  var BufferClass = ('function' === typeof Buffer) ? Buffer : Array;

	  // Maps for number <-> hex string conversion
	  var _byteToHex = [];
	  var _hexToByte = {};
	  for (var i = 0; i < 256; i++) {
	    _byteToHex[i] = (i + 0x100).toString(16).substr(1);
	    _hexToByte[_byteToHex[i]] = i;
	  }

	  // **`parse()` - Parse a UUID into it's component bytes**
	  function parse(s, buf, offset) {
	    var i = (buf && offset) || 0, ii = 0;

	    buf = buf || [];
	    s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {
	      if (ii < 16) { // Don't overflow!
	        buf[i + ii++] = _hexToByte[oct];
	      }
	    });

	    // Zero out remaining bytes if string was short
	    while (ii < 16) {
	      buf[i + ii++] = 0;
	    }

	    return buf;
	  }

	  // **`unparse()` - Convert UUID byte array (ala parse()) into a string**
	  function unparse(buf, offset) {
	    var i = offset || 0, bth = _byteToHex;
	    return  bth[buf[i++]] + bth[buf[i++]] +
	            bth[buf[i++]] + bth[buf[i++]] + '-' +
	            bth[buf[i++]] + bth[buf[i++]] + '-' +
	            bth[buf[i++]] + bth[buf[i++]] + '-' +
	            bth[buf[i++]] + bth[buf[i++]] + '-' +
	            bth[buf[i++]] + bth[buf[i++]] +
	            bth[buf[i++]] + bth[buf[i++]] +
	            bth[buf[i++]] + bth[buf[i++]];
	  }

	  // **`v1()` - Generate time-based UUID**
	  //
	  // Inspired by https://github.com/LiosK/UUID.js
	  // and http://docs.python.org/library/uuid.html

	  // random #'s we need to init node and clockseq
	  var _seedBytes = _rng();

	  // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
	  var _nodeId = [
	    _seedBytes[0] | 0x01,
	    _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]
	  ];

	  // Per 4.2.2, randomize (14 bit) clockseq
	  var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;

	  // Previous uuid creation time
	  var _lastMSecs = 0, _lastNSecs = 0;

	  // See https://github.com/broofa/node-uuid for API details
	  function v1(options, buf, offset) {
	    var i = buf && offset || 0;
	    var b = buf || [];

	    options = options || {};

	    var clockseq = (options.clockseq != null) ? options.clockseq : _clockseq;

	    // UUID timestamps are 100 nano-second units since the Gregorian epoch,
	    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
	    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
	    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
	    var msecs = (options.msecs != null) ? options.msecs : new Date().getTime();

	    // Per 4.2.1.2, use count of uuid's generated during the current clock
	    // cycle to simulate higher resolution clock
	    var nsecs = (options.nsecs != null) ? options.nsecs : _lastNSecs + 1;

	    // Time since last uuid creation (in msecs)
	    var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

	    // Per 4.2.1.2, Bump clockseq on clock regression
	    if (dt < 0 && options.clockseq == null) {
	      clockseq = clockseq + 1 & 0x3fff;
	    }

	    // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
	    // time interval
	    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs == null) {
	      nsecs = 0;
	    }

	    // Per 4.2.1.2 Throw error if too many uuids are requested
	    if (nsecs >= 10000) {
	      throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
	    }

	    _lastMSecs = msecs;
	    _lastNSecs = nsecs;
	    _clockseq = clockseq;

	    // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
	    msecs += 12219292800000;

	    // `time_low`
	    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
	    b[i++] = tl >>> 24 & 0xff;
	    b[i++] = tl >>> 16 & 0xff;
	    b[i++] = tl >>> 8 & 0xff;
	    b[i++] = tl & 0xff;

	    // `time_mid`
	    var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
	    b[i++] = tmh >>> 8 & 0xff;
	    b[i++] = tmh & 0xff;

	    // `time_high_and_version`
	    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
	    b[i++] = tmh >>> 16 & 0xff;

	    // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
	    b[i++] = clockseq >>> 8 | 0x80;

	    // `clock_seq_low`
	    b[i++] = clockseq & 0xff;

	    // `node`
	    var node = options.node || _nodeId;
	    for (var n = 0; n < 6; n++) {
	      b[i + n] = node[n];
	    }

	    return buf ? buf : unparse(b);
	  }

	  // **`v4()` - Generate random UUID**

	  // See https://github.com/broofa/node-uuid for API details
	  function v4(options, buf, offset) {
	    // Deprecated - 'format' argument, as supported in v1.2
	    var i = buf && offset || 0;

	    if (typeof(options) === 'string') {
	      buf = (options === 'binary') ? new BufferClass(16) : null;
	      options = null;
	    }
	    options = options || {};

	    var rnds = options.random || (options.rng || _rng)();

	    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
	    rnds[6] = (rnds[6] & 0x0f) | 0x40;
	    rnds[8] = (rnds[8] & 0x3f) | 0x80;

	    // Copy bytes to buffer, if provided
	    if (buf) {
	      for (var ii = 0; ii < 16; ii++) {
	        buf[i + ii] = rnds[ii];
	      }
	    }

	    return buf || unparse(rnds);
	  }

	  // Export public API
	  var uuid = v4;
	  uuid.v1 = v1;
	  uuid.v4 = v4;
	  uuid.parse = parse;
	  uuid.unparse = unparse;
	  uuid.BufferClass = BufferClass;
	  uuid._rng = _rng;
	  uuid._mathRNG = _mathRNG;
	  uuid._nodeRNG = _nodeRNG;
	  uuid._whatwgRNG = _whatwgRNG;

	  if (('undefined' !== typeof module) && module.exports) {
	    // Publish as node.js module
	    module.exports = uuid;
	  } else if (true) {
	    // Publish as AMD module
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {return uuid;}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


	  } else {
	    // Publish as global (in browsers)
	    _previousRoot = _window.uuid;

	    // **`noConflict()` - (browser only) to reset global 'uuid' var**
	    uuid.noConflict = function() {
	      _window.uuid = _previousRoot;
	      return uuid;
	    };

	    _window.uuid = uuid;
	  }
	})('undefined' !== typeof window ? window : null);


/***/ },
/* 86 */
/***/ function(module, exports) {

	module.exports = require("crypto");

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var schemaGenerator_1 = __webpack_require__(3);
	function autopublishMutationResults(schema, pubsub) {
	    // decorate the mutations with your thingy
	    var mutationFields = schema.getMutationType().getFields();
	    Object.keys(mutationFields).forEach(function (fieldName) {
	        var field = mutationFields[fieldName];
	        // define the function
	        var publishMutatedValue = function (source, args, ctx, info) {
	            pubsub.publish(fieldName, source);
	            return source;
	        };
	        field.resolve = schemaGenerator_1.chainResolvers([field.resolve, publishMutatedValue]);
	    });
	}
	exports.autopublishMutationResults = autopublishMutationResults;
	//# sourceMappingURL=autopublish.js.map

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _dynamodbConnector = __webpack_require__(89);

	var resolvers = {
	  RootQuery: {
	    players: function players() {
	      return (0, _dynamodbConnector.getAllPlayers)('FandualWeekNine').then(function (players) {
	        return players;
	      }).catch(function (err) {
	        throw err;
	      });
	    }
	  }
	};

	exports.default = resolvers;

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _awsSdk = __webpack_require__(90);

	var _awsSdk2 = _interopRequireDefault(_awsSdk);

	var _underscore = __webpack_require__(486);

	var _underscore2 = _interopRequireDefault(_underscore);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Get and item from a dynamoDB instance
	 * @param {string} tableName The name of the table to scan
	 **/

	module.exports.getAllPlayers = function (tableName) {

	  _awsSdk2.default.config.update({
	    region: "us-west-2"
	  });

	  // create a new ddb
	  var dynamodb = new _awsSdk2.default.DynamoDB();

	  // construct the params for the get request
	  var params = {
	    "TableName": tableName
	  };

	  // make the getItem call
	  return new Promise(function (resolve, reject) {
	    dynamodb.scan(params, function (err, data) {
	      if (err) reject(err);
	      var players = [];
	      data.Items.forEach(function (item) {
	        players.push(_underscore2.default.mapObject(item, function (val, key) {
	          var value = _underscore2.default.values(val);
	          var newItem = item[key] = value[0];
	          return newItem;
	        }));
	      });
	      resolve(players);
	    });
	  });
	};

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);

	var AWS = __webpack_require__(93);

	// Load all service classes
	__webpack_require__(233);
	module.exports = AWS;


/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	var util = __webpack_require__(92);

	// node.js specific modules
	util.crypto.lib = __webpack_require__(86);
	util.Buffer = __webpack_require__(210).Buffer;
	util.domain = __webpack_require__(211);
	util.stream = __webpack_require__(212);
	util.url = __webpack_require__(213);
	util.querystring = __webpack_require__(214);

	var AWS = __webpack_require__(93);

	// Use default API loader function
	__webpack_require__(181);

	// Load the xml2js XML parser
	AWS.XML.Parser = __webpack_require__(215);

	// Load Node HTTP client
	__webpack_require__(223);

	// Load custom credential providers
	__webpack_require__(226);
	__webpack_require__(228);
	__webpack_require__(229);
	__webpack_require__(230);
	__webpack_require__(231);

	// Setup default chain providers
	// If this changes, please update documentation for
	// AWS.CredentialProviderChain.defaultProviders in
	// credentials/credential_provider_chain.js
	AWS.CredentialProviderChain.defaultProviders = [
	  function () { return new AWS.EnvironmentCredentials('AWS'); },
	  function () { return new AWS.EnvironmentCredentials('AMAZON'); },
	  function () { return new AWS.SharedIniFileCredentials(); },
	  function () {
	    if (AWS.ECSCredentials.prototype.getECSRelativeUri() !== undefined) {
	      return new AWS.ECSCredentials();
	    }
	    return new AWS.EC2MetadataCredentials();
	  }
	];

	// Update configuration keys
	AWS.util.update(AWS.Config.prototype.keys, {
	  credentials: function () {
	    var credentials = null;
	    new AWS.CredentialProviderChain([
	      function () { return new AWS.EnvironmentCredentials('AWS'); },
	      function () { return new AWS.EnvironmentCredentials('AMAZON'); },
	      function () { return new AWS.SharedIniFileCredentials({ disableAssumeRole: true }); }
	    ]).resolve(function(err, creds) {
	      if (!err) credentials = creds;
	    });
	    return credentials;
	  },
	  credentialProvider: function() {
	    return new AWS.CredentialProviderChain();
	  },
	  region: function() {
	    return process.env.AWS_REGION || process.env.AMAZON_REGION;
	  }
	});

	// Reset configuration
	AWS.config = new AWS.Config();


/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	/* eslint guard-for-in:0 */
	var AWS;

	/**
	 * A set of utility methods for use with the AWS SDK.
	 *
	 * @!attribute abort
	 *   Return this value from an iterator function {each} or {arrayEach}
	 *   to break out of the iteration.
	 *   @example Breaking out of an iterator function
	 *     AWS.util.each({a: 1, b: 2, c: 3}, function(key, value) {
	 *       if (key == 'b') return AWS.util.abort;
	 *     });
	 *   @see each
	 *   @see arrayEach
	 * @api private
	 */
	var util = {
	  engine: function engine() {
	    if (util.isBrowser() && typeof navigator !== 'undefined') {
	      return navigator.userAgent;
	    } else {
	      return process.platform + '/' + process.version;
	    }
	  },

	  userAgent: function userAgent() {
	    var name = util.isBrowser() ? 'js' : 'nodejs';
	    var agent = 'aws-sdk-' + name + '/' + __webpack_require__(93).VERSION;
	    if (name === 'nodejs') agent += ' ' + util.engine();
	    return agent;
	  },

	  isBrowser: function isBrowser() { return process && process.browser; },
	  isNode: function isNode() { return !util.isBrowser(); },
	  uriEscape: function uriEscape(string) {
	    var output = encodeURIComponent(string);
	    output = output.replace(/[^A-Za-z0-9_.~\-%]+/g, escape);

	    // AWS percent-encodes some extra non-standard characters in a URI
	    output = output.replace(/[*]/g, function(ch) {
	      return '%' + ch.charCodeAt(0).toString(16).toUpperCase();
	    });

	    return output;
	  },

	  uriEscapePath: function uriEscapePath(string) {
	    var parts = [];
	    util.arrayEach(string.split('/'), function (part) {
	      parts.push(util.uriEscape(part));
	    });
	    return parts.join('/');
	  },

	  urlParse: function urlParse(url) {
	    return util.url.parse(url);
	  },

	  urlFormat: function urlFormat(url) {
	    return util.url.format(url);
	  },

	  queryStringParse: function queryStringParse(qs) {
	    return util.querystring.parse(qs);
	  },

	  queryParamsToString: function queryParamsToString(params) {
	    var items = [];
	    var escape = util.uriEscape;
	    var sortedKeys = Object.keys(params).sort();

	    util.arrayEach(sortedKeys, function(name) {
	      var value = params[name];
	      var ename = escape(name);
	      var result = ename + '=';
	      if (Array.isArray(value)) {
	        var vals = [];
	        util.arrayEach(value, function(item) { vals.push(escape(item)); });
	        result = ename + '=' + vals.sort().join('&' + ename + '=');
	      } else if (value !== undefined && value !== null) {
	        result = ename + '=' + escape(value);
	      }
	      items.push(result);
	    });

	    return items.join('&');
	  },

	  readFileSync: function readFileSync(path) {
	    if (util.isBrowser()) return null;
	    return __webpack_require__(208).readFileSync(path, 'utf-8');
	  },

	  base64: {

	    encode: function encode64(string) {
	      return new util.Buffer(string).toString('base64');
	    },

	    decode: function decode64(string) {
	      return new util.Buffer(string, 'base64');
	    }

	  },

	  buffer: {
	    toStream: function toStream(buffer) {
	      if (!util.Buffer.isBuffer(buffer)) buffer = new util.Buffer(buffer);

	      var readable = new (util.stream.Readable)();
	      var pos = 0;
	      readable._read = function(size) {
	        if (pos >= buffer.length) return readable.push(null);

	        var end = pos + size;
	        if (end > buffer.length) end = buffer.length;
	        readable.push(buffer.slice(pos, end));
	        pos = end;
	      };

	      return readable;
	    },

	    /**
	     * Concatenates a list of Buffer objects.
	     */
	    concat: function(buffers) {
	      var length = 0,
	          offset = 0,
	          buffer = null, i;

	      for (i = 0; i < buffers.length; i++) {
	        length += buffers[i].length;
	      }

	      buffer = new util.Buffer(length);

	      for (i = 0; i < buffers.length; i++) {
	        buffers[i].copy(buffer, offset);
	        offset += buffers[i].length;
	      }

	      return buffer;
	    }
	  },

	  string: {
	    byteLength: function byteLength(string) {
	      if (string === null || string === undefined) return 0;
	      if (typeof string === 'string') string = new util.Buffer(string);

	      if (typeof string.byteLength === 'number') {
	        return string.byteLength;
	      } else if (typeof string.length === 'number') {
	        return string.length;
	      } else if (typeof string.size === 'number') {
	        return string.size;
	      } else if (typeof string.path === 'string') {
	        return __webpack_require__(208).lstatSync(string.path).size;
	      } else {
	        throw util.error(new Error('Cannot determine length of ' + string),
	          { object: string });
	      }
	    },

	    upperFirst: function upperFirst(string) {
	      return string[0].toUpperCase() + string.substr(1);
	    },

	    lowerFirst: function lowerFirst(string) {
	      return string[0].toLowerCase() + string.substr(1);
	    }
	  },

	  ini: {
	    parse: function string(ini) {
	      var currentSection, map = {};
	      util.arrayEach(ini.split(/\r?\n/), function(line) {
	        line = line.split(/(^|\s)[;#]/)[0]; // remove comments
	        var section = line.match(/^\s*\[([^\[\]]+)\]\s*$/);
	        if (section) {
	          currentSection = section[1];
	        } else if (currentSection) {
	          var item = line.match(/^\s*(.+?)\s*=\s*(.+?)\s*$/);
	          if (item) {
	            map[currentSection] = map[currentSection] || {};
	            map[currentSection][item[1]] = item[2];
	          }
	        }
	      });

	      return map;
	    }
	  },

	  fn: {
	    noop: function() {},

	    /**
	     * Turn a synchronous function into as "async" function by making it call
	     * a callback. The underlying function is called with all but the last argument,
	     * which is treated as the callback. The callback is passed passed a first argument
	     * of null on success to mimick standard node callbacks.
	     */
	    makeAsync: function makeAsync(fn, expectedArgs) {
	      if (expectedArgs && expectedArgs <= fn.length) {
	        return fn;
	      }

	      return function() {
	        var args = Array.prototype.slice.call(arguments, 0);
	        var callback = args.pop();
	        var result = fn.apply(null, args);
	        callback(result);
	      };
	    }
	  },

	  /**
	   * Date and time utility functions.
	   */
	  date: {

	    /**
	     * @return [Date] the current JavaScript date object. Since all
	     *   AWS services rely on this date object, you can override
	     *   this function to provide a special time value to AWS service
	     *   requests.
	     */
	    getDate: function getDate() {
	      if (!AWS) AWS = __webpack_require__(93);
	      if (AWS.config.systemClockOffset) { // use offset when non-zero
	        return new Date(new Date().getTime() + AWS.config.systemClockOffset);
	      } else {
	        return new Date();
	      }
	    },

	    /**
	     * @return [String] the date in ISO-8601 format
	     */
	    iso8601: function iso8601(date) {
	      if (date === undefined) { date = util.date.getDate(); }
	      return date.toISOString().replace(/\.\d{3}Z$/, 'Z');
	    },

	    /**
	     * @return [String] the date in RFC 822 format
	     */
	    rfc822: function rfc822(date) {
	      if (date === undefined) { date = util.date.getDate(); }
	      return date.toUTCString();
	    },

	    /**
	     * @return [Integer] the UNIX timestamp value for the current time
	     */
	    unixTimestamp: function unixTimestamp(date) {
	      if (date === undefined) { date = util.date.getDate(); }
	      return date.getTime() / 1000;
	    },

	    /**
	     * @param [String,number,Date] date
	     * @return [Date]
	     */
	    from: function format(date) {
	      if (typeof date === 'number') {
	        return new Date(date * 1000); // unix timestamp
	      } else {
	        return new Date(date);
	      }
	    },

	    /**
	     * Given a Date or date-like value, this function formats the
	     * date into a string of the requested value.
	     * @param [String,number,Date] date
	     * @param [String] formatter Valid formats are:
	     #   * 'iso8601'
	     #   * 'rfc822'
	     #   * 'unixTimestamp'
	     * @return [String]
	     */
	    format: function format(date, formatter) {
	      if (!formatter) formatter = 'iso8601';
	      return util.date[formatter](util.date.from(date));
	    },

	    parseTimestamp: function parseTimestamp(value) {
	      if (typeof value === 'number') { // unix timestamp (number)
	        return new Date(value * 1000);
	      } else if (value.match(/^\d+$/)) { // unix timestamp
	        return new Date(value * 1000);
	      } else if (value.match(/^\d{4}/)) { // iso8601
	        return new Date(value);
	      } else if (value.match(/^\w{3},/)) { // rfc822
	        return new Date(value);
	      } else {
	        throw util.error(
	          new Error('unhandled timestamp format: ' + value),
	          {code: 'TimestampParserError'});
	      }
	    }

	  },

	  crypto: {
	    crc32Table: [
	     0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419,
	     0x706AF48F, 0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4,
	     0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07,
	     0x90BF1D91, 0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE,
	     0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7, 0x136C9856,
	     0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9,
	     0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4,
	     0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,
	     0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3,
	     0x45DF5C75, 0xDCD60DCF, 0xABD13D59, 0x26D930AC, 0x51DE003A,
	     0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599,
	     0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
	     0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190,
	     0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F,
	     0x9FBFE4A5, 0xE8B8D433, 0x7807C9A2, 0x0F00F934, 0x9609A88E,
	     0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,
	     0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED,
	     0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950,
	     0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3,
	     0xFBD44C65, 0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2,
	     0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A,
	     0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5,
	     0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA, 0xBE0B1010,
	     0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
	     0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17,
	     0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6,
	     0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615,
	     0x73DC1683, 0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8,
	     0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1, 0xF00F9344,
	     0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB,
	     0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A,
	     0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,
	     0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1,
	     0xA6BC5767, 0x3FB506DD, 0x48B2364B, 0xD80D2BDA, 0xAF0A1B4C,
	     0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF,
	     0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
	     0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE,
	     0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31,
	     0x2CD99E8B, 0x5BDEAE1D, 0x9B64C2B0, 0xEC63F226, 0x756AA39C,
	     0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,
	     0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B,
	     0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242,
	     0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1,
	     0x18B74777, 0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C,
	     0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45, 0xA00AE278,
	     0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7,
	     0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC, 0x40DF0B66,
	     0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
	     0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605,
	     0xCDD70693, 0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8,
	     0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B,
	     0x2D02EF8D],

	    crc32: function crc32(data) {
	      var tbl = util.crypto.crc32Table;
	      var crc = 0 ^ -1;

	      if (typeof data === 'string') {
	        data = new util.Buffer(data);
	      }

	      for (var i = 0; i < data.length; i++) {
	        var code = data.readUInt8(i);
	        crc = (crc >>> 8) ^ tbl[(crc ^ code) & 0xFF];
	      }
	      return (crc ^ -1) >>> 0;
	    },

	    hmac: function hmac(key, string, digest, fn) {
	      if (!digest) digest = 'binary';
	      if (digest === 'buffer') { digest = undefined; }
	      if (!fn) fn = 'sha256';
	      if (typeof string === 'string') string = new util.Buffer(string);
	      return util.crypto.lib.createHmac(fn, key).update(string).digest(digest);
	    },

	    md5: function md5(data, digest, callback) {
	      return util.crypto.hash('md5', data, digest, callback);
	    },

	    sha256: function sha256(data, digest, callback) {
	      return util.crypto.hash('sha256', data, digest, callback);
	    },

	    hash: function(algorithm, data, digest, callback) {
	      var hash = util.crypto.createHash(algorithm);
	      if (!digest) { digest = 'binary'; }
	      if (digest === 'buffer') { digest = undefined; }
	      if (typeof data === 'string') data = new util.Buffer(data);
	      var sliceFn = util.arraySliceFn(data);
	      var isBuffer = util.Buffer.isBuffer(data);
	      //Identifying objects with an ArrayBuffer as buffers
	      if (util.isBrowser() && typeof ArrayBuffer !== 'undefined' && data && data.buffer instanceof ArrayBuffer) isBuffer = true;

	      if (callback && typeof data === 'object' &&
	          typeof data.on === 'function' && !isBuffer) {
	        data.on('data', function(chunk) { hash.update(chunk); });
	        data.on('error', function(err) { callback(err); });
	        data.on('end', function() { callback(null, hash.digest(digest)); });
	      } else if (callback && sliceFn && !isBuffer &&
	                 typeof FileReader !== 'undefined') {
	        // this might be a File/Blob
	        var index = 0, size = 1024 * 512;
	        var reader = new FileReader();
	        reader.onerror = function() {
	          callback(new Error('Failed to read data.'));
	        };
	        reader.onload = function() {
	          var buf = new util.Buffer(new Uint8Array(reader.result));
	          hash.update(buf);
	          index += buf.length;
	          reader._continueReading();
	        };
	        reader._continueReading = function() {
	          if (index >= data.size) {
	            callback(null, hash.digest(digest));
	            return;
	          }

	          var back = index + size;
	          if (back > data.size) back = data.size;
	          reader.readAsArrayBuffer(sliceFn.call(data, index, back));
	        };

	        reader._continueReading();
	      } else {
	        if (util.isBrowser() && typeof data === 'object' && !isBuffer) {
	          data = new util.Buffer(new Uint8Array(data));
	        }
	        var out = hash.update(data).digest(digest);
	        if (callback) callback(null, out);
	        return out;
	      }
	    },

	    toHex: function toHex(data) {
	      var out = [];
	      for (var i = 0; i < data.length; i++) {
	        out.push(('0' + data.charCodeAt(i).toString(16)).substr(-2, 2));
	      }
	      return out.join('');
	    },

	    createHash: function createHash(algorithm) {
	      return util.crypto.lib.createHash(algorithm);
	    }

	  },

	  /** @!ignore */

	  /* Abort constant */
	  abort: {},

	  each: function each(object, iterFunction) {
	    for (var key in object) {
	      if (Object.prototype.hasOwnProperty.call(object, key)) {
	        var ret = iterFunction.call(this, key, object[key]);
	        if (ret === util.abort) break;
	      }
	    }
	  },

	  arrayEach: function arrayEach(array, iterFunction) {
	    for (var idx in array) {
	      if (Object.prototype.hasOwnProperty.call(array, idx)) {
	        var ret = iterFunction.call(this, array[idx], parseInt(idx, 10));
	        if (ret === util.abort) break;
	      }
	    }
	  },

	  update: function update(obj1, obj2) {
	    util.each(obj2, function iterator(key, item) {
	      obj1[key] = item;
	    });
	    return obj1;
	  },

	  merge: function merge(obj1, obj2) {
	    return util.update(util.copy(obj1), obj2);
	  },

	  copy: function copy(object) {
	    if (object === null || object === undefined) return object;
	    var dupe = {};
	    // jshint forin:false
	    for (var key in object) {
	      dupe[key] = object[key];
	    }
	    return dupe;
	  },

	  isEmpty: function isEmpty(obj) {
	    for (var prop in obj) {
	      if (Object.prototype.hasOwnProperty.call(obj, prop)) {
	        return false;
	      }
	    }
	    return true;
	  },

	  arraySliceFn: function arraySliceFn(obj) {
	    var fn = obj.slice || obj.webkitSlice || obj.mozSlice;
	    return typeof fn === 'function' ? fn : null;
	  },

	  isType: function isType(obj, type) {
	    // handle cross-"frame" objects
	    if (typeof type === 'function') type = util.typeName(type);
	    return Object.prototype.toString.call(obj) === '[object ' + type + ']';
	  },

	  typeName: function typeName(type) {
	    if (Object.prototype.hasOwnProperty.call(type, 'name')) return type.name;
	    var str = type.toString();
	    var match = str.match(/^\s*function (.+)\(/);
	    return match ? match[1] : str;
	  },

	  error: function error(err, options) {
	    var originalError = null;
	    if (typeof err.message === 'string' && err.message !== '') {
	      if (typeof options === 'string' || (options && options.message)) {
	        originalError = util.copy(err);
	        originalError.message = err.message;
	      }
	    }
	    err.message = err.message || null;

	    if (typeof options === 'string') {
	      err.message = options;
	    } else if (typeof options === 'object' && options !== null) {
	      util.update(err, options);
	      if (options.message)
	        err.message = options.message;
	      if (options.code || options.name)
	        err.code = options.code || options.name;
	      if (options.stack)
	        err.stack = options.stack;
	    }

	    if (typeof Object.defineProperty === 'function') {
	      Object.defineProperty(err, 'name', {writable: true, enumerable: false});
	      Object.defineProperty(err, 'message', {enumerable: true});
	    }

	    err.name = options && options.name || err.name || err.code || 'Error';
	    err.time = new Date();

	    if (originalError) err.originalError = originalError;

	    return err;
	  },

	  /**
	   * @api private
	   */
	  inherit: function inherit(klass, features) {
	    var newObject = null;
	    if (features === undefined) {
	      features = klass;
	      klass = Object;
	      newObject = {};
	    } else {
	      var ctor = function ConstructorWrapper() {};
	      ctor.prototype = klass.prototype;
	      newObject = new ctor();
	    }

	    // constructor not supplied, create pass-through ctor
	    if (features.constructor === Object) {
	      features.constructor = function() {
	        if (klass !== Object) {
	          return klass.apply(this, arguments);
	        }
	      };
	    }

	    features.constructor.prototype = newObject;
	    util.update(features.constructor.prototype, features);
	    features.constructor.__super__ = klass;
	    return features.constructor;
	  },

	  /**
	   * @api private
	   */
	  mixin: function mixin() {
	    var klass = arguments[0];
	    for (var i = 1; i < arguments.length; i++) {
	      // jshint forin:false
	      for (var prop in arguments[i].prototype) {
	        var fn = arguments[i].prototype[prop];
	        if (prop !== 'constructor') {
	          klass.prototype[prop] = fn;
	        }
	      }
	    }
	    return klass;
	  },

	  /**
	   * @api private
	   */
	  hideProperties: function hideProperties(obj, props) {
	    if (typeof Object.defineProperty !== 'function') return;

	    util.arrayEach(props, function (key) {
	      Object.defineProperty(obj, key, {
	        enumerable: false, writable: true, configurable: true });
	    });
	  },

	  /**
	   * @api private
	   */
	  property: function property(obj, name, value, enumerable, isValue) {
	    var opts = {
	      configurable: true,
	      enumerable: enumerable !== undefined ? enumerable : true
	    };
	    if (typeof value === 'function' && !isValue) {
	      opts.get = value;
	    }
	    else {
	      opts.value = value; opts.writable = true;
	    }

	    Object.defineProperty(obj, name, opts);
	  },

	  /**
	   * @api private
	   */
	  memoizedProperty: function memoizedProperty(obj, name, get, enumerable) {
	    var cachedValue = null;

	    // build enumerable attribute for each value with lazy accessor.
	    util.property(obj, name, function() {
	      if (cachedValue === null) {
	        cachedValue = get();
	      }
	      return cachedValue;
	    }, enumerable);
	  },

	  /**
	   * TODO Remove in major version revision
	   * This backfill populates response data without the
	   * top-level payload name.
	   *
	   * @api private
	   */
	  hoistPayloadMember: function hoistPayloadMember(resp) {
	    var req = resp.request;
	    var operation = req.operation;
	    var output = req.service.api.operations[operation].output;
	    if (output.payload) {
	      var payloadMember = output.members[output.payload];
	      var responsePayload = resp.data[output.payload];
	      if (payloadMember.type === 'structure') {
	        util.each(responsePayload, function(key, value) {
	          util.property(resp.data, key, value, false);
	        });
	      }
	    }
	  },

	  /**
	   * Compute SHA-256 checksums of streams
	   *
	   * @api private
	   */
	  computeSha256: function computeSha256(body, done) {
	    if (util.isNode()) {
	      var Stream = util.stream.Stream;
	      var fs = __webpack_require__(208);
	      if (body instanceof Stream) {
	        if (typeof body.path === 'string') { // assume file object
	          var settings = {};
	          if (typeof body.start === 'number') {
	            settings.start = body.start;
	          }
	          if (typeof body.end === 'number') {
	            settings.end = body.end;
	          }
	          body = fs.createReadStream(body.path, settings);
	        } else { // TODO support other stream types
	          return done(new Error('Non-file stream objects are ' +
	                                'not supported with SigV4'));
	        }
	      }
	    }

	    util.crypto.sha256(body, 'hex', function(err, sha) {
	      if (err) done(err);
	      else done(null, sha);
	    });
	  },

	  /**
	   * @api private
	   */
	  isClockSkewed: function isClockSkewed(serverTime) {
	    if (serverTime) {
	      util.property(AWS.config, 'isClockSkewed',
	        Math.abs(new Date().getTime() - serverTime) >= 300000, false);
	      return AWS.config.isClockSkewed;
	    }
	  },

	  applyClockOffset: function applyClockOffset(serverTime) {
	    if (serverTime)
	      AWS.config.systemClockOffset = serverTime - new Date().getTime();
	  },

	  /**
	   * @api private
	   */
	  extractRequestId: function extractRequestId(resp) {
	    var requestId = resp.httpResponse.headers['x-amz-request-id'] ||
	                     resp.httpResponse.headers['x-amzn-requestid'];

	    if (!requestId && resp.data && resp.data.ResponseMetadata) {
	      requestId = resp.data.ResponseMetadata.RequestId;
	    }

	    if (requestId) {
	      resp.requestId = requestId;
	    }

	    if (resp.error) {
	      resp.error.requestId = requestId;
	    }
	  },

	  /**
	   * @api private
	   */
	  addPromises: function addPromises(constructors, PromiseDependency) {
	    if (PromiseDependency === undefined && AWS && AWS.config) {
	      PromiseDependency = AWS.config.getPromisesDependency();
	    }
	    if (PromiseDependency === undefined && typeof Promise !== 'undefined') {
	      PromiseDependency = Promise;
	    }
	    if (typeof PromiseDependency !== 'function') var deletePromises = true;
	    if (!Array.isArray(constructors)) constructors = [constructors];

	    for (var ind = 0; ind < constructors.length; ind++) {
	      var constructor = constructors[ind];
	      if (deletePromises) {
	        if (constructor.deletePromisesFromClass) {
	          constructor.deletePromisesFromClass();
	        }
	      } else if (constructor.addPromisesToClass) {
	        constructor.addPromisesToClass(PromiseDependency);
	      }
	    }
	  },

	  /**
	   * @api private
	   */
	  promisifyMethod: function promisifyMethod(methodName, PromiseDependency) {
	    return function promise() {
	      var self = this;
	      return new PromiseDependency(function(resolve, reject) {
	        self[methodName](function(err, data) {
	          if (err) {
	            reject(err);
	          } else {
	            resolve(data);
	          }
	        });
	      });
	    };
	  },

	  /**
	   * @api private
	   */
	  isDualstackAvailable: function isDualstackAvailable(service) {
	    if (!service) return false;
	    var metadata = __webpack_require__(209);
	    if (typeof service !== 'string') service = service.serviceIdentifier;
	    if (typeof service !== 'string' || !metadata.hasOwnProperty(service)) return false;
	    return !!metadata[service].dualstackAvailable;
	  },

	  /**
	   * @api private
	   */
	  calculateRetryDelay: function calculateRetryDelay(retryCount, retryDelayOptions) {
	    if (!retryDelayOptions) retryDelayOptions = {};
	    var customBackoff = retryDelayOptions.customBackoff || null;
	    if (typeof customBackoff === 'function') {
	      return customBackoff(retryCount);
	    }
	    var base = retryDelayOptions.base || 100;
	    var delay = Math.random() * (Math.pow(2, retryCount) * base);
	    return delay;
	  },

	  /**
	   * @api private
	   */
	  handleRequestWithRetries: function handleRequestWithRetries(httpRequest, options, cb) {
	    if (!options) options = {};
	    var http = AWS.HttpClient.getInstance();
	    var httpOptions = options.httpOptions || {};
	    var retryCount = 0;

	    var errCallback = function(err) {
	      var maxRetries = options.maxRetries || 0;
	      if (err && err.code === 'TimeoutError') err.retryable = true;
	      if (err && err.retryable && retryCount < maxRetries) {
	        retryCount++;
	        var delay = util.calculateRetryDelay(retryCount, options.retryDelayOptions);
	        setTimeout(sendRequest, delay + (err.retryAfter || 0));
	      } else {
	        cb(err);
	      }
	    };

	    var sendRequest = function() {
	      var data = '';
	      http.handleRequest(httpRequest, httpOptions, function(httpResponse) {
	        httpResponse.on('data', function(chunk) { data += chunk.toString(); });
	        httpResponse.on('end', function() {
	          var statusCode = httpResponse.statusCode;
	          if (statusCode < 300) {
	            cb(null, data);
	          } else {
	            var retryAfter = parseInt(httpResponse.headers['retry-after'], 10) * 1000 || 0;
	            var err = util.error(new Error(),
	              { retryable: statusCode >= 500 || statusCode === 429 }
	            );
	            if (retryAfter && err.retryable) err.retryAfter = retryAfter;
	            errCallback(err);
	          }
	        });
	      }, errCallback);
	    };

	    process.nextTick(sendRequest);
	  }

	};

	module.exports = util;


/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * The main AWS namespace
	 */
	var AWS = { util: __webpack_require__(92) };

	/**
	 * @api private
	 * @!macro [new] nobrowser
	 *   @note This feature is not supported in the browser environment of the SDK.
	 */
	var _hidden = {}; _hidden.toString(); // hack to parse macro

	module.exports = AWS;

	AWS.util.update(AWS, {

	  /**
	   * @constant
	   */
	  VERSION: '2.6.15',

	  /**
	   * @api private
	   */
	  Signers: {},

	  /**
	   * @api private
	   */
	  Protocol: {
	    Json: __webpack_require__(94),
	    Query: __webpack_require__(97),
	    Rest: __webpack_require__(101),
	    RestJson: __webpack_require__(102),
	    RestXml: __webpack_require__(103)
	  },

	  /**
	   * @api private
	   */
	  XML: {
	    Builder: __webpack_require__(104),
	    Parser: null // conditionally set based on environment
	  },

	  /**
	   * @api private
	   */
	  JSON: {
	    Builder: __webpack_require__(95),
	    Parser: __webpack_require__(96)
	  },

	  /**
	   * @api private
	   */
	  Model: {
	    Api: __webpack_require__(170),
	    Operation: __webpack_require__(171),
	    Shape: __webpack_require__(99),
	    Paginator: __webpack_require__(172),
	    ResourceWaiter: __webpack_require__(173)
	  },

	  util: __webpack_require__(92),

	  /**
	   * @api private
	   */
	  apiLoader: function() { throw new Error('No API loader set'); }
	});

	__webpack_require__(174);

	__webpack_require__(177);
	__webpack_require__(178);
	__webpack_require__(179);
	__webpack_require__(184);
	__webpack_require__(185);
	__webpack_require__(189);

	__webpack_require__(190);
	__webpack_require__(191);
	__webpack_require__(192);
	__webpack_require__(193);
	__webpack_require__(195);
	__webpack_require__(198);
	__webpack_require__(199);
	__webpack_require__(200);
	__webpack_require__(207);

	/**
	 * @readonly
	 * @return [AWS.SequentialExecutor] a collection of global event listeners that
	 *   are attached to every sent request.
	 * @see AWS.Request AWS.Request for a list of events to listen for
	 * @example Logging the time taken to send a request
	 *   AWS.events.on('send', function startSend(resp) {
	 *     resp.startTime = new Date().getTime();
	 *   }).on('complete', function calculateTime(resp) {
	 *     var time = (new Date().getTime() - resp.startTime) / 1000;
	 *     console.log('Request took ' + time + ' seconds');
	 *   });
	 *
	 *   new AWS.S3().listBuckets(); // prints 'Request took 0.285 seconds'
	 */
	AWS.events = new AWS.SequentialExecutor();


/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	var util = __webpack_require__(92);
	var JsonBuilder = __webpack_require__(95);
	var JsonParser = __webpack_require__(96);

	function buildRequest(req) {
	  var httpRequest = req.httpRequest;
	  var api = req.service.api;
	  var target = api.targetPrefix + '.' + api.operations[req.operation].name;
	  var version = api.jsonVersion || '1.0';
	  var input = api.operations[req.operation].input;
	  var builder = new JsonBuilder();

	  if (version === 1) version = '1.0';
	  httpRequest.body = builder.build(req.params || {}, input);
	  httpRequest.headers['Content-Type'] = 'application/x-amz-json-' + version;
	  httpRequest.headers['X-Amz-Target'] = target;
	}

	function extractError(resp) {
	  var error = {};
	  var httpResponse = resp.httpResponse;

	  error.code = httpResponse.headers['x-amzn-errortype'] || 'UnknownError';
	  if (typeof error.code === 'string') {
	    error.code = error.code.split(':')[0];
	  }

	  if (httpResponse.body.length > 0) {
	    var e = JSON.parse(httpResponse.body.toString());
	    if (e.__type || e.code) {
	      error.code = (e.__type || e.code).split('#').pop();
	    }
	    if (error.code === 'RequestEntityTooLarge') {
	      error.message = 'Request body must be less than 1 MB';
	    } else {
	      error.message = (e.message || e.Message || null);
	    }
	  } else {
	    error.statusCode = httpResponse.statusCode;
	    error.message = httpResponse.statusCode.toString();
	  }

	  resp.error = util.error(new Error(), error);
	}

	function extractData(resp) {
	  var body = resp.httpResponse.body.toString() || '{}';
	  if (resp.request.service.config.convertResponseTypes === false) {
	    resp.data = JSON.parse(body);
	  } else {
	    var operation = resp.request.service.api.operations[resp.request.operation];
	    var shape = operation.output || {};
	    var parser = new JsonParser();
	    resp.data = parser.parse(body, shape);
	  }
	}

	module.exports = {
	  buildRequest: buildRequest,
	  extractError: extractError,
	  extractData: extractData
	};


/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	var util = __webpack_require__(92);

	function JsonBuilder() { }

	JsonBuilder.prototype.build = function(value, shape) {
	  return JSON.stringify(translate(value, shape));
	};

	function translate(value, shape) {
	  if (!shape || value === undefined || value === null) return undefined;

	  switch (shape.type) {
	    case 'structure': return translateStructure(value, shape);
	    case 'map': return translateMap(value, shape);
	    case 'list': return translateList(value, shape);
	    default: return translateScalar(value, shape);
	  }
	}

	function translateStructure(structure, shape) {
	  var struct = {};
	  util.each(structure, function(name, value) {
	    var memberShape = shape.members[name];
	    if (memberShape) {
	      if (memberShape.location !== 'body') return;
	      var locationName = memberShape.isLocationName ? memberShape.name : name;
	      var result = translate(value, memberShape);
	      if (result !== undefined) struct[locationName] = result;
	    }
	  });
	  return struct;
	}

	function translateList(list, shape) {
	  var out = [];
	  util.arrayEach(list, function(value) {
	    var result = translate(value, shape.member);
	    if (result !== undefined) out.push(result);
	  });
	  return out;
	}

	function translateMap(map, shape) {
	  var out = {};
	  util.each(map, function(key, value) {
	    var result = translate(value, shape.value);
	    if (result !== undefined) out[key] = result;
	  });
	  return out;
	}

	function translateScalar(value, shape) {
	  return shape.toWireFormat(value);
	}

	module.exports = JsonBuilder;


/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	var util = __webpack_require__(92);

	function JsonParser() { }

	JsonParser.prototype.parse = function(value, shape) {
	  return translate(JSON.parse(value), shape);
	};

	function translate(value, shape) {
	  if (!shape || value === undefined) return undefined;

	  switch (shape.type) {
	    case 'structure': return translateStructure(value, shape);
	    case 'map': return translateMap(value, shape);
	    case 'list': return translateList(value, shape);
	    default: return translateScalar(value, shape);
	  }
	}

	function translateStructure(structure, shape) {
	  if (structure == null) return undefined;

	  var struct = {};
	  var shapeMembers = shape.members;
	  util.each(shapeMembers, function(name, memberShape) {
	    var locationName = memberShape.isLocationName ? memberShape.name : name;
	    if (Object.prototype.hasOwnProperty.call(structure, locationName)) {
	      var value = structure[locationName];
	      var result = translate(value, memberShape);
	      if (result !== undefined) struct[name] = result;
	    }
	  });
	  return struct;
	}

	function translateList(list, shape) {
	  if (list == null) return undefined;

	  var out = [];
	  util.arrayEach(list, function(value) {
	    var result = translate(value, shape.member);
	    if (result === undefined) out.push(null);
	    else out.push(result);
	  });
	  return out;
	}

	function translateMap(map, shape) {
	  if (map == null) return undefined;

	  var out = {};
	  util.each(map, function(key, value) {
	    var result = translate(value, shape.value);
	    if (result === undefined) out[key] = null;
	    else out[key] = result;
	  });
	  return out;
	}

	function translateScalar(value, shape) {
	  return shape.toType(value);
	}

	module.exports = JsonParser;


/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(93);
	var util = __webpack_require__(92);
	var QueryParamSerializer = __webpack_require__(98);
	var Shape = __webpack_require__(99);

	function buildRequest(req) {
	  var operation = req.service.api.operations[req.operation];
	  var httpRequest = req.httpRequest;
	  httpRequest.headers['Content-Type'] =
	    'application/x-www-form-urlencoded; charset=utf-8';
	  httpRequest.params = {
	    Version: req.service.api.apiVersion,
	    Action: operation.name
	  };

	  // convert the request parameters into a list of query params,
	  // e.g. Deeply.NestedParam.0.Name=value
	  var builder = new QueryParamSerializer();
	  builder.serialize(req.params, operation.input, function(name, value) {
	    httpRequest.params[name] = value;
	  });
	  httpRequest.body = util.queryParamsToString(httpRequest.params);
	}

	function extractError(resp) {
	  var data, body = resp.httpResponse.body.toString();
	  if (body.match('<UnknownOperationException')) {
	    data = {
	      Code: 'UnknownOperation',
	      Message: 'Unknown operation ' + resp.request.operation
	    };
	  } else {
	    data = new AWS.XML.Parser().parse(body);
	  }

	  if (data.requestId && !resp.requestId) resp.requestId = data.requestId;
	  if (data.Errors) data = data.Errors;
	  if (data.Error) data = data.Error;
	  if (data.Code) {
	    resp.error = util.error(new Error(), {
	      code: data.Code,
	      message: data.Message
	    });
	  } else {
	    resp.error = util.error(new Error(), {
	      code: resp.httpResponse.statusCode,
	      message: null
	    });
	  }
	}

	function extractData(resp) {
	  var req = resp.request;
	  var operation = req.service.api.operations[req.operation];
	  var shape = operation.output || {};
	  var origRules = shape;

	  if (origRules.resultWrapper) {
	    var tmp = Shape.create({type: 'structure'});
	    tmp.members[origRules.resultWrapper] = shape;
	    tmp.memberNames = [origRules.resultWrapper];
	    util.property(shape, 'name', shape.resultWrapper);
	    shape = tmp;
	  }

	  var parser = new AWS.XML.Parser();

	  // TODO: Refactor XML Parser to parse RequestId from response.
	  if (shape && shape.members && !shape.members._XAMZRequestId) {
	    var requestIdShape = Shape.create(
	      { type: 'string' },
	      { api: { protocol: 'query' } },
	      'requestId'
	    );
	    shape.members._XAMZRequestId = requestIdShape;
	  }

	  var data = parser.parse(resp.httpResponse.body.toString(), shape);
	  resp.requestId = data._XAMZRequestId || data.requestId;

	  if (data._XAMZRequestId) delete data._XAMZRequestId;

	  if (origRules.resultWrapper) {
	    if (data[origRules.resultWrapper]) {
	      util.update(data, data[origRules.resultWrapper]);
	      delete data[origRules.resultWrapper];
	    }
	  }

	  resp.data = data;
	}

	module.exports = {
	  buildRequest: buildRequest,
	  extractError: extractError,
	  extractData: extractData
	};


/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	var util = __webpack_require__(92);

	function QueryParamSerializer() {
	}

	QueryParamSerializer.prototype.serialize = function(params, shape, fn) {
	  serializeStructure('', params, shape, fn);
	};

	function ucfirst(shape) {
	  if (shape.isQueryName || shape.api.protocol !== 'ec2') {
	    return shape.name;
	  } else {
	    return shape.name[0].toUpperCase() + shape.name.substr(1);
	  }
	}

	function serializeStructure(prefix, struct, rules, fn) {
	  util.each(rules.members, function(name, member) {
	    var value = struct[name];
	    if (value === null || value === undefined) return;

	    var memberName = ucfirst(member);
	    memberName = prefix ? prefix + '.' + memberName : memberName;
	    serializeMember(memberName, value, member, fn);
	  });
	}

	function serializeMap(name, map, rules, fn) {
	  var i = 1;
	  util.each(map, function (key, value) {
	    var prefix = rules.flattened ? '.' : '.entry.';
	    var position = prefix + (i++) + '.';
	    var keyName = position + (rules.key.name || 'key');
	    var valueName = position + (rules.value.name || 'value');
	    serializeMember(name + keyName, key, rules.key, fn);
	    serializeMember(name + valueName, value, rules.value, fn);
	  });
	}

	function serializeList(name, list, rules, fn) {
	  var memberRules = rules.member || {};

	  if (list.length === 0) {
	    fn.call(this, name, null);
	    return;
	  }

	  util.arrayEach(list, function (v, n) {
	    var suffix = '.' + (n + 1);
	    if (rules.api.protocol === 'ec2') {
	      // Do nothing for EC2
	      suffix = suffix + ''; // make linter happy
	    } else if (rules.flattened) {
	      if (memberRules.name) {
	        var parts = name.split('.');
	        parts.pop();
	        parts.push(ucfirst(memberRules));
	        name = parts.join('.');
	      }
	    } else {
	      suffix = '.member' + suffix;
	    }
	    serializeMember(name + suffix, v, memberRules, fn);
	  });
	}

	function serializeMember(name, value, rules, fn) {
	  if (value === null || value === undefined) return;
	  if (rules.type === 'structure') {
	    serializeStructure(name, value, rules, fn);
	  } else if (rules.type === 'list') {
	    serializeList(name, value, rules, fn);
	  } else if (rules.type === 'map') {
	    serializeMap(name, value, rules, fn);
	  } else {
	    fn(name, rules.toWireFormat(value).toString());
	  }
	}

	module.exports = QueryParamSerializer;


/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	var Collection = __webpack_require__(100);

	var util = __webpack_require__(92);

	function property(obj, name, value) {
	  if (value !== null && value !== undefined) {
	    util.property.apply(this, arguments);
	  }
	}

	function memoizedProperty(obj, name) {
	  if (!obj.constructor.prototype[name]) {
	    util.memoizedProperty.apply(this, arguments);
	  }
	}

	function Shape(shape, options, memberName) {
	  options = options || {};

	  property(this, 'shape', shape.shape);
	  property(this, 'api', options.api, false);
	  property(this, 'type', shape.type);
	  property(this, 'enum', shape.enum);
	  property(this, 'min', shape.min);
	  property(this, 'max', shape.max);
	  property(this, 'pattern', shape.pattern);
	  property(this, 'location', shape.location || this.location || 'body');
	  property(this, 'name', this.name || shape.xmlName || shape.queryName ||
	    shape.locationName || memberName);
	  property(this, 'isStreaming', shape.streaming || this.isStreaming || false);
	  property(this, 'isComposite', shape.isComposite || false);
	  property(this, 'isShape', true, false);
	  property(this, 'isQueryName', shape.queryName ? true : false, false);
	  property(this, 'isLocationName', shape.locationName ? true : false, false);

	  if (options.documentation) {
	    property(this, 'documentation', shape.documentation);
	    property(this, 'documentationUrl', shape.documentationUrl);
	  }

	  if (shape.xmlAttribute) {
	    property(this, 'isXmlAttribute', shape.xmlAttribute || false);
	  }

	  // type conversion and parsing
	  property(this, 'defaultValue', null);
	  this.toWireFormat = function(value) {
	    if (value === null || value === undefined) return '';
	    return value;
	  };
	  this.toType = function(value) { return value; };
	}

	/**
	 * @api private
	 */
	Shape.normalizedTypes = {
	  character: 'string',
	  double: 'float',
	  long: 'integer',
	  short: 'integer',
	  biginteger: 'integer',
	  bigdecimal: 'float',
	  blob: 'binary'
	};

	/**
	 * @api private
	 */
	Shape.types = {
	  'structure': StructureShape,
	  'list': ListShape,
	  'map': MapShape,
	  'boolean': BooleanShape,
	  'timestamp': TimestampShape,
	  'float': FloatShape,
	  'integer': IntegerShape,
	  'string': StringShape,
	  'base64': Base64Shape,
	  'binary': BinaryShape
	};

	Shape.resolve = function resolve(shape, options) {
	  if (shape.shape) {
	    var refShape = options.api.shapes[shape.shape];
	    if (!refShape) {
	      throw new Error('Cannot find shape reference: ' + shape.shape);
	    }

	    return refShape;
	  } else {
	    return null;
	  }
	};

	Shape.create = function create(shape, options, memberName) {
	  if (shape.isShape) return shape;

	  var refShape = Shape.resolve(shape, options);
	  if (refShape) {
	    var filteredKeys = Object.keys(shape);
	    if (!options.documentation) {
	      filteredKeys = filteredKeys.filter(function(name) {
	        return !name.match(/documentation/);
	      });
	    }
	    if (filteredKeys === ['shape']) { // no inline customizations
	      return refShape;
	    }

	    // create an inline shape with extra members
	    var InlineShape = function() {
	      refShape.constructor.call(this, shape, options, memberName);
	    };
	    InlineShape.prototype = refShape;
	    return new InlineShape();
	  } else {
	    // set type if not set
	    if (!shape.type) {
	      if (shape.members) shape.type = 'structure';
	      else if (shape.member) shape.type = 'list';
	      else if (shape.key) shape.type = 'map';
	      else shape.type = 'string';
	    }

	    // normalize types
	    var origType = shape.type;
	    if (Shape.normalizedTypes[shape.type]) {
	      shape.type = Shape.normalizedTypes[shape.type];
	    }

	    if (Shape.types[shape.type]) {
	      return new Shape.types[shape.type](shape, options, memberName);
	    } else {
	      throw new Error('Unrecognized shape type: ' + origType);
	    }
	  }
	};

	function CompositeShape(shape) {
	  Shape.apply(this, arguments);
	  property(this, 'isComposite', true);

	  if (shape.flattened) {
	    property(this, 'flattened', shape.flattened || false);
	  }
	}

	function StructureShape(shape, options) {
	  var requiredMap = null, firstInit = !this.isShape;

	  CompositeShape.apply(this, arguments);

	  if (firstInit) {
	    property(this, 'defaultValue', function() { return {}; });
	    property(this, 'members', {});
	    property(this, 'memberNames', []);
	    property(this, 'required', []);
	    property(this, 'isRequired', function() { return false; });
	  }

	  if (shape.members) {
	    property(this, 'members', new Collection(shape.members, options, function(name, member) {
	      return Shape.create(member, options, name);
	    }));
	    memoizedProperty(this, 'memberNames', function() {
	      return shape.xmlOrder || Object.keys(shape.members);
	    });
	  }

	  if (shape.required) {
	    property(this, 'required', shape.required);
	    property(this, 'isRequired', function(name) {
	      if (!requiredMap) {
	        requiredMap = {};
	        for (var i = 0; i < shape.required.length; i++) {
	          requiredMap[shape.required[i]] = true;
	        }
	      }

	      return requiredMap[name];
	    }, false, true);
	  }

	  property(this, 'resultWrapper', shape.resultWrapper || null);

	  if (shape.payload) {
	    property(this, 'payload', shape.payload);
	  }

	  if (typeof shape.xmlNamespace === 'string') {
	    property(this, 'xmlNamespaceUri', shape.xmlNamespace);
	  } else if (typeof shape.xmlNamespace === 'object') {
	    property(this, 'xmlNamespacePrefix', shape.xmlNamespace.prefix);
	    property(this, 'xmlNamespaceUri', shape.xmlNamespace.uri);
	  }
	}

	function ListShape(shape, options) {
	  var self = this, firstInit = !this.isShape;
	  CompositeShape.apply(this, arguments);

	  if (firstInit) {
	    property(this, 'defaultValue', function() { return []; });
	  }

	  if (shape.member) {
	    memoizedProperty(this, 'member', function() {
	      return Shape.create(shape.member, options);
	    });
	  }

	  if (this.flattened) {
	    var oldName = this.name;
	    memoizedProperty(this, 'name', function() {
	      return self.member.name || oldName;
	    });
	  }
	}

	function MapShape(shape, options) {
	  var firstInit = !this.isShape;
	  CompositeShape.apply(this, arguments);

	  if (firstInit) {
	    property(this, 'defaultValue', function() { return {}; });
	    property(this, 'key', Shape.create({type: 'string'}, options));
	    property(this, 'value', Shape.create({type: 'string'}, options));
	  }

	  if (shape.key) {
	    memoizedProperty(this, 'key', function() {
	      return Shape.create(shape.key, options);
	    });
	  }
	  if (shape.value) {
	    memoizedProperty(this, 'value', function() {
	      return Shape.create(shape.value, options);
	    });
	  }
	}

	function TimestampShape(shape) {
	  var self = this;
	  Shape.apply(this, arguments);

	  if (this.location === 'header') {
	    property(this, 'timestampFormat', 'rfc822');
	  } else if (shape.timestampFormat) {
	    property(this, 'timestampFormat', shape.timestampFormat);
	  } else if (this.api) {
	    if (this.api.timestampFormat) {
	      property(this, 'timestampFormat', this.api.timestampFormat);
	    } else {
	      switch (this.api.protocol) {
	        case 'json':
	        case 'rest-json':
	          property(this, 'timestampFormat', 'unixTimestamp');
	          break;
	        case 'rest-xml':
	        case 'query':
	        case 'ec2':
	          property(this, 'timestampFormat', 'iso8601');
	          break;
	      }
	    }
	  }

	  this.toType = function(value) {
	    if (value === null || value === undefined) return null;
	    if (typeof value.toUTCString === 'function') return value;
	    return typeof value === 'string' || typeof value === 'number' ?
	           util.date.parseTimestamp(value) : null;
	  };

	  this.toWireFormat = function(value) {
	    return util.date.format(value, self.timestampFormat);
	  };
	}

	function StringShape() {
	  Shape.apply(this, arguments);

	  if (this.api) {
	    switch (this.api.protocol) {
	      case 'rest-xml':
	      case 'query':
	      case 'ec2':
	        this.toType = function(value) { return value || ''; };
	    }
	  }
	}

	function FloatShape() {
	  Shape.apply(this, arguments);

	  this.toType = function(value) {
	    if (value === null || value === undefined) return null;
	    return parseFloat(value);
	  };
	  this.toWireFormat = this.toType;
	}

	function IntegerShape() {
	  Shape.apply(this, arguments);

	  this.toType = function(value) {
	    if (value === null || value === undefined) return null;
	    return parseInt(value, 10);
	  };
	  this.toWireFormat = this.toType;
	}

	function BinaryShape() {
	  Shape.apply(this, arguments);
	  this.toType = util.base64.decode;
	  this.toWireFormat = util.base64.encode;
	}

	function Base64Shape() {
	  BinaryShape.apply(this, arguments);
	}

	function BooleanShape() {
	  Shape.apply(this, arguments);

	  this.toType = function(value) {
	    if (typeof value === 'boolean') return value;
	    if (value === null || value === undefined) return null;
	    return value === 'true';
	  };
	}

	/**
	 * @api private
	 */
	Shape.shapes = {
	  StructureShape: StructureShape,
	  ListShape: ListShape,
	  MapShape: MapShape,
	  StringShape: StringShape,
	  BooleanShape: BooleanShape,
	  Base64Shape: Base64Shape
	};

	module.exports = Shape;


/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	var memoizedProperty = __webpack_require__(92).memoizedProperty;

	function memoize(name, value, fn, nameTr) {
	  memoizedProperty(this, nameTr(name), function() {
	    return fn(name, value);
	  });
	}

	function Collection(iterable, options, fn, nameTr) {
	  nameTr = nameTr || String;
	  var self = this;

	  for (var id in iterable) {
	    if (Object.prototype.hasOwnProperty.call(iterable, id)) {
	      memoize.call(self, id, iterable[id], fn, nameTr);
	    }
	  }
	}

	module.exports = Collection;


/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	var util = __webpack_require__(92);

	function populateMethod(req) {
	  req.httpRequest.method = req.service.api.operations[req.operation].httpMethod;
	}

	function populateURI(req) {
	  var operation = req.service.api.operations[req.operation];
	  var input = operation.input;
	  var uri = [req.httpRequest.endpoint.path, operation.httpPath].join('/');
	  uri = uri.replace(/\/+/g, '/');

	  var queryString = {}, queryStringSet = false;
	  util.each(input.members, function (name, member) {
	    var paramValue = req.params[name];
	    if (paramValue === null || paramValue === undefined) return;
	    if (member.location === 'uri') {
	      var regex = new RegExp('\\{' + member.name + '(\\+)?\\}');
	      uri = uri.replace(regex, function(_, plus) {
	        var fn = plus ? util.uriEscapePath : util.uriEscape;
	        return fn(String(paramValue));
	      });
	    } else if (member.location === 'querystring') {
	      queryStringSet = true;

	      if (member.type === 'list') {
	        queryString[member.name] = paramValue.map(function(val) {
	          return util.uriEscape(String(val));
	        });
	      } else if (member.type === 'map') {
	        util.each(paramValue, function(key, value) {
	          if (Array.isArray(value)) {
	            queryString[key] = value.map(function(val) {
	              return util.uriEscape(String(val));
	            });
	          } else {
	            queryString[key] = util.uriEscape(String(value));
	          }
	        });
	      } else {
	        queryString[member.name] = util.uriEscape(String(paramValue));
	      }
	    }
	  });

	  if (queryStringSet) {
	    uri += (uri.indexOf('?') >= 0 ? '&' : '?');
	    var parts = [];
	    util.arrayEach(Object.keys(queryString).sort(), function(key) {
	      if (!Array.isArray(queryString[key])) {
	        queryString[key] = [queryString[key]];
	      }
	      for (var i = 0; i < queryString[key].length; i++) {
	        parts.push(util.uriEscape(String(key)) + '=' + queryString[key][i]);
	      }
	    });
	    uri += parts.join('&');
	  }

	  req.httpRequest.path = uri;
	}

	function populateHeaders(req) {
	  var operation = req.service.api.operations[req.operation];
	  util.each(operation.input.members, function (name, member) {
	    var value = req.params[name];
	    if (value === null || value === undefined) return;

	    if (member.location === 'headers' && member.type === 'map') {
	      util.each(value, function(key, memberValue) {
	        req.httpRequest.headers[member.name + key] = memberValue;
	      });
	    } else if (member.location === 'header') {
	      value = member.toWireFormat(value).toString();
	      req.httpRequest.headers[member.name] = value;
	    }
	  });
	}

	function buildRequest(req) {
	  populateMethod(req);
	  populateURI(req);
	  populateHeaders(req);
	}

	function extractError() {
	}

	function extractData(resp) {
	  var req = resp.request;
	  var data = {};
	  var r = resp.httpResponse;
	  var operation = req.service.api.operations[req.operation];
	  var output = operation.output;

	  // normalize headers names to lower-cased keys for matching
	  var headers = {};
	  util.each(r.headers, function (k, v) {
	    headers[k.toLowerCase()] = v;
	  });

	  util.each(output.members, function(name, member) {
	    var header = (member.name || name).toLowerCase();
	    if (member.location === 'headers' && member.type === 'map') {
	      data[name] = {};
	      var location = member.isLocationName ? member.name : '';
	      var pattern = new RegExp('^' + location + '(.+)', 'i');
	      util.each(r.headers, function (k, v) {
	        var result = k.match(pattern);
	        if (result !== null) {
	          data[name][result[1]] = v;
	        }
	      });
	    } else if (member.location === 'header') {
	      if (headers[header] !== undefined) {
	        data[name] = headers[header];
	      }
	    } else if (member.location === 'statusCode') {
	      data[name] = parseInt(r.statusCode, 10);
	    }
	  });

	  resp.data = data;
	}

	module.exports = {
	  buildRequest: buildRequest,
	  extractError: extractError,
	  extractData: extractData
	};


/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	var util = __webpack_require__(92);
	var Rest = __webpack_require__(101);
	var Json = __webpack_require__(94);
	var JsonBuilder = __webpack_require__(95);
	var JsonParser = __webpack_require__(96);

	function populateBody(req) {
	  var builder = new JsonBuilder();
	  var input = req.service.api.operations[req.operation].input;

	  if (input.payload) {
	    var params = {};
	    var payloadShape = input.members[input.payload];
	    params = req.params[input.payload];
	    if (params === undefined) return;

	    if (payloadShape.type === 'structure') {
	      req.httpRequest.body = builder.build(params, payloadShape);
	    } else { // non-JSON payload
	      req.httpRequest.body = params;
	    }
	  } else {
	    req.httpRequest.body = builder.build(req.params, input);
	  }
	}

	function buildRequest(req) {
	  Rest.buildRequest(req);

	  // never send body payload on GET/HEAD/DELETE
	  if (['GET', 'HEAD', 'DELETE'].indexOf(req.httpRequest.method) < 0) {
	    populateBody(req);
	  }
	}

	function extractError(resp) {
	  Json.extractError(resp);
	}

	function extractData(resp) {
	  Rest.extractData(resp);

	  var req = resp.request;
	  var rules = req.service.api.operations[req.operation].output || {};
	  if (rules.payload) {
	    var payloadMember = rules.members[rules.payload];
	    var body = resp.httpResponse.body;
	    if (payloadMember.isStreaming) {
	      resp.data[rules.payload] = body;
	    } else if (payloadMember.type === 'structure' || payloadMember.type === 'list') {
	      var parser = new JsonParser();
	      resp.data[rules.payload] = parser.parse(body, payloadMember);
	    } else {
	      resp.data[rules.payload] = body.toString();
	    }
	  } else {
	    var data = resp.data;
	    Json.extractData(resp);
	    resp.data = util.merge(data, resp.data);
	  }
	}

	module.exports = {
	  buildRequest: buildRequest,
	  extractError: extractError,
	  extractData: extractData
	};


/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(93);
	var util = __webpack_require__(92);
	var Rest = __webpack_require__(101);

	function populateBody(req) {
	  var input = req.service.api.operations[req.operation].input;
	  var builder = new AWS.XML.Builder();
	  var params = req.params;

	  var payload = input.payload;
	  if (payload) {
	    var payloadMember = input.members[payload];
	    params = params[payload];
	    if (params === undefined) return;

	    if (payloadMember.type === 'structure') {
	      var rootElement = payloadMember.name;
	      req.httpRequest.body = builder.toXML(params, payloadMember, rootElement, true);
	    } else { // non-xml payload
	      req.httpRequest.body = params;
	    }
	  } else {
	    req.httpRequest.body = builder.toXML(params, input, input.name ||
	      input.shape || util.string.upperFirst(req.operation) + 'Request');
	  }
	}

	function buildRequest(req) {
	  Rest.buildRequest(req);

	  // never send body payload on GET/HEAD
	  if (['GET', 'HEAD'].indexOf(req.httpRequest.method) < 0) {
	    populateBody(req);
	  }
	}

	function extractError(resp) {
	  Rest.extractError(resp);

	  var data = new AWS.XML.Parser().parse(resp.httpResponse.body.toString());
	  if (data.Errors) data = data.Errors;
	  if (data.Error) data = data.Error;
	  if (data.Code) {
	    resp.error = util.error(new Error(), {
	      code: data.Code,
	      message: data.Message
	    });
	  } else {
	    resp.error = util.error(new Error(), {
	      code: resp.httpResponse.statusCode,
	      message: null
	    });
	  }
	}

	function extractData(resp) {
	  Rest.extractData(resp);

	  var parser;
	  var req = resp.request;
	  var body = resp.httpResponse.body;
	  var operation = req.service.api.operations[req.operation];
	  var output = operation.output;

	  var payload = output.payload;
	  if (payload) {
	    var payloadMember = output.members[payload];
	    if (payloadMember.isStreaming) {
	      resp.data[payload] = body;
	    } else if (payloadMember.type === 'structure') {
	      parser = new AWS.XML.Parser();
	      resp.data[payload] = parser.parse(body.toString(), payloadMember);
	    } else {
	      resp.data[payload] = body.toString();
	    }
	  } else if (body.length > 0) {
	    parser = new AWS.XML.Parser();
	    var data = parser.parse(body.toString(), output);
	    util.update(resp.data, data);
	  }
	}

	module.exports = {
	  buildRequest: buildRequest,
	  extractError: extractError,
	  extractData: extractData
	};


/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	var util = __webpack_require__(92);
	var builder = __webpack_require__(105);

	function XmlBuilder() { }

	XmlBuilder.prototype.toXML = function(params, shape, rootElement, noEmpty) {
	  var xml = builder.create(rootElement);
	  applyNamespaces(xml, shape);
	  serialize(xml, params, shape);
	  return xml.children.length > 0 || noEmpty ? xml.root().toString() : '';
	};

	function serialize(xml, value, shape) {
	  switch (shape.type) {
	    case 'structure': return serializeStructure(xml, value, shape);
	    case 'map': return serializeMap(xml, value, shape);
	    case 'list': return serializeList(xml, value, shape);
	    default: return serializeScalar(xml, value, shape);
	  }
	}

	function serializeStructure(xml, params, shape) {
	  util.arrayEach(shape.memberNames, function(memberName) {
	    var memberShape = shape.members[memberName];
	    if (memberShape.location !== 'body') return;

	    var value = params[memberName];
	    var name = memberShape.name;
	    if (value !== undefined && value !== null) {
	      if (memberShape.isXmlAttribute) {
	        xml.att(name, value);
	      } else if (memberShape.flattened) {
	        serialize(xml, value, memberShape);
	      } else {
	        var element = xml.ele(name);
	        applyNamespaces(element, memberShape);
	        serialize(element, value, memberShape);
	      }
	    }
	  });
	}

	function serializeMap(xml, map, shape) {
	  var xmlKey = shape.key.name || 'key';
	  var xmlValue = shape.value.name || 'value';

	  util.each(map, function(key, value) {
	    var entry = xml.ele(shape.flattened ? shape.name : 'entry');
	    serialize(entry.ele(xmlKey), key, shape.key);
	    serialize(entry.ele(xmlValue), value, shape.value);
	  });
	}

	function serializeList(xml, list, shape) {
	  if (shape.flattened) {
	    util.arrayEach(list, function(value) {
	      var name = shape.member.name || shape.name;
	      var element = xml.ele(name);
	      serialize(element, value, shape.member);
	    });
	  } else {
	    util.arrayEach(list, function(value) {
	      var name = shape.member.name || 'member';
	      var element = xml.ele(name);
	      serialize(element, value, shape.member);
	    });
	  }
	}

	function serializeScalar(xml, value, shape) {
	  xml.txt(shape.toWireFormat(value));
	}

	function applyNamespaces(xml, shape) {
	  var uri, prefix = 'xmlns';
	  if (shape.xmlNamespaceUri) {
	    uri = shape.xmlNamespaceUri;
	    if (shape.xmlNamespacePrefix) prefix += ':' + shape.xmlNamespacePrefix;
	  } else if (xml.isRoot && shape.api.xmlNamespaceUri) {
	    uri = shape.api.xmlNamespaceUri;
	  }

	  if (uri) xml.att(prefix, uri);
	}

	module.exports = XmlBuilder;


/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.9.1
	(function() {
	  var XMLBuilder, assign;

	  assign = __webpack_require__(106);

	  XMLBuilder = __webpack_require__(126);

	  module.exports.create = function(name, xmldec, doctype, options) {
	    options = assign({}, xmldec, doctype, options);
	    return new XMLBuilder(name, options).root();
	  };

	}).call(this);


/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	var baseAssign = __webpack_require__(107),
	    createAssigner = __webpack_require__(122);

	/**
	 * Assigns own enumerable properties of source object(s) to the destination
	 * object. Subsequent sources overwrite property assignments of previous sources.
	 * If `customizer` is provided it is invoked to produce the assigned values.
	 * The `customizer` is bound to `thisArg` and invoked with five arguments;
	 * (objectValue, sourceValue, key, object, source).
	 *
	 * @static
	 * @memberOf _
	 * @alias extend
	 * @category Object
	 * @param {Object} object The destination object.
	 * @param {...Object} [sources] The source objects.
	 * @param {Function} [customizer] The function to customize assigning values.
	 * @param {*} [thisArg] The `this` binding of `customizer`.
	 * @returns {Object} Returns `object`.
	 * @example
	 *
	 * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });
	 * // => { 'user': 'fred', 'age': 40 }
	 *
	 * // using a customizer callback
	 * var defaults = _.partialRight(_.assign, function(value, other) {
	 *   return typeof value == 'undefined' ? other : value;
	 * });
	 *
	 * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
	 * // => { 'user': 'barney', 'age': 36 }
	 */
	var assign = createAssigner(baseAssign);

	module.exports = assign;


/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	var baseCopy = __webpack_require__(108),
	    keys = __webpack_require__(109);

	/**
	 * The base implementation of `_.assign` without support for argument juggling,
	 * multiple sources, and `this` binding `customizer` functions.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @param {Function} [customizer] The function to customize assigning values.
	 * @returns {Object} Returns the destination object.
	 */
	function baseAssign(object, source, customizer) {
	  var props = keys(source);
	  if (!customizer) {
	    return baseCopy(source, object, props);
	  }
	  var index = -1,
	      length = props.length;

	  while (++index < length) {
	    var key = props[index],
	        value = object[key],
	        result = customizer(value, source[key], key, object, source);

	    if ((result === result ? (result !== value) : (value === value)) ||
	        (typeof value == 'undefined' && !(key in object))) {
	      object[key] = result;
	    }
	  }
	  return object;
	}

	module.exports = baseAssign;


/***/ },
/* 108 */
/***/ function(module, exports) {

	/**
	 * Copies the properties of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy properties from.
	 * @param {Object} [object={}] The object to copy properties to.
	 * @param {Array} props The property names to copy.
	 * @returns {Object} Returns `object`.
	 */
	function baseCopy(source, object, props) {
	  if (!props) {
	    props = object;
	    object = {};
	  }
	  var index = -1,
	      length = props.length;

	  while (++index < length) {
	    var key = props[index];
	    object[key] = source[key];
	  }
	  return object;
	}

	module.exports = baseCopy;


/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	var isLength = __webpack_require__(110),
	    isNative = __webpack_require__(111),
	    isObject = __webpack_require__(115),
	    shimKeys = __webpack_require__(116);

	/* Native method references for those with the same name as other `lodash` methods. */
	var nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys;

	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to inspect.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	var keys = !nativeKeys ? shimKeys : function(object) {
	  if (object) {
	    var Ctor = object.constructor,
	        length = object.length;
	  }
	  if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
	      (typeof object != 'function' && (length && isLength(length)))) {
	    return shimKeys(object);
	  }
	  return isObject(object) ? nativeKeys(object) : [];
	};

	module.exports = keys;


/***/ },
/* 110 */
/***/ function(module, exports) {

	/**
	 * Used as the maximum length of an array-like value.
	 * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
	 * for more details.
	 */
	var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This function is based on ES `ToLength`. See the
	 * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength)
	 * for more details.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 */
	function isLength(value) {
	  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	module.exports = isLength;


/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	var escapeRegExp = __webpack_require__(112),
	    isObjectLike = __webpack_require__(114);

	/** `Object#toString` result references. */
	var funcTag = '[object Function]';

	/** Used to detect host constructors (Safari > 5). */
	var reHostCtor = /^\[object .+?Constructor\]$/;

	/** Used for native method references. */
	var objectProto = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var fnToString = Function.prototype.toString;

	/**
	 * Used to resolve the `toStringTag` of values.
	 * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
	 * for more details.
	 */
	var objToString = objectProto.toString;

	/** Used to detect if a method is native. */
	var reNative = RegExp('^' +
	  escapeRegExp(objToString)
	  .replace(/toString|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/**
	 * Checks if `value` is a native function.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
	 * @example
	 *
	 * _.isNative(Array.prototype.push);
	 * // => true
	 *
	 * _.isNative(_);
	 * // => false
	 */
	function isNative(value) {
	  if (value == null) {
	    return false;
	  }
	  if (objToString.call(value) == funcTag) {
	    return reNative.test(fnToString.call(value));
	  }
	  return (isObjectLike(value) && reHostCtor.test(value)) || false;
	}

	module.exports = isNative;


/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	var baseToString = __webpack_require__(113);

	/**
	 * Used to match `RegExp` special characters.
	 * See this [article on `RegExp` characters](http://www.regular-expressions.info/characters.html#special)
	 * for more details.
	 */
	var reRegExpChars = /[.*+?^${}()|[\]\/\\]/g,
	    reHasRegExpChars = RegExp(reRegExpChars.source);

	/**
	 * Escapes the `RegExp` special characters "\", "^", "$", ".", "|", "?", "*",
	 * "+", "(", ")", "[", "]", "{" and "}" in `string`.
	 *
	 * @static
	 * @memberOf _
	 * @category String
	 * @param {string} [string=''] The string to escape.
	 * @returns {string} Returns the escaped string.
	 * @example
	 *
	 * _.escapeRegExp('[lodash](https://lodash.com/)');
	 * // => '\[lodash\]\(https://lodash\.com/\)'
	 */
	function escapeRegExp(string) {
	  string = baseToString(string);
	  return (string && reHasRegExpChars.test(string))
	    ? string.replace(reRegExpChars, '\\$&')
	    : string;
	}

	module.exports = escapeRegExp;


/***/ },
/* 113 */
/***/ function(module, exports) {

	/**
	 * Converts `value` to a string if it is not one. An empty string is returned
	 * for `null` or `undefined` values.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 */
	function baseToString(value) {
	  if (typeof value == 'string') {
	    return value;
	  }
	  return value == null ? '' : (value + '');
	}

	module.exports = baseToString;


/***/ },
/* 114 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is object-like.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 */
	function isObjectLike(value) {
	  return (value && typeof value == 'object') || false;
	}

	module.exports = isObjectLike;


/***/ },
/* 115 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is the language type of `Object`.
	 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * **Note:** See the [ES5 spec](https://es5.github.io/#x8) for more details.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(1);
	 * // => false
	 */
	function isObject(value) {
	  // Avoid a V8 JIT bug in Chrome 19-20.
	  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
	  var type = typeof value;
	  return type == 'function' || (value && type == 'object') || false;
	}

	module.exports = isObject;


/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	var isArguments = __webpack_require__(117),
	    isArray = __webpack_require__(118),
	    isIndex = __webpack_require__(119),
	    isLength = __webpack_require__(110),
	    keysIn = __webpack_require__(120),
	    support = __webpack_require__(121);

	/** Used for native method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * A fallback implementation of `Object.keys` which creates an array of the
	 * own enumerable property names of `object`.
	 *
	 * @private
	 * @param {Object} object The object to inspect.
	 * @returns {Array} Returns the array of property names.
	 */
	function shimKeys(object) {
	  var props = keysIn(object),
	      propsLength = props.length,
	      length = propsLength && object.length;

	  var allowIndexes = length && isLength(length) &&
	    (isArray(object) || (support.nonEnumArgs && isArguments(object)));

	  var index = -1,
	      result = [];

	  while (++index < propsLength) {
	    var key = props[index];
	    if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	module.exports = shimKeys;


/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	var isLength = __webpack_require__(110),
	    isObjectLike = __webpack_require__(114);

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]';

	/** Used for native method references. */
	var objectProto = Object.prototype;

	/**
	 * Used to resolve the `toStringTag` of values.
	 * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
	 * for more details.
	 */
	var objToString = objectProto.toString;

	/**
	 * Checks if `value` is classified as an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	function isArguments(value) {
	  var length = isObjectLike(value) ? value.length : undefined;
	  return (isLength(length) && objToString.call(value) == argsTag) || false;
	}

	module.exports = isArguments;


/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	var isLength = __webpack_require__(110),
	    isNative = __webpack_require__(111),
	    isObjectLike = __webpack_require__(114);

	/** `Object#toString` result references. */
	var arrayTag = '[object Array]';

	/** Used for native method references. */
	var objectProto = Object.prototype;

	/**
	 * Used to resolve the `toStringTag` of values.
	 * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
	 * for more details.
	 */
	var objToString = objectProto.toString;

	/* Native method references for those with the same name as other `lodash` methods. */
	var nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray;

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(function() { return arguments; }());
	 * // => false
	 */
	var isArray = nativeIsArray || function(value) {
	  return (isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag) || false;
	};

	module.exports = isArray;


/***/ },
/* 119 */
/***/ function(module, exports) {

	/**
	 * Used as the maximum length of an array-like value.
	 * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
	 * for more details.
	 */
	var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;

	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  value = +value;
	  length = length == null ? MAX_SAFE_INTEGER : length;
	  return value > -1 && value % 1 == 0 && value < length;
	}

	module.exports = isIndex;


/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	var isArguments = __webpack_require__(117),
	    isArray = __webpack_require__(118),
	    isIndex = __webpack_require__(119),
	    isLength = __webpack_require__(110),
	    isObject = __webpack_require__(115),
	    support = __webpack_require__(121);

	/** Used for native method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Creates an array of the own and inherited enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects.
	 *
	 * @static
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to inspect.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keysIn(new Foo);
	 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	 */
	function keysIn(object) {
	  if (object == null) {
	    return [];
	  }
	  if (!isObject(object)) {
	    object = Object(object);
	  }
	  var length = object.length;
	  length = (length && isLength(length) &&
	    (isArray(object) || (support.nonEnumArgs && isArguments(object))) && length) || 0;

	  var Ctor = object.constructor,
	      index = -1,
	      isProto = typeof Ctor == 'function' && Ctor.prototype === object,
	      result = Array(length),
	      skipIndexes = length > 0;

	  while (++index < length) {
	    result[index] = (index + '');
	  }
	  for (var key in object) {
	    if (!(skipIndexes && isIndex(key, length)) &&
	        !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	module.exports = keysIn;


/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	var isNative = __webpack_require__(111);

	/** Used to detect functions containing a `this` reference. */
	var reThis = /\bthis\b/;

	/** Used for native method references. */
	var objectProto = Object.prototype;

	/** Used to detect DOM support. */
	var document = (document = global.window) && document.document;

	/** Native method references. */
	var propertyIsEnumerable = objectProto.propertyIsEnumerable;

	/**
	 * An object environment feature flags.
	 *
	 * @static
	 * @memberOf _
	 * @type Object
	 */
	var support = {};

	(function(x) {

	  /**
	   * Detect if functions can be decompiled by `Function#toString`
	   * (all but Firefox OS certified apps, older Opera mobile browsers, and
	   * the PlayStation 3; forced `false` for Windows 8 apps).
	   *
	   * @memberOf _.support
	   * @type boolean
	   */
	  support.funcDecomp = !isNative(global.WinRTError) && reThis.test(function() { return this; });

	  /**
	   * Detect if `Function#name` is supported (all but IE).
	   *
	   * @memberOf _.support
	   * @type boolean
	   */
	  support.funcNames = typeof Function.name == 'string';

	  /**
	   * Detect if the DOM is supported.
	   *
	   * @memberOf _.support
	   * @type boolean
	   */
	  try {
	    support.dom = document.createDocumentFragment().nodeType === 11;
	  } catch(e) {
	    support.dom = false;
	  }

	  /**
	   * Detect if `arguments` object indexes are non-enumerable.
	   *
	   * In Firefox < 4, IE < 9, PhantomJS, and Safari < 5.1 `arguments` object
	   * indexes are non-enumerable. Chrome < 25 and Node.js < 0.11.0 treat
	   * `arguments` object indexes as non-enumerable and fail `hasOwnProperty`
	   * checks for indexes that exceed their function's formal parameters with
	   * associated values of `0`.
	   *
	   * @memberOf _.support
	   * @type boolean
	   */
	  try {
	    support.nonEnumArgs = !propertyIsEnumerable.call(arguments, 1);
	  } catch(e) {
	    support.nonEnumArgs = true;
	  }
	}(0, 0));

	module.exports = support;


/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	var bindCallback = __webpack_require__(123),
	    isIterateeCall = __webpack_require__(125);

	/**
	 * Creates a function that assigns properties of source object(s) to a given
	 * destination object.
	 *
	 * @private
	 * @param {Function} assigner The function to assign values.
	 * @returns {Function} Returns the new assigner function.
	 */
	function createAssigner(assigner) {
	  return function() {
	    var args = arguments,
	        length = args.length,
	        object = args[0];

	    if (length < 2 || object == null) {
	      return object;
	    }
	    var customizer = args[length - 2],
	        thisArg = args[length - 1],
	        guard = args[3];

	    if (length > 3 && typeof customizer == 'function') {
	      customizer = bindCallback(customizer, thisArg, 5);
	      length -= 2;
	    } else {
	      customizer = (length > 2 && typeof thisArg == 'function') ? thisArg : null;
	      length -= (customizer ? 1 : 0);
	    }
	    if (guard && isIterateeCall(args[1], args[2], guard)) {
	      customizer = length == 3 ? null : customizer;
	      length = 2;
	    }
	    var index = 0;
	    while (++index < length) {
	      var source = args[index];
	      if (source) {
	        assigner(object, source, customizer);
	      }
	    }
	    return object;
	  };
	}

	module.exports = createAssigner;


/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	var identity = __webpack_require__(124);

	/**
	 * A specialized version of `baseCallback` which only supports `this` binding
	 * and specifying the number of arguments to provide to `func`.
	 *
	 * @private
	 * @param {Function} func The function to bind.
	 * @param {*} thisArg The `this` binding of `func`.
	 * @param {number} [argCount] The number of arguments to provide to `func`.
	 * @returns {Function} Returns the callback.
	 */
	function bindCallback(func, thisArg, argCount) {
	  if (typeof func != 'function') {
	    return identity;
	  }
	  if (typeof thisArg == 'undefined') {
	    return func;
	  }
	  switch (argCount) {
	    case 1: return function(value) {
	      return func.call(thisArg, value);
	    };
	    case 3: return function(value, index, collection) {
	      return func.call(thisArg, value, index, collection);
	    };
	    case 4: return function(accumulator, value, index, collection) {
	      return func.call(thisArg, accumulator, value, index, collection);
	    };
	    case 5: return function(value, other, key, object, source) {
	      return func.call(thisArg, value, other, key, object, source);
	    };
	  }
	  return function() {
	    return func.apply(thisArg, arguments);
	  };
	}

	module.exports = bindCallback;


/***/ },
/* 124 */
/***/ function(module, exports) {

	/**
	 * This method returns the first argument provided to it.
	 *
	 * @static
	 * @memberOf _
	 * @category Utility
	 * @param {*} value Any value.
	 * @returns {*} Returns `value`.
	 * @example
	 *
	 * var object = { 'user': 'fred' };
	 *
	 * _.identity(object) === object;
	 * // => true
	 */
	function identity(value) {
	  return value;
	}

	module.exports = identity;


/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	var isIndex = __webpack_require__(119),
	    isLength = __webpack_require__(110),
	    isObject = __webpack_require__(115);

	/**
	 * Checks if the provided arguments are from an iteratee call.
	 *
	 * @private
	 * @param {*} value The potential iteratee value argument.
	 * @param {*} index The potential iteratee index or key argument.
	 * @param {*} object The potential iteratee object argument.
	 * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
	 */
	function isIterateeCall(value, index, object) {
	  if (!isObject(object)) {
	    return false;
	  }
	  var type = typeof index;
	  if (type == 'number') {
	    var length = object.length,
	        prereq = isLength(length) && isIndex(index, length);
	  } else {
	    prereq = type == 'string' && index in object;
	  }
	  if (prereq) {
	    var other = object[index];
	    return value === value ? (value === other) : (other !== other);
	  }
	  return false;
	}

	module.exports = isIterateeCall;


/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.9.1
	(function() {
	  var XMLBuilder, XMLDeclaration, XMLDocType, XMLElement, XMLStringifier;

	  XMLStringifier = __webpack_require__(127);

	  XMLDeclaration = __webpack_require__(128);

	  XMLDocType = __webpack_require__(163);

	  XMLElement = __webpack_require__(136);

	  module.exports = XMLBuilder = (function() {
	    function XMLBuilder(name, options) {
	      var root, temp;
	      if (name == null) {
	        throw new Error("Root element needs a name");
	      }
	      if (options == null) {
	        options = {};
	      }
	      this.options = options;
	      this.stringify = new XMLStringifier(options);
	      temp = new XMLElement(this, 'doc');
	      root = temp.element(name);
	      root.isRoot = true;
	      root.documentObject = this;
	      this.rootObject = root;
	      if (!options.headless) {
	        root.declaration(options);
	        if ((options.pubID != null) || (options.sysID != null)) {
	          root.doctype(options);
	        }
	      }
	    }

	    XMLBuilder.prototype.root = function() {
	      return this.rootObject;
	    };

	    XMLBuilder.prototype.end = function(options) {
	      return this.toString(options);
	    };

	    XMLBuilder.prototype.toString = function(options) {
	      var indent, newline, offset, pretty, r, ref, ref1, ref2;
	      pretty = (options != null ? options.pretty : void 0) || false;
	      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
	      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
	      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
	      r = '';
	      if (this.xmldec != null) {
	        r += this.xmldec.toString(options);
	      }
	      if (this.doctype != null) {
	        r += this.doctype.toString(options);
	      }
	      r += this.rootObject.toString(options);
	      if (pretty && r.slice(-newline.length) === newline) {
	        r = r.slice(0, -newline.length);
	      }
	      return r;
	    };

	    return XMLBuilder;

	  })();

	}).call(this);


/***/ },
/* 127 */
/***/ function(module, exports) {

	// Generated by CoffeeScript 1.9.1
	(function() {
	  var XMLStringifier,
	    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	    hasProp = {}.hasOwnProperty;

	  module.exports = XMLStringifier = (function() {
	    function XMLStringifier(options) {
	      this.assertLegalChar = bind(this.assertLegalChar, this);
	      var key, ref, value;
	      this.allowSurrogateChars = options != null ? options.allowSurrogateChars : void 0;
	      ref = (options != null ? options.stringify : void 0) || {};
	      for (key in ref) {
	        if (!hasProp.call(ref, key)) continue;
	        value = ref[key];
	        this[key] = value;
	      }
	    }

	    XMLStringifier.prototype.eleName = function(val) {
	      val = '' + val || '';
	      return this.assertLegalChar(val);
	    };

	    XMLStringifier.prototype.eleText = function(val) {
	      val = '' + val || '';
	      return this.assertLegalChar(this.elEscape(val));
	    };

	    XMLStringifier.prototype.cdata = function(val) {
	      val = '' + val || '';
	      if (val.match(/]]>/)) {
	        throw new Error("Invalid CDATA text: " + val);
	      }
	      return this.assertLegalChar(val);
	    };

	    XMLStringifier.prototype.comment = function(val) {
	      val = '' + val || '';
	      if (val.match(/--/)) {
	        throw new Error("Comment text cannot contain double-hypen: " + val);
	      }
	      return this.assertLegalChar(val);
	    };

	    XMLStringifier.prototype.raw = function(val) {
	      return '' + val || '';
	    };

	    XMLStringifier.prototype.attName = function(val) {
	      return '' + val || '';
	    };

	    XMLStringifier.prototype.attValue = function(val) {
	      val = '' + val || '';
	      return this.attEscape(val);
	    };

	    XMLStringifier.prototype.insTarget = function(val) {
	      return '' + val || '';
	    };

	    XMLStringifier.prototype.insValue = function(val) {
	      val = '' + val || '';
	      if (val.match(/\?>/)) {
	        throw new Error("Invalid processing instruction value: " + val);
	      }
	      return val;
	    };

	    XMLStringifier.prototype.xmlVersion = function(val) {
	      val = '' + val || '';
	      if (!val.match(/1\.[0-9]+/)) {
	        throw new Error("Invalid version number: " + val);
	      }
	      return val;
	    };

	    XMLStringifier.prototype.xmlEncoding = function(val) {
	      val = '' + val || '';
	      if (!val.match(/[A-Za-z](?:[A-Za-z0-9._-]|-)*/)) {
	        throw new Error("Invalid encoding: " + val);
	      }
	      return val;
	    };

	    XMLStringifier.prototype.xmlStandalone = function(val) {
	      if (val) {
	        return "yes";
	      } else {
	        return "no";
	      }
	    };

	    XMLStringifier.prototype.dtdPubID = function(val) {
	      return '' + val || '';
	    };

	    XMLStringifier.prototype.dtdSysID = function(val) {
	      return '' + val || '';
	    };

	    XMLStringifier.prototype.dtdElementValue = function(val) {
	      return '' + val || '';
	    };

	    XMLStringifier.prototype.dtdAttType = function(val) {
	      return '' + val || '';
	    };

	    XMLStringifier.prototype.dtdAttDefault = function(val) {
	      if (val != null) {
	        return '' + val || '';
	      } else {
	        return val;
	      }
	    };

	    XMLStringifier.prototype.dtdEntityValue = function(val) {
	      return '' + val || '';
	    };

	    XMLStringifier.prototype.dtdNData = function(val) {
	      return '' + val || '';
	    };

	    XMLStringifier.prototype.convertAttKey = '@';

	    XMLStringifier.prototype.convertPIKey = '?';

	    XMLStringifier.prototype.convertTextKey = '#text';

	    XMLStringifier.prototype.convertCDataKey = '#cdata';

	    XMLStringifier.prototype.convertCommentKey = '#comment';

	    XMLStringifier.prototype.convertRawKey = '#raw';

	    XMLStringifier.prototype.convertListKey = '#list';

	    XMLStringifier.prototype.assertLegalChar = function(str) {
	      var chars, chr;
	      if (this.allowSurrogateChars) {
	        chars = /[\u0000-\u0008\u000B-\u000C\u000E-\u001F\uFFFE-\uFFFF]/;
	      } else {
	        chars = /[\u0000-\u0008\u000B-\u000C\u000E-\u001F\uD800-\uDFFF\uFFFE-\uFFFF]/;
	      }
	      chr = str.match(chars);
	      if (chr) {
	        throw new Error("Invalid character (" + chr + ") in string: " + str + " at index " + chr.index);
	      }
	      return str;
	    };

	    XMLStringifier.prototype.elEscape = function(str) {
	      return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\r/g, '&#xD;');
	    };

	    XMLStringifier.prototype.attEscape = function(str) {
	      return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/"/g, '&quot;').replace(/\t/g, '&#x9;').replace(/\n/g, '&#xA;').replace(/\r/g, '&#xD;');
	    };

	    return XMLStringifier;

	  })();

	}).call(this);


/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.9.1
	(function() {
	  var XMLDeclaration, XMLNode, create, isObject,
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;

	  create = __webpack_require__(129);

	  isObject = __webpack_require__(115);

	  XMLNode = __webpack_require__(131);

	  module.exports = XMLDeclaration = (function(superClass) {
	    extend(XMLDeclaration, superClass);

	    function XMLDeclaration(parent, version, encoding, standalone) {
	      var ref;
	      XMLDeclaration.__super__.constructor.call(this, parent);
	      if (isObject(version)) {
	        ref = version, version = ref.version, encoding = ref.encoding, standalone = ref.standalone;
	      }
	      if (!version) {
	        version = '1.0';
	      }
	      if (version != null) {
	        this.version = this.stringify.xmlVersion(version);
	      }
	      if (encoding != null) {
	        this.encoding = this.stringify.xmlEncoding(encoding);
	      }
	      if (standalone != null) {
	        this.standalone = this.stringify.xmlStandalone(standalone);
	      }
	    }

	    XMLDeclaration.prototype.clone = function() {
	      return create(XMLDeclaration.prototype, this);
	    };

	    XMLDeclaration.prototype.toString = function(options, level) {
	      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;
	      pretty = (options != null ? options.pretty : void 0) || false;
	      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
	      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
	      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
	      level || (level = 0);
	      space = new Array(level + offset + 1).join(indent);
	      r = '';
	      if (pretty) {
	        r += space;
	      }
	      r += '<?xml';
	      if (this.version != null) {
	        r += ' version="' + this.version + '"';
	      }
	      if (this.encoding != null) {
	        r += ' encoding="' + this.encoding + '"';
	      }
	      if (this.standalone != null) {
	        r += ' standalone="' + this.standalone + '"';
	      }
	      r += '?>';
	      if (pretty) {
	        r += newline;
	      }
	      return r;
	    };

	    return XMLDeclaration;

	  })(XMLNode);

	}).call(this);


/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	var baseCopy = __webpack_require__(108),
	    baseCreate = __webpack_require__(130),
	    isIterateeCall = __webpack_require__(125),
	    keys = __webpack_require__(109);

	/**
	 * Creates an object that inherits from the given `prototype` object. If a
	 * `properties` object is provided its own enumerable properties are assigned
	 * to the created object.
	 *
	 * @static
	 * @memberOf _
	 * @category Object
	 * @param {Object} prototype The object to inherit from.
	 * @param {Object} [properties] The properties to assign to the object.
	 * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	 * @returns {Object} Returns the new object.
	 * @example
	 *
	 * function Shape() {
	 *   this.x = 0;
	 *   this.y = 0;
	 * }
	 *
	 * function Circle() {
	 *   Shape.call(this);
	 * }
	 *
	 * Circle.prototype = _.create(Shape.prototype, {
	 *   'constructor': Circle
	 * });
	 *
	 * var circle = new Circle;
	 * circle instanceof Circle;
	 * // => true
	 *
	 * circle instanceof Shape;
	 * // => true
	 */
	function create(prototype, properties, guard) {
	  var result = baseCreate(prototype);
	  if (guard && isIterateeCall(prototype, properties, guard)) {
	    properties = null;
	  }
	  return properties ? baseCopy(properties, result, keys(properties)) : result;
	}

	module.exports = create;


/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(115);

	/**
	 * The base implementation of `_.create` without support for assigning
	 * properties to the created object.
	 *
	 * @private
	 * @param {Object} prototype The object to inherit from.
	 * @returns {Object} Returns the new object.
	 */
	var baseCreate = (function() {
	  function Object() {}
	  return function(prototype) {
	    if (isObject(prototype)) {
	      Object.prototype = prototype;
	      var result = new Object;
	      Object.prototype = null;
	    }
	    return result || global.Object();
	  };
	}());

	module.exports = baseCreate;


/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.9.1
	(function() {
	  var XMLCData, XMLComment, XMLDeclaration, XMLDocType, XMLElement, XMLNode, XMLRaw, XMLText, isArray, isEmpty, isFunction, isObject,
	    hasProp = {}.hasOwnProperty;

	  isObject = __webpack_require__(115);

	  isArray = __webpack_require__(118);

	  isFunction = __webpack_require__(132);

	  isEmpty = __webpack_require__(134);

	  XMLElement = null;

	  XMLCData = null;

	  XMLComment = null;

	  XMLDeclaration = null;

	  XMLDocType = null;

	  XMLRaw = null;

	  XMLText = null;

	  module.exports = XMLNode = (function() {
	    function XMLNode(parent) {
	      this.parent = parent;
	      this.options = this.parent.options;
	      this.stringify = this.parent.stringify;
	      if (XMLElement === null) {
	        XMLElement = __webpack_require__(136);
	        XMLCData = __webpack_require__(161);
	        XMLComment = __webpack_require__(162);
	        XMLDeclaration = __webpack_require__(128);
	        XMLDocType = __webpack_require__(163);
	        XMLRaw = __webpack_require__(168);
	        XMLText = __webpack_require__(169);
	      }
	    }

	    XMLNode.prototype.clone = function() {
	      throw new Error("Cannot clone generic XMLNode");
	    };

	    XMLNode.prototype.element = function(name, attributes, text) {
	      var item, j, key, lastChild, len, ref, val;
	      lastChild = null;
	      if (attributes == null) {
	        attributes = {};
	      }
	      attributes = attributes.valueOf();
	      if (!isObject(attributes)) {
	        ref = [attributes, text], text = ref[0], attributes = ref[1];
	      }
	      if (name != null) {
	        name = name.valueOf();
	      }
	      if (isArray(name)) {
	        for (j = 0, len = name.length; j < len; j++) {
	          item = name[j];
	          lastChild = this.element(item);
	        }
	      } else if (isFunction(name)) {
	        lastChild = this.element(name.apply());
	      } else if (isObject(name)) {
	        for (key in name) {
	          if (!hasProp.call(name, key)) continue;
	          val = name[key];
	          if (isFunction(val)) {
	            val = val.apply();
	          }
	          if ((isObject(val)) && (isEmpty(val))) {
	            val = null;
	          }
	          if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) {
	            lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val);
	          } else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && key.indexOf(this.stringify.convertPIKey) === 0) {
	            lastChild = this.instruction(key.substr(this.stringify.convertPIKey.length), val);
	          } else if (isObject(val)) {
	            if (!this.options.ignoreDecorators && this.stringify.convertListKey && key.indexOf(this.stringify.convertListKey) === 0 && isArray(val)) {
	              lastChild = this.element(val);
	            } else {
	              lastChild = this.element(key);
	              lastChild.element(val);
	            }
	          } else {
	            lastChild = this.element(key, val);
	          }
	        }
	      } else {
	        if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name.indexOf(this.stringify.convertTextKey) === 0) {
	          lastChild = this.text(text);
	        } else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name.indexOf(this.stringify.convertCDataKey) === 0) {
	          lastChild = this.cdata(text);
	        } else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name.indexOf(this.stringify.convertCommentKey) === 0) {
	          lastChild = this.comment(text);
	        } else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name.indexOf(this.stringify.convertRawKey) === 0) {
	          lastChild = this.raw(text);
	        } else {
	          lastChild = this.node(name, attributes, text);
	        }
	      }
	      if (lastChild == null) {
	        throw new Error("Could not create any elements with: " + name);
	      }
	      return lastChild;
	    };

	    XMLNode.prototype.insertBefore = function(name, attributes, text) {
	      var child, i, removed;
	      if (this.isRoot) {
	        throw new Error("Cannot insert elements at root level");
	      }
	      i = this.parent.children.indexOf(this);
	      removed = this.parent.children.splice(i);
	      child = this.parent.element(name, attributes, text);
	      Array.prototype.push.apply(this.parent.children, removed);
	      return child;
	    };

	    XMLNode.prototype.insertAfter = function(name, attributes, text) {
	      var child, i, removed;
	      if (this.isRoot) {
	        throw new Error("Cannot insert elements at root level");
	      }
	      i = this.parent.children.indexOf(this);
	      removed = this.parent.children.splice(i + 1);
	      child = this.parent.element(name, attributes, text);
	      Array.prototype.push.apply(this.parent.children, removed);
	      return child;
	    };

	    XMLNode.prototype.remove = function() {
	      var i, ref;
	      if (this.isRoot) {
	        throw new Error("Cannot remove the root element");
	      }
	      i = this.parent.children.indexOf(this);
	      [].splice.apply(this.parent.children, [i, i - i + 1].concat(ref = [])), ref;
	      return this.parent;
	    };

	    XMLNode.prototype.node = function(name, attributes, text) {
	      var child, ref;
	      if (name != null) {
	        name = name.valueOf();
	      }
	      if (attributes == null) {
	        attributes = {};
	      }
	      attributes = attributes.valueOf();
	      if (!isObject(attributes)) {
	        ref = [attributes, text], text = ref[0], attributes = ref[1];
	      }
	      child = new XMLElement(this, name, attributes);
	      if (text != null) {
	        child.text(text);
	      }
	      this.children.push(child);
	      return child;
	    };

	    XMLNode.prototype.text = function(value) {
	      var child;
	      child = new XMLText(this, value);
	      this.children.push(child);
	      return this;
	    };

	    XMLNode.prototype.cdata = function(value) {
	      var child;
	      child = new XMLCData(this, value);
	      this.children.push(child);
	      return this;
	    };

	    XMLNode.prototype.comment = function(value) {
	      var child;
	      child = new XMLComment(this, value);
	      this.children.push(child);
	      return this;
	    };

	    XMLNode.prototype.raw = function(value) {
	      var child;
	      child = new XMLRaw(this, value);
	      this.children.push(child);
	      return this;
	    };

	    XMLNode.prototype.declaration = function(version, encoding, standalone) {
	      var doc, xmldec;
	      doc = this.document();
	      xmldec = new XMLDeclaration(doc, version, encoding, standalone);
	      doc.xmldec = xmldec;
	      return doc.root();
	    };

	    XMLNode.prototype.doctype = function(pubID, sysID) {
	      var doc, doctype;
	      doc = this.document();
	      doctype = new XMLDocType(doc, pubID, sysID);
	      doc.doctype = doctype;
	      return doctype;
	    };

	    XMLNode.prototype.up = function() {
	      if (this.isRoot) {
	        throw new Error("The root node has no parent. Use doc() if you need to get the document object.");
	      }
	      return this.parent;
	    };

	    XMLNode.prototype.root = function() {
	      var child;
	      if (this.isRoot) {
	        return this;
	      }
	      child = this.parent;
	      while (!child.isRoot) {
	        child = child.parent;
	      }
	      return child;
	    };

	    XMLNode.prototype.document = function() {
	      return this.root().documentObject;
	    };

	    XMLNode.prototype.end = function(options) {
	      return this.document().toString(options);
	    };

	    XMLNode.prototype.prev = function() {
	      var i;
	      if (this.isRoot) {
	        throw new Error("Root node has no siblings");
	      }
	      i = this.parent.children.indexOf(this);
	      if (i < 1) {
	        throw new Error("Already at the first node");
	      }
	      return this.parent.children[i - 1];
	    };

	    XMLNode.prototype.next = function() {
	      var i;
	      if (this.isRoot) {
	        throw new Error("Root node has no siblings");
	      }
	      i = this.parent.children.indexOf(this);
	      if (i === -1 || i === this.parent.children.length - 1) {
	        throw new Error("Already at the last node");
	      }
	      return this.parent.children[i + 1];
	    };

	    XMLNode.prototype.importXMLBuilder = function(xmlbuilder) {
	      var clonedRoot;
	      clonedRoot = xmlbuilder.root().clone();
	      clonedRoot.parent = this;
	      clonedRoot.isRoot = false;
	      this.children.push(clonedRoot);
	      return this;
	    };

	    XMLNode.prototype.ele = function(name, attributes, text) {
	      return this.element(name, attributes, text);
	    };

	    XMLNode.prototype.nod = function(name, attributes, text) {
	      return this.node(name, attributes, text);
	    };

	    XMLNode.prototype.txt = function(value) {
	      return this.text(value);
	    };

	    XMLNode.prototype.dat = function(value) {
	      return this.cdata(value);
	    };

	    XMLNode.prototype.com = function(value) {
	      return this.comment(value);
	    };

	    XMLNode.prototype.doc = function() {
	      return this.document();
	    };

	    XMLNode.prototype.dec = function(version, encoding, standalone) {
	      return this.declaration(version, encoding, standalone);
	    };

	    XMLNode.prototype.dtd = function(pubID, sysID) {
	      return this.doctype(pubID, sysID);
	    };

	    XMLNode.prototype.e = function(name, attributes, text) {
	      return this.element(name, attributes, text);
	    };

	    XMLNode.prototype.n = function(name, attributes, text) {
	      return this.node(name, attributes, text);
	    };

	    XMLNode.prototype.t = function(value) {
	      return this.text(value);
	    };

	    XMLNode.prototype.d = function(value) {
	      return this.cdata(value);
	    };

	    XMLNode.prototype.c = function(value) {
	      return this.comment(value);
	    };

	    XMLNode.prototype.r = function(value) {
	      return this.raw(value);
	    };

	    XMLNode.prototype.u = function() {
	      return this.up();
	    };

	    return XMLNode;

	  })();

	}).call(this);


/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	var baseIsFunction = __webpack_require__(133),
	    isNative = __webpack_require__(111);

	/** `Object#toString` result references. */
	var funcTag = '[object Function]';

	/** Used for native method references. */
	var objectProto = Object.prototype;

	/**
	 * Used to resolve the `toStringTag` of values.
	 * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
	 * for more details.
	 */
	var objToString = objectProto.toString;

	/** Native method references. */
	var Uint8Array = isNative(Uint8Array = global.Uint8Array) && Uint8Array;

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	var isFunction = !(baseIsFunction(/x/) || (Uint8Array && !baseIsFunction(Uint8Array))) ? baseIsFunction : function(value) {
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in older versions of Chrome and Safari which return 'function' for regexes
	  // and Safari 8 equivalents which return 'object' for typed array constructors.
	  return objToString.call(value) == funcTag;
	};

	module.exports = isFunction;


/***/ },
/* 133 */
/***/ function(module, exports) {

	/**
	 * The base implementation of `_.isFunction` without support for environments
	 * with incorrect `typeof` results.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 */
	function baseIsFunction(value) {
	  // Avoid a Chakra JIT bug in compatibility modes of IE 11.
	  // See https://github.com/jashkenas/underscore/issues/1621 for more details.
	  return typeof value == 'function' || false;
	}

	module.exports = baseIsFunction;


/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	var isArguments = __webpack_require__(117),
	    isArray = __webpack_require__(118),
	    isFunction = __webpack_require__(132),
	    isLength = __webpack_require__(110),
	    isObjectLike = __webpack_require__(114),
	    isString = __webpack_require__(135),
	    keys = __webpack_require__(109);

	/**
	 * Checks if `value` is empty. A value is considered empty unless it is an
	 * `arguments` object, array, string, or jQuery-like collection with a length
	 * greater than `0` or an object with own enumerable properties.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {Array|Object|string} value The value to inspect.
	 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
	 * @example
	 *
	 * _.isEmpty(null);
	 * // => true
	 *
	 * _.isEmpty(true);
	 * // => true
	 *
	 * _.isEmpty(1);
	 * // => true
	 *
	 * _.isEmpty([1, 2, 3]);
	 * // => false
	 *
	 * _.isEmpty({ 'a': 1 });
	 * // => false
	 */
	function isEmpty(value) {
	  if (value == null) {
	    return true;
	  }
	  var length = value.length;
	  if (isLength(length) && (isArray(value) || isString(value) || isArguments(value) ||
	      (isObjectLike(value) && isFunction(value.splice)))) {
	    return !length;
	  }
	  return !keys(value).length;
	}

	module.exports = isEmpty;


/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	var isObjectLike = __webpack_require__(114);

	/** `Object#toString` result references. */
	var stringTag = '[object String]';

	/** Used for native method references. */
	var objectProto = Object.prototype;

	/**
	 * Used to resolve the `toStringTag` of values.
	 * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
	 * for more details.
	 */
	var objToString = objectProto.toString;

	/**
	 * Checks if `value` is classified as a `String` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isString('abc');
	 * // => true
	 *
	 * _.isString(1);
	 * // => false
	 */
	function isString(value) {
	  return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag) || false;
	}

	module.exports = isString;


/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.9.1
	(function() {
	  var XMLAttribute, XMLElement, XMLNode, XMLProcessingInstruction, create, every, isArray, isFunction, isObject,
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;

	  create = __webpack_require__(129);

	  isObject = __webpack_require__(115);

	  isArray = __webpack_require__(118);

	  isFunction = __webpack_require__(132);

	  every = __webpack_require__(137);

	  XMLNode = __webpack_require__(131);

	  XMLAttribute = __webpack_require__(159);

	  XMLProcessingInstruction = __webpack_require__(160);

	  module.exports = XMLElement = (function(superClass) {
	    extend(XMLElement, superClass);

	    function XMLElement(parent, name, attributes) {
	      XMLElement.__super__.constructor.call(this, parent);
	      if (name == null) {
	        throw new Error("Missing element name");
	      }
	      this.name = this.stringify.eleName(name);
	      this.children = [];
	      this.instructions = [];
	      this.attributes = {};
	      if (attributes != null) {
	        this.attribute(attributes);
	      }
	    }

	    XMLElement.prototype.clone = function() {
	      var att, attName, clonedSelf, i, len, pi, ref, ref1;
	      clonedSelf = create(XMLElement.prototype, this);
	      if (clonedSelf.isRoot) {
	        clonedSelf.documentObject = null;
	      }
	      clonedSelf.attributes = {};
	      ref = this.attributes;
	      for (attName in ref) {
	        if (!hasProp.call(ref, attName)) continue;
	        att = ref[attName];
	        clonedSelf.attributes[attName] = att.clone();
	      }
	      clonedSelf.instructions = [];
	      ref1 = this.instructions;
	      for (i = 0, len = ref1.length; i < len; i++) {
	        pi = ref1[i];
	        clonedSelf.instructions.push(pi.clone());
	      }
	      clonedSelf.children = [];
	      this.children.forEach(function(child) {
	        var clonedChild;
	        clonedChild = child.clone();
	        clonedChild.parent = clonedSelf;
	        return clonedSelf.children.push(clonedChild);
	      });
	      return clonedSelf;
	    };

	    XMLElement.prototype.attribute = function(name, value) {
	      var attName, attValue;
	      if (name != null) {
	        name = name.valueOf();
	      }
	      if (isObject(name)) {
	        for (attName in name) {
	          if (!hasProp.call(name, attName)) continue;
	          attValue = name[attName];
	          this.attribute(attName, attValue);
	        }
	      } else {
	        if (isFunction(value)) {
	          value = value.apply();
	        }
	        if (!this.options.skipNullAttributes || (value != null)) {
	          this.attributes[name] = new XMLAttribute(this, name, value);
	        }
	      }
	      return this;
	    };

	    XMLElement.prototype.removeAttribute = function(name) {
	      var attName, i, len;
	      if (name == null) {
	        throw new Error("Missing attribute name");
	      }
	      name = name.valueOf();
	      if (isArray(name)) {
	        for (i = 0, len = name.length; i < len; i++) {
	          attName = name[i];
	          delete this.attributes[attName];
	        }
	      } else {
	        delete this.attributes[name];
	      }
	      return this;
	    };

	    XMLElement.prototype.instruction = function(target, value) {
	      var i, insTarget, insValue, instruction, len;
	      if (target != null) {
	        target = target.valueOf();
	      }
	      if (value != null) {
	        value = value.valueOf();
	      }
	      if (isArray(target)) {
	        for (i = 0, len = target.length; i < len; i++) {
	          insTarget = target[i];
	          this.instruction(insTarget);
	        }
	      } else if (isObject(target)) {
	        for (insTarget in target) {
	          if (!hasProp.call(target, insTarget)) continue;
	          insValue = target[insTarget];
	          this.instruction(insTarget, insValue);
	        }
	      } else {
	        if (isFunction(value)) {
	          value = value.apply();
	        }
	        instruction = new XMLProcessingInstruction(this, target, value);
	        this.instructions.push(instruction);
	      }
	      return this;
	    };

	    XMLElement.prototype.toString = function(options, level) {
	      var att, child, i, indent, instruction, j, len, len1, name, newline, offset, pretty, r, ref, ref1, ref2, ref3, ref4, ref5, space;
	      pretty = (options != null ? options.pretty : void 0) || false;
	      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
	      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
	      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
	      level || (level = 0);
	      space = new Array(level + offset + 1).join(indent);
	      r = '';
	      ref3 = this.instructions;
	      for (i = 0, len = ref3.length; i < len; i++) {
	        instruction = ref3[i];
	        r += instruction.toString(options, level + 1);
	      }
	      if (pretty) {
	        r += space;
	      }
	      r += '<' + this.name;
	      ref4 = this.attributes;
	      for (name in ref4) {
	        if (!hasProp.call(ref4, name)) continue;
	        att = ref4[name];
	        r += att.toString(options);
	      }
	      if (this.children.length === 0 || every(this.children, function(e) {
	        return e.value === '';
	      })) {
	        r += '/>';
	        if (pretty) {
	          r += newline;
	        }
	      } else if (pretty && this.children.length === 1 && (this.children[0].value != null)) {
	        r += '>';
	        r += this.children[0].value;
	        r += '</' + this.name + '>';
	        r += newline;
	      } else {
	        r += '>';
	        if (pretty) {
	          r += newline;
	        }
	        ref5 = this.children;
	        for (j = 0, len1 = ref5.length; j < len1; j++) {
	          child = ref5[j];
	          r += child.toString(options, level + 1);
	        }
	        if (pretty) {
	          r += space;
	        }
	        r += '</' + this.name + '>';
	        if (pretty) {
	          r += newline;
	        }
	      }
	      return r;
	    };

	    XMLElement.prototype.att = function(name, value) {
	      return this.attribute(name, value);
	    };

	    XMLElement.prototype.ins = function(target, value) {
	      return this.instruction(target, value);
	    };

	    XMLElement.prototype.a = function(name, value) {
	      return this.attribute(name, value);
	    };

	    XMLElement.prototype.i = function(target, value) {
	      return this.instruction(target, value);
	    };

	    return XMLElement;

	  })(XMLNode);

	}).call(this);


/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	var arrayEvery = __webpack_require__(138),
	    baseCallback = __webpack_require__(139),
	    baseEvery = __webpack_require__(154),
	    isArray = __webpack_require__(118);

	/**
	 * Checks if `predicate` returns truthy for **all** elements of `collection`.
	 * The predicate is bound to `thisArg` and invoked with three arguments;
	 * (value, index|key, collection).
	 *
	 * If a property name is provided for `predicate` the created `_.property`
	 * style callback returns the property value of the given element.
	 *
	 * If a value is also provided for `thisArg` the created `_.matchesProperty`
	 * style callback returns `true` for elements that have a matching property
	 * value, else `false`.
	 *
	 * If an object is provided for `predicate` the created `_.matches` style
	 * callback returns `true` for elements that have the properties of the given
	 * object, else `false`.
	 *
	 * @static
	 * @memberOf _
	 * @alias all
	 * @category Collection
	 * @param {Array|Object|string} collection The collection to iterate over.
	 * @param {Function|Object|string} [predicate=_.identity] The function invoked
	 *  per iteration.
	 * @param {*} [thisArg] The `this` binding of `predicate`.
	 * @returns {boolean} Returns `true` if all elements pass the predicate check,
	 *  else `false`.
	 * @example
	 *
	 * _.every([true, 1, null, 'yes'], Boolean);
	 * // => false
	 *
	 * var users = [
	 *   { 'user': 'barney', 'active': false },
	 *   { 'user': 'fred',   'active': false }
	 * ];
	 *
	 * // using the `_.matches` callback shorthand
	 * _.every(users, { 'user': 'barney', 'active': false });
	 * // => false
	 *
	 * // using the `_.matchesProperty` callback shorthand
	 * _.every(users, 'active', false);
	 * // => true
	 *
	 * // using the `_.property` callback shorthand
	 * _.every(users, 'active');
	 * // => false
	 */
	function every(collection, predicate, thisArg) {
	  var func = isArray(collection) ? arrayEvery : baseEvery;
	  if (typeof predicate != 'function' || typeof thisArg != 'undefined') {
	    predicate = baseCallback(predicate, thisArg, 3);
	  }
	  return func(collection, predicate);
	}

	module.exports = every;


/***/ },
/* 138 */
/***/ function(module, exports) {

	/**
	 * A specialized version of `_.every` for arrays without support for callback
	 * shorthands or `this` binding.
	 *
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {boolean} Returns `true` if all elements pass the predicate check,
	 *  else `false`.
	 */
	function arrayEvery(array, predicate) {
	  var index = -1,
	      length = array.length;

	  while (++index < length) {
	    if (!predicate(array[index], index, array)) {
	      return false;
	    }
	  }
	  return true;
	}

	module.exports = arrayEvery;


/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	var baseMatches = __webpack_require__(140),
	    baseMatchesProperty = __webpack_require__(149),
	    baseProperty = __webpack_require__(150),
	    bindCallback = __webpack_require__(123),
	    identity = __webpack_require__(124),
	    isBindable = __webpack_require__(151);

	/**
	 * The base implementation of `_.callback` which supports specifying the
	 * number of arguments to provide to `func`.
	 *
	 * @private
	 * @param {*} [func=_.identity] The value to convert to a callback.
	 * @param {*} [thisArg] The `this` binding of `func`.
	 * @param {number} [argCount] The number of arguments to provide to `func`.
	 * @returns {Function} Returns the callback.
	 */
	function baseCallback(func, thisArg, argCount) {
	  var type = typeof func;
	  if (type == 'function') {
	    return (typeof thisArg != 'undefined' && isBindable(func))
	      ? bindCallback(func, thisArg, argCount)
	      : func;
	  }
	  if (func == null) {
	    return identity;
	  }
	  if (type == 'object') {
	    return baseMatches(func);
	  }
	  return typeof thisArg == 'undefined'
	    ? baseProperty(func + '')
	    : baseMatchesProperty(func + '', thisArg);
	}

	module.exports = baseCallback;


/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	var baseIsMatch = __webpack_require__(141),
	    isStrictComparable = __webpack_require__(148),
	    keys = __webpack_require__(109);

	/** Used for native method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * The base implementation of `_.matches` which does not clone `source`.
	 *
	 * @private
	 * @param {Object} source The object of property values to match.
	 * @returns {Function} Returns the new function.
	 */
	function baseMatches(source) {
	  var props = keys(source),
	      length = props.length;

	  if (length == 1) {
	    var key = props[0],
	        value = source[key];

	    if (isStrictComparable(value)) {
	      return function(object) {
	        return object != null && object[key] === value && hasOwnProperty.call(object, key);
	      };
	    }
	  }
	  var values = Array(length),
	      strictCompareFlags = Array(length);

	  while (length--) {
	    value = source[props[length]];
	    values[length] = value;
	    strictCompareFlags[length] = isStrictComparable(value);
	  }
	  return function(object) {
	    return baseIsMatch(object, props, values, strictCompareFlags);
	  };
	}

	module.exports = baseMatches;


/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	var baseIsEqual = __webpack_require__(142);

	/** Used for native method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * The base implementation of `_.isMatch` without support for callback
	 * shorthands or `this` binding.
	 *
	 * @private
	 * @param {Object} object The object to inspect.
	 * @param {Array} props The source property names to match.
	 * @param {Array} values The source values to match.
	 * @param {Array} strictCompareFlags Strict comparison flags for source values.
	 * @param {Function} [customizer] The function to customize comparing objects.
	 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	 */
	function baseIsMatch(object, props, values, strictCompareFlags, customizer) {
	  var length = props.length;
	  if (object == null) {
	    return !length;
	  }
	  var index = -1,
	      noCustomizer = !customizer;

	  while (++index < length) {
	    if ((noCustomizer && strictCompareFlags[index])
	          ? values[index] !== object[props[index]]
	          : !hasOwnProperty.call(object, props[index])
	        ) {
	      return false;
	    }
	  }
	  index = -1;
	  while (++index < length) {
	    var key = props[index];
	    if (noCustomizer && strictCompareFlags[index]) {
	      var result = hasOwnProperty.call(object, key);
	    } else {
	      var objValue = object[key],
	          srcValue = values[index];

	      result = customizer ? customizer(objValue, srcValue, key) : undefined;
	      if (typeof result == 'undefined') {
	        result = baseIsEqual(srcValue, objValue, customizer, true);
	      }
	    }
	    if (!result) {
	      return false;
	    }
	  }
	  return true;
	}

	module.exports = baseIsMatch;


/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	var baseIsEqualDeep = __webpack_require__(143);

	/**
	 * The base implementation of `_.isEqual` without support for `this` binding
	 * `customizer` functions.
	 *
	 * @private
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @param {Function} [customizer] The function to customize comparing values.
	 * @param {boolean} [isWhere] Specify performing partial comparisons.
	 * @param {Array} [stackA] Tracks traversed `value` objects.
	 * @param {Array} [stackB] Tracks traversed `other` objects.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 */
	function baseIsEqual(value, other, customizer, isWhere, stackA, stackB) {
	  // Exit early for identical values.
	  if (value === other) {
	    // Treat `+0` vs. `-0` as not equal.
	    return value !== 0 || (1 / value == 1 / other);
	  }
	  var valType = typeof value,
	      othType = typeof other;

	  // Exit early for unlike primitive values.
	  if ((valType != 'function' && valType != 'object' && othType != 'function' && othType != 'object') ||
	      value == null || other == null) {
	    // Return `false` unless both values are `NaN`.
	    return value !== value && other !== other;
	  }
	  return baseIsEqualDeep(value, other, baseIsEqual, customizer, isWhere, stackA, stackB);
	}

	module.exports = baseIsEqual;


/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	var equalArrays = __webpack_require__(144),
	    equalByTag = __webpack_require__(145),
	    equalObjects = __webpack_require__(146),
	    isArray = __webpack_require__(118),
	    isTypedArray = __webpack_require__(147);

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    objectTag = '[object Object]';

	/** Used for native method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the `toStringTag` of values.
	 * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
	 * for more details.
	 */
	var objToString = objectProto.toString;

	/**
	 * A specialized version of `baseIsEqual` for arrays and objects which performs
	 * deep comparisons and tracks traversed objects enabling objects with circular
	 * references to be compared.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Function} [customizer] The function to customize comparing objects.
	 * @param {boolean} [isWhere] Specify performing partial comparisons.
	 * @param {Array} [stackA=[]] Tracks traversed `value` objects.
	 * @param {Array} [stackB=[]] Tracks traversed `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function baseIsEqualDeep(object, other, equalFunc, customizer, isWhere, stackA, stackB) {
	  var objIsArr = isArray(object),
	      othIsArr = isArray(other),
	      objTag = arrayTag,
	      othTag = arrayTag;

	  if (!objIsArr) {
	    objTag = objToString.call(object);
	    if (objTag == argsTag) {
	      objTag = objectTag;
	    } else if (objTag != objectTag) {
	      objIsArr = isTypedArray(object);
	    }
	  }
	  if (!othIsArr) {
	    othTag = objToString.call(other);
	    if (othTag == argsTag) {
	      othTag = objectTag;
	    } else if (othTag != objectTag) {
	      othIsArr = isTypedArray(other);
	    }
	  }
	  var objIsObj = objTag == objectTag,
	      othIsObj = othTag == objectTag,
	      isSameTag = objTag == othTag;

	  if (isSameTag && !(objIsArr || objIsObj)) {
	    return equalByTag(object, other, objTag);
	  }
	  var valWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
	      othWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

	  if (valWrapped || othWrapped) {
	    return equalFunc(valWrapped ? object.value() : object, othWrapped ? other.value() : other, customizer, isWhere, stackA, stackB);
	  }
	  if (!isSameTag) {
	    return false;
	  }
	  // Assume cyclic values are equal.
	  // For more information on detecting circular references see https://es5.github.io/#JO.
	  stackA || (stackA = []);
	  stackB || (stackB = []);

	  var length = stackA.length;
	  while (length--) {
	    if (stackA[length] == object) {
	      return stackB[length] == other;
	    }
	  }
	  // Add `object` and `other` to the stack of traversed objects.
	  stackA.push(object);
	  stackB.push(other);

	  var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isWhere, stackA, stackB);

	  stackA.pop();
	  stackB.pop();

	  return result;
	}

	module.exports = baseIsEqualDeep;


/***/ },
/* 144 */
/***/ function(module, exports) {

	/**
	 * A specialized version of `baseIsEqualDeep` for arrays with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Array} array The array to compare.
	 * @param {Array} other The other array to compare.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Function} [customizer] The function to customize comparing arrays.
	 * @param {boolean} [isWhere] Specify performing partial comparisons.
	 * @param {Array} [stackA] Tracks traversed `value` objects.
	 * @param {Array} [stackB] Tracks traversed `other` objects.
	 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	 */
	function equalArrays(array, other, equalFunc, customizer, isWhere, stackA, stackB) {
	  var index = -1,
	      arrLength = array.length,
	      othLength = other.length,
	      result = true;

	  if (arrLength != othLength && !(isWhere && othLength > arrLength)) {
	    return false;
	  }
	  // Deep compare the contents, ignoring non-numeric properties.
	  while (result && ++index < arrLength) {
	    var arrValue = array[index],
	        othValue = other[index];

	    result = undefined;
	    if (customizer) {
	      result = isWhere
	        ? customizer(othValue, arrValue, index)
	        : customizer(arrValue, othValue, index);
	    }
	    if (typeof result == 'undefined') {
	      // Recursively compare arrays (susceptible to call stack limits).
	      if (isWhere) {
	        var othIndex = othLength;
	        while (othIndex--) {
	          othValue = other[othIndex];
	          result = (arrValue && arrValue === othValue) || equalFunc(arrValue, othValue, customizer, isWhere, stackA, stackB);
	          if (result) {
	            break;
	          }
	        }
	      } else {
	        result = (arrValue && arrValue === othValue) || equalFunc(arrValue, othValue, customizer, isWhere, stackA, stackB);
	      }
	    }
	  }
	  return !!result;
	}

	module.exports = equalArrays;


/***/ },
/* 145 */
/***/ function(module, exports) {

	/** `Object#toString` result references. */
	var boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    numberTag = '[object Number]',
	    regexpTag = '[object RegExp]',
	    stringTag = '[object String]';

	/**
	 * A specialized version of `baseIsEqualDeep` for comparing objects of
	 * the same `toStringTag`.
	 *
	 * **Note:** This function only supports comparing values with tags of
	 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	 *
	 * @private
	 * @param {Object} value The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {string} tag The `toStringTag` of the objects to compare.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalByTag(object, other, tag) {
	  switch (tag) {
	    case boolTag:
	    case dateTag:
	      // Coerce dates and booleans to numbers, dates to milliseconds and booleans
	      // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.
	      return +object == +other;

	    case errorTag:
	      return object.name == other.name && object.message == other.message;

	    case numberTag:
	      // Treat `NaN` vs. `NaN` as equal.
	      return (object != +object)
	        ? other != +other
	        // But, treat `-0` vs. `+0` as not equal.
	        : (object == 0 ? ((1 / object) == (1 / other)) : object == +other);

	    case regexpTag:
	    case stringTag:
	      // Coerce regexes to strings and treat strings primitives and string
	      // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.
	      return object == (other + '');
	  }
	  return false;
	}

	module.exports = equalByTag;


/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	var keys = __webpack_require__(109);

	/** Used for native method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * A specialized version of `baseIsEqualDeep` for objects with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Function} [customizer] The function to customize comparing values.
	 * @param {boolean} [isWhere] Specify performing partial comparisons.
	 * @param {Array} [stackA] Tracks traversed `value` objects.
	 * @param {Array} [stackB] Tracks traversed `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalObjects(object, other, equalFunc, customizer, isWhere, stackA, stackB) {
	  var objProps = keys(object),
	      objLength = objProps.length,
	      othProps = keys(other),
	      othLength = othProps.length;

	  if (objLength != othLength && !isWhere) {
	    return false;
	  }
	  var hasCtor,
	      index = -1;

	  while (++index < objLength) {
	    var key = objProps[index],
	        result = hasOwnProperty.call(other, key);

	    if (result) {
	      var objValue = object[key],
	          othValue = other[key];

	      result = undefined;
	      if (customizer) {
	        result = isWhere
	          ? customizer(othValue, objValue, key)
	          : customizer(objValue, othValue, key);
	      }
	      if (typeof result == 'undefined') {
	        // Recursively compare objects (susceptible to call stack limits).
	        result = (objValue && objValue === othValue) || equalFunc(objValue, othValue, customizer, isWhere, stackA, stackB);
	      }
	    }
	    if (!result) {
	      return false;
	    }
	    hasCtor || (hasCtor = key == 'constructor');
	  }
	  if (!hasCtor) {
	    var objCtor = object.constructor,
	        othCtor = other.constructor;

	    // Non `Object` object instances with different constructors are not equal.
	    if (objCtor != othCtor &&
	        ('constructor' in object && 'constructor' in other) &&
	        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
	          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	      return false;
	    }
	  }
	  return true;
	}

	module.exports = equalObjects;


/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	var isLength = __webpack_require__(110),
	    isObjectLike = __webpack_require__(114);

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    funcTag = '[object Function]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    objectTag = '[object Object]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    weakMapTag = '[object WeakMap]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';

	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
	typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	typedArrayTags[dateTag] = typedArrayTags[errorTag] =
	typedArrayTags[funcTag] = typedArrayTags[mapTag] =
	typedArrayTags[numberTag] = typedArrayTags[objectTag] =
	typedArrayTags[regexpTag] = typedArrayTags[setTag] =
	typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

	/** Used for native method references. */
	var objectProto = Object.prototype;

	/**
	 * Used to resolve the `toStringTag` of values.
	 * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
	 * for more details.
	 */
	var objToString = objectProto.toString;

	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */
	function isTypedArray(value) {
	  return (isObjectLike(value) && isLength(value.length) && typedArrayTags[objToString.call(value)]) || false;
	}

	module.exports = isTypedArray;


/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(115);

	/**
	 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` if suitable for strict
	 *  equality comparisons, else `false`.
	 */
	function isStrictComparable(value) {
	  return value === value && (value === 0 ? ((1 / value) > 0) : !isObject(value));
	}

	module.exports = isStrictComparable;


/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	var baseIsEqual = __webpack_require__(142),
	    isStrictComparable = __webpack_require__(148);

	/**
	 * The base implementation of `_.matchesProperty` which does not coerce `key`
	 * to a string.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @param {*} value The value to compare.
	 * @returns {Function} Returns the new function.
	 */
	function baseMatchesProperty(key, value) {
	  if (isStrictComparable(value)) {
	    return function(object) {
	      return object != null && object[key] === value;
	    };
	  }
	  return function(object) {
	    return object != null && baseIsEqual(value, object[key], null, true);
	  };
	}

	module.exports = baseMatchesProperty;


/***/ },
/* 150 */
/***/ function(module, exports) {

	/**
	 * The base implementation of `_.property` which does not coerce `key` to a string.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @returns {Function} Returns the new function.
	 */
	function baseProperty(key) {
	  return function(object) {
	    return object == null ? undefined : object[key];
	  };
	}

	module.exports = baseProperty;


/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	var baseSetData = __webpack_require__(152),
	    isNative = __webpack_require__(111),
	    support = __webpack_require__(121);

	/** Used to detect named functions. */
	var reFuncName = /^\s*function[ \n\r\t]+\w/;

	/** Used to detect functions containing a `this` reference. */
	var reThis = /\bthis\b/;

	/** Used to resolve the decompiled source of functions. */
	var fnToString = Function.prototype.toString;

	/**
	 * Checks if `func` is eligible for `this` binding.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is eligible, else `false`.
	 */
	function isBindable(func) {
	  var result = !(support.funcNames ? func.name : support.funcDecomp);

	  if (!result) {
	    var source = fnToString.call(func);
	    if (!support.funcNames) {
	      result = !reFuncName.test(source);
	    }
	    if (!result) {
	      // Check if `func` references the `this` keyword and store the result.
	      result = reThis.test(source) || isNative(func);
	      baseSetData(func, result);
	    }
	  }
	  return result;
	}

	module.exports = isBindable;


/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	var identity = __webpack_require__(124),
	    metaMap = __webpack_require__(153);

	/**
	 * The base implementation of `setData` without support for hot loop detection.
	 *
	 * @private
	 * @param {Function} func The function to associate metadata with.
	 * @param {*} data The metadata.
	 * @returns {Function} Returns `func`.
	 */
	var baseSetData = !metaMap ? identity : function(func, data) {
	  metaMap.set(func, data);
	  return func;
	};

	module.exports = baseSetData;


/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	var isNative = __webpack_require__(111);

	/** Native method references. */
	var WeakMap = isNative(WeakMap = global.WeakMap) && WeakMap;

	/** Used to store function metadata. */
	var metaMap = WeakMap && new WeakMap;

	module.exports = metaMap;


/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	var baseEach = __webpack_require__(155);

	/**
	 * The base implementation of `_.every` without support for callback
	 * shorthands or `this` binding.
	 *
	 * @private
	 * @param {Array|Object|string} collection The collection to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {boolean} Returns `true` if all elements pass the predicate check,
	 *  else `false`
	 */
	function baseEvery(collection, predicate) {
	  var result = true;
	  baseEach(collection, function(value, index, collection) {
	    result = !!predicate(value, index, collection);
	    return result;
	  });
	  return result;
	}

	module.exports = baseEvery;


/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	var baseForOwn = __webpack_require__(156),
	    isLength = __webpack_require__(110),
	    toObject = __webpack_require__(158);

	/**
	 * The base implementation of `_.forEach` without support for callback
	 * shorthands and `this` binding.
	 *
	 * @private
	 * @param {Array|Object|string} collection The collection to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array|Object|string} Returns `collection`.
	 */
	function baseEach(collection, iteratee) {
	  var length = collection ? collection.length : 0;
	  if (!isLength(length)) {
	    return baseForOwn(collection, iteratee);
	  }
	  var index = -1,
	      iterable = toObject(collection);

	  while (++index < length) {
	    if (iteratee(iterable[index], index, iterable) === false) {
	      break;
	    }
	  }
	  return collection;
	}

	module.exports = baseEach;


/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	var baseFor = __webpack_require__(157),
	    keys = __webpack_require__(109);

	/**
	 * The base implementation of `_.forOwn` without support for callback
	 * shorthands and `this` binding.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Object} Returns `object`.
	 */
	function baseForOwn(object, iteratee) {
	  return baseFor(object, iteratee, keys);
	}

	module.exports = baseForOwn;


/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	var toObject = __webpack_require__(158);

	/**
	 * The base implementation of `baseForIn` and `baseForOwn` which iterates
	 * over `object` properties returned by `keysFunc` invoking `iteratee` for
	 * each property. Iterator functions may exit iteration early by explicitly
	 * returning `false`.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @returns {Object} Returns `object`.
	 */
	function baseFor(object, iteratee, keysFunc) {
	  var index = -1,
	      iterable = toObject(object),
	      props = keysFunc(object),
	      length = props.length;

	  while (++index < length) {
	    var key = props[index];
	    if (iteratee(iterable[key], key, iterable) === false) {
	      break;
	    }
	  }
	  return object;
	}

	module.exports = baseFor;


/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(115);

	/**
	 * Converts `value` to an object if it is not one.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {Object} Returns the object.
	 */
	function toObject(value) {
	  return isObject(value) ? value : Object(value);
	}

	module.exports = toObject;


/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.9.1
	(function() {
	  var XMLAttribute, create;

	  create = __webpack_require__(129);

	  module.exports = XMLAttribute = (function() {
	    function XMLAttribute(parent, name, value) {
	      this.stringify = parent.stringify;
	      if (name == null) {
	        throw new Error("Missing attribute name of element " + parent.name);
	      }
	      if (value == null) {
	        throw new Error("Missing attribute value for attribute " + name + " of element " + parent.name);
	      }
	      this.name = this.stringify.attName(name);
	      this.value = this.stringify.attValue(value);
	    }

	    XMLAttribute.prototype.clone = function() {
	      return create(XMLAttribute.prototype, this);
	    };

	    XMLAttribute.prototype.toString = function(options, level) {
	      return ' ' + this.name + '="' + this.value + '"';
	    };

	    return XMLAttribute;

	  })();

	}).call(this);


/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.9.1
	(function() {
	  var XMLProcessingInstruction, create;

	  create = __webpack_require__(129);

	  module.exports = XMLProcessingInstruction = (function() {
	    function XMLProcessingInstruction(parent, target, value) {
	      this.stringify = parent.stringify;
	      if (target == null) {
	        throw new Error("Missing instruction target");
	      }
	      this.target = this.stringify.insTarget(target);
	      if (value) {
	        this.value = this.stringify.insValue(value);
	      }
	    }

	    XMLProcessingInstruction.prototype.clone = function() {
	      return create(XMLProcessingInstruction.prototype, this);
	    };

	    XMLProcessingInstruction.prototype.toString = function(options, level) {
	      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;
	      pretty = (options != null ? options.pretty : void 0) || false;
	      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
	      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
	      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
	      level || (level = 0);
	      space = new Array(level + offset + 1).join(indent);
	      r = '';
	      if (pretty) {
	        r += space;
	      }
	      r += '<?';
	      r += this.target;
	      if (this.value) {
	        r += ' ' + this.value;
	      }
	      r += '?>';
	      if (pretty) {
	        r += newline;
	      }
	      return r;
	    };

	    return XMLProcessingInstruction;

	  })();

	}).call(this);


/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.9.1
	(function() {
	  var XMLCData, XMLNode, create,
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;

	  create = __webpack_require__(129);

	  XMLNode = __webpack_require__(131);

	  module.exports = XMLCData = (function(superClass) {
	    extend(XMLCData, superClass);

	    function XMLCData(parent, text) {
	      XMLCData.__super__.constructor.call(this, parent);
	      if (text == null) {
	        throw new Error("Missing CDATA text");
	      }
	      this.text = this.stringify.cdata(text);
	    }

	    XMLCData.prototype.clone = function() {
	      return create(XMLCData.prototype, this);
	    };

	    XMLCData.prototype.toString = function(options, level) {
	      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;
	      pretty = (options != null ? options.pretty : void 0) || false;
	      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
	      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
	      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
	      level || (level = 0);
	      space = new Array(level + offset + 1).join(indent);
	      r = '';
	      if (pretty) {
	        r += space;
	      }
	      r += '<![CDATA[' + this.text + ']]>';
	      if (pretty) {
	        r += newline;
	      }
	      return r;
	    };

	    return XMLCData;

	  })(XMLNode);

	}).call(this);


/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.9.1
	(function() {
	  var XMLComment, XMLNode, create,
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;

	  create = __webpack_require__(129);

	  XMLNode = __webpack_require__(131);

	  module.exports = XMLComment = (function(superClass) {
	    extend(XMLComment, superClass);

	    function XMLComment(parent, text) {
	      XMLComment.__super__.constructor.call(this, parent);
	      if (text == null) {
	        throw new Error("Missing comment text");
	      }
	      this.text = this.stringify.comment(text);
	    }

	    XMLComment.prototype.clone = function() {
	      return create(XMLComment.prototype, this);
	    };

	    XMLComment.prototype.toString = function(options, level) {
	      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;
	      pretty = (options != null ? options.pretty : void 0) || false;
	      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
	      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
	      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
	      level || (level = 0);
	      space = new Array(level + offset + 1).join(indent);
	      r = '';
	      if (pretty) {
	        r += space;
	      }
	      r += '<!-- ' + this.text + ' -->';
	      if (pretty) {
	        r += newline;
	      }
	      return r;
	    };

	    return XMLComment;

	  })(XMLNode);

	}).call(this);


/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.9.1
	(function() {
	  var XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDocType, XMLProcessingInstruction, create, isObject;

	  create = __webpack_require__(129);

	  isObject = __webpack_require__(115);

	  XMLCData = __webpack_require__(161);

	  XMLComment = __webpack_require__(162);

	  XMLDTDAttList = __webpack_require__(164);

	  XMLDTDEntity = __webpack_require__(165);

	  XMLDTDElement = __webpack_require__(166);

	  XMLDTDNotation = __webpack_require__(167);

	  XMLProcessingInstruction = __webpack_require__(160);

	  module.exports = XMLDocType = (function() {
	    function XMLDocType(parent, pubID, sysID) {
	      var ref, ref1;
	      this.documentObject = parent;
	      this.stringify = this.documentObject.stringify;
	      this.children = [];
	      if (isObject(pubID)) {
	        ref = pubID, pubID = ref.pubID, sysID = ref.sysID;
	      }
	      if (sysID == null) {
	        ref1 = [pubID, sysID], sysID = ref1[0], pubID = ref1[1];
	      }
	      if (pubID != null) {
	        this.pubID = this.stringify.dtdPubID(pubID);
	      }
	      if (sysID != null) {
	        this.sysID = this.stringify.dtdSysID(sysID);
	      }
	    }

	    XMLDocType.prototype.clone = function() {
	      return create(XMLDocType.prototype, this);
	    };

	    XMLDocType.prototype.element = function(name, value) {
	      var child;
	      child = new XMLDTDElement(this, name, value);
	      this.children.push(child);
	      return this;
	    };

	    XMLDocType.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
	      var child;
	      child = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
	      this.children.push(child);
	      return this;
	    };

	    XMLDocType.prototype.entity = function(name, value) {
	      var child;
	      child = new XMLDTDEntity(this, false, name, value);
	      this.children.push(child);
	      return this;
	    };

	    XMLDocType.prototype.pEntity = function(name, value) {
	      var child;
	      child = new XMLDTDEntity(this, true, name, value);
	      this.children.push(child);
	      return this;
	    };

	    XMLDocType.prototype.notation = function(name, value) {
	      var child;
	      child = new XMLDTDNotation(this, name, value);
	      this.children.push(child);
	      return this;
	    };

	    XMLDocType.prototype.cdata = function(value) {
	      var child;
	      child = new XMLCData(this, value);
	      this.children.push(child);
	      return this;
	    };

	    XMLDocType.prototype.comment = function(value) {
	      var child;
	      child = new XMLComment(this, value);
	      this.children.push(child);
	      return this;
	    };

	    XMLDocType.prototype.instruction = function(target, value) {
	      var child;
	      child = new XMLProcessingInstruction(this, target, value);
	      this.children.push(child);
	      return this;
	    };

	    XMLDocType.prototype.root = function() {
	      return this.documentObject.root();
	    };

	    XMLDocType.prototype.document = function() {
	      return this.documentObject;
	    };

	    XMLDocType.prototype.toString = function(options, level) {
	      var child, i, indent, len, newline, offset, pretty, r, ref, ref1, ref2, ref3, space;
	      pretty = (options != null ? options.pretty : void 0) || false;
	      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
	      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
	      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
	      level || (level = 0);
	      space = new Array(level + offset + 1).join(indent);
	      r = '';
	      if (pretty) {
	        r += space;
	      }
	      r += '<!DOCTYPE ' + this.root().name;
	      if (this.pubID && this.sysID) {
	        r += ' PUBLIC "' + this.pubID + '" "' + this.sysID + '"';
	      } else if (this.sysID) {
	        r += ' SYSTEM "' + this.sysID + '"';
	      }
	      if (this.children.length > 0) {
	        r += ' [';
	        if (pretty) {
	          r += newline;
	        }
	        ref3 = this.children;
	        for (i = 0, len = ref3.length; i < len; i++) {
	          child = ref3[i];
	          r += child.toString(options, level + 1);
	        }
	        r += ']';
	      }
	      r += '>';
	      if (pretty) {
	        r += newline;
	      }
	      return r;
	    };

	    XMLDocType.prototype.ele = function(name, value) {
	      return this.element(name, value);
	    };

	    XMLDocType.prototype.att = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
	      return this.attList(elementName, attributeName, attributeType, defaultValueType, defaultValue);
	    };

	    XMLDocType.prototype.ent = function(name, value) {
	      return this.entity(name, value);
	    };

	    XMLDocType.prototype.pent = function(name, value) {
	      return this.pEntity(name, value);
	    };

	    XMLDocType.prototype.not = function(name, value) {
	      return this.notation(name, value);
	    };

	    XMLDocType.prototype.dat = function(value) {
	      return this.cdata(value);
	    };

	    XMLDocType.prototype.com = function(value) {
	      return this.comment(value);
	    };

	    XMLDocType.prototype.ins = function(target, value) {
	      return this.instruction(target, value);
	    };

	    XMLDocType.prototype.up = function() {
	      return this.root();
	    };

	    XMLDocType.prototype.doc = function() {
	      return this.document();
	    };

	    return XMLDocType;

	  })();

	}).call(this);


/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.9.1
	(function() {
	  var XMLDTDAttList, create;

	  create = __webpack_require__(129);

	  module.exports = XMLDTDAttList = (function() {
	    function XMLDTDAttList(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {
	      this.stringify = parent.stringify;
	      if (elementName == null) {
	        throw new Error("Missing DTD element name");
	      }
	      if (attributeName == null) {
	        throw new Error("Missing DTD attribute name");
	      }
	      if (!attributeType) {
	        throw new Error("Missing DTD attribute type");
	      }
	      if (!defaultValueType) {
	        throw new Error("Missing DTD attribute default");
	      }
	      if (defaultValueType.indexOf('#') !== 0) {
	        defaultValueType = '#' + defaultValueType;
	      }
	      if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) {
	        throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT");
	      }
	      if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) {
	        throw new Error("Default value only applies to #FIXED or #DEFAULT");
	      }
	      this.elementName = this.stringify.eleName(elementName);
	      this.attributeName = this.stringify.attName(attributeName);
	      this.attributeType = this.stringify.dtdAttType(attributeType);
	      this.defaultValue = this.stringify.dtdAttDefault(defaultValue);
	      this.defaultValueType = defaultValueType;
	    }

	    XMLDTDAttList.prototype.clone = function() {
	      return create(XMLDTDAttList.prototype, this);
	    };

	    XMLDTDAttList.prototype.toString = function(options, level) {
	      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;
	      pretty = (options != null ? options.pretty : void 0) || false;
	      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
	      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
	      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
	      level || (level = 0);
	      space = new Array(level + offset + 1).join(indent);
	      r = '';
	      if (pretty) {
	        r += space;
	      }
	      r += '<!ATTLIST ' + this.elementName + ' ' + this.attributeName + ' ' + this.attributeType;
	      if (this.defaultValueType !== '#DEFAULT') {
	        r += ' ' + this.defaultValueType;
	      }
	      if (this.defaultValue) {
	        r += ' "' + this.defaultValue + '"';
	      }
	      r += '>';
	      if (pretty) {
	        r += newline;
	      }
	      return r;
	    };

	    return XMLDTDAttList;

	  })();

	}).call(this);


/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.9.1
	(function() {
	  var XMLDTDEntity, create, isObject;

	  create = __webpack_require__(129);

	  isObject = __webpack_require__(115);

	  module.exports = XMLDTDEntity = (function() {
	    function XMLDTDEntity(parent, pe, name, value) {
	      this.stringify = parent.stringify;
	      if (name == null) {
	        throw new Error("Missing entity name");
	      }
	      if (value == null) {
	        throw new Error("Missing entity value");
	      }
	      this.pe = !!pe;
	      this.name = this.stringify.eleName(name);
	      if (!isObject(value)) {
	        this.value = this.stringify.dtdEntityValue(value);
	      } else {
	        if (!value.pubID && !value.sysID) {
	          throw new Error("Public and/or system identifiers are required for an external entity");
	        }
	        if (value.pubID && !value.sysID) {
	          throw new Error("System identifier is required for a public external entity");
	        }
	        if (value.pubID != null) {
	          this.pubID = this.stringify.dtdPubID(value.pubID);
	        }
	        if (value.sysID != null) {
	          this.sysID = this.stringify.dtdSysID(value.sysID);
	        }
	        if (value.nData != null) {
	          this.nData = this.stringify.dtdNData(value.nData);
	        }
	        if (this.pe && this.nData) {
	          throw new Error("Notation declaration is not allowed in a parameter entity");
	        }
	      }
	    }

	    XMLDTDEntity.prototype.clone = function() {
	      return create(XMLDTDEntity.prototype, this);
	    };

	    XMLDTDEntity.prototype.toString = function(options, level) {
	      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;
	      pretty = (options != null ? options.pretty : void 0) || false;
	      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
	      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
	      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
	      level || (level = 0);
	      space = new Array(level + offset + 1).join(indent);
	      r = '';
	      if (pretty) {
	        r += space;
	      }
	      r += '<!ENTITY';
	      if (this.pe) {
	        r += ' %';
	      }
	      r += ' ' + this.name;
	      if (this.value) {
	        r += ' "' + this.value + '"';
	      } else {
	        if (this.pubID && this.sysID) {
	          r += ' PUBLIC "' + this.pubID + '" "' + this.sysID + '"';
	        } else if (this.sysID) {
	          r += ' SYSTEM "' + this.sysID + '"';
	        }
	        if (this.nData) {
	          r += ' NDATA ' + this.nData;
	        }
	      }
	      r += '>';
	      if (pretty) {
	        r += newline;
	      }
	      return r;
	    };

	    return XMLDTDEntity;

	  })();

	}).call(this);


/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.9.1
	(function() {
	  var XMLDTDElement, create, isArray;

	  create = __webpack_require__(129);

	  isArray = __webpack_require__(118);

	  module.exports = XMLDTDElement = (function() {
	    function XMLDTDElement(parent, name, value) {
	      this.stringify = parent.stringify;
	      if (name == null) {
	        throw new Error("Missing DTD element name");
	      }
	      if (!value) {
	        value = '(#PCDATA)';
	      }
	      if (isArray(value)) {
	        value = '(' + value.join(',') + ')';
	      }
	      this.name = this.stringify.eleName(name);
	      this.value = this.stringify.dtdElementValue(value);
	    }

	    XMLDTDElement.prototype.clone = function() {
	      return create(XMLDTDElement.prototype, this);
	    };

	    XMLDTDElement.prototype.toString = function(options, level) {
	      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;
	      pretty = (options != null ? options.pretty : void 0) || false;
	      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
	      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
	      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
	      level || (level = 0);
	      space = new Array(level + offset + 1).join(indent);
	      r = '';
	      if (pretty) {
	        r += space;
	      }
	      r += '<!ELEMENT ' + this.name + ' ' + this.value + '>';
	      if (pretty) {
	        r += newline;
	      }
	      return r;
	    };

	    return XMLDTDElement;

	  })();

	}).call(this);


/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.9.1
	(function() {
	  var XMLDTDNotation, create;

	  create = __webpack_require__(129);

	  module.exports = XMLDTDNotation = (function() {
	    function XMLDTDNotation(parent, name, value) {
	      this.stringify = parent.stringify;
	      if (name == null) {
	        throw new Error("Missing notation name");
	      }
	      if (!value.pubID && !value.sysID) {
	        throw new Error("Public or system identifiers are required for an external entity");
	      }
	      this.name = this.stringify.eleName(name);
	      if (value.pubID != null) {
	        this.pubID = this.stringify.dtdPubID(value.pubID);
	      }
	      if (value.sysID != null) {
	        this.sysID = this.stringify.dtdSysID(value.sysID);
	      }
	    }

	    XMLDTDNotation.prototype.clone = function() {
	      return create(XMLDTDNotation.prototype, this);
	    };

	    XMLDTDNotation.prototype.toString = function(options, level) {
	      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;
	      pretty = (options != null ? options.pretty : void 0) || false;
	      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
	      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
	      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
	      level || (level = 0);
	      space = new Array(level + offset + 1).join(indent);
	      r = '';
	      if (pretty) {
	        r += space;
	      }
	      r += '<!NOTATION ' + this.name;
	      if (this.pubID && this.sysID) {
	        r += ' PUBLIC "' + this.pubID + '" "' + this.sysID + '"';
	      } else if (this.pubID) {
	        r += ' PUBLIC "' + this.pubID + '"';
	      } else if (this.sysID) {
	        r += ' SYSTEM "' + this.sysID + '"';
	      }
	      r += '>';
	      if (pretty) {
	        r += newline;
	      }
	      return r;
	    };

	    return XMLDTDNotation;

	  })();

	}).call(this);


/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.9.1
	(function() {
	  var XMLNode, XMLRaw, create,
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;

	  create = __webpack_require__(129);

	  XMLNode = __webpack_require__(131);

	  module.exports = XMLRaw = (function(superClass) {
	    extend(XMLRaw, superClass);

	    function XMLRaw(parent, text) {
	      XMLRaw.__super__.constructor.call(this, parent);
	      if (text == null) {
	        throw new Error("Missing raw text");
	      }
	      this.value = this.stringify.raw(text);
	    }

	    XMLRaw.prototype.clone = function() {
	      return create(XMLRaw.prototype, this);
	    };

	    XMLRaw.prototype.toString = function(options, level) {
	      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;
	      pretty = (options != null ? options.pretty : void 0) || false;
	      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
	      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
	      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
	      level || (level = 0);
	      space = new Array(level + offset + 1).join(indent);
	      r = '';
	      if (pretty) {
	        r += space;
	      }
	      r += this.value;
	      if (pretty) {
	        r += newline;
	      }
	      return r;
	    };

	    return XMLRaw;

	  })(XMLNode);

	}).call(this);


/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.9.1
	(function() {
	  var XMLNode, XMLText, create,
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;

	  create = __webpack_require__(129);

	  XMLNode = __webpack_require__(131);

	  module.exports = XMLText = (function(superClass) {
	    extend(XMLText, superClass);

	    function XMLText(parent, text) {
	      XMLText.__super__.constructor.call(this, parent);
	      if (text == null) {
	        throw new Error("Missing element text");
	      }
	      this.value = this.stringify.eleText(text);
	    }

	    XMLText.prototype.clone = function() {
	      return create(XMLText.prototype, this);
	    };

	    XMLText.prototype.toString = function(options, level) {
	      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;
	      pretty = (options != null ? options.pretty : void 0) || false;
	      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
	      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
	      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
	      level || (level = 0);
	      space = new Array(level + offset + 1).join(indent);
	      r = '';
	      if (pretty) {
	        r += space;
	      }
	      r += this.value;
	      if (pretty) {
	        r += newline;
	      }
	      return r;
	    };

	    return XMLText;

	  })(XMLNode);

	}).call(this);


/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	var Collection = __webpack_require__(100);
	var Operation = __webpack_require__(171);
	var Shape = __webpack_require__(99);
	var Paginator = __webpack_require__(172);
	var ResourceWaiter = __webpack_require__(173);

	var util = __webpack_require__(92);
	var property = util.property;
	var memoizedProperty = util.memoizedProperty;

	function Api(api, options) {
	  api = api || {};
	  options = options || {};
	  options.api = this;

	  api.metadata = api.metadata || {};

	  property(this, 'isApi', true, false);
	  property(this, 'apiVersion', api.metadata.apiVersion);
	  property(this, 'endpointPrefix', api.metadata.endpointPrefix);
	  property(this, 'signingName', api.metadata.signingName);
	  property(this, 'globalEndpoint', api.metadata.globalEndpoint);
	  property(this, 'signatureVersion', api.metadata.signatureVersion);
	  property(this, 'jsonVersion', api.metadata.jsonVersion);
	  property(this, 'targetPrefix', api.metadata.targetPrefix);
	  property(this, 'protocol', api.metadata.protocol);
	  property(this, 'timestampFormat', api.metadata.timestampFormat);
	  property(this, 'xmlNamespaceUri', api.metadata.xmlNamespace);
	  property(this, 'abbreviation', api.metadata.serviceAbbreviation);
	  property(this, 'fullName', api.metadata.serviceFullName);

	  memoizedProperty(this, 'className', function() {
	    var name = api.metadata.serviceAbbreviation || api.metadata.serviceFullName;
	    if (!name) return null;

	    name = name.replace(/^Amazon|AWS\s*|\(.*|\s+|\W+/g, '');
	    if (name === 'ElasticLoadBalancing') name = 'ELB';
	    return name;
	  });

	  property(this, 'operations', new Collection(api.operations, options, function(name, operation) {
	    return new Operation(name, operation, options);
	  }, util.string.lowerFirst));

	  property(this, 'shapes', new Collection(api.shapes, options, function(name, shape) {
	    return Shape.create(shape, options);
	  }));

	  property(this, 'paginators', new Collection(api.paginators, options, function(name, paginator) {
	    return new Paginator(name, paginator, options);
	  }));

	  property(this, 'waiters', new Collection(api.waiters, options, function(name, waiter) {
	    return new ResourceWaiter(name, waiter, options);
	  }, util.string.lowerFirst));

	  if (options.documentation) {
	    property(this, 'documentation', api.documentation);
	    property(this, 'documentationUrl', api.documentationUrl);
	  }
	}

	module.exports = Api;


/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	var Shape = __webpack_require__(99);

	var util = __webpack_require__(92);
	var property = util.property;
	var memoizedProperty = util.memoizedProperty;

	function Operation(name, operation, options) {
	  options = options || {};

	  property(this, 'name', operation.name || name);
	  property(this, 'api', options.api, false);

	  operation.http = operation.http || {};
	  property(this, 'httpMethod', operation.http.method || 'POST');
	  property(this, 'httpPath', operation.http.requestUri || '/');
	  property(this, 'authtype', operation.authtype || '');

	  memoizedProperty(this, 'input', function() {
	    if (!operation.input) {
	      return new Shape.create({type: 'structure'}, options);
	    }
	    return Shape.create(operation.input, options);
	  });

	  memoizedProperty(this, 'output', function() {
	    if (!operation.output) {
	      return new Shape.create({type: 'structure'}, options);
	    }
	    return Shape.create(operation.output, options);
	  });

	  memoizedProperty(this, 'errors', function() {
	    var list = [];
	    if (!operation.errors) return null;

	    for (var i = 0; i < operation.errors.length; i++) {
	      list.push(Shape.create(operation.errors[i], options));
	    }

	    return list;
	  });

	  memoizedProperty(this, 'paginator', function() {
	    return options.api.paginators[name];
	  });

	  if (options.documentation) {
	    property(this, 'documentation', operation.documentation);
	    property(this, 'documentationUrl', operation.documentationUrl);
	  }
	}

	module.exports = Operation;


/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	var property = __webpack_require__(92).property;

	function Paginator(name, paginator) {
	  property(this, 'inputToken', paginator.input_token);
	  property(this, 'limitKey', paginator.limit_key);
	  property(this, 'moreResults', paginator.more_results);
	  property(this, 'outputToken', paginator.output_token);
	  property(this, 'resultKey', paginator.result_key);
	}

	module.exports = Paginator;


/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	var util = __webpack_require__(92);
	var property = util.property;

	function ResourceWaiter(name, waiter, options) {
	  options = options || {};
	  property(this, 'name', name);
	  property(this, 'api', options.api, false);

	  if (waiter.operation) {
	    property(this, 'operation', util.string.lowerFirst(waiter.operation));
	  }

	  var self = this;
	  var keys = [
	    'type',
	    'description',
	    'delay',
	    'maxAttempts',
	    'acceptors'
	  ];

	  keys.forEach(function(key) {
	    var value = waiter[key];
	    if (value) {
	      property(self, key, value);
	    }
	  });
	}

	module.exports = ResourceWaiter;


/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(93);
	var Api = __webpack_require__(170);
	var regionConfig = __webpack_require__(175);
	var inherit = AWS.util.inherit;
	var clientCount = 0;

	/**
	 * The service class representing an AWS service.
	 *
	 * @abstract
	 *
	 * @!attribute apiVersions
	 *   @return [Array<String>] the list of API versions supported by this service.
	 *   @readonly
	 */
	AWS.Service = inherit({
	  /**
	   * Create a new service object with a configuration object
	   *
	   * @param config [map] a map of configuration options
	   */
	  constructor: function Service(config) {
	    if (!this.loadServiceClass) {
	      throw AWS.util.error(new Error(),
	        'Service must be constructed with `new\' operator');
	    }
	    var ServiceClass = this.loadServiceClass(config || {});
	    if (ServiceClass) {
	      var originalConfig = AWS.util.copy(config);
	      var svc = new ServiceClass(config);
	      Object.defineProperty(svc, '_originalConfig', {
	        get: function() { return originalConfig; },
	        enumerable: false,
	        configurable: true
	      });
	      svc._clientId = ++clientCount;
	      return svc;
	    }
	    this.initialize(config);
	  },

	  /**
	   * @api private
	   */
	  initialize: function initialize(config) {
	    var svcConfig = AWS.config[this.serviceIdentifier];

	    this.config = new AWS.Config(AWS.config);
	    if (svcConfig) this.config.update(svcConfig, true);
	    if (config) this.config.update(config, true);

	    this.validateService();
	    if (!this.config.endpoint) regionConfig(this);

	    this.config.endpoint = this.endpointFromTemplate(this.config.endpoint);
	    this.setEndpoint(this.config.endpoint);
	  },

	  /**
	   * @api private
	   */
	  validateService: function validateService() {
	  },

	  /**
	   * @api private
	   */
	  loadServiceClass: function loadServiceClass(serviceConfig) {
	    var config = serviceConfig;
	    if (!AWS.util.isEmpty(this.api)) {
	      return null;
	    } else if (config.apiConfig) {
	      return AWS.Service.defineServiceApi(this.constructor, config.apiConfig);
	    } else if (!this.constructor.services) {
	      return null;
	    } else {
	      config = new AWS.Config(AWS.config);
	      config.update(serviceConfig, true);
	      var version = config.apiVersions[this.constructor.serviceIdentifier];
	      version = version || config.apiVersion;
	      return this.getLatestServiceClass(version);
	    }
	  },

	  /**
	   * @api private
	   */
	  getLatestServiceClass: function getLatestServiceClass(version) {
	    version = this.getLatestServiceVersion(version);
	    if (this.constructor.services[version] === null) {
	      AWS.Service.defineServiceApi(this.constructor, version);
	    }

	    return this.constructor.services[version];
	  },

	  /**
	   * @api private
	   */
	  getLatestServiceVersion: function getLatestServiceVersion(version) {
	    if (!this.constructor.services || this.constructor.services.length === 0) {
	      throw new Error('No services defined on ' +
	                      this.constructor.serviceIdentifier);
	    }

	    if (!version) {
	      version = 'latest';
	    } else if (AWS.util.isType(version, Date)) {
	      version = AWS.util.date.iso8601(version).split('T')[0];
	    }

	    if (Object.hasOwnProperty(this.constructor.services, version)) {
	      return version;
	    }

	    var keys = Object.keys(this.constructor.services).sort();
	    var selectedVersion = null;
	    for (var i = keys.length - 1; i >= 0; i--) {
	      // versions that end in "*" are not available on disk and can be
	      // skipped, so do not choose these as selectedVersions
	      if (keys[i][keys[i].length - 1] !== '*') {
	        selectedVersion = keys[i];
	      }
	      if (keys[i].substr(0, 10) <= version) {
	        return selectedVersion;
	      }
	    }

	    throw new Error('Could not find ' + this.constructor.serviceIdentifier +
	                    ' API to satisfy version constraint `' + version + '\'');
	  },

	  /**
	   * @api private
	   */
	  api: {},

	  /**
	   * @api private
	   */
	  defaultRetryCount: 3,

	  /**
	   * Calls an operation on a service with the given input parameters.
	   *
	   * @param operation [String] the name of the operation to call on the service.
	   * @param params [map] a map of input options for the operation
	   * @callback callback function(err, data)
	   *   If a callback is supplied, it is called when a response is returned
	   *   from the service.
	   *   @param err [Error] the error object returned from the request.
	   *     Set to `null` if the request is successful.
	   *   @param data [Object] the de-serialized data returned from
	   *     the request. Set to `null` if a request error occurs.
	   */
	  makeRequest: function makeRequest(operation, params, callback) {
	    if (typeof params === 'function') {
	      callback = params;
	      params = null;
	    }

	    params = params || {};
	    if (this.config.params) { // copy only toplevel bound params
	      var rules = this.api.operations[operation];
	      if (rules) {
	        params = AWS.util.copy(params);
	        AWS.util.each(this.config.params, function(key, value) {
	          if (rules.input.members[key]) {
	            if (params[key] === undefined || params[key] === null) {
	              params[key] = value;
	            }
	          }
	        });
	      }
	    }

	    var request = new AWS.Request(this, operation, params);
	    this.addAllRequestListeners(request);

	    if (callback) request.send(callback);
	    return request;
	  },

	  /**
	   * Calls an operation on a service with the given input parameters, without
	   * any authentication data. This method is useful for "public" API operations.
	   *
	   * @param operation [String] the name of the operation to call on the service.
	   * @param params [map] a map of input options for the operation
	   * @callback callback function(err, data)
	   *   If a callback is supplied, it is called when a response is returned
	   *   from the service.
	   *   @param err [Error] the error object returned from the request.
	   *     Set to `null` if the request is successful.
	   *   @param data [Object] the de-serialized data returned from
	   *     the request. Set to `null` if a request error occurs.
	   */
	  makeUnauthenticatedRequest: function makeUnauthenticatedRequest(operation, params, callback) {
	    if (typeof params === 'function') {
	      callback = params;
	      params = {};
	    }

	    var request = this.makeRequest(operation, params).toUnauthenticated();
	    return callback ? request.send(callback) : request;
	  },

	  /**
	   * Waits for a given state
	   *
	   * @param state [String] the state on the service to wait for
	   * @param params [map] a map of parameters to pass with each request
	   * @callback callback function(err, data)
	   *   If a callback is supplied, it is called when a response is returned
	   *   from the service.
	   *   @param err [Error] the error object returned from the request.
	   *     Set to `null` if the request is successful.
	   *   @param data [Object] the de-serialized data returned from
	   *     the request. Set to `null` if a request error occurs.
	   */
	  waitFor: function waitFor(state, params, callback) {
	    var waiter = new AWS.ResourceWaiter(this, state);
	    return waiter.wait(params, callback);
	  },

	  /**
	   * @api private
	   */
	  addAllRequestListeners: function addAllRequestListeners(request) {
	    var list = [AWS.events, AWS.EventListeners.Core, this.serviceInterface(),
	                AWS.EventListeners.CorePost];
	    for (var i = 0; i < list.length; i++) {
	      if (list[i]) request.addListeners(list[i]);
	    }

	    // disable parameter validation
	    if (!this.config.paramValidation) {
	      request.removeListener('validate',
	        AWS.EventListeners.Core.VALIDATE_PARAMETERS);
	    }

	    if (this.config.logger) { // add logging events
	      request.addListeners(AWS.EventListeners.Logger);
	    }

	    this.setupRequestListeners(request);
	  },

	  /**
	   * Override this method to setup any custom request listeners for each
	   * new request to the service.
	   *
	   * @abstract
	   */
	  setupRequestListeners: function setupRequestListeners() {
	  },

	  /**
	   * Gets the signer class for a given request
	   * @api private
	   */
	  getSignerClass: function getSignerClass() {
	    var version;
	    if (this.config.signatureVersion) {
	      version = this.config.signatureVersion;
	    } else {
	      version = this.api.signatureVersion;
	    }
	    return AWS.Signers.RequestSigner.getVersion(version);
	  },

	  /**
	   * @api private
	   */
	  serviceInterface: function serviceInterface() {
	    switch (this.api.protocol) {
	      case 'ec2': return AWS.EventListeners.Query;
	      case 'query': return AWS.EventListeners.Query;
	      case 'json': return AWS.EventListeners.Json;
	      case 'rest-json': return AWS.EventListeners.RestJson;
	      case 'rest-xml': return AWS.EventListeners.RestXml;
	    }
	    if (this.api.protocol) {
	      throw new Error('Invalid service `protocol\' ' +
	        this.api.protocol + ' in API config');
	    }
	  },

	  /**
	   * @api private
	   */
	  successfulResponse: function successfulResponse(resp) {
	    return resp.httpResponse.statusCode < 300;
	  },

	  /**
	   * How many times a failed request should be retried before giving up.
	   * the defaultRetryCount can be overriden by service classes.
	   *
	   * @api private
	   */
	  numRetries: function numRetries() {
	    if (this.config.maxRetries !== undefined) {
	      return this.config.maxRetries;
	    } else {
	      return this.defaultRetryCount;
	    }
	  },

	  /**
	   * @api private
	   */
	  retryDelays: function retryDelays(retryCount) {
	    return AWS.util.calculateRetryDelay(retryCount, this.config.retryDelayOptions);
	  },

	  /**
	   * @api private
	   */
	  retryableError: function retryableError(error) {
	    if (this.networkingError(error)) return true;
	    if (this.expiredCredentialsError(error)) return true;
	    if (this.throttledError(error)) return true;
	    if (error.statusCode >= 500) return true;
	    return false;
	  },

	  /**
	   * @api private
	   */
	  networkingError: function networkingError(error) {
	    return error.code === 'NetworkingError';
	  },

	  /**
	   * @api private
	   */
	  expiredCredentialsError: function expiredCredentialsError(error) {
	    // TODO : this only handles *one* of the expired credential codes
	    return (error.code === 'ExpiredTokenException');
	  },

	  /**
	   * @api private
	   */
	  clockSkewError: function clockSkewError(error) {
	    switch (error.code) {
	      case 'RequestTimeTooSkewed':
	      case 'RequestExpired':
	      case 'InvalidSignatureException':
	      case 'SignatureDoesNotMatch':
	      case 'AuthFailure':
	      case 'RequestInTheFuture':
	        return true;
	      default: return false;
	    }
	  },

	  /**
	   * @api private
	   */
	  throttledError: function throttledError(error) {
	    // this logic varies between services
	    switch (error.code) {
	      case 'ProvisionedThroughputExceededException':
	      case 'Throttling':
	      case 'ThrottlingException':
	      case 'RequestLimitExceeded':
	      case 'RequestThrottled':
	        return true;
	      default:
	        return false;
	    }
	  },

	  /**
	   * @api private
	   */
	  endpointFromTemplate: function endpointFromTemplate(endpoint) {
	    if (typeof endpoint !== 'string') return endpoint;

	    var e = endpoint;
	    e = e.replace(/\{service\}/g, this.api.endpointPrefix);
	    e = e.replace(/\{region\}/g, this.config.region);
	    e = e.replace(/\{scheme\}/g, this.config.sslEnabled ? 'https' : 'http');
	    return e;
	  },

	  /**
	   * @api private
	   */
	  setEndpoint: function setEndpoint(endpoint) {
	    this.endpoint = new AWS.Endpoint(endpoint, this.config);
	  },

	  /**
	   * @api private
	   */
	  paginationConfig: function paginationConfig(operation, throwException) {
	    var paginator = this.api.operations[operation].paginator;
	    if (!paginator) {
	      if (throwException) {
	        var e = new Error();
	        throw AWS.util.error(e, 'No pagination configuration for ' + operation);
	      }
	      return null;
	    }

	    return paginator;
	  }
	});

	AWS.util.update(AWS.Service, {

	  /**
	   * Adds one method for each operation described in the api configuration
	   *
	   * @api private
	   */
	  defineMethods: function defineMethods(svc) {
	    AWS.util.each(svc.prototype.api.operations, function iterator(method) {
	      if (svc.prototype[method]) return;
	      var operation = svc.prototype.api.operations[method];
	      if (operation.authtype === 'none') {
	        svc.prototype[method] = function (params, callback) {
	          return this.makeUnauthenticatedRequest(method, params, callback);
	        };
	      } else {
	        svc.prototype[method] = function (params, callback) {
	          return this.makeRequest(method, params, callback);
	        };
	      }
	    });
	  },

	  /**
	   * Defines a new Service class using a service identifier and list of versions
	   * including an optional set of features (functions) to apply to the class
	   * prototype.
	   *
	   * @param serviceIdentifier [String] the identifier for the service
	   * @param versions [Array<String>] a list of versions that work with this
	   *   service
	   * @param features [Object] an object to attach to the prototype
	   * @return [Class<Service>] the service class defined by this function.
	   */
	  defineService: function defineService(serviceIdentifier, versions, features) {
	    AWS.Service._serviceMap[serviceIdentifier] = true;
	    if (!Array.isArray(versions)) {
	      features = versions;
	      versions = [];
	    }

	    var svc = inherit(AWS.Service, features || {});

	    if (typeof serviceIdentifier === 'string') {
	      AWS.Service.addVersions(svc, versions);

	      var identifier = svc.serviceIdentifier || serviceIdentifier;
	      svc.serviceIdentifier = identifier;
	    } else { // defineService called with an API
	      svc.prototype.api = serviceIdentifier;
	      AWS.Service.defineMethods(svc);
	    }

	    return svc;
	  },

	  /**
	   * @api private
	   */
	  addVersions: function addVersions(svc, versions) {
	    if (!Array.isArray(versions)) versions = [versions];

	    svc.services = svc.services || {};
	    for (var i = 0; i < versions.length; i++) {
	      if (svc.services[versions[i]] === undefined) {
	        svc.services[versions[i]] = null;
	      }
	    }

	    svc.apiVersions = Object.keys(svc.services).sort();
	  },

	  /**
	   * @api private
	   */
	  defineServiceApi: function defineServiceApi(superclass, version, apiConfig) {
	    var svc = inherit(superclass, {
	      serviceIdentifier: superclass.serviceIdentifier
	    });

	    function setApi(api) {
	      if (api.isApi) {
	        svc.prototype.api = api;
	      } else {
	        svc.prototype.api = new Api(api);
	      }
	    }

	    if (typeof version === 'string') {
	      if (apiConfig) {
	        setApi(apiConfig);
	      } else {
	        try {
	          setApi(AWS.apiLoader(superclass.serviceIdentifier, version));
	        } catch (err) {
	          throw AWS.util.error(err, {
	            message: 'Could not find API configuration ' +
	              superclass.serviceIdentifier + '-' + version
	          });
	        }
	      }
	      if (!Object.prototype.hasOwnProperty.call(superclass.services, version)) {
	        superclass.apiVersions = superclass.apiVersions.concat(version).sort();
	      }
	      superclass.services[version] = svc;
	    } else {
	      setApi(version);
	    }

	    AWS.Service.defineMethods(svc);
	    return svc;
	  },

	  /**
	   * @api private
	   */
	  hasService: function(identifier) {
	    return Object.prototype.hasOwnProperty.call(AWS.Service._serviceMap, identifier);
	  },

	  /**
	   * @api private
	   */
	  _serviceMap: {}
	});

	module.exports = AWS.Service;

/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	var util = __webpack_require__(92);
	var regionConfig = __webpack_require__(176);

	function generateRegionPrefix(region) {
	  if (!region) return null;

	  var parts = region.split('-');
	  if (parts.length < 3) return null;
	  return parts.slice(0, parts.length - 2).join('-') + '-*';
	}

	function derivedKeys(service) {
	  var region = service.config.region;
	  var regionPrefix = generateRegionPrefix(region);
	  var endpointPrefix = service.api.endpointPrefix;

	  return [
	    [region, endpointPrefix],
	    [regionPrefix, endpointPrefix],
	    [region, '*'],
	    [regionPrefix, '*'],
	    ['*', endpointPrefix],
	    ['*', '*']
	  ].map(function(item) {
	    return item[0] && item[1] ? item.join('/') : null;
	  });
	}

	function applyConfig(service, config) {
	  util.each(config, function(key, value) {
	    if (key === 'globalEndpoint') return;
	    if (service.config[key] === undefined || service.config[key] === null) {
	      service.config[key] = value;
	    }
	  });
	}

	function configureEndpoint(service) {
	  var keys = derivedKeys(service);
	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i];
	    if (!key) continue;

	    if (Object.prototype.hasOwnProperty.call(regionConfig.rules, key)) {
	      var config = regionConfig.rules[key];
	      if (typeof config === 'string') {
	        config = regionConfig.patterns[config];
	      }

	      // set dualstack endpoint
	      if (service.config.useDualstack && util.isDualstackAvailable(service)) {
	        config = util.copy(config);
	        config.endpoint = '{service}.dualstack.{region}.amazonaws.com';
	      }

	      // set global endpoint
	      service.isGlobalEndpoint = !!config.globalEndpoint;

	      // signature version
	      if (!config.signatureVersion) config.signatureVersion = 'v4';

	      // merge config
	      applyConfig(service, config);
	      return;
	    }
	  }
	}

	module.exports = configureEndpoint;


/***/ },
/* 176 */
/***/ function(module, exports) {

	module.exports = {
		"rules": {
			"*/*": {
				"endpoint": "{service}.{region}.amazonaws.com"
			},
			"cn-*/*": {
				"endpoint": "{service}.{region}.amazonaws.com.cn"
			},
			"*/budgets": "globalSSL",
			"*/cloudfront": "globalSSL",
			"*/iam": "globalSSL",
			"*/sts": "globalSSL",
			"*/importexport": {
				"endpoint": "{service}.amazonaws.com",
				"signatureVersion": "v2",
				"globalEndpoint": true
			},
			"*/route53": {
				"endpoint": "https://{service}.amazonaws.com",
				"signatureVersion": "v3https",
				"globalEndpoint": true
			},
			"*/waf": "globalSSL",
			"us-gov-*/iam": "globalGovCloud",
			"us-gov-*/sts": {
				"endpoint": "{service}.{region}.amazonaws.com"
			},
			"us-gov-west-1/s3": "s3dash",
			"us-west-1/s3": "s3dash",
			"us-west-2/s3": "s3dash",
			"eu-west-1/s3": "s3dash",
			"ap-southeast-1/s3": "s3dash",
			"ap-southeast-2/s3": "s3dash",
			"ap-northeast-1/s3": "s3dash",
			"sa-east-1/s3": "s3dash",
			"us-east-1/s3": {
				"endpoint": "{service}.amazonaws.com",
				"signatureVersion": "s3"
			},
			"us-east-1/sdb": {
				"endpoint": "{service}.amazonaws.com",
				"signatureVersion": "v2"
			},
			"*/sdb": {
				"endpoint": "{service}.{region}.amazonaws.com",
				"signatureVersion": "v2"
			}
		},
		"patterns": {
			"globalSSL": {
				"endpoint": "https://{service}.amazonaws.com",
				"globalEndpoint": true
			},
			"globalGovCloud": {
				"endpoint": "{service}.us-gov.amazonaws.com"
			},
			"s3dash": {
				"endpoint": "{service}-{region}.amazonaws.com",
				"signatureVersion": "s3"
			}
		}
	};

/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(93);

	/**
	 * Represents your AWS security credentials, specifically the
	 * {accessKeyId}, {secretAccessKey}, and optional {sessionToken}.
	 * Creating a `Credentials` object allows you to pass around your
	 * security information to configuration and service objects.
	 *
	 * Note that this class typically does not need to be constructed manually,
	 * as the {AWS.Config} and {AWS.Service} classes both accept simple
	 * options hashes with the three keys. These structures will be converted
	 * into Credentials objects automatically.
	 *
	 * ## Expiring and Refreshing Credentials
	 *
	 * Occasionally credentials can expire in the middle of a long-running
	 * application. In this case, the SDK will automatically attempt to
	 * refresh the credentials from the storage location if the Credentials
	 * class implements the {refresh} method.
	 *
	 * If you are implementing a credential storage location, you
	 * will want to create a subclass of the `Credentials` class and
	 * override the {refresh} method. This method allows credentials to be
	 * retrieved from the backing store, be it a file system, database, or
	 * some network storage. The method should reset the credential attributes
	 * on the object.
	 *
	 * @!attribute expired
	 *   @return [Boolean] whether the credentials have been expired and
	 *     require a refresh. Used in conjunction with {expireTime}.
	 * @!attribute expireTime
	 *   @return [Date] a time when credentials should be considered expired. Used
	 *     in conjunction with {expired}.
	 * @!attribute accessKeyId
	 *   @return [String] the AWS access key ID
	 * @!attribute secretAccessKey
	 *   @return [String] the AWS secret access key
	 * @!attribute sessionToken
	 *   @return [String] an optional AWS session token
	 */
	AWS.Credentials = AWS.util.inherit({
	  /**
	   * A credentials object can be created using positional arguments or an options
	   * hash.
	   *
	   * @overload AWS.Credentials(accessKeyId, secretAccessKey, sessionToken=null)
	   *   Creates a Credentials object with a given set of credential information
	   *   as positional arguments.
	   *   @param accessKeyId [String] the AWS access key ID
	   *   @param secretAccessKey [String] the AWS secret access key
	   *   @param sessionToken [String] the optional AWS session token
	   *   @example Create a credentials object with AWS credentials
	   *     var creds = new AWS.Credentials('akid', 'secret', 'session');
	   * @overload AWS.Credentials(options)
	   *   Creates a Credentials object with a given set of credential information
	   *   as an options hash.
	   *   @option options accessKeyId [String] the AWS access key ID
	   *   @option options secretAccessKey [String] the AWS secret access key
	   *   @option options sessionToken [String] the optional AWS session token
	   *   @example Create a credentials object with AWS credentials
	   *     var creds = new AWS.Credentials({
	   *       accessKeyId: 'akid', secretAccessKey: 'secret', sessionToken: 'session'
	   *     });
	   */
	  constructor: function Credentials() {
	    // hide secretAccessKey from being displayed with util.inspect
	    AWS.util.hideProperties(this, ['secretAccessKey']);

	    this.expired = false;
	    this.expireTime = null;
	    if (arguments.length === 1 && typeof arguments[0] === 'object') {
	      var creds = arguments[0].credentials || arguments[0];
	      this.accessKeyId = creds.accessKeyId;
	      this.secretAccessKey = creds.secretAccessKey;
	      this.sessionToken = creds.sessionToken;
	    } else {
	      this.accessKeyId = arguments[0];
	      this.secretAccessKey = arguments[1];
	      this.sessionToken = arguments[2];
	    }
	  },

	  /**
	   * @return [Integer] the window size in seconds to attempt refreshing of
	   *   credentials before the expireTime occurs.
	   */
	  expiryWindow: 15,

	  /**
	   * @return [Boolean] whether the credentials object should call {refresh}
	   * @note Subclasses should override this method to provide custom refresh
	   *   logic.
	   */
	  needsRefresh: function needsRefresh() {
	    var currentTime = AWS.util.date.getDate().getTime();
	    var adjustedTime = new Date(currentTime + this.expiryWindow * 1000);

	    if (this.expireTime && adjustedTime > this.expireTime) {
	      return true;
	    } else {
	      return this.expired || !this.accessKeyId || !this.secretAccessKey;
	    }
	  },

	  /**
	   * Gets the existing credentials, refreshing them if they are not yet loaded
	   * or have expired. Users should call this method before using {refresh},
	   * as this will not attempt to reload credentials when they are already
	   * loaded into the object.
	   *
	   * @callback callback function(err)
	   *   When this callback is called with no error, it means either credentials
	   *   do not need to be refreshed or refreshed credentials information has
	   *   been loaded into the object (as the `accessKeyId`, `secretAccessKey`,
	   *   and `sessionToken` properties).
	   *   @param err [Error] if an error occurred, this value will be filled
	   */
	  get: function get(callback) {
	    var self = this;
	    if (this.needsRefresh()) {
	      this.refresh(function(err) {
	        if (!err) self.expired = false; // reset expired flag
	        if (callback) callback(err);
	      });
	    } else if (callback) {
	      callback();
	    }
	  },

	  /**
	   * @!method  getPromise()
	   *   Returns a 'thenable' promise.
	   *   Gets the existing credentials, refreshing them if they are not yet loaded
	   *   or have expired. Users should call this method before using {refresh},
	   *   as this will not attempt to reload credentials when they are already
	   *   loaded into the object.
	   *
	   *   Two callbacks can be provided to the `then` method on the returned promise.
	   *   The first callback will be called if the promise is fulfilled, and the second
	   *   callback will be called if the promise is rejected.
	   *   @callback fulfilledCallback function()
	   *     Called if the promise is fulfilled. When this callback is called, it
	   *     means either credentials do not need to be refreshed or refreshed
	   *     credentials information has been loaded into the object (as the
	   *     `accessKeyId`, `secretAccessKey`, and `sessionToken` properties).
	   *   @callback rejectedCallback function(err)
	   *     Called if the promise is rejected.
	   *     @param err [Error] if an error occurred, this value will be filled
	   *   @return [Promise] A promise that represents the state of the `get` call.
	   *   @example Calling the `getPromise` method.
	   *     var promise = credProvider.getPromise();
	   *     promise.then(function() { ... }, function(err) { ... });
	   */

	  /**
	   * @!method  refreshPromise()
	   *   Returns a 'thenable' promise.
	   *   Refreshes the credentials. Users should call {get} before attempting
	   *   to forcibly refresh credentials.
	   *
	   *   Two callbacks can be provided to the `then` method on the returned promise.
	   *   The first callback will be called if the promise is fulfilled, and the second
	   *   callback will be called if the promise is rejected.
	   *   @callback fulfilledCallback function()
	   *     Called if the promise is fulfilled. When this callback is called, it
	   *     means refreshed credentials information has been loaded into the object
	   *     (as the `accessKeyId`, `secretAccessKey`, and `sessionToken` properties).
	   *   @callback rejectedCallback function(err)
	   *     Called if the promise is rejected.
	   *     @param err [Error] if an error occurred, this value will be filled
	   *   @return [Promise] A promise that represents the state of the `refresh` call.
	   *   @example Calling the `refreshPromise` method.
	   *     var promise = credProvider.refreshPromise();
	   *     promise.then(function() { ... }, function(err) { ... });
	   */

	  /**
	   * Refreshes the credentials. Users should call {get} before attempting
	   * to forcibly refresh credentials.
	   *
	   * @callback callback function(err)
	   *   When this callback is called with no error, it means refreshed
	   *   credentials information has been loaded into the object (as the
	   *   `accessKeyId`, `secretAccessKey`, and `sessionToken` properties).
	   *   @param err [Error] if an error occurred, this value will be filled
	   * @note Subclasses should override this class to reset the
	   *   {accessKeyId}, {secretAccessKey} and optional {sessionToken}
	   *   on the credentials object and then call the callback with
	   *   any error information.
	   * @see get
	   */
	  refresh: function refresh(callback) {
	    this.expired = false;
	    callback();
	  }
	});

	/**
	 * @api private
	 */
	AWS.Credentials.addPromisesToClass = function addPromisesToClass(PromiseDependency) {
	  this.prototype.getPromise = AWS.util.promisifyMethod('get', PromiseDependency);
	  this.prototype.refreshPromise = AWS.util.promisifyMethod('refresh', PromiseDependency);
	};

	/**
	 * @api private
	 */
	AWS.Credentials.deletePromisesFromClass = function deletePromisesFromClass() {
	  delete this.prototype.getPromise;
	  delete this.prototype.refreshPromise;
	};

	AWS.util.addPromises(AWS.Credentials);


/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(93);

	/**
	 * Creates a credential provider chain that searches for AWS credentials
	 * in a list of credential providers specified by the {providers} property.
	 *
	 * By default, the chain will use the {defaultProviders} to resolve credentials.
	 * These providers will look in the environment using the
	 * {AWS.EnvironmentCredentials} class with the 'AWS' and 'AMAZON' prefixes.
	 *
	 * ## Setting Providers
	 *
	 * Each provider in the {providers} list should be a function that returns
	 * a {AWS.Credentials} object, or a hardcoded credentials object. The function
	 * form allows for delayed execution of the credential construction.
	 *
	 * ## Resolving Credentials from a Chain
	 *
	 * Call {resolve} to return the first valid credential object that can be
	 * loaded by the provider chain.
	 *
	 * For example, to resolve a chain with a custom provider that checks a file
	 * on disk after the set of {defaultProviders}:
	 *
	 * ```javascript
	 * var diskProvider = new AWS.FileSystemCredentials('./creds.json');
	 * var chain = new AWS.CredentialProviderChain();
	 * chain.providers.push(diskProvider);
	 * chain.resolve();
	 * ```
	 *
	 * The above code will return the `diskProvider` object if the
	 * file contains credentials and the `defaultProviders` do not contain
	 * any credential settings.
	 *
	 * @!attribute providers
	 *   @return [Array<AWS.Credentials, Function>]
	 *     a list of credentials objects or functions that return credentials
	 *     objects. If the provider is a function, the function will be
	 *     executed lazily when the provider needs to be checked for valid
	 *     credentials. By default, this object will be set to the
	 *     {defaultProviders}.
	 *   @see defaultProviders
	 */
	AWS.CredentialProviderChain = AWS.util.inherit(AWS.Credentials, {

	  /**
	   * Creates a new CredentialProviderChain with a default set of providers
	   * specified by {defaultProviders}.
	   */
	  constructor: function CredentialProviderChain(providers) {
	    if (providers) {
	      this.providers = providers;
	    } else {
	      this.providers = AWS.CredentialProviderChain.defaultProviders.slice(0);
	    }
	  },

	  /**
	   * @!method  resolvePromise()
	   *   Returns a 'thenable' promise.
	   *   Resolves the provider chain by searching for the first set of
	   *   credentials in {providers}.
	   *
	   *   Two callbacks can be provided to the `then` method on the returned promise.
	   *   The first callback will be called if the promise is fulfilled, and the second
	   *   callback will be called if the promise is rejected.
	   *   @callback fulfilledCallback function(credentials)
	   *     Called if the promise is fulfilled and the provider resolves the chain
	   *     to a credentials object
	   *     @param credentials [AWS.Credentials] the credentials object resolved
	   *       by the provider chain.
	   *   @callback rejectedCallback function(error)
	   *     Called if the promise is rejected.
	   *     @param err [Error] the error object returned if no credentials are found.
	   *   @return [Promise] A promise that represents the state of the `resolve` method call.
	   *   @example Calling the `resolvePromise` method.
	   *     var promise = chain.resolvePromise();
	   *     promise.then(function(credentials) { ... }, function(err) { ... });
	   */

	  /**
	   * Resolves the provider chain by searching for the first set of
	   * credentials in {providers}.
	   *
	   * @callback callback function(err, credentials)
	   *   Called when the provider resolves the chain to a credentials object
	   *   or null if no credentials can be found.
	   *
	   *   @param err [Error] the error object returned if no credentials are
	   *     found.
	   *   @param credentials [AWS.Credentials] the credentials object resolved
	   *     by the provider chain.
	   * @return [AWS.CredentialProviderChain] the provider, for chaining.
	   */
	  resolve: function resolve(callback) {
	    if (this.providers.length === 0) {
	      callback(new Error('No providers'));
	      return this;
	    }

	    var index = 0;
	    var providers = this.providers.slice(0);

	    function resolveNext(err, creds) {
	      if ((!err && creds) || index === providers.length) {
	        callback(err, creds);
	        return;
	      }

	      var provider = providers[index++];
	      if (typeof provider === 'function') {
	        creds = provider.call();
	      } else {
	        creds = provider;
	      }

	      if (creds.get) {
	        creds.get(function(getErr) {
	          resolveNext(getErr, getErr ? null : creds);
	        });
	      } else {
	        resolveNext(null, creds);
	      }
	    }

	    resolveNext();
	    return this;
	  }
	});

	/**
	 * The default set of providers used by a vanilla CredentialProviderChain.
	 *
	 * In the browser:
	 *
	 * ```javascript
	 * AWS.CredentialProviderChain.defaultProviders = []
	 * ```
	 *
	 * In Node.js:
	 *
	 * ```javascript
	 * AWS.CredentialProviderChain.defaultProviders = [
	 *   function () { return new AWS.EnvironmentCredentials('AWS'); },
	 *   function () { return new AWS.EnvironmentCredentials('AMAZON'); },
	 *   function () { return new AWS.SharedIniFileCredentials(); },
	 *   function () {
	 *     // if AWS_CONTAINER_CREDENTIALS_RELATIVE_URI is set
	 *       return new AWS.ECSCredentials();
	 *     // else
	 *       return new AWS.EC2MetadataCredentials();
	 *   }
	 * ]
	 * ```
	 */
	AWS.CredentialProviderChain.defaultProviders = [];

	/**
	 * @api private
	 */
	AWS.CredentialProviderChain.addPromisesToClass = function addPromisesToClass(PromiseDependency) {
	  this.prototype.resolvePromise = AWS.util.promisifyMethod('resolve', PromiseDependency);
	};

	/**
	 * @api private
	 */
	AWS.CredentialProviderChain.deletePromisesFromClass = function deletePromisesFromClass() {
	  delete this.prototype.resolvePromise;
	};

	AWS.util.addPromises(AWS.CredentialProviderChain);


/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(93);
	var STS = __webpack_require__(180);

	/**
	 * Represents temporary credentials retrieved from {AWS.STS}. Without any
	 * extra parameters, credentials will be fetched from the
	 * {AWS.STS.getSessionToken} operation. If an IAM role is provided, the
	 * {AWS.STS.assumeRole} operation will be used to fetch credentials for the
	 * role instead.
	 *
	 * To setup temporary credentials, configure a set of master credentials
	 * using the standard credentials providers (environment, EC2 instance metadata,
	 * or from the filesystem), then set the global credentials to a new
	 * temporary credentials object:
	 *
	 * ```javascript
	 * // Note that environment credentials are loaded by default,
	 * // the following line is shown for clarity:
	 * AWS.config.credentials = new AWS.EnvironmentCredentials('AWS');
	 *
	 * // Now set temporary credentials seeded from the master credentials
	 * AWS.config.credentials = new AWS.TemporaryCredentials();
	 *
	 * // subsequent requests will now use temporary credentials from AWS STS.
	 * new AWS.S3().listBucket(function(err, data) { ... });
	 * ```
	 *
	 * @!attribute masterCredentials
	 *   @return [AWS.Credentials] the master (non-temporary) credentials used to
	 *     get and refresh temporary credentials from AWS STS.
	 * @note (see constructor)
	 */
	AWS.TemporaryCredentials = AWS.util.inherit(AWS.Credentials, {
	  /**
	   * Creates a new temporary credentials object.
	   *
	   * @note In order to create temporary credentials, you first need to have
	   *   "master" credentials configured in {AWS.Config.credentials}. These
	   *   master credentials are necessary to retrieve the temporary credentials,
	   *   as well as refresh the credentials when they expire.
	   * @param params [map] a map of options that are passed to the
	   *   {AWS.STS.assumeRole} or {AWS.STS.getSessionToken} operations.
	   *   If a `RoleArn` parameter is passed in, credentials will be based on the
	   *   IAM role.
	   * @example Creating a new credentials object for generic temporary credentials
	   *   AWS.config.credentials = new AWS.TemporaryCredentials();
	   * @example Creating a new credentials object for an IAM role
	   *   AWS.config.credentials = new AWS.TemporaryCredentials({
	   *     RoleArn: 'arn:aws:iam::1234567890:role/TemporaryCredentials',
	   *   });
	   * @see AWS.STS.assumeRole
	   * @see AWS.STS.getSessionToken
	   */
	  constructor: function TemporaryCredentials(params) {
	    AWS.Credentials.call(this);
	    this.loadMasterCredentials();
	    this.expired = true;

	    this.params = params || {};
	    if (this.params.RoleArn) {
	      this.params.RoleSessionName =
	        this.params.RoleSessionName || 'temporary-credentials';
	    }
	  },

	  /**
	   * Refreshes credentials using {AWS.STS.assumeRole} or
	   * {AWS.STS.getSessionToken}, depending on whether an IAM role ARN was passed
	   * to the credentials {constructor}.
	   *
	   * @callback callback function(err)
	   *   Called when the STS service responds (or fails). When
	   *   this callback is called with no error, it means that the credentials
	   *   information has been loaded into the object (as the `accessKeyId`,
	   *   `secretAccessKey`, and `sessionToken` properties).
	   *   @param err [Error] if an error occurred, this value will be filled
	   * @see get
	   */
	  refresh: function refresh(callback) {
	    var self = this;
	    self.createClients();
	    if (!callback) callback = function(err) { if (err) throw err; };

	    self.service.config.credentials = self.masterCredentials;
	    var operation = self.params.RoleArn ?
	      self.service.assumeRole : self.service.getSessionToken;
	    operation.call(self.service, function (err, data) {
	      if (!err) {
	        self.service.credentialsFrom(data, self);
	      }
	      callback(err);
	    });
	  },

	  /**
	   * @api private
	   */
	  loadMasterCredentials: function loadMasterCredentials() {
	    this.masterCredentials = AWS.config.credentials;
	    while (this.masterCredentials.masterCredentials) {
	      this.masterCredentials = this.masterCredentials.masterCredentials;
	    }
	  },

	  /**
	   * @api private
	   */
	  createClients: function() {
	    this.service = this.service || new STS({params: this.params});
	  }

	});


/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['sts'] = {};
	AWS.STS = Service.defineService('sts', ['2011-06-15']);
	__webpack_require__(182);
	Object.defineProperty(apiLoader.services['sts'], '2011-06-15', {
	  get: function get() {
	    var model = __webpack_require__(183);
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.STS;


/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(93);

	AWS.apiLoader = function(svc, version) {
	  if (!AWS.apiLoader.services.hasOwnProperty(svc)) {
	    throw new Error('InvalidService: Failed to load api for ' + svc);
	  }
	  return AWS.apiLoader.services[svc][version];
	};

	AWS.apiLoader.services = {};

	module.exports = AWS.apiLoader;

/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(93);

	AWS.util.update(AWS.STS.prototype, {
	  /**
	   * @overload credentialsFrom(data, credentials = null)
	   *   Creates a credentials object from STS response data containing
	   *   credentials information. Useful for quickly setting AWS credentials.
	   *
	   *   @note This is a low-level utility function. If you want to load temporary
	   *     credentials into your process for subsequent requests to AWS resources,
	   *     you should use {AWS.TemporaryCredentials} instead.
	   *   @param data [map] data retrieved from a call to {getFederatedToken},
	   *     {getSessionToken}, {assumeRole}, or {assumeRoleWithWebIdentity}.
	   *   @param credentials [AWS.Credentials] an optional credentials object to
	   *     fill instead of creating a new object. Useful when modifying an
	   *     existing credentials object from a refresh call.
	   *   @return [AWS.TemporaryCredentials] the set of temporary credentials
	   *     loaded from a raw STS operation response.
	   *   @example Using credentialsFrom to load global AWS credentials
	   *     var sts = new AWS.STS();
	   *     sts.getSessionToken(function (err, data) {
	   *       if (err) console.log("Error getting credentials");
	   *       else {
	   *         AWS.config.credentials = sts.credentialsFrom(data);
	   *       }
	   *     });
	   *   @see AWS.TemporaryCredentials
	   */
	  credentialsFrom: function credentialsFrom(data, credentials) {
	    if (!data) return null;
	    if (!credentials) credentials = new AWS.TemporaryCredentials();
	    credentials.expired = false;
	    credentials.accessKeyId = data.Credentials.AccessKeyId;
	    credentials.secretAccessKey = data.Credentials.SecretAccessKey;
	    credentials.sessionToken = data.Credentials.SessionToken;
	    credentials.expireTime = data.Credentials.Expiration;
	    return credentials;
	  },

	  assumeRoleWithWebIdentity: function assumeRoleWithWebIdentity(params, callback) {
	    return this.makeUnauthenticatedRequest('assumeRoleWithWebIdentity', params, callback);
	  },

	  assumeRoleWithSAML: function assumeRoleWithSAML(params, callback) {
	    return this.makeUnauthenticatedRequest('assumeRoleWithSAML', params, callback);
	  }
	});


/***/ },
/* 183 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2011-06-15",
			"endpointPrefix": "sts",
			"globalEndpoint": "sts.amazonaws.com",
			"protocol": "query",
			"serviceAbbreviation": "AWS STS",
			"serviceFullName": "AWS Security Token Service",
			"signatureVersion": "v4",
			"xmlNamespace": "https://sts.amazonaws.com/doc/2011-06-15/"
		},
		"operations": {
			"AssumeRole": {
				"input": {
					"type": "structure",
					"required": [
						"RoleArn",
						"RoleSessionName"
					],
					"members": {
						"RoleArn": {},
						"RoleSessionName": {},
						"Policy": {},
						"DurationSeconds": {
							"type": "integer"
						},
						"ExternalId": {},
						"SerialNumber": {},
						"TokenCode": {}
					}
				},
				"output": {
					"resultWrapper": "AssumeRoleResult",
					"type": "structure",
					"members": {
						"Credentials": {
							"shape": "Sa"
						},
						"AssumedRoleUser": {
							"shape": "Sf"
						},
						"PackedPolicySize": {
							"type": "integer"
						}
					}
				}
			},
			"AssumeRoleWithSAML": {
				"input": {
					"type": "structure",
					"required": [
						"RoleArn",
						"PrincipalArn",
						"SAMLAssertion"
					],
					"members": {
						"RoleArn": {},
						"PrincipalArn": {},
						"SAMLAssertion": {},
						"Policy": {},
						"DurationSeconds": {
							"type": "integer"
						}
					}
				},
				"output": {
					"resultWrapper": "AssumeRoleWithSAMLResult",
					"type": "structure",
					"members": {
						"Credentials": {
							"shape": "Sa"
						},
						"AssumedRoleUser": {
							"shape": "Sf"
						},
						"PackedPolicySize": {
							"type": "integer"
						},
						"Subject": {},
						"SubjectType": {},
						"Issuer": {},
						"Audience": {},
						"NameQualifier": {}
					}
				}
			},
			"AssumeRoleWithWebIdentity": {
				"input": {
					"type": "structure",
					"required": [
						"RoleArn",
						"RoleSessionName",
						"WebIdentityToken"
					],
					"members": {
						"RoleArn": {},
						"RoleSessionName": {},
						"WebIdentityToken": {},
						"ProviderId": {},
						"Policy": {},
						"DurationSeconds": {
							"type": "integer"
						}
					}
				},
				"output": {
					"resultWrapper": "AssumeRoleWithWebIdentityResult",
					"type": "structure",
					"members": {
						"Credentials": {
							"shape": "Sa"
						},
						"SubjectFromWebIdentityToken": {},
						"AssumedRoleUser": {
							"shape": "Sf"
						},
						"PackedPolicySize": {
							"type": "integer"
						},
						"Provider": {},
						"Audience": {}
					}
				}
			},
			"DecodeAuthorizationMessage": {
				"input": {
					"type": "structure",
					"required": [
						"EncodedMessage"
					],
					"members": {
						"EncodedMessage": {}
					}
				},
				"output": {
					"resultWrapper": "DecodeAuthorizationMessageResult",
					"type": "structure",
					"members": {
						"DecodedMessage": {}
					}
				}
			},
			"GetCallerIdentity": {
				"input": {
					"type": "structure",
					"members": {}
				},
				"output": {
					"resultWrapper": "GetCallerIdentityResult",
					"type": "structure",
					"members": {
						"UserId": {},
						"Account": {},
						"Arn": {}
					}
				}
			},
			"GetFederationToken": {
				"input": {
					"type": "structure",
					"required": [
						"Name"
					],
					"members": {
						"Name": {},
						"Policy": {},
						"DurationSeconds": {
							"type": "integer"
						}
					}
				},
				"output": {
					"resultWrapper": "GetFederationTokenResult",
					"type": "structure",
					"members": {
						"Credentials": {
							"shape": "Sa"
						},
						"FederatedUser": {
							"type": "structure",
							"required": [
								"FederatedUserId",
								"Arn"
							],
							"members": {
								"FederatedUserId": {},
								"Arn": {}
							}
						},
						"PackedPolicySize": {
							"type": "integer"
						}
					}
				}
			},
			"GetSessionToken": {
				"input": {
					"type": "structure",
					"members": {
						"DurationSeconds": {
							"type": "integer"
						},
						"SerialNumber": {},
						"TokenCode": {}
					}
				},
				"output": {
					"resultWrapper": "GetSessionTokenResult",
					"type": "structure",
					"members": {
						"Credentials": {
							"shape": "Sa"
						}
					}
				}
			}
		},
		"shapes": {
			"Sa": {
				"type": "structure",
				"required": [
					"AccessKeyId",
					"SecretAccessKey",
					"SessionToken",
					"Expiration"
				],
				"members": {
					"AccessKeyId": {},
					"SecretAccessKey": {},
					"SessionToken": {},
					"Expiration": {
						"type": "timestamp"
					}
				}
			},
			"Sf": {
				"type": "structure",
				"required": [
					"AssumedRoleId",
					"Arn"
				],
				"members": {
					"AssumedRoleId": {},
					"Arn": {}
				}
			}
		}
	};

/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(93);
	var STS = __webpack_require__(180);

	/**
	 * Represents credentials retrieved from STS Web Identity Federation support.
	 *
	 * By default this provider gets credentials using the
	 * {AWS.STS.assumeRoleWithWebIdentity} service operation. This operation
	 * requires a `RoleArn` containing the ARN of the IAM trust policy for the
	 * application for which credentials will be given. In addition, the
	 * `WebIdentityToken` must be set to the token provided by the identity
	 * provider. See {constructor} for an example on creating a credentials
	 * object with proper `RoleArn` and `WebIdentityToken` values.
	 *
	 * ## Refreshing Credentials from Identity Service
	 *
	 * In addition to AWS credentials expiring after a given amount of time, the
	 * login token from the identity provider will also expire. Once this token
	 * expires, it will not be usable to refresh AWS credentials, and another
	 * token will be needed. The SDK does not manage refreshing of the token value,
	 * but this can be done through a "refresh token" supported by most identity
	 * providers. Consult the documentation for the identity provider for refreshing
	 * tokens. Once the refreshed token is acquired, you should make sure to update
	 * this new token in the credentials object's {params} property. The following
	 * code will update the WebIdentityToken, assuming you have retrieved an updated
	 * token from the identity provider:
	 *
	 * ```javascript
	 * AWS.config.credentials.params.WebIdentityToken = updatedToken;
	 * ```
	 *
	 * Future calls to `credentials.refresh()` will now use the new token.
	 *
	 * @!attribute params
	 *   @return [map] the map of params passed to
	 *     {AWS.STS.assumeRoleWithWebIdentity}. To update the token, set the
	 *     `params.WebIdentityToken` property.
	 * @!attribute data
	 *   @return [map] the raw data response from the call to
	 *     {AWS.STS.assumeRoleWithWebIdentity}. Use this if you want to get
	 *     access to other properties from the response.
	 */
	AWS.WebIdentityCredentials = AWS.util.inherit(AWS.Credentials, {
	  /**
	   * Creates a new credentials object.
	   * @param (see AWS.STS.assumeRoleWithWebIdentity)
	   * @example Creating a new credentials object
	   *   AWS.config.credentials = new AWS.WebIdentityCredentials({
	   *     RoleArn: 'arn:aws:iam::1234567890:role/WebIdentity',
	   *     WebIdentityToken: 'ABCDEFGHIJKLMNOP', // token from identity service
	   *     RoleSessionName: 'web' // optional name, defaults to web-identity
	   *   });
	   * @see AWS.STS.assumeRoleWithWebIdentity
	   */
	  constructor: function WebIdentityCredentials(params) {
	    AWS.Credentials.call(this);
	    this.expired = true;
	    this.params = params;
	    this.params.RoleSessionName = this.params.RoleSessionName || 'web-identity';
	    this.data = null;
	  },

	  /**
	   * Refreshes credentials using {AWS.STS.assumeRoleWithWebIdentity}
	   *
	   * @callback callback function(err)
	   *   Called when the STS service responds (or fails). When
	   *   this callback is called with no error, it means that the credentials
	   *   information has been loaded into the object (as the `accessKeyId`,
	   *   `secretAccessKey`, and `sessionToken` properties).
	   *   @param err [Error] if an error occurred, this value will be filled
	   * @see get
	   */
	  refresh: function refresh(callback) {
	    var self = this;
	    self.createClients();
	    if (!callback) callback = function(err) { if (err) throw err; };

	    self.service.assumeRoleWithWebIdentity(function (err, data) {
	      self.data = null;
	      if (!err) {
	        self.data = data;
	        self.service.credentialsFrom(data, self);
	      }
	      callback(err);
	    });
	  },

	  /**
	   * @api private
	   */
	  createClients: function() {
	    this.service = this.service || new STS({params: this.params});
	  }

	});


/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(93);
	var CognitoIdentity = __webpack_require__(186);
	var STS = __webpack_require__(180);

	/**
	 * Represents credentials retrieved from STS Web Identity Federation using
	 * the Amazon Cognito Identity service.
	 *
	 * By default this provider gets credentials using the
	 * {AWS.CognitoIdentity.getCredentialsForIdentity} service operation, which
	 * requires either an `IdentityId` or an `IdentityPoolId` (Amazon Cognito
	 * Identity Pool ID), which is used to call {AWS.CognitoIdentity.getId} to
	 * obtain an `IdentityId`. If the identity or identity pool is not configured in
	 * the Amazon Cognito Console to use IAM roles with the appropriate permissions,
	 * then additionally a `RoleArn` is required containing the ARN of the IAM trust
	 * policy for the Amazon Cognito role that the user will log into. If a `RoleArn`
	 * is provided, then this provider gets credentials using the
	 * {AWS.STS.assumeRoleWithWebIdentity} service operation, after first getting an
	 * Open ID token from {AWS.CognitoIdentity.getOpenIdToken}.
	 *
	 * In addition, if this credential provider is used to provide authenticated
	 * login, the `Logins` map may be set to the tokens provided by the respective
	 * identity providers. See {constructor} for an example on creating a credentials
	 * object with proper property values.
	 *
	 * ## Refreshing Credentials from Identity Service
	 *
	 * In addition to AWS credentials expiring after a given amount of time, the
	 * login token from the identity provider will also expire. Once this token
	 * expires, it will not be usable to refresh AWS credentials, and another
	 * token will be needed. The SDK does not manage refreshing of the token value,
	 * but this can be done through a "refresh token" supported by most identity
	 * providers. Consult the documentation for the identity provider for refreshing
	 * tokens. Once the refreshed token is acquired, you should make sure to update
	 * this new token in the credentials object's {params} property. The following
	 * code will update the WebIdentityToken, assuming you have retrieved an updated
	 * token from the identity provider:
	 *
	 * ```javascript
	 * AWS.config.credentials.params.Logins['graph.facebook.com'] = updatedToken;
	 * ```
	 *
	 * Future calls to `credentials.refresh()` will now use the new token.
	 *
	 * @!attribute params
	 *   @return [map] the map of params passed to
	 *     {AWS.CognitoIdentity.getId},
	 *     {AWS.CognitoIdentity.getOpenIdToken}, and
	 *     {AWS.STS.assumeRoleWithWebIdentity}. To update the token, set the
	 *     `params.WebIdentityToken` property.
	 * @!attribute data
	 *   @return [map] the raw data response from the call to
	 *     {AWS.CognitoIdentity.getCredentialsForIdentity}, or
	 *     {AWS.STS.assumeRoleWithWebIdentity}. Use this if you want to get
	 *     access to other properties from the response.
	 * @!attribute identityId
	 *   @return [String] the Cognito ID returned by the last call to
	 *     {AWS.CognitoIdentity.getOpenIdToken}. This ID represents the actual
	 *     final resolved identity ID from Amazon Cognito.
	 */
	AWS.CognitoIdentityCredentials = AWS.util.inherit(AWS.Credentials, {
	  /**
	   * @api private
	   */
	  localStorageKey: {
	    id: 'aws.cognito.identity-id.',
	    providers: 'aws.cognito.identity-providers.'
	  },

	  /**
	   * Creates a new credentials object.
	   * @example Creating a new credentials object
	   *   AWS.config.credentials = new AWS.CognitoIdentityCredentials({
	   *
	   *     // either IdentityPoolId or IdentityId is required
	   *     // See the IdentityPoolId param for AWS.CognitoIdentity.getID (linked below)
	   *     // See the IdentityId param for AWS.CognitoIdentity.getCredentialsForIdentity
	   *     // or AWS.CognitoIdentity.getOpenIdToken (linked below)
	   *     IdentityPoolId: 'us-east-1:1699ebc0-7900-4099-b910-2df94f52a030',
	   *     IdentityId: 'us-east-1:128d0a74-c82f-4553-916d-90053e4a8b0f'
	   *
	   *     // optional, only necessary when the identity pool is not configured
	   *     // to use IAM roles in the Amazon Cognito Console
	   *     // See the RoleArn param for AWS.STS.assumeRoleWithWebIdentity (linked below)
	   *     RoleArn: 'arn:aws:iam::1234567890:role/MYAPP-CognitoIdentity',
	   *
	   *     // optional tokens, used for authenticated login
	   *     // See the Logins param for AWS.CognitoIdentity.getID (linked below)
	   *     Logins: {
	   *       'graph.facebook.com': 'FBTOKEN',
	   *       'www.amazon.com': 'AMAZONTOKEN',
	   *       'accounts.google.com': 'GOOGLETOKEN',
	   *       'api.twitter.com': 'TWITTERTOKEN',
	   *       'www.digits.com': 'DIGITSTOKEN'
	   *     },
	   *
	   *     // optional name, defaults to web-identity
	   *     // See the RoleSessionName param for AWS.STS.assumeRoleWithWebIdentity (linked below)
	   *     RoleSessionName: 'web',
	   *
	   *     // optional, only necessary when application runs in a browser
	   *     // and multiple users are signed in at once, used for caching
	   *     LoginId: 'example@gmail.com'
	   *
	   *   });
	   * @see AWS.CognitoIdentity.getId
	   * @see AWS.CognitoIdentity.getCredentialsForIdentity
	   * @see AWS.STS.assumeRoleWithWebIdentity
	   * @see AWS.CognitoIdentity.getOpenIdToken
	   */
	  constructor: function CognitoIdentityCredentials(params) {
	    AWS.Credentials.call(this);
	    this.expired = true;
	    this.params = params;
	    this.data = null;
	    this.identityId = null;
	    this.loadCachedId();
	  },

	  /**
	   * Refreshes credentials using {AWS.CognitoIdentity.getCredentialsForIdentity},
	   * or {AWS.STS.assumeRoleWithWebIdentity}.
	   *
	   * @callback callback function(err)
	   *   Called when the STS service responds (or fails). When
	   *   this callback is called with no error, it means that the credentials
	   *   information has been loaded into the object (as the `accessKeyId`,
	   *   `secretAccessKey`, and `sessionToken` properties).
	   *   @param err [Error] if an error occurred, this value will be filled
	   * @see get
	   */
	  refresh: function refresh(callback) {
	    var self = this;
	    self.createClients();
	    self.data = null;
	    self.identityId = null;
	    self.getId(function(err) {
	      if (!err) {
	        if (!self.params.RoleArn) {
	          self.getCredentialsForIdentity(callback);
	        } else {
	          self.getCredentialsFromSTS(callback);
	        }
	      } else {
	        self.clearIdOnNotAuthorized(err);
	        callback(err);
	      }
	    });
	  },

	  /**
	   * Clears the cached Cognito ID associated with the currently configured
	   * identity pool ID. Use this to manually invalidate your cache if
	   * the identity pool ID was deleted.
	   */
	  clearCachedId: function clearCache() {
	    this.identityId = null;
	    delete this.params.IdentityId;

	    var poolId = this.params.IdentityPoolId;
	    var loginId = this.params.LoginId || '';
	    delete this.storage[this.localStorageKey.id + poolId + loginId];
	    delete this.storage[this.localStorageKey.providers + poolId + loginId];
	  },

	  /**
	   * @api private
	   */
	  clearIdOnNotAuthorized: function clearIdOnNotAuthorized(err) {
	    var self = this;
	    if (err.code == 'NotAuthorizedException') {
	      self.clearCachedId();
	    }
	  },

	  /**
	   * Retrieves a Cognito ID, loading from cache if it was already retrieved
	   * on this device.
	   *
	   * @callback callback function(err, identityId)
	   *   @param err [Error, null] an error object if the call failed or null if
	   *     it succeeded.
	   *   @param identityId [String, null] if successful, the callback will return
	   *     the Cognito ID.
	   * @note If not loaded explicitly, the Cognito ID is loaded and stored in
	   *   localStorage in the browser environment of a device.
	   * @api private
	   */
	  getId: function getId(callback) {
	    var self = this;
	    if (typeof self.params.IdentityId === 'string') {
	      return callback(null, self.params.IdentityId);
	    }

	    self.cognito.getId(function(err, data) {
	      if (!err && data.IdentityId) {
	        self.params.IdentityId = data.IdentityId;
	        callback(null, data.IdentityId);
	      } else {
	        callback(err);
	      }
	    });
	  },


	  /**
	   * @api private
	   */
	  loadCredentials: function loadCredentials(data, credentials) {
	    if (!data || !credentials) return;
	    credentials.expired = false;
	    credentials.accessKeyId = data.Credentials.AccessKeyId;
	    credentials.secretAccessKey = data.Credentials.SecretKey;
	    credentials.sessionToken = data.Credentials.SessionToken;
	    credentials.expireTime = data.Credentials.Expiration;
	  },

	  /**
	   * @api private
	   */
	  getCredentialsForIdentity: function getCredentialsForIdentity(callback) {
	    var self = this;
	    self.cognito.getCredentialsForIdentity(function(err, data) {
	      if (!err) {
	        self.cacheId(data);
	        self.data = data;
	        self.loadCredentials(self.data, self);
	      } else {
	        self.clearIdOnNotAuthorized(err);
	      }
	      callback(err);
	    });
	  },

	  /**
	   * @api private
	   */
	  getCredentialsFromSTS: function getCredentialsFromSTS(callback) {
	    var self = this;
	    self.cognito.getOpenIdToken(function(err, data) {
	      if (!err) {
	        self.cacheId(data);
	        self.params.WebIdentityToken = data.Token;
	        self.webIdentityCredentials.refresh(function(webErr) {
	          if (!webErr) {
	            self.data = self.webIdentityCredentials.data;
	            self.sts.credentialsFrom(self.data, self);
	          }
	          callback(webErr);
	        });
	      } else {
	        self.clearIdOnNotAuthorized(err);
	        callback(err);
	      }
	    });
	  },

	  /**
	   * @api private
	   */
	  loadCachedId: function loadCachedId() {
	    var self = this;

	    // in the browser we source default IdentityId from localStorage
	    if (AWS.util.isBrowser() && !self.params.IdentityId) {
	      var id = self.getStorage('id');
	      if (id && self.params.Logins) {
	        var actualProviders = Object.keys(self.params.Logins);
	        var cachedProviders =
	          (self.getStorage('providers') || '').split(',');

	        // only load ID if at least one provider used this ID before
	        var intersect = cachedProviders.filter(function(n) {
	          return actualProviders.indexOf(n) !== -1;
	        });
	        if (intersect.length !== 0) {
	          self.params.IdentityId = id;
	        }
	      } else if (id) {
	        self.params.IdentityId = id;
	      }
	    }
	  },

	  /**
	   * @api private
	   */
	  createClients: function() {
	    this.webIdentityCredentials = this.webIdentityCredentials ||
	      new AWS.WebIdentityCredentials(this.params);
	    this.cognito = this.cognito ||
	      new CognitoIdentity({params: this.params});
	    this.sts = this.sts || new STS();
	  },

	  /**
	   * @api private
	   */
	  cacheId: function cacheId(data) {
	    this.identityId = data.IdentityId;
	    this.params.IdentityId = this.identityId;

	    // cache this IdentityId in browser localStorage if possible
	    if (AWS.util.isBrowser()) {
	      this.setStorage('id', data.IdentityId);

	      if (this.params.Logins) {
	        this.setStorage('providers', Object.keys(this.params.Logins).join(','));
	      }
	    }
	  },

	  /**
	   * @api private
	   */
	  getStorage: function getStorage(key) {
	    return this.storage[this.localStorageKey[key] + this.params.IdentityPoolId + (this.params.LoginId || '')];
	  },

	  /**
	   * @api private
	   */
	  setStorage: function setStorage(key, val) {
	    try {
	      this.storage[this.localStorageKey[key] + this.params.IdentityPoolId + (this.params.LoginId || '')] = val;
	    } catch (_) {}
	  },

	  /**
	   * @api private
	   */
	  storage: (function() {
	    try {
	      return AWS.util.isBrowser() && window.localStorage !== null && typeof window.localStorage === 'object' ?
	             window.localStorage : {};
	    } catch (_) {
	      return {};
	    }
	  })()
	});


/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['cognitoidentity'] = {};
	AWS.CognitoIdentity = Service.defineService('cognitoidentity', ['2014-06-30']);
	__webpack_require__(187);
	Object.defineProperty(apiLoader.services['cognitoidentity'], '2014-06-30', {
	  get: function get() {
	    var model = __webpack_require__(188);
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.CognitoIdentity;


/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(93);

	AWS.util.update(AWS.CognitoIdentity.prototype, {
	  getOpenIdToken: function getOpenIdToken(params, callback) {
	    return this.makeUnauthenticatedRequest('getOpenIdToken', params, callback);
	  },

	  getId: function getId(params, callback) {
	    return this.makeUnauthenticatedRequest('getId', params, callback);
	  },

	  getCredentialsForIdentity: function getCredentialsForIdentity(params, callback) {
	    return this.makeUnauthenticatedRequest('getCredentialsForIdentity', params, callback);
	  }
	});


/***/ },
/* 188 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2014-06-30",
			"endpointPrefix": "cognito-identity",
			"jsonVersion": "1.1",
			"protocol": "json",
			"serviceFullName": "Amazon Cognito Identity",
			"signatureVersion": "v4",
			"targetPrefix": "AWSCognitoIdentityService"
		},
		"operations": {
			"CreateIdentityPool": {
				"input": {
					"type": "structure",
					"required": [
						"IdentityPoolName",
						"AllowUnauthenticatedIdentities"
					],
					"members": {
						"IdentityPoolName": {},
						"AllowUnauthenticatedIdentities": {
							"type": "boolean"
						},
						"SupportedLoginProviders": {
							"shape": "S4"
						},
						"DeveloperProviderName": {},
						"OpenIdConnectProviderARNs": {
							"shape": "S8"
						},
						"CognitoIdentityProviders": {
							"shape": "Sa"
						},
						"SamlProviderARNs": {
							"shape": "Se"
						}
					}
				},
				"output": {
					"shape": "Sf"
				}
			},
			"DeleteIdentities": {
				"input": {
					"type": "structure",
					"required": [
						"IdentityIdsToDelete"
					],
					"members": {
						"IdentityIdsToDelete": {
							"type": "list",
							"member": {}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"UnprocessedIdentityIds": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"IdentityId": {},
									"ErrorCode": {}
								}
							}
						}
					}
				}
			},
			"DeleteIdentityPool": {
				"input": {
					"type": "structure",
					"required": [
						"IdentityPoolId"
					],
					"members": {
						"IdentityPoolId": {}
					}
				}
			},
			"DescribeIdentity": {
				"input": {
					"type": "structure",
					"required": [
						"IdentityId"
					],
					"members": {
						"IdentityId": {}
					}
				},
				"output": {
					"shape": "Sq"
				}
			},
			"DescribeIdentityPool": {
				"input": {
					"type": "structure",
					"required": [
						"IdentityPoolId"
					],
					"members": {
						"IdentityPoolId": {}
					}
				},
				"output": {
					"shape": "Sf"
				}
			},
			"GetCredentialsForIdentity": {
				"input": {
					"type": "structure",
					"required": [
						"IdentityId"
					],
					"members": {
						"IdentityId": {},
						"Logins": {
							"shape": "Sv"
						},
						"CustomRoleArn": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"IdentityId": {},
						"Credentials": {
							"type": "structure",
							"members": {
								"AccessKeyId": {},
								"SecretKey": {},
								"SessionToken": {},
								"Expiration": {
									"type": "timestamp"
								}
							}
						}
					}
				}
			},
			"GetId": {
				"input": {
					"type": "structure",
					"required": [
						"IdentityPoolId"
					],
					"members": {
						"AccountId": {},
						"IdentityPoolId": {},
						"Logins": {
							"shape": "Sv"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"IdentityId": {}
					}
				}
			},
			"GetIdentityPoolRoles": {
				"input": {
					"type": "structure",
					"required": [
						"IdentityPoolId"
					],
					"members": {
						"IdentityPoolId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"IdentityPoolId": {},
						"Roles": {
							"shape": "S17"
						}
					}
				}
			},
			"GetOpenIdToken": {
				"input": {
					"type": "structure",
					"required": [
						"IdentityId"
					],
					"members": {
						"IdentityId": {},
						"Logins": {
							"shape": "Sv"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"IdentityId": {},
						"Token": {}
					}
				}
			},
			"GetOpenIdTokenForDeveloperIdentity": {
				"input": {
					"type": "structure",
					"required": [
						"IdentityPoolId",
						"Logins"
					],
					"members": {
						"IdentityPoolId": {},
						"IdentityId": {},
						"Logins": {
							"shape": "Sv"
						},
						"TokenDuration": {
							"type": "long"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"IdentityId": {},
						"Token": {}
					}
				}
			},
			"ListIdentities": {
				"input": {
					"type": "structure",
					"required": [
						"IdentityPoolId",
						"MaxResults"
					],
					"members": {
						"IdentityPoolId": {},
						"MaxResults": {
							"type": "integer"
						},
						"NextToken": {},
						"HideDisabled": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"IdentityPoolId": {},
						"Identities": {
							"type": "list",
							"member": {
								"shape": "Sq"
							}
						},
						"NextToken": {}
					}
				}
			},
			"ListIdentityPools": {
				"input": {
					"type": "structure",
					"required": [
						"MaxResults"
					],
					"members": {
						"MaxResults": {
							"type": "integer"
						},
						"NextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"IdentityPools": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"IdentityPoolId": {},
									"IdentityPoolName": {}
								}
							}
						},
						"NextToken": {}
					}
				}
			},
			"LookupDeveloperIdentity": {
				"input": {
					"type": "structure",
					"required": [
						"IdentityPoolId"
					],
					"members": {
						"IdentityPoolId": {},
						"IdentityId": {},
						"DeveloperUserIdentifier": {},
						"MaxResults": {
							"type": "integer"
						},
						"NextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"IdentityId": {},
						"DeveloperUserIdentifierList": {
							"type": "list",
							"member": {}
						},
						"NextToken": {}
					}
				}
			},
			"MergeDeveloperIdentities": {
				"input": {
					"type": "structure",
					"required": [
						"SourceUserIdentifier",
						"DestinationUserIdentifier",
						"DeveloperProviderName",
						"IdentityPoolId"
					],
					"members": {
						"SourceUserIdentifier": {},
						"DestinationUserIdentifier": {},
						"DeveloperProviderName": {},
						"IdentityPoolId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"IdentityId": {}
					}
				}
			},
			"SetIdentityPoolRoles": {
				"input": {
					"type": "structure",
					"required": [
						"IdentityPoolId",
						"Roles"
					],
					"members": {
						"IdentityPoolId": {},
						"Roles": {
							"shape": "S17"
						}
					}
				}
			},
			"UnlinkDeveloperIdentity": {
				"input": {
					"type": "structure",
					"required": [
						"IdentityId",
						"IdentityPoolId",
						"DeveloperProviderName",
						"DeveloperUserIdentifier"
					],
					"members": {
						"IdentityId": {},
						"IdentityPoolId": {},
						"DeveloperProviderName": {},
						"DeveloperUserIdentifier": {}
					}
				}
			},
			"UnlinkIdentity": {
				"input": {
					"type": "structure",
					"required": [
						"IdentityId",
						"Logins",
						"LoginsToRemove"
					],
					"members": {
						"IdentityId": {},
						"Logins": {
							"shape": "Sv"
						},
						"LoginsToRemove": {
							"shape": "Sr"
						}
					}
				}
			},
			"UpdateIdentityPool": {
				"input": {
					"shape": "Sf"
				},
				"output": {
					"shape": "Sf"
				}
			}
		},
		"shapes": {
			"S4": {
				"type": "map",
				"key": {},
				"value": {}
			},
			"S8": {
				"type": "list",
				"member": {}
			},
			"Sa": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"ProviderName": {},
						"ClientId": {}
					}
				}
			},
			"Se": {
				"type": "list",
				"member": {}
			},
			"Sf": {
				"type": "structure",
				"required": [
					"IdentityPoolId",
					"IdentityPoolName",
					"AllowUnauthenticatedIdentities"
				],
				"members": {
					"IdentityPoolId": {},
					"IdentityPoolName": {},
					"AllowUnauthenticatedIdentities": {
						"type": "boolean"
					},
					"SupportedLoginProviders": {
						"shape": "S4"
					},
					"DeveloperProviderName": {},
					"OpenIdConnectProviderARNs": {
						"shape": "S8"
					},
					"CognitoIdentityProviders": {
						"shape": "Sa"
					},
					"SamlProviderARNs": {
						"shape": "Se"
					}
				}
			},
			"Sq": {
				"type": "structure",
				"members": {
					"IdentityId": {},
					"Logins": {
						"shape": "Sr"
					},
					"CreationDate": {
						"type": "timestamp"
					},
					"LastModifiedDate": {
						"type": "timestamp"
					}
				}
			},
			"Sr": {
				"type": "list",
				"member": {}
			},
			"Sv": {
				"type": "map",
				"key": {},
				"value": {}
			},
			"S17": {
				"type": "map",
				"key": {},
				"value": {}
			}
		}
	};

/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(93);
	var STS = __webpack_require__(180);

	/**
	 * Represents credentials retrieved from STS SAML support.
	 *
	 * By default this provider gets credentials using the
	 * {AWS.STS.assumeRoleWithSAML} service operation. This operation
	 * requires a `RoleArn` containing the ARN of the IAM trust policy for the
	 * application for which credentials will be given, as well as a `PrincipalArn`
	 * representing the ARN for the SAML identity provider. In addition, the
	 * `SAMLAssertion` must be set to the token provided by the identity
	 * provider. See {constructor} for an example on creating a credentials
	 * object with proper `RoleArn`, `PrincipalArn`, and `SAMLAssertion` values.
	 *
	 * ## Refreshing Credentials from Identity Service
	 *
	 * In addition to AWS credentials expiring after a given amount of time, the
	 * login token from the identity provider will also expire. Once this token
	 * expires, it will not be usable to refresh AWS credentials, and another
	 * token will be needed. The SDK does not manage refreshing of the token value,
	 * but this can be done through a "refresh token" supported by most identity
	 * providers. Consult the documentation for the identity provider for refreshing
	 * tokens. Once the refreshed token is acquired, you should make sure to update
	 * this new token in the credentials object's {params} property. The following
	 * code will update the SAMLAssertion, assuming you have retrieved an updated
	 * token from the identity provider:
	 *
	 * ```javascript
	 * AWS.config.credentials.params.SAMLAssertion = updatedToken;
	 * ```
	 *
	 * Future calls to `credentials.refresh()` will now use the new token.
	 *
	 * @!attribute params
	 *   @return [map] the map of params passed to
	 *     {AWS.STS.assumeRoleWithSAML}. To update the token, set the
	 *     `params.SAMLAssertion` property.
	 */
	AWS.SAMLCredentials = AWS.util.inherit(AWS.Credentials, {
	  /**
	   * Creates a new credentials object.
	   * @param (see AWS.STS.assumeRoleWithSAML)
	   * @example Creating a new credentials object
	   *   AWS.config.credentials = new AWS.SAMLCredentials({
	   *     RoleArn: 'arn:aws:iam::1234567890:role/SAMLRole',
	   *     PrincipalArn: 'arn:aws:iam::1234567890:role/SAMLPrincipal',
	   *     SAMLAssertion: 'base64-token', // base64-encoded token from IdP
	   *   });
	   * @see AWS.STS.assumeRoleWithSAML
	   */
	  constructor: function SAMLCredentials(params) {
	    AWS.Credentials.call(this);
	    this.expired = true;
	    this.params = params;
	  },

	  /**
	   * Refreshes credentials using {AWS.STS.assumeRoleWithSAML}
	   *
	   * @callback callback function(err)
	   *   Called when the STS service responds (or fails). When
	   *   this callback is called with no error, it means that the credentials
	   *   information has been loaded into the object (as the `accessKeyId`,
	   *   `secretAccessKey`, and `sessionToken` properties).
	   *   @param err [Error] if an error occurred, this value will be filled
	   * @see get
	   */
	  refresh: function refresh(callback) {
	    var self = this;
	    self.createClients();
	    if (!callback) callback = function(err) { if (err) throw err; };

	    self.service.assumeRoleWithSAML(function (err, data) {
	      if (!err) {
	        self.service.credentialsFrom(data, self);
	      }
	      callback(err);
	    });
	  },

	  /**
	   * @api private
	   */
	  createClients: function() {
	    this.service = this.service || new STS({params: this.params});
	  }

	});


/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(93);
	__webpack_require__(177);
	__webpack_require__(178);
	var PromisesDependency;

	/**
	 * The main configuration class used by all service objects to set
	 * the region, credentials, and other options for requests.
	 *
	 * By default, credentials and region settings are left unconfigured.
	 * This should be configured by the application before using any
	 * AWS service APIs.
	 *
	 * In order to set global configuration options, properties should
	 * be assigned to the global {AWS.config} object.
	 *
	 * @see AWS.config
	 *
	 * @!group General Configuration Options
	 *
	 * @!attribute credentials
	 *   @return [AWS.Credentials] the AWS credentials to sign requests with.
	 *
	 * @!attribute region
	 *   @example Set the global region setting to us-west-2
	 *     AWS.config.update({region: 'us-west-2'});
	 *   @return [AWS.Credentials] The region to send service requests to.
	 *   @see http://docs.amazonwebservices.com/general/latest/gr/rande.html
	 *     A list of available endpoints for each AWS service
	 *
	 * @!attribute maxRetries
	 *   @return [Integer] the maximum amount of retries to perform for a
	 *     service request. By default this value is calculated by the specific
	 *     service object that the request is being made to.
	 *
	 * @!attribute maxRedirects
	 *   @return [Integer] the maximum amount of redirects to follow for a
	 *     service request. Defaults to 10.
	 *
	 * @!attribute paramValidation
	 *   @return [Boolean|map] whether input parameters should be validated against
	 *     the operation description before sending the request. Defaults to true.
	 *     Pass a map to enable any of the following specific validation features:
	 *
	 *     * **min** [Boolean] &mdash; Validates that a value meets the min
	 *       constraint. This is enabled by default when paramValidation is set
	 *       to `true`.
	 *     * **max** [Boolean] &mdash; Validates that a value meets the max
	 *       constraint.
	 *     * **pattern** [Boolean] &mdash; Validates that a string value matches a
	 *       regular expression.
	 *     * **enum** [Boolean] &mdash; Validates that a string value matches one
	 *       of the allowable enum values.
	 *
	 * @!attribute computeChecksums
	 *   @return [Boolean] whether to compute checksums for payload bodies when
	 *     the service accepts it (currently supported in S3 only).
	 *
	 * @!attribute convertResponseTypes
	 *   @return [Boolean] whether types are converted when parsing response data.
	 *     Currently only supported for JSON based services. Turning this off may
	 *     improve performance on large response payloads. Defaults to `true`.
	 *
	 * @!attribute correctClockSkew
	 *   @return [Boolean] whether to apply a clock skew correction and retry
	 *     requests that fail because of an skewed client clock. Defaults to
	 *     `false`.
	 *
	 * @!attribute sslEnabled
	 *   @return [Boolean] whether SSL is enabled for requests
	 *
	 * @!attribute s3ForcePathStyle
	 *   @return [Boolean] whether to force path style URLs for S3 objects
	 *
	 * @!attribute s3BucketEndpoint
	 *   @note Setting this configuration option requires an `endpoint` to be
	 *     provided explicitly to the service constructor.
	 *   @return [Boolean] whether the provided endpoint addresses an individual
	 *     bucket (false if it addresses the root API endpoint).
	 *
	 * @!attribute s3DisableBodySigning
	 *   @return [Boolean] whether to disable S3 body signing when using signature version `v4`.
	 *     Body signing can only be disabled when using https. Defaults to `true`.
	 *
	 * @!attribute useAccelerateEndpoint
	 *   @note This configuration option is only compatible with S3 while accessing
	 *     dns-compatible buckets.
	 *   @return [Boolean] Whether to use the Accelerate endpoint with the S3 service.
	 *     Defaults to `false`.
	 *
	 * @!attribute retryDelayOptions
	 *   @example Set the base retry delay for all services to 300 ms
	 *     AWS.config.update({retryDelayOptions: {base: 300}});
	 *     // Delays with maxRetries = 3: 300, 600, 1200
	 *   @example Set a custom backoff function to provide delay values on retries
	 *     AWS.config.update({retryDelayOptions: {customBackoff: function(retryCount) {
	 *       // returns delay in ms
	 *     }}});
	 *   @note This works with all services except DynamoDB.
	 *   @return [map] A set of options to configure the retry delay on retryable errors.
	 *     Currently supported options are:
	 *
	 *     * **base** [Integer] &mdash; The base number of milliseconds to use in the
	 *       exponential backoff for operation retries. Defaults to 100 ms.
	 *     * **customBackoff ** [function] &mdash; A custom function that accepts a retry count
	 *       and returns the amount of time to delay in milliseconds. The `base` option will be
	 *       ignored if this option is supplied.
	 *
	 * @!attribute httpOptions
	 *   @return [map] A set of options to pass to the low-level HTTP request.
	 *     Currently supported options are:
	 *
	 *     * **proxy** [String] &mdash; the URL to proxy requests through
	 *     * **agent** [http.Agent, https.Agent] &mdash; the Agent object to perform
	 *       HTTP requests with. Used for connection pooling. Defaults to the global
	 *       agent (`http.globalAgent`) for non-SSL connections. Note that for
	 *       SSL connections, a special Agent object is used in order to enable
	 *       peer certificate verification. This feature is only supported in the
	 *       Node.js environment.
	 *     * **timeout** [Integer] &mdash; The number of milliseconds to wait before
	 *       giving up on a connection attempt. Defaults to two minutes (120000).
	 *     * **xhrAsync** [Boolean] &mdash; Whether the SDK will send asynchronous
	 *       HTTP requests. Used in the browser environment only. Set to false to
	 *       send requests synchronously. Defaults to true (async on).
	 *     * **xhrWithCredentials** [Boolean] &mdash; Sets the "withCredentials"
	 *       property of an XMLHttpRequest object. Used in the browser environment
	 *       only. Defaults to false.
	 * @!attribute logger
	 *   @return [#write,#log] an object that responds to .write() (like a stream)
	 *     or .log() (like the console object) in order to log information about
	 *     requests
	 *
	 * @!attribute systemClockOffset
	 *   @return [Number] an offset value in milliseconds to apply to all signing
	 *     times. Use this to compensate for clock skew when your system may be
	 *     out of sync with the service time. Note that this configuration option
	 *     can only be applied to the global `AWS.config` object and cannot be
	 *     overridden in service-specific configuration. Defaults to 0 milliseconds.
	 *
	 * @!attribute signatureVersion
	 *   @return [String] the signature version to sign requests with (overriding
	 *     the API configuration). Possible values are: 'v2', 'v3', 'v4'.
	 *
	 * @!attribute signatureCache
	 *   @return [Boolean] whether the signature to sign requests with (overriding
	 *     the API configuration) is cached. Only applies to the signature version 'v4'.
	 *     Defaults to `true`.
	 */
	AWS.Config = AWS.util.inherit({
	  /**
	   * @!endgroup
	   */

	  /**
	   * Creates a new configuration object. This is the object that passes
	   * option data along to service requests, including credentials, security,
	   * region information, and some service specific settings.
	   *
	   * @example Creating a new configuration object with credentials and region
	   *   var config = new AWS.Config({
	   *     accessKeyId: 'AKID', secretAccessKey: 'SECRET', region: 'us-west-2'
	   *   });
	   * @option options accessKeyId [String] your AWS access key ID.
	   * @option options secretAccessKey [String] your AWS secret access key.
	   * @option options sessionToken [AWS.Credentials] the optional AWS
	   *   session token to sign requests with.
	   * @option options credentials [AWS.Credentials] the AWS credentials
	   *   to sign requests with. You can either specify this object, or
	   *   specify the accessKeyId and secretAccessKey options directly.
	   * @option options credentialProvider [AWS.CredentialProviderChain] the
	   *   provider chain used to resolve credentials if no static `credentials`
	   *   property is set.
	   * @option options region [String] the region to send service requests to.
	   *   See {region} for more information.
	   * @option options maxRetries [Integer] the maximum amount of retries to
	   *   attempt with a request. See {maxRetries} for more information.
	   * @option options maxRedirects [Integer] the maximum amount of redirects to
	   *   follow with a request. See {maxRedirects} for more information.
	   * @option options sslEnabled [Boolean] whether to enable SSL for
	   *   requests.
	   * @option options paramValidation [Boolean|map] whether input parameters
	   *   should be validated against the operation description before sending
	   *   the request. Defaults to true. Pass a map to enable any of the
	   *   following specific validation features:
	   *
	   *   * **min** [Boolean] &mdash; Validates that a value meets the min
	   *     constraint. This is enabled by default when paramValidation is set
	   *     to `true`.
	   *   * **max** [Boolean] &mdash; Validates that a value meets the max
	   *     constraint.
	   *   * **pattern** [Boolean] &mdash; Validates that a string value matches a
	   *     regular expression.
	   *   * **enum** [Boolean] &mdash; Validates that a string value matches one
	   *     of the allowable enum values.
	   * @option options computeChecksums [Boolean] whether to compute checksums
	   *   for payload bodies when the service accepts it (currently supported
	   *   in S3 only)
	   * @option options convertResponseTypes [Boolean] whether types are converted
	   *     when parsing response data. Currently only supported for JSON based
	   *     services. Turning this off may improve performance on large response
	   *     payloads. Defaults to `true`.
	   * @option options correctClockSkew [Boolean] whether to apply a clock skew
	   *     correction and retry requests that fail because of an skewed client
	   *     clock. Defaults to `false`.
	   * @option options s3ForcePathStyle [Boolean] whether to force path
	   *   style URLs for S3 objects.
	   * @option options s3BucketEndpoint [Boolean] whether the provided endpoint
	   *   addresses an individual bucket (false if it addresses the root API
	   *   endpoint). Note that setting this configuration option requires an
	   *   `endpoint` to be provided explicitly to the service constructor.
	   * @option options s3DisableBodySigning [Boolean] whether S3 body signing
	   *   should be disabled when using signature version `v4`. Body signing
	   *   can only be disabled when using https. Defaults to `true`.
	   *
	   * @option options retryDelayOptions [map] A set of options to configure
	   *   the retry delay on retryable errors. Currently supported options are:
	   *
	   *   * **base** [Integer] &mdash; The base number of milliseconds to use in the
	   *     exponential backoff for operation retries. Defaults to 100 ms.
	   *   * **customBackoff ** [function] &mdash; A custom function that accepts a retry count
	   *     and returns the amount of time to delay in milliseconds. The `base` option will be
	   *     ignored if this option is supplied.
	   * @option options httpOptions [map] A set of options to pass to the low-level
	   *   HTTP request. Currently supported options are:
	   *
	   *   * **proxy** [String] &mdash; the URL to proxy requests through
	   *   * **agent** [http.Agent, https.Agent] &mdash; the Agent object to perform
	   *     HTTP requests with. Used for connection pooling. Defaults to the global
	   *     agent (`http.globalAgent`) for non-SSL connections. Note that for
	   *     SSL connections, a special Agent object is used in order to enable
	   *     peer certificate verification. This feature is only available in the
	   *     Node.js environment.
	   *   * **timeout** [Integer] &mdash; Sets the socket to timeout after timeout
	   *     milliseconds of inactivity on the socket. Defaults to two minutes
	   *     (120000).
	   *   * **xhrAsync** [Boolean] &mdash; Whether the SDK will send asynchronous
	   *     HTTP requests. Used in the browser environment only. Set to false to
	   *     send requests synchronously. Defaults to true (async on).
	   *   * **xhrWithCredentials** [Boolean] &mdash; Sets the "withCredentials"
	   *     property of an XMLHttpRequest object. Used in the browser environment
	   *     only. Defaults to false.
	   * @option options apiVersion [String, Date] a String in YYYY-MM-DD format
	   *   (or a date) that represents the latest possible API version that can be
	   *   used in all services (unless overridden by `apiVersions`). Specify
	   *   'latest' to use the latest possible version.
	   * @option options apiVersions [map<String, String|Date>] a map of service
	   *   identifiers (the lowercase service class name) with the API version to
	   *   use when instantiating a service. Specify 'latest' for each individual
	   *   that can use the latest available version.
	   * @option options logger [#write,#log] an object that responds to .write()
	   *   (like a stream) or .log() (like the console object) in order to log
	   *   information about requests
	   * @option options systemClockOffset [Number] an offset value in milliseconds
	   *   to apply to all signing times. Use this to compensate for clock skew
	   *   when your system may be out of sync with the service time. Note that
	   *   this configuration option can only be applied to the global `AWS.config`
	   *   object and cannot be overridden in service-specific configuration.
	   *   Defaults to 0 milliseconds.
	   * @option options signatureVersion [String] the signature version to sign
	   *   requests with (overriding the API configuration). Possible values are:
	   *   'v2', 'v3', 'v4'.
	   * @option options signatureCache [Boolean] whether the signature to sign
	   *   requests with (overriding the API configuration) is cached. Only applies
	   *   to the signature version 'v4'. Defaults to `true`.
	   */
	  constructor: function Config(options) {
	    if (options === undefined) options = {};
	    options = this.extractCredentials(options);

	    AWS.util.each.call(this, this.keys, function (key, value) {
	      this.set(key, options[key], value);
	    });
	  },

	  /**
	   * @!group Managing Credentials
	   */

	  /**
	   * Loads credentials from the configuration object. This is used internally
	   * by the SDK to ensure that refreshable {Credentials} objects are properly
	   * refreshed and loaded when sending a request. If you want to ensure that
	   * your credentials are loaded prior to a request, you can use this method
	   * directly to provide accurate credential data stored in the object.
	   *
	   * @note If you configure the SDK with static or environment credentials,
	   *   the credential data should already be present in {credentials} attribute.
	   *   This method is primarily necessary to load credentials from asynchronous
	   *   sources, or sources that can refresh credentials periodically.
	   * @example Getting your access key
	   *   AWS.config.getCredentials(function(err) {
	   *     if (err) console.log(err.stack); // credentials not loaded
	   *     else console.log("Access Key:", AWS.config.credentials.accessKeyId);
	   *   })
	   * @callback callback function(err)
	   *   Called when the {credentials} have been properly set on the configuration
	   *   object.
	   *
	   *   @param err [Error] if this is set, credentials were not successfuly
	   *     loaded and this error provides information why.
	   * @see credentials
	   * @see Credentials
	   */
	  getCredentials: function getCredentials(callback) {
	    var self = this;

	    function finish(err) {
	      callback(err, err ? null : self.credentials);
	    }

	    function credError(msg, err) {
	      return new AWS.util.error(err || new Error(), {
	        code: 'CredentialsError', message: msg
	      });
	    }

	    function getAsyncCredentials() {
	      self.credentials.get(function(err) {
	        if (err) {
	          var msg = 'Could not load credentials from ' +
	            self.credentials.constructor.name;
	          err = credError(msg, err);
	        }
	        finish(err);
	      });
	    }

	    function getStaticCredentials() {
	      var err = null;
	      if (!self.credentials.accessKeyId || !self.credentials.secretAccessKey) {
	        err = credError('Missing credentials');
	      }
	      finish(err);
	    }

	    if (self.credentials) {
	      if (typeof self.credentials.get === 'function') {
	        getAsyncCredentials();
	      } else { // static credentials
	        getStaticCredentials();
	      }
	    } else if (self.credentialProvider) {
	      self.credentialProvider.resolve(function(err, creds) {
	        if (err) {
	          err = credError('Could not load credentials from any providers', err);
	        }
	        self.credentials = creds;
	        finish(err);
	      });
	    } else {
	      finish(credError('No credentials to load'));
	    }
	  },

	  /**
	   * @!group Loading and Setting Configuration Options
	   */

	  /**
	   * @overload update(options, allowUnknownKeys = false)
	   *   Updates the current configuration object with new options.
	   *
	   *   @example Update maxRetries property of a configuration object
	   *     config.update({maxRetries: 10});
	   *   @param [Object] options a map of option keys and values.
	   *   @param [Boolean] allowUnknownKeys whether unknown keys can be set on
	   *     the configuration object. Defaults to `false`.
	   *   @see constructor
	   */
	  update: function update(options, allowUnknownKeys) {
	    allowUnknownKeys = allowUnknownKeys || false;
	    options = this.extractCredentials(options);
	    AWS.util.each.call(this, options, function (key, value) {
	      if (allowUnknownKeys || Object.prototype.hasOwnProperty.call(this.keys, key) ||
	          AWS.Service.hasService(key)) {
	        this.set(key, value);
	      }
	    });
	  },

	  /**
	   * Loads configuration data from a JSON file into this config object.
	   * @note Loading configuration will reset all existing configuration
	   *   on the object.
	   * @!macro nobrowser
	   * @param path [String] the path relative to your process's current
	   *    working directory to load configuration from.
	   * @return [AWS.Config] the same configuration object
	   */
	  loadFromPath: function loadFromPath(path) {
	    this.clear();

	    var options = JSON.parse(AWS.util.readFileSync(path));
	    var fileSystemCreds = new AWS.FileSystemCredentials(path);
	    var chain = new AWS.CredentialProviderChain();
	    chain.providers.unshift(fileSystemCreds);
	    chain.resolve(function (err, creds) {
	      if (err) throw err;
	      else options.credentials = creds;
	    });

	    this.constructor(options);

	    return this;
	  },

	  /**
	   * Clears configuration data on this object
	   *
	   * @api private
	   */
	  clear: function clear() {
	    /*jshint forin:false */
	    AWS.util.each.call(this, this.keys, function (key) {
	      delete this[key];
	    });

	    // reset credential provider
	    this.set('credentials', undefined);
	    this.set('credentialProvider', undefined);
	  },

	  /**
	   * Sets a property on the configuration object, allowing for a
	   * default value
	   * @api private
	   */
	  set: function set(property, value, defaultValue) {
	    if (value === undefined) {
	      if (defaultValue === undefined) {
	        defaultValue = this.keys[property];
	      }
	      if (typeof defaultValue === 'function') {
	        this[property] = defaultValue.call(this);
	      } else {
	        this[property] = defaultValue;
	      }
	    } else if (property === 'httpOptions' && this[property]) {
	      // deep merge httpOptions
	      this[property] = AWS.util.merge(this[property], value);
	    } else {
	      this[property] = value;
	    }
	  },

	  /**
	   * All of the keys with their default values.
	   *
	   * @constant
	   * @api private
	   */
	  keys: {
	    credentials: null,
	    credentialProvider: null,
	    region: null,
	    logger: null,
	    apiVersions: {},
	    apiVersion: null,
	    endpoint: undefined,
	    httpOptions: {
	      timeout: 120000
	    },
	    maxRetries: undefined,
	    maxRedirects: 10,
	    paramValidation: true,
	    sslEnabled: true,
	    s3ForcePathStyle: false,
	    s3BucketEndpoint: false,
	    s3DisableBodySigning: true,
	    computeChecksums: true,
	    convertResponseTypes: true,
	    correctClockSkew: false,
	    customUserAgent: null,
	    dynamoDbCrc32: true,
	    systemClockOffset: 0,
	    signatureVersion: null,
	    signatureCache: true,
	    retryDelayOptions: {
	      base: 100
	    },
	    useAccelerateEndpoint: false
	  },

	  /**
	   * Extracts accessKeyId, secretAccessKey and sessionToken
	   * from a configuration hash.
	   *
	   * @api private
	   */
	  extractCredentials: function extractCredentials(options) {
	    if (options.accessKeyId && options.secretAccessKey) {
	      options = AWS.util.copy(options);
	      options.credentials = new AWS.Credentials(options);
	    }
	    return options;
	  },

	  /**
	   * Sets the promise dependency the SDK will use wherever Promises are returned.
	   * @param [Constructor] dep A reference to a Promise constructor
	   */
	  setPromisesDependency: function setPromisesDependency(dep) {
	    PromisesDependency = dep;
	    var constructors = [AWS.Request, AWS.Credentials, AWS.CredentialProviderChain];
	    if (AWS.S3 && AWS.S3.ManagedUpload) constructors.push(AWS.S3.ManagedUpload);
	    AWS.util.addPromises(constructors, dep);
	  },

	  /**
	   * Gets the promise dependency set by `AWS.config.setPromisesDependency`.
	   */
	  getPromisesDependency: function getPromisesDependency() {
	    return PromisesDependency;
	  }
	});

	/**
	 * @return [AWS.Config] The global configuration object singleton instance
	 * @readonly
	 * @see AWS.Config
	 */
	AWS.config = new AWS.Config();


/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(93);
	var inherit = AWS.util.inherit;

	/**
	 * The endpoint that a service will talk to, for example,
	 * `'https://ec2.ap-southeast-1.amazonaws.com'`. If
	 * you need to override an endpoint for a service, you can
	 * set the endpoint on a service by passing the endpoint
	 * object with the `endpoint` option key:
	 *
	 * ```javascript
	 * var ep = new AWS.Endpoint('awsproxy.example.com');
	 * var s3 = new AWS.S3({endpoint: ep});
	 * s3.service.endpoint.hostname == 'awsproxy.example.com'
	 * ```
	 *
	 * Note that if you do not specify a protocol, the protocol will
	 * be selected based on your current {AWS.config} configuration.
	 *
	 * @!attribute protocol
	 *   @return [String] the protocol (http or https) of the endpoint
	 *     URL
	 * @!attribute hostname
	 *   @return [String] the host portion of the endpoint, e.g.,
	 *     example.com
	 * @!attribute host
	 *   @return [String] the host portion of the endpoint including
	 *     the port, e.g., example.com:80
	 * @!attribute port
	 *   @return [Integer] the port of the endpoint
	 * @!attribute href
	 *   @return [String] the full URL of the endpoint
	 */
	AWS.Endpoint = inherit({

	  /**
	   * @overload Endpoint(endpoint)
	   *   Constructs a new endpoint given an endpoint URL. If the
	   *   URL omits a protocol (http or https), the default protocol
	   *   set in the global {AWS.config} will be used.
	   *   @param endpoint [String] the URL to construct an endpoint from
	   */
	  constructor: function Endpoint(endpoint, config) {
	    AWS.util.hideProperties(this, ['slashes', 'auth', 'hash', 'search', 'query']);

	    if (typeof endpoint === 'undefined' || endpoint === null) {
	      throw new Error('Invalid endpoint: ' + endpoint);
	    } else if (typeof endpoint !== 'string') {
	      return AWS.util.copy(endpoint);
	    }

	    if (!endpoint.match(/^http/)) {
	      var useSSL = config && config.sslEnabled !== undefined ?
	        config.sslEnabled : AWS.config.sslEnabled;
	      endpoint = (useSSL ? 'https' : 'http') + '://' + endpoint;
	    }

	    AWS.util.update(this, AWS.util.urlParse(endpoint));

	    // Ensure the port property is set as an integer
	    if (this.port) {
	      this.port = parseInt(this.port, 10);
	    } else {
	      this.port = this.protocol === 'https:' ? 443 : 80;
	    }
	  }

	});

	/**
	 * The low level HTTP request object, encapsulating all HTTP header
	 * and body data sent by a service request.
	 *
	 * @!attribute method
	 *   @return [String] the HTTP method of the request
	 * @!attribute path
	 *   @return [String] the path portion of the URI, e.g.,
	 *     "/list/?start=5&num=10"
	 * @!attribute headers
	 *   @return [map<String,String>]
	 *     a map of header keys and their respective values
	 * @!attribute body
	 *   @return [String] the request body payload
	 * @!attribute endpoint
	 *   @return [AWS.Endpoint] the endpoint for the request
	 * @!attribute region
	 *   @api private
	 *   @return [String] the region, for signing purposes only.
	 */
	AWS.HttpRequest = inherit({

	  /**
	   * @api private
	   */
	  constructor: function HttpRequest(endpoint, region, customUserAgent) {
	    endpoint = new AWS.Endpoint(endpoint);
	    this.method = 'POST';
	    this.path = endpoint.path || '/';
	    this.headers = {};
	    this.body = '';
	    this.endpoint = endpoint;
	    this.region = region;
	    this.setUserAgent(customUserAgent);
	  },

	  /**
	   * @api private
	   */
	  setUserAgent: function setUserAgent(customUserAgent) {
	    var prefix = AWS.util.isBrowser() ? 'X-Amz-' : '';
	    var customSuffix = '';
	    if (typeof customUserAgent === 'string' && customUserAgent) {
	      customSuffix += ' ' + customUserAgent;
	    }
	    this.headers[prefix + 'User-Agent'] = AWS.util.userAgent() + customSuffix;
	  },

	  /**
	   * @return [String] the part of the {path} excluding the
	   *   query string
	   */
	  pathname: function pathname() {
	    return this.path.split('?', 1)[0];
	  },

	  /**
	   * @return [String] the query string portion of the {path}
	   */
	  search: function search() {
	    var query = this.path.split('?', 2)[1];
	    if (query) {
	      query = AWS.util.queryStringParse(query);
	      return AWS.util.queryParamsToString(query);
	    }
	    return '';
	  }

	});

	/**
	 * The low level HTTP response object, encapsulating all HTTP header
	 * and body data returned from the request.
	 *
	 * @!attribute statusCode
	 *   @return [Integer] the HTTP status code of the response (e.g., 200, 404)
	 * @!attribute headers
	 *   @return [map<String,String>]
	 *      a map of response header keys and their respective values
	 * @!attribute body
	 *   @return [String] the response body payload
	 * @!attribute [r] streaming
	 *   @return [Boolean] whether this response is being streamed at a low-level.
	 *     Defaults to `false` (buffered reads). Do not modify this manually, use
	 *     {createUnbufferedStream} to convert the stream to unbuffered mode
	 *     instead.
	 */
	AWS.HttpResponse = inherit({

	  /**
	   * @api private
	   */
	  constructor: function HttpResponse() {
	    this.statusCode = undefined;
	    this.headers = {};
	    this.body = undefined;
	    this.streaming = false;
	    this.stream = null;
	  },

	  /**
	   * Disables buffering on the HTTP response and returns the stream for reading.
	   * @return [Stream, XMLHttpRequest, null] the underlying stream object.
	   *   Use this object to directly read data off of the stream.
	   * @note This object is only available after the {AWS.Request~httpHeaders}
	   *   event has fired. This method must be called prior to
	   *   {AWS.Request~httpData}.
	   * @example Taking control of a stream
	   *   request.on('httpHeaders', function(statusCode, headers) {
	   *     if (statusCode < 300) {
	   *       if (headers.etag === 'xyz') {
	   *         // pipe the stream, disabling buffering
	   *         var stream = this.response.httpResponse.createUnbufferedStream();
	   *         stream.pipe(process.stdout);
	   *       } else { // abort this request and set a better error message
	   *         this.abort();
	   *         this.response.error = new Error('Invalid ETag');
	   *       }
	   *     }
	   *   }).send(console.log);
	   */
	  createUnbufferedStream: function createUnbufferedStream() {
	    this.streaming = true;
	    return this.stream;
	  }
	});


	AWS.HttpClient = inherit({});

	/**
	 * @api private
	 */
	AWS.HttpClient.getInstance = function getInstance() {
	  if (this.singleton === undefined) {
	    this.singleton = new this();
	  }
	  return this.singleton;
	};


/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(93);

	/**
	 * @api private
	 * @!method on(eventName, callback)
	 *   Registers an event listener callback for the event given by `eventName`.
	 *   Parameters passed to the callback function depend on the individual event
	 *   being triggered. See the event documentation for those parameters.
	 *
	 *   @param eventName [String] the event name to register the listener for
	 *   @param callback [Function] the listener callback function
	 *   @return [AWS.SequentialExecutor] the same object for chaining
	 */
	AWS.SequentialExecutor = AWS.util.inherit({

	  constructor: function SequentialExecutor() {
	    this._events = {};
	  },

	  /**
	   * @api private
	   */
	  listeners: function listeners(eventName) {
	    return this._events[eventName] ? this._events[eventName].slice(0) : [];
	  },

	  on: function on(eventName, listener) {
	    if (this._events[eventName]) {
	      this._events[eventName].push(listener);
	    } else {
	      this._events[eventName] = [listener];
	    }
	    return this;
	  },

	  /**
	   * @api private
	   */
	  onAsync: function onAsync(eventName, listener) {
	    listener._isAsync = true;
	    return this.on(eventName, listener);
	  },

	  removeListener: function removeListener(eventName, listener) {
	    var listeners = this._events[eventName];
	    if (listeners) {
	      var length = listeners.length;
	      var position = -1;
	      for (var i = 0; i < length; ++i) {
	        if (listeners[i] === listener) {
	          position = i;
	        }
	      }
	      if (position > -1) {
	        listeners.splice(position, 1);
	      }
	    }
	    return this;
	  },

	  removeAllListeners: function removeAllListeners(eventName) {
	    if (eventName) {
	      delete this._events[eventName];
	    } else {
	      this._events = {};
	    }
	    return this;
	  },

	  /**
	   * @api private
	   */
	  emit: function emit(eventName, eventArgs, doneCallback) {
	    if (!doneCallback) doneCallback = function() { };
	    var listeners = this.listeners(eventName);
	    var count = listeners.length;
	    this.callListeners(listeners, eventArgs, doneCallback);
	    return count > 0;
	  },

	  /**
	   * @api private
	   */
	  callListeners: function callListeners(listeners, args, doneCallback, prevError) {
	    var self = this;
	    var error = prevError || null;

	    function callNextListener(err) {
	      if (err) {
	        error = AWS.util.error(error || new Error(), err);
	        if (self._haltHandlersOnError) {
	          return doneCallback.call(self, error);
	        }
	      }
	      self.callListeners(listeners, args, doneCallback, error);
	    }

	    while (listeners.length > 0) {
	      var listener = listeners.shift();
	      if (listener._isAsync) { // asynchronous listener
	        listener.apply(self, args.concat([callNextListener]));
	        return; // stop here, callNextListener will continue
	      } else { // synchronous listener
	        try {
	          listener.apply(self, args);
	        } catch (err) {
	          error = AWS.util.error(error || new Error(), err);
	        }
	        if (error && self._haltHandlersOnError) {
	          doneCallback.call(self, error);
	          return;
	        }
	      }
	    }
	    doneCallback.call(self, error);
	  },

	  /**
	   * Adds or copies a set of listeners from another list of
	   * listeners or SequentialExecutor object.
	   *
	   * @param listeners [map<String,Array<Function>>, AWS.SequentialExecutor]
	   *   a list of events and callbacks, or an event emitter object
	   *   containing listeners to add to this emitter object.
	   * @return [AWS.SequentialExecutor] the emitter object, for chaining.
	   * @example Adding listeners from a map of listeners
	   *   emitter.addListeners({
	   *     event1: [function() { ... }, function() { ... }],
	   *     event2: [function() { ... }]
	   *   });
	   *   emitter.emit('event1'); // emitter has event1
	   *   emitter.emit('event2'); // emitter has event2
	   * @example Adding listeners from another emitter object
	   *   var emitter1 = new AWS.SequentialExecutor();
	   *   emitter1.on('event1', function() { ... });
	   *   emitter1.on('event2', function() { ... });
	   *   var emitter2 = new AWS.SequentialExecutor();
	   *   emitter2.addListeners(emitter1);
	   *   emitter2.emit('event1'); // emitter2 has event1
	   *   emitter2.emit('event2'); // emitter2 has event2
	   */
	  addListeners: function addListeners(listeners) {
	    var self = this;

	    // extract listeners if parameter is an SequentialExecutor object
	    if (listeners._events) listeners = listeners._events;

	    AWS.util.each(listeners, function(event, callbacks) {
	      if (typeof callbacks === 'function') callbacks = [callbacks];
	      AWS.util.arrayEach(callbacks, function(callback) {
	        self.on(event, callback);
	      });
	    });

	    return self;
	  },

	  /**
	   * Registers an event with {on} and saves the callback handle function
	   * as a property on the emitter object using a given `name`.
	   *
	   * @param name [String] the property name to set on this object containing
	   *   the callback function handle so that the listener can be removed in
	   *   the future.
	   * @param (see on)
	   * @return (see on)
	   * @example Adding a named listener DATA_CALLBACK
	   *   var listener = function() { doSomething(); };
	   *   emitter.addNamedListener('DATA_CALLBACK', 'data', listener);
	   *
	   *   // the following prints: true
	   *   console.log(emitter.DATA_CALLBACK == listener);
	   */
	  addNamedListener: function addNamedListener(name, eventName, callback) {
	    this[name] = callback;
	    this.addListener(eventName, callback);
	    return this;
	  },

	  /**
	   * @api private
	   */
	  addNamedAsyncListener: function addNamedAsyncListener(name, eventName, callback) {
	    callback._isAsync = true;
	    return this.addNamedListener(name, eventName, callback);
	  },

	  /**
	   * Helper method to add a set of named listeners using
	   * {addNamedListener}. The callback contains a parameter
	   * with a handle to the `addNamedListener` method.
	   *
	   * @callback callback function(add)
	   *   The callback function is called immediately in order to provide
	   *   the `add` function to the block. This simplifies the addition of
	   *   a large group of named listeners.
	   *   @param add [Function] the {addNamedListener} function to call
	   *     when registering listeners.
	   * @example Adding a set of named listeners
	   *   emitter.addNamedListeners(function(add) {
	   *     add('DATA_CALLBACK', 'data', function() { ... });
	   *     add('OTHER', 'otherEvent', function() { ... });
	   *     add('LAST', 'lastEvent', function() { ... });
	   *   });
	   *
	   *   // these properties are now set:
	   *   emitter.DATA_CALLBACK;
	   *   emitter.OTHER;
	   *   emitter.LAST;
	   */
	  addNamedListeners: function addNamedListeners(callback) {
	    var self = this;
	    callback(
	      function() {
	        self.addNamedListener.apply(self, arguments);
	      },
	      function() {
	        self.addNamedAsyncListener.apply(self, arguments);
	      }
	    );
	    return this;
	  }
	});

	/**
	 * {on} is the prefered method.
	 * @api private
	 */
	AWS.SequentialExecutor.prototype.addListener = AWS.SequentialExecutor.prototype.on;

	module.exports = AWS.SequentialExecutor;


/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(93);
	var SequentialExecutor = __webpack_require__(192);

	/**
	 * The namespace used to register global event listeners for request building
	 * and sending.
	 */
	AWS.EventListeners = {
	  /**
	   * @!attribute VALIDATE_CREDENTIALS
	   *   A request listener that validates whether the request is being
	   *   sent with credentials.
	   *   Handles the {AWS.Request~validate 'validate' Request event}
	   *   @example Sending a request without validating credentials
	   *     var listener = AWS.EventListeners.Core.VALIDATE_CREDENTIALS;
	   *     request.removeListener('validate', listener);
	   *   @readonly
	   *   @return [Function]
	   * @!attribute VALIDATE_REGION
	   *   A request listener that validates whether the region is set
	   *   for a request.
	   *   Handles the {AWS.Request~validate 'validate' Request event}
	   *   @example Sending a request without validating region configuration
	   *     var listener = AWS.EventListeners.Core.VALIDATE_REGION;
	   *     request.removeListener('validate', listener);
	   *   @readonly
	   *   @return [Function]
	   * @!attribute VALIDATE_PARAMETERS
	   *   A request listener that validates input parameters in a request.
	   *   Handles the {AWS.Request~validate 'validate' Request event}
	   *   @example Sending a request without validating parameters
	   *     var listener = AWS.EventListeners.Core.VALIDATE_PARAMETERS;
	   *     request.removeListener('validate', listener);
	   *   @example Disable parameter validation globally
	   *     AWS.EventListeners.Core.removeListener('validate',
	   *       AWS.EventListeners.Core.VALIDATE_REGION);
	   *   @readonly
	   *   @return [Function]
	   * @!attribute SEND
	   *   A request listener that initiates the HTTP connection for a
	   *   request being sent. Handles the {AWS.Request~send 'send' Request event}
	   *   @example Replacing the HTTP handler
	   *     var listener = AWS.EventListeners.Core.SEND;
	   *     request.removeListener('send', listener);
	   *     request.on('send', function(response) {
	   *       customHandler.send(response);
	   *     });
	   *   @return [Function]
	   *   @readonly
	   * @!attribute HTTP_DATA
	   *   A request listener that reads data from the HTTP connection in order
	   *   to build the response data.
	   *   Handles the {AWS.Request~httpData 'httpData' Request event}.
	   *   Remove this handler if you are overriding the 'httpData' event and
	   *   do not want extra data processing and buffering overhead.
	   *   @example Disabling default data processing
	   *     var listener = AWS.EventListeners.Core.HTTP_DATA;
	   *     request.removeListener('httpData', listener);
	   *   @return [Function]
	   *   @readonly
	   */
	  Core: {} /* doc hack */
	};

	AWS.EventListeners = {
	  Core: new SequentialExecutor().addNamedListeners(function(add, addAsync) {
	    addAsync('VALIDATE_CREDENTIALS', 'validate',
	        function VALIDATE_CREDENTIALS(req, done) {
	      if (!req.service.api.signatureVersion) return done(); // none
	      req.service.config.getCredentials(function(err) {
	        if (err) {
	          req.response.error = AWS.util.error(err,
	            {code: 'CredentialsError', message: 'Missing credentials in config'});
	        }
	        done();
	      });
	    });

	    add('VALIDATE_REGION', 'validate', function VALIDATE_REGION(req) {
	      if (!req.service.config.region && !req.service.isGlobalEndpoint) {
	        req.response.error = AWS.util.error(new Error(),
	          {code: 'ConfigError', message: 'Missing region in config'});
	      }
	    });

	    add('VALIDATE_PARAMETERS', 'validate', function VALIDATE_PARAMETERS(req) {
	      var rules = req.service.api.operations[req.operation].input;
	      var validation = req.service.config.paramValidation;
	      new AWS.ParamValidator(validation).validate(rules, req.params);
	    });

	    addAsync('COMPUTE_SHA256', 'afterBuild', function COMPUTE_SHA256(req, done) {
	      req.haltHandlersOnError();
	      if (!req.service.api.signatureVersion) return done(); // none
	      if (req.service.getSignerClass(req) === AWS.Signers.V4) {
	        var body = req.httpRequest.body || '';
	        AWS.util.computeSha256(body, function(err, sha) {
	          if (err) {
	            done(err);
	          }
	          else {
	            req.httpRequest.headers['X-Amz-Content-Sha256'] = sha;
	            done();
	          }
	        });
	      } else {
	        done();
	      }
	    });

	    add('SET_CONTENT_LENGTH', 'afterBuild', function SET_CONTENT_LENGTH(req) {
	      if (req.httpRequest.headers['Content-Length'] === undefined) {
	        var length = AWS.util.string.byteLength(req.httpRequest.body);
	        req.httpRequest.headers['Content-Length'] = length;
	      }
	    });

	    add('SET_HTTP_HOST', 'afterBuild', function SET_HTTP_HOST(req) {
	      req.httpRequest.headers['Host'] = req.httpRequest.endpoint.host;
	    });

	    add('RESTART', 'restart', function RESTART() {
	      var err = this.response.error;
	      if (!err || !err.retryable) return;

	      this.httpRequest = new AWS.HttpRequest(
	        this.service.endpoint,
	        this.service.region
	      );

	      if (this.response.retryCount < this.service.config.maxRetries) {
	        this.response.retryCount++;
	      } else {
	        this.response.error = null;
	      }
	    });

	    addAsync('SIGN', 'sign', function SIGN(req, done) {
	      var service = req.service;
	      if (!service.api.signatureVersion) return done(); // none

	      service.config.getCredentials(function (err, credentials) {
	        if (err) {
	          req.response.error = err;
	          return done();
	        }

	        try {
	          var date = AWS.util.date.getDate();
	          var SignerClass = service.getSignerClass(req);
	          var signer = new SignerClass(req.httpRequest,
	            service.api.signingName || service.api.endpointPrefix,
	           service.config.signatureCache);
	          signer.setServiceClientId(service._clientId);

	          // clear old authorization headers
	          delete req.httpRequest.headers['Authorization'];
	          delete req.httpRequest.headers['Date'];
	          delete req.httpRequest.headers['X-Amz-Date'];

	          // add new authorization
	          signer.addAuthorization(credentials, date);
	          req.signedAt = date;
	        } catch (e) {
	          req.response.error = e;
	        }
	        done();
	      });
	    });

	    add('VALIDATE_RESPONSE', 'validateResponse', function VALIDATE_RESPONSE(resp) {
	      if (this.service.successfulResponse(resp, this)) {
	        resp.data = {};
	        resp.error = null;
	      } else {
	        resp.data = null;
	        resp.error = AWS.util.error(new Error(),
	          {code: 'UnknownError', message: 'An unknown error occurred.'});
	      }
	    });

	    addAsync('SEND', 'send', function SEND(resp, done) {
	      resp.httpResponse._abortCallback = done;
	      resp.error = null;
	      resp.data = null;

	      function callback(httpResp) {
	        resp.httpResponse.stream = httpResp;

	        httpResp.on('headers', function onHeaders(statusCode, headers) {
	          resp.request.emit('httpHeaders', [statusCode, headers, resp]);

	          if (!resp.httpResponse.streaming) {
	            if (AWS.HttpClient.streamsApiVersion === 2) { // streams2 API check
	              httpResp.on('readable', function onReadable() {
	                var data = httpResp.read();
	                if (data !== null) {
	                  resp.request.emit('httpData', [data, resp]);
	                }
	              });
	            } else { // legacy streams API
	              httpResp.on('data', function onData(data) {
	                resp.request.emit('httpData', [data, resp]);
	              });
	            }
	          }
	        });

	        httpResp.on('end', function onEnd() {
	          resp.request.emit('httpDone');
	          done();
	        });
	      }

	      function progress(httpResp) {
	        httpResp.on('sendProgress', function onSendProgress(value) {
	          resp.request.emit('httpUploadProgress', [value, resp]);
	        });

	        httpResp.on('receiveProgress', function onReceiveProgress(value) {
	          resp.request.emit('httpDownloadProgress', [value, resp]);
	        });
	      }

	      function error(err) {
	        resp.error = AWS.util.error(err, {
	          code: 'NetworkingError',
	          region: resp.request.httpRequest.region,
	          hostname: resp.request.httpRequest.endpoint.hostname,
	          retryable: true
	        });
	        resp.request.emit('httpError', [resp.error, resp], function() {
	          done();
	        });
	      }

	      function executeSend() {
	        var http = AWS.HttpClient.getInstance();
	        var httpOptions = resp.request.service.config.httpOptions || {};
	        try {
	          var stream = http.handleRequest(resp.request.httpRequest, httpOptions,
	                                          callback, error);
	          progress(stream);
	        } catch (err) {
	          error(err);
	        }
	      }

	      var timeDiff = (AWS.util.date.getDate() - this.signedAt) / 1000;
	      if (timeDiff >= 60 * 10) { // if we signed 10min ago, re-sign
	        this.emit('sign', [this], function(err) {
	          if (err) done(err);
	          else executeSend();
	        });
	      } else {
	        executeSend();
	      }
	    });

	    add('HTTP_HEADERS', 'httpHeaders',
	        function HTTP_HEADERS(statusCode, headers, resp) {
	      resp.httpResponse.statusCode = statusCode;
	      resp.httpResponse.headers = headers;
	      resp.httpResponse.body = new AWS.util.Buffer('');
	      resp.httpResponse.buffers = [];
	      resp.httpResponse.numBytes = 0;
	      var dateHeader = headers.date || headers.Date;
	      if (dateHeader) {
	        var serverTime = Date.parse(dateHeader);
	        if (resp.request.service.config.correctClockSkew
	            && AWS.util.isClockSkewed(serverTime)) {
	          AWS.util.applyClockOffset(serverTime);
	        }
	      }
	    });

	    add('HTTP_DATA', 'httpData', function HTTP_DATA(chunk, resp) {
	      if (chunk) {
	        if (AWS.util.isNode()) {
	          resp.httpResponse.numBytes += chunk.length;

	          var total = resp.httpResponse.headers['content-length'];
	          var progress = { loaded: resp.httpResponse.numBytes, total: total };
	          resp.request.emit('httpDownloadProgress', [progress, resp]);
	        }

	        resp.httpResponse.buffers.push(new AWS.util.Buffer(chunk));
	      }
	    });

	    add('HTTP_DONE', 'httpDone', function HTTP_DONE(resp) {
	      // convert buffers array into single buffer
	      if (resp.httpResponse.buffers && resp.httpResponse.buffers.length > 0) {
	        var body = AWS.util.buffer.concat(resp.httpResponse.buffers);
	        resp.httpResponse.body = body;
	      }
	      delete resp.httpResponse.numBytes;
	      delete resp.httpResponse.buffers;
	    });

	    add('FINALIZE_ERROR', 'retry', function FINALIZE_ERROR(resp) {
	      if (resp.httpResponse.statusCode) {
	        resp.error.statusCode = resp.httpResponse.statusCode;
	        if (resp.error.retryable === undefined) {
	          resp.error.retryable = this.service.retryableError(resp.error, this);
	        }
	      }
	    });

	    add('INVALIDATE_CREDENTIALS', 'retry', function INVALIDATE_CREDENTIALS(resp) {
	      if (!resp.error) return;
	      switch (resp.error.code) {
	        case 'RequestExpired': // EC2 only
	        case 'ExpiredTokenException':
	        case 'ExpiredToken':
	          resp.error.retryable = true;
	          resp.request.service.config.credentials.expired = true;
	      }
	    });

	    add('EXPIRED_SIGNATURE', 'retry', function EXPIRED_SIGNATURE(resp) {
	      var err = resp.error;
	      if (!err) return;
	      if (typeof err.code === 'string' && typeof err.message === 'string') {
	        if (err.code.match(/Signature/) && err.message.match(/expired/)) {
	          resp.error.retryable = true;
	        }
	      }
	    });

	    add('CLOCK_SKEWED', 'retry', function CLOCK_SKEWED(resp) {
	      if (!resp.error) return;
	      if (this.service.clockSkewError(resp.error)
	          && this.service.config.correctClockSkew
	          && AWS.config.isClockSkewed) {
	        resp.error.retryable = true;
	      }
	    });

	    add('REDIRECT', 'retry', function REDIRECT(resp) {
	      if (resp.error && resp.error.statusCode >= 300 &&
	          resp.error.statusCode < 400 && resp.httpResponse.headers['location']) {
	        this.httpRequest.endpoint =
	          new AWS.Endpoint(resp.httpResponse.headers['location']);
	        this.httpRequest.headers['Host'] = this.httpRequest.endpoint.host;
	        resp.error.redirect = true;
	        resp.error.retryable = true;
	      }
	    });

	    add('RETRY_CHECK', 'retry', function RETRY_CHECK(resp) {
	      if (resp.error) {
	        if (resp.error.redirect && resp.redirectCount < resp.maxRedirects) {
	          resp.error.retryDelay = 0;
	        } else if (resp.retryCount < resp.maxRetries) {
	          resp.error.retryDelay = this.service.retryDelays(resp.retryCount) || 0;
	        }
	      }
	    });

	    addAsync('RESET_RETRY_STATE', 'afterRetry', function RESET_RETRY_STATE(resp, done) {
	      var delay, willRetry = false;

	      if (resp.error) {
	        delay = resp.error.retryDelay || 0;
	        if (resp.error.retryable && resp.retryCount < resp.maxRetries) {
	          resp.retryCount++;
	          willRetry = true;
	        } else if (resp.error.redirect && resp.redirectCount < resp.maxRedirects) {
	          resp.redirectCount++;
	          willRetry = true;
	        }
	      }

	      if (willRetry) {
	        resp.error = null;
	        setTimeout(done, delay);
	      } else {
	        done();
	      }
	    });
	  }),

	  CorePost: new SequentialExecutor().addNamedListeners(function(add) {
	    add('EXTRACT_REQUEST_ID', 'extractData', AWS.util.extractRequestId);
	    add('EXTRACT_REQUEST_ID', 'extractError', AWS.util.extractRequestId);

	    add('ENOTFOUND_ERROR', 'httpError', function ENOTFOUND_ERROR(err) {
	      if (err.code === 'NetworkingError' && err.errno === 'ENOTFOUND') {
	        var message = 'Inaccessible host: `' + err.hostname +
	          '\'. This service may not be available in the `' + err.region +
	          '\' region.';
	        this.response.error = AWS.util.error(new Error(message), {
	          code: 'UnknownEndpoint',
	          region: err.region,
	          hostname: err.hostname,
	          retryable: true,
	          originalError: err
	        });
	      }
	    });
	  }),

	  Logger: new SequentialExecutor().addNamedListeners(function(add) {
	    add('LOG_REQUEST', 'complete', function LOG_REQUEST(resp) {
	      var req = resp.request;
	      var logger = req.service.config.logger;
	      if (!logger) return;

	      function buildMessage() {
	        var time = AWS.util.date.getDate().getTime();
	        var delta = (time - req.startTime.getTime()) / 1000;
	        var ansi = logger.isTTY ? true : false;
	        var status = resp.httpResponse.statusCode;
	        var params = __webpack_require__(194).inspect(req.params, true, null);

	        var message = '';
	        if (ansi) message += '\x1B[33m';
	        message += '[AWS ' + req.service.serviceIdentifier + ' ' + status;
	        message += ' ' + delta.toString() + 's ' + resp.retryCount + ' retries]';
	        if (ansi) message += '\x1B[0;1m';
	        message += ' ' + AWS.util.string.lowerFirst(req.operation);
	        message += '(' + params + ')';
	        if (ansi) message += '\x1B[0m';
	        return message;
	      }

	      var line = buildMessage();
	      if (typeof logger.log === 'function') {
	        logger.log(line);
	      } else if (typeof logger.write === 'function') {
	        logger.write(line + '\n');
	      }
	    });
	  }),

	  Json: new SequentialExecutor().addNamedListeners(function(add) {
	    var svc = __webpack_require__(94);
	    add('BUILD', 'build', svc.buildRequest);
	    add('EXTRACT_DATA', 'extractData', svc.extractData);
	    add('EXTRACT_ERROR', 'extractError', svc.extractError);
	  }),

	  Rest: new SequentialExecutor().addNamedListeners(function(add) {
	    var svc = __webpack_require__(101);
	    add('BUILD', 'build', svc.buildRequest);
	    add('EXTRACT_DATA', 'extractData', svc.extractData);
	    add('EXTRACT_ERROR', 'extractError', svc.extractError);
	  }),

	  RestJson: new SequentialExecutor().addNamedListeners(function(add) {
	    var svc = __webpack_require__(102);
	    add('BUILD', 'build', svc.buildRequest);
	    add('EXTRACT_DATA', 'extractData', svc.extractData);
	    add('EXTRACT_ERROR', 'extractError', svc.extractError);
	  }),

	  RestXml: new SequentialExecutor().addNamedListeners(function(add) {
	    var svc = __webpack_require__(103);
	    add('BUILD', 'build', svc.buildRequest);
	    add('EXTRACT_DATA', 'extractData', svc.extractData);
	    add('EXTRACT_ERROR', 'extractError', svc.extractError);
	  }),

	  Query: new SequentialExecutor().addNamedListeners(function(add) {
	    var svc = __webpack_require__(97);
	    add('BUILD', 'build', svc.buildRequest);
	    add('EXTRACT_DATA', 'extractData', svc.extractData);
	    add('EXTRACT_ERROR', 'extractError', svc.extractError);
	  })
	};


/***/ },
/* 194 */
/***/ function(module, exports) {

	module.exports = require("util");

/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(93);
	var AcceptorStateMachine = __webpack_require__(196);
	var inherit = AWS.util.inherit;
	var domain = AWS.util.domain;
	var jmespath = __webpack_require__(197);

	/**
	 * @api private
	 */
	var hardErrorStates = {success: 1, error: 1, complete: 1};

	function isTerminalState(machine) {
	  return Object.prototype.hasOwnProperty.call(hardErrorStates, machine._asm.currentState);
	}

	var fsm = new AcceptorStateMachine();
	fsm.setupStates = function() {
	  var transition = function(_, done) {
	    var self = this;
	    self._haltHandlersOnError = false;

	    self.emit(self._asm.currentState, function(err) {
	      if (err) {
	        if (isTerminalState(self)) {
	          if (domain && self.domain instanceof domain.Domain) {
	            err.domainEmitter = self;
	            err.domain = self.domain;
	            err.domainThrown = false;
	            self.domain.emit('error', err);
	          } else {
	            throw err;
	          }
	        } else {
	          self.response.error = err;
	          done(err);
	        }
	      } else {
	        done(self.response.error);
	      }
	    });

	  };

	  this.addState('validate', 'build', 'error', transition);
	  this.addState('build', 'afterBuild', 'restart', transition);
	  this.addState('afterBuild', 'sign', 'restart', transition);
	  this.addState('sign', 'send', 'retry', transition);
	  this.addState('retry', 'afterRetry', 'afterRetry', transition);
	  this.addState('afterRetry', 'sign', 'error', transition);
	  this.addState('send', 'validateResponse', 'retry', transition);
	  this.addState('validateResponse', 'extractData', 'extractError', transition);
	  this.addState('extractError', 'extractData', 'retry', transition);
	  this.addState('extractData', 'success', 'retry', transition);
	  this.addState('restart', 'build', 'error', transition);
	  this.addState('success', 'complete', 'complete', transition);
	  this.addState('error', 'complete', 'complete', transition);
	  this.addState('complete', null, null, transition);
	};
	fsm.setupStates();

	/**
	 * ## Asynchronous Requests
	 *
	 * All requests made through the SDK are asynchronous and use a
	 * callback interface. Each service method that kicks off a request
	 * returns an `AWS.Request` object that you can use to register
	 * callbacks.
	 *
	 * For example, the following service method returns the request
	 * object as "request", which can be used to register callbacks:
	 *
	 * ```javascript
	 * // request is an AWS.Request object
	 * var request = ec2.describeInstances();
	 *
	 * // register callbacks on request to retrieve response data
	 * request.on('success', function(response) {
	 *   console.log(response.data);
	 * });
	 * ```
	 *
	 * When a request is ready to be sent, the {send} method should
	 * be called:
	 *
	 * ```javascript
	 * request.send();
	 * ```
	 *
	 * ## Removing Default Listeners for Events
	 *
	 * Request objects are built with default listeners for the various events,
	 * depending on the service type. In some cases, you may want to remove
	 * some built-in listeners to customize behaviour. Doing this requires
	 * access to the built-in listener functions, which are exposed through
	 * the {AWS.EventListeners.Core} namespace. For instance, you may
	 * want to customize the HTTP handler used when sending a request. In this
	 * case, you can remove the built-in listener associated with the 'send'
	 * event, the {AWS.EventListeners.Core.SEND} listener and add your own.
	 *
	 * ## Multiple Callbacks and Chaining
	 *
	 * You can register multiple callbacks on any request object. The
	 * callbacks can be registered for different events, or all for the
	 * same event. In addition, you can chain callback registration, for
	 * example:
	 *
	 * ```javascript
	 * request.
	 *   on('success', function(response) {
	 *     console.log("Success!");
	 *   }).
	 *   on('error', function(response) {
	 *     console.log("Error!");
	 *   }).
	 *   on('complete', function(response) {
	 *     console.log("Always!");
	 *   }).
	 *   send();
	 * ```
	 *
	 * The above example will print either "Success! Always!", or "Error! Always!",
	 * depending on whether the request succeeded or not.
	 *
	 * @!attribute httpRequest
	 *   @readonly
	 *   @!group HTTP Properties
	 *   @return [AWS.HttpRequest] the raw HTTP request object
	 *     containing request headers and body information
	 *     sent by the service.
	 *
	 * @!attribute startTime
	 *   @readonly
	 *   @!group Operation Properties
	 *   @return [Date] the time that the request started
	 *
	 * @!group Request Building Events
	 *
	 * @!event validate(request)
	 *   Triggered when a request is being validated. Listeners
	 *   should throw an error if the request should not be sent.
	 *   @param request [Request] the request object being sent
	 *   @see AWS.EventListeners.Core.VALIDATE_CREDENTIALS
	 *   @see AWS.EventListeners.Core.VALIDATE_REGION
	 *   @example Ensuring that a certain parameter is set before sending a request
	 *     var req = s3.putObject(params);
	 *     req.on('validate', function() {
	 *       if (!req.params.Body.match(/^Hello\s/)) {
	 *         throw new Error('Body must start with "Hello "');
	 *       }
	 *     });
	 *     req.send(function(err, data) { ... });
	 *
	 * @!event build(request)
	 *   Triggered when the request payload is being built. Listeners
	 *   should fill the necessary information to send the request
	 *   over HTTP.
	 *   @param (see AWS.Request~validate)
	 *   @example Add a custom HTTP header to a request
	 *     var req = s3.putObject(params);
	 *     req.on('build', function() {
	 *       req.httpRequest.headers['Custom-Header'] = 'value';
	 *     });
	 *     req.send(function(err, data) { ... });
	 *
	 * @!event sign(request)
	 *   Triggered when the request is being signed. Listeners should
	 *   add the correct authentication headers and/or adjust the body,
	 *   depending on the authentication mechanism being used.
	 *   @param (see AWS.Request~validate)
	 *
	 * @!group Request Sending Events
	 *
	 * @!event send(response)
	 *   Triggered when the request is ready to be sent. Listeners
	 *   should call the underlying transport layer to initiate
	 *   the sending of the request.
	 *   @param response [Response] the response object
	 *   @context [Request] the request object that was sent
	 *   @see AWS.EventListeners.Core.SEND
	 *
	 * @!event retry(response)
	 *   Triggered when a request failed and might need to be retried or redirected.
	 *   If the response is retryable, the listener should set the
	 *   `response.error.retryable` property to `true`, and optionally set
	 *   `response.error.retryCount` to the millisecond delay for the next attempt.
	 *   In the case of a redirect, `response.error.redirect` should be set to
	 *   `true` with `retryCount` set to an optional delay on the next request.
	 *
	 *   If a listener decides that a request should not be retried,
	 *   it should set both `retryable` and `redirect` to false.
	 *
	 *   Note that a retryable error will be retried at most
	 *   {AWS.Config.maxRetries} times (based on the service object's config).
	 *   Similarly, a request that is redirected will only redirect at most
	 *   {AWS.Config.maxRedirects} times.
	 *
	 *   @param (see AWS.Request~send)
	 *   @context (see AWS.Request~send)
	 *   @example Adding a custom retry for a 404 response
	 *     request.on('retry', function(response) {
	 *       // this resource is not yet available, wait 10 seconds to get it again
	 *       if (response.httpResponse.statusCode === 404 && response.error) {
	 *         response.error.retryable = true;   // retry this error
	 *         response.error.retryCount = 10000; // wait 10 seconds
	 *       }
	 *     });
	 *
	 * @!group Data Parsing Events
	 *
	 * @!event extractError(response)
	 *   Triggered on all non-2xx requests so that listeners can extract
	 *   error details from the response body. Listeners to this event
	 *   should set the `response.error` property.
	 *   @param (see AWS.Request~send)
	 *   @context (see AWS.Request~send)
	 *
	 * @!event extractData(response)
	 *   Triggered in successful requests to allow listeners to
	 *   de-serialize the response body into `response.data`.
	 *   @param (see AWS.Request~send)
	 *   @context (see AWS.Request~send)
	 *
	 * @!group Completion Events
	 *
	 * @!event success(response)
	 *   Triggered when the request completed successfully.
	 *   `response.data` will contain the response data and
	 *   `response.error` will be null.
	 *   @param (see AWS.Request~send)
	 *   @context (see AWS.Request~send)
	 *
	 * @!event error(error, response)
	 *   Triggered when an error occurs at any point during the
	 *   request. `response.error` will contain details about the error
	 *   that occurred. `response.data` will be null.
	 *   @param error [Error] the error object containing details about
	 *     the error that occurred.
	 *   @param (see AWS.Request~send)
	 *   @context (see AWS.Request~send)
	 *
	 * @!event complete(response)
	 *   Triggered whenever a request cycle completes. `response.error`
	 *   should be checked, since the request may have failed.
	 *   @param (see AWS.Request~send)
	 *   @context (see AWS.Request~send)
	 *
	 * @!group HTTP Events
	 *
	 * @!event httpHeaders(statusCode, headers, response)
	 *   Triggered when headers are sent by the remote server
	 *   @param statusCode [Integer] the HTTP response code
	 *   @param headers [map<String,String>] the response headers
	 *   @param (see AWS.Request~send)
	 *   @context (see AWS.Request~send)
	 *
	 * @!event httpData(chunk, response)
	 *   Triggered when data is sent by the remote server
	 *   @param chunk [Buffer] the buffer data containing the next data chunk
	 *     from the server
	 *   @param (see AWS.Request~send)
	 *   @context (see AWS.Request~send)
	 *   @see AWS.EventListeners.Core.HTTP_DATA
	 *
	 * @!event httpUploadProgress(progress, response)
	 *   Triggered when the HTTP request has uploaded more data
	 *   @param progress [map] An object containing the `loaded` and `total` bytes
	 *     of the request.
	 *   @param (see AWS.Request~send)
	 *   @context (see AWS.Request~send)
	 *   @note This event will not be emitted in Node.js 0.8.x.
	 *
	 * @!event httpDownloadProgress(progress, response)
	 *   Triggered when the HTTP request has downloaded more data
	 *   @param progress [map] An object containing the `loaded` and `total` bytes
	 *     of the request.
	 *   @param (see AWS.Request~send)
	 *   @context (see AWS.Request~send)
	 *   @note This event will not be emitted in Node.js 0.8.x.
	 *
	 * @!event httpError(error, response)
	 *   Triggered when the HTTP request failed
	 *   @param error [Error] the error object that was thrown
	 *   @param (see AWS.Request~send)
	 *   @context (see AWS.Request~send)
	 *
	 * @!event httpDone(response)
	 *   Triggered when the server is finished sending data
	 *   @param (see AWS.Request~send)
	 *   @context (see AWS.Request~send)
	 *
	 * @see AWS.Response
	 */
	AWS.Request = inherit({

	  /**
	   * Creates a request for an operation on a given service with
	   * a set of input parameters.
	   *
	   * @param service [AWS.Service] the service to perform the operation on
	   * @param operation [String] the operation to perform on the service
	   * @param params [Object] parameters to send to the operation.
	   *   See the operation's documentation for the format of the
	   *   parameters.
	   */
	  constructor: function Request(service, operation, params) {
	    var endpoint = service.endpoint;
	    var region = service.config.region;
	    var customUserAgent = service.config.customUserAgent;

	    // global endpoints sign as us-east-1
	    if (service.isGlobalEndpoint) region = 'us-east-1';

	    this.domain = domain && domain.active;
	    this.service = service;
	    this.operation = operation;
	    this.params = params || {};
	    this.httpRequest = new AWS.HttpRequest(endpoint, region, customUserAgent);
	    this.startTime = AWS.util.date.getDate();

	    this.response = new AWS.Response(this);
	    this._asm = new AcceptorStateMachine(fsm.states, 'validate');
	    this._haltHandlersOnError = false;

	    AWS.SequentialExecutor.call(this);
	    this.emit = this.emitEvent;
	  },

	  /**
	   * @!group Sending a Request
	   */

	  /**
	   * @overload send(callback = null)
	   *   Sends the request object.
	   *
	   *   @callback callback function(err, data)
	   *     If a callback is supplied, it is called when a response is returned
	   *     from the service.
	   *     @context [AWS.Request] the request object being sent.
	   *     @param err [Error] the error object returned from the request.
	   *       Set to `null` if the request is successful.
	   *     @param data [Object] the de-serialized data returned from
	   *       the request. Set to `null` if a request error occurs.
	   *   @example Sending a request with a callback
	   *     request = s3.putObject({Bucket: 'bucket', Key: 'key'});
	   *     request.send(function(err, data) { console.log(err, data); });
	   *   @example Sending a request with no callback (using event handlers)
	   *     request = s3.putObject({Bucket: 'bucket', Key: 'key'});
	   *     request.on('complete', function(response) { ... }); // register a callback
	   *     request.send();
	   */
	  send: function send(callback) {
	    if (callback) {
	      this.on('complete', function (resp) {
	        callback.call(resp, resp.error, resp.data);
	      });
	    }
	    this.runTo();

	    return this.response;
	  },

	  /**
	   * @!method  promise()
	   *   Returns a 'thenable' promise.
	   *
	   *   Two callbacks can be provided to the `then` method on the returned promise.
	   *   The first callback will be called if the promise is fulfilled, and the second
	   *   callback will be called if the promise is rejected.
	   *   @callback fulfilledCallback function(data)
	   *     Called if the promise is fulfilled.
	   *     @param data [Object] the de-serialized data returned from the request.
	   *   @callback rejectedCallback function(error)
	   *     Called if the promise is rejected.
	   *     @param error [Error] the error object returned from the request.
	   *   @return [Promise] A promise that represents the state of the request.
	   *   @example Sending a request using promises.
	   *     var request = s3.putObject({Bucket: 'bucket', Key: 'key'});
	   *     var result = request.promise();
	   *     result.then(function(data) { ... }, function(error) { ... });
	   */

	  /**
	   * @api private
	   */
	  build: function build(callback) {
	    return this.runTo('send', callback);
	  },

	  /**
	   * @api private
	   */
	  runTo: function runTo(state, done) {
	    this._asm.runTo(state, done, this);
	    return this;
	  },

	  /**
	   * Aborts a request, emitting the error and complete events.
	   *
	   * @!macro nobrowser
	   * @example Aborting a request after sending
	   *   var params = {
	   *     Bucket: 'bucket', Key: 'key',
	   *     Body: new Buffer(1024 * 1024 * 5) // 5MB payload
	   *   };
	   *   var request = s3.putObject(params);
	   *   request.send(function (err, data) {
	   *     if (err) console.log("Error:", err.code, err.message);
	   *     else console.log(data);
	   *   });
	   *
	   *   // abort request in 1 second
	   *   setTimeout(request.abort.bind(request), 1000);
	   *
	   *   // prints "Error: RequestAbortedError Request aborted by user"
	   * @return [AWS.Request] the same request object, for chaining.
	   * @since v1.4.0
	   */
	  abort: function abort() {
	    this.removeAllListeners('validateResponse');
	    this.removeAllListeners('extractError');
	    this.on('validateResponse', function addAbortedError(resp) {
	      resp.error = AWS.util.error(new Error('Request aborted by user'), {
	         code: 'RequestAbortedError', retryable: false
	      });
	    });

	    if (this.httpRequest.stream) { // abort HTTP stream
	      this.httpRequest.stream.abort();
	      if (this.httpRequest._abortCallback) {
	         this.httpRequest._abortCallback();
	      } else {
	        this.removeAllListeners('send'); // haven't sent yet, so let's not
	      }
	    }

	    return this;
	  },

	  /**
	   * Iterates over each page of results given a pageable request, calling
	   * the provided callback with each page of data. After all pages have been
	   * retrieved, the callback is called with `null` data.
	   *
	   * @note This operation can generate multiple requests to a service.
	   * @example Iterating over multiple pages of objects in an S3 bucket
	   *   var pages = 1;
	   *   s3.listObjects().eachPage(function(err, data) {
	   *     if (err) return;
	   *     console.log("Page", pages++);
	   *     console.log(data);
	   *   });
	   * @example Iterating over multiple pages with an asynchronous callback
	   *   s3.listObjects(params).eachPage(function(err, data, done) {
	   *     doSomethingAsyncAndOrExpensive(function() {
	   *       // The next page of results isn't fetched until done is called
	   *       done();
	   *     });
	   *   });
	   * @callback callback function(err, data, [doneCallback])
	   *   Called with each page of resulting data from the request. If the
	   *   optional `doneCallback` is provided in the function, it must be called
	   *   when the callback is complete.
	   *
	   *   @param err [Error] an error object, if an error occurred.
	   *   @param data [Object] a single page of response data. If there is no
	   *     more data, this object will be `null`.
	   *   @param doneCallback [Function] an optional done callback. If this
	   *     argument is defined in the function declaration, it should be called
	   *     when the next page is ready to be retrieved. This is useful for
	   *     controlling serial pagination across asynchronous operations.
	   *   @return [Boolean] if the callback returns `false`, pagination will
	   *     stop.
	   *
	   * @see AWS.Request.eachItem
	   * @see AWS.Response.nextPage
	   * @since v1.4.0
	   */
	  eachPage: function eachPage(callback) {
	    // Make all callbacks async-ish
	    callback = AWS.util.fn.makeAsync(callback, 3);

	    function wrappedCallback(response) {
	      callback.call(response, response.error, response.data, function (result) {
	        if (result === false) return;

	        if (response.hasNextPage()) {
	          response.nextPage().on('complete', wrappedCallback).send();
	        } else {
	          callback.call(response, null, null, AWS.util.fn.noop);
	        }
	      });
	    }

	    this.on('complete', wrappedCallback).send();
	  },

	  /**
	   * Enumerates over individual items of a request, paging the responses if
	   * necessary.
	   *
	   * @api experimental
	   * @since v1.4.0
	   */
	  eachItem: function eachItem(callback) {
	    var self = this;
	    function wrappedCallback(err, data) {
	      if (err) return callback(err, null);
	      if (data === null) return callback(null, null);

	      var config = self.service.paginationConfig(self.operation);
	      var resultKey = config.resultKey;
	      if (Array.isArray(resultKey)) resultKey = resultKey[0];
	      var items = jmespath.search(data, resultKey);
	      var continueIteration = true;
	      AWS.util.arrayEach(items, function(item) {
	        continueIteration = callback(null, item);
	        if (continueIteration === false) {
	          return AWS.util.abort;
	        }
	      });
	      return continueIteration;
	    }

	    this.eachPage(wrappedCallback);
	  },

	  /**
	   * @return [Boolean] whether the operation can return multiple pages of
	   *   response data.
	   * @see AWS.Response.eachPage
	   * @since v1.4.0
	   */
	  isPageable: function isPageable() {
	    return this.service.paginationConfig(this.operation) ? true : false;
	  },

	  /**
	   * Converts the request object into a readable stream that
	   * can be read from or piped into a writable stream.
	   *
	   * @note The data read from a readable stream contains only
	   *   the raw HTTP body contents.
	   * @example Manually reading from a stream
	   *   request.createReadStream().on('data', function(data) {
	   *     console.log("Got data:", data.toString());
	   *   });
	   * @example Piping a request body into a file
	   *   var out = fs.createWriteStream('/path/to/outfile.jpg');
	   *   s3.service.getObject(params).createReadStream().pipe(out);
	   * @return [Stream] the readable stream object that can be piped
	   *   or read from (by registering 'data' event listeners).
	   * @!macro nobrowser
	   */
	  createReadStream: function createReadStream() {
	    var streams = AWS.util.stream;
	    var req = this;
	    var stream = null;

	    if (AWS.HttpClient.streamsApiVersion === 2) {
	      stream = new streams.PassThrough();
	      req.send();
	    } else {
	      stream = new streams.Stream();
	      stream.readable = true;

	      stream.sent = false;
	      stream.on('newListener', function(event) {
	        if (!stream.sent && event === 'data') {
	          stream.sent = true;
	          process.nextTick(function() { req.send(); });
	        }
	      });
	    }

	    this.on('httpHeaders', function streamHeaders(statusCode, headers, resp) {
	      if (statusCode < 300) {
	        req.removeListener('httpData', AWS.EventListeners.Core.HTTP_DATA);
	        req.removeListener('httpError', AWS.EventListeners.Core.HTTP_ERROR);
	        req.on('httpError', function streamHttpError(error) {
	          resp.error = error;
	          resp.error.retryable = false;
	        });

	        var shouldCheckContentLength = false;
	        var expectedLen;
	        if (req.httpRequest.method !== 'HEAD') {
	          expectedLen = parseInt(headers['content-length'], 10);
	        }
	        if (expectedLen !== undefined && !isNaN(expectedLen) && expectedLen >= 0) {
	          shouldCheckContentLength = true;
	          var receivedLen = 0;
	        }

	        var checkContentLengthAndEmit = function checkContentLengthAndEmit() {
	          if (shouldCheckContentLength && receivedLen !== expectedLen) {
	            stream.emit('error', AWS.util.error(
	              new Error('Stream content length mismatch. Received ' +
	                receivedLen + ' of ' + expectedLen + ' bytes.'),
	              { code: 'StreamContentLengthMismatch' }
	            ));
	          } else if (AWS.HttpClient.streamsApiVersion === 2) {
	            stream.end();
	          } else {
	            stream.emit('end')
	          }
	        }

	        var httpStream = resp.httpResponse.createUnbufferedStream();

	        if (AWS.HttpClient.streamsApiVersion === 2) {
	          if (shouldCheckContentLength) {
	            var lengthAccumulator = new streams.PassThrough();
	            lengthAccumulator._write = function(chunk) {
	              if (chunk && chunk.length) {
	                receivedLen += chunk.length;
	              }
	              return streams.PassThrough.prototype._write.apply(this, arguments);
	            };

	            lengthAccumulator.on('end', checkContentLengthAndEmit);
	            httpStream.pipe(lengthAccumulator).pipe(stream, { end: false });
	          } else {
	            httpStream.pipe(stream);
	          }
	        } else {

	          if (shouldCheckContentLength) {
	            httpStream.on('data', function(arg) {
	              if (arg && arg.length) {
	                receivedLen += arg.length;
	              }
	            });
	          }

	          httpStream.on('data', function(arg) {
	            stream.emit('data', arg);
	          });
	          httpStream.on('end', checkContentLengthAndEmit);
	        }

	        httpStream.on('error', function(err) {
	          shouldCheckContentLength = false;
	          stream.emit('error', err);
	        });
	      }
	    });

	    this.on('error', function(err) {
	      stream.emit('error', err);
	    });

	    return stream;
	  },

	  /**
	   * @param [Array,Response] args This should be the response object,
	   *   or an array of args to send to the event.
	   * @api private
	   */
	  emitEvent: function emit(eventName, args, done) {
	    if (typeof args === 'function') { done = args; args = null; }
	    if (!done) done = function() { };
	    if (!args) args = this.eventParameters(eventName, this.response);

	    var origEmit = AWS.SequentialExecutor.prototype.emit;
	    origEmit.call(this, eventName, args, function (err) {
	      if (err) this.response.error = err;
	      done.call(this, err);
	    });
	  },

	  /**
	   * @api private
	   */
	  eventParameters: function eventParameters(eventName) {
	    switch (eventName) {
	      case 'restart':
	      case 'validate':
	      case 'sign':
	      case 'build':
	      case 'afterValidate':
	      case 'afterBuild':
	        return [this];
	      case 'error':
	        return [this.response.error, this.response];
	      default:
	        return [this.response];
	    }
	  },

	  /**
	   * @api private
	   */
	  presign: function presign(expires, callback) {
	    if (!callback && typeof expires === 'function') {
	      callback = expires;
	      expires = null;
	    }
	    return new AWS.Signers.Presign().sign(this.toGet(), expires, callback);
	  },

	  /**
	   * @api private
	   */
	  isPresigned: function isPresigned() {
	    return Object.prototype.hasOwnProperty.call(this.httpRequest.headers, 'presigned-expires');
	  },

	  /**
	   * @api private
	   */
	  toUnauthenticated: function toUnauthenticated() {
	    this.removeListener('validate', AWS.EventListeners.Core.VALIDATE_CREDENTIALS);
	    this.removeListener('sign', AWS.EventListeners.Core.SIGN);
	    return this;
	  },

	  /**
	   * @api private
	   */
	  toGet: function toGet() {
	    if (this.service.api.protocol === 'query' ||
	        this.service.api.protocol === 'ec2') {
	      this.removeListener('build', this.buildAsGet);
	      this.addListener('build', this.buildAsGet);
	    }
	    return this;
	  },

	  /**
	   * @api private
	   */
	  buildAsGet: function buildAsGet(request) {
	    request.httpRequest.method = 'GET';
	    request.httpRequest.path = request.service.endpoint.path +
	                               '?' + request.httpRequest.body;
	    request.httpRequest.body = '';

	    // don't need these headers on a GET request
	    delete request.httpRequest.headers['Content-Length'];
	    delete request.httpRequest.headers['Content-Type'];
	  },

	  /**
	   * @api private
	   */
	  haltHandlersOnError: function haltHandlersOnError() {
	    this._haltHandlersOnError = true;
	  }
	});

	/**
	 * @api private
	 */
	AWS.Request.addPromisesToClass = function addPromisesToClass(PromiseDependency) {
	  this.prototype.promise = function promise() {
	    var self = this;
	    return new PromiseDependency(function(resolve, reject) {
	      self.on('complete', function(resp) {
	        if (resp.error) {
	          reject(resp.error);
	        } else {
	          resolve(resp.data);
	        }
	      });
	      self.runTo();
	    });
	  };
	};

	/**
	 * @api private
	 */
	AWS.Request.deletePromisesFromClass = function deletePromisesFromClass() {
	  delete this.prototype.promise;
	};

	AWS.util.addPromises(AWS.Request);

	AWS.util.mixin(AWS.Request, AWS.SequentialExecutor);


/***/ },
/* 196 */
/***/ function(module, exports) {

	function AcceptorStateMachine(states, state) {
	  this.currentState = state || null;
	  this.states = states || {};
	}

	AcceptorStateMachine.prototype.runTo = function runTo(finalState, done, bindObject, inputError) {
	  if (typeof finalState === 'function') {
	    inputError = bindObject; bindObject = done;
	    done = finalState; finalState = null;
	  }

	  var self = this;
	  var state = self.states[self.currentState];
	  state.fn.call(bindObject || self, inputError, function(err) {
	    if (err) {
	      if (state.fail) self.currentState = state.fail;
	      else return done ? done.call(bindObject, err) : null;
	    } else {
	      if (state.accept) self.currentState = state.accept;
	      else return done ? done.call(bindObject) : null;
	    }
	    if (self.currentState === finalState) {
	      return done ? done.call(bindObject, err) : null;
	    }

	    self.runTo(finalState, done, bindObject, err);
	  });
	};

	AcceptorStateMachine.prototype.addState = function addState(name, acceptState, failState, fn) {
	  if (typeof acceptState === 'function') {
	    fn = acceptState; acceptState = null; failState = null;
	  } else if (typeof failState === 'function') {
	    fn = failState; failState = null;
	  }

	  if (!this.currentState) this.currentState = name;
	  this.states[name] = { accept: acceptState, fail: failState, fn: fn };
	  return this;
	};

	module.exports = AcceptorStateMachine;


/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	(function(exports) {
	  "use strict";

	  function isArray(obj) {
	    if (obj !== null) {
	      return Object.prototype.toString.call(obj) === "[object Array]";
	    } else {
	      return false;
	    }
	  }

	  function isObject(obj) {
	    if (obj !== null) {
	      return Object.prototype.toString.call(obj) === "[object Object]";
	    } else {
	      return false;
	    }
	  }

	  function strictDeepEqual(first, second) {
	    // Check the scalar case first.
	    if (first === second) {
	      return true;
	    }

	    // Check if they are the same type.
	    var firstType = Object.prototype.toString.call(first);
	    if (firstType !== Object.prototype.toString.call(second)) {
	      return false;
	    }
	    // We know that first and second have the same type so we can just check the
	    // first type from now on.
	    if (isArray(first) === true) {
	      // Short circuit if they're not the same length;
	      if (first.length !== second.length) {
	        return false;
	      }
	      for (var i = 0; i < first.length; i++) {
	        if (strictDeepEqual(first[i], second[i]) === false) {
	          return false;
	        }
	      }
	      return true;
	    }
	    if (isObject(first) === true) {
	      // An object is equal if it has the same key/value pairs.
	      var keysSeen = {};
	      for (var key in first) {
	        if (hasOwnProperty.call(first, key)) {
	          if (strictDeepEqual(first[key], second[key]) === false) {
	            return false;
	          }
	          keysSeen[key] = true;
	        }
	      }
	      // Now check that there aren't any keys in second that weren't
	      // in first.
	      for (var key2 in second) {
	        if (hasOwnProperty.call(second, key2)) {
	          if (keysSeen[key2] !== true) {
	            return false;
	          }
	        }
	      }
	      return true;
	    }
	    return false;
	  }

	  function isFalse(obj) {
	    // From the spec:
	    // A false value corresponds to the following values:
	    // Empty list
	    // Empty object
	    // Empty string
	    // False boolean
	    // null value

	    // First check the scalar values.
	    if (obj === "" || obj === false || obj === null) {
	        return true;
	    } else if (isArray(obj) && obj.length === 0) {
	        // Check for an empty array.
	        return true;
	    } else if (isObject(obj)) {
	        // Check for an empty object.
	        for (var key in obj) {
	            // If there are any keys, then
	            // the object is not empty so the object
	            // is not false.
	            if (obj.hasOwnProperty(key)) {
	              return false;
	            }
	        }
	        return true;
	    } else {
	        return false;
	    }
	  }

	  function objValues(obj) {
	    var keys = Object.keys(obj);
	    var values = [];
	    for (var i = 0; i < keys.length; i++) {
	      values.push(obj[keys[i]]);
	    }
	    return values;
	  }

	  function merge(a, b) {
	      var merged = {};
	      for (var key in a) {
	          merged[key] = a[key];
	      }
	      for (var key2 in b) {
	          merged[key2] = b[key2];
	      }
	      return merged;
	  }

	  var trimLeft;
	  if (typeof String.prototype.trimLeft === "function") {
	    trimLeft = function(str) {
	      return str.trimLeft();
	    };
	  } else {
	    trimLeft = function(str) {
	      return str.match(/^\s*(.*)/)[1];
	    };
	  }

	  // Type constants used to define functions.
	  var TYPE_NUMBER = 0;
	  var TYPE_ANY = 1;
	  var TYPE_STRING = 2;
	  var TYPE_ARRAY = 3;
	  var TYPE_OBJECT = 4;
	  var TYPE_BOOLEAN = 5;
	  var TYPE_EXPREF = 6;
	  var TYPE_NULL = 7;
	  var TYPE_ARRAY_NUMBER = 8;
	  var TYPE_ARRAY_STRING = 9;

	  var TOK_EOF = "EOF";
	  var TOK_UNQUOTEDIDENTIFIER = "UnquotedIdentifier";
	  var TOK_QUOTEDIDENTIFIER = "QuotedIdentifier";
	  var TOK_RBRACKET = "Rbracket";
	  var TOK_RPAREN = "Rparen";
	  var TOK_COMMA = "Comma";
	  var TOK_COLON = "Colon";
	  var TOK_RBRACE = "Rbrace";
	  var TOK_NUMBER = "Number";
	  var TOK_CURRENT = "Current";
	  var TOK_EXPREF = "Expref";
	  var TOK_PIPE = "Pipe";
	  var TOK_OR = "Or";
	  var TOK_AND = "And";
	  var TOK_EQ = "EQ";
	  var TOK_GT = "GT";
	  var TOK_LT = "LT";
	  var TOK_GTE = "GTE";
	  var TOK_LTE = "LTE";
	  var TOK_NE = "NE";
	  var TOK_FLATTEN = "Flatten";
	  var TOK_STAR = "Star";
	  var TOK_FILTER = "Filter";
	  var TOK_DOT = "Dot";
	  var TOK_NOT = "Not";
	  var TOK_LBRACE = "Lbrace";
	  var TOK_LBRACKET = "Lbracket";
	  var TOK_LPAREN= "Lparen";
	  var TOK_LITERAL= "Literal";

	  // The "&", "[", "<", ">" tokens
	  // are not in basicToken because
	  // there are two token variants
	  // ("&&", "[?", "<=", ">=").  This is specially handled
	  // below.

	  var basicTokens = {
	    ".": TOK_DOT,
	    "*": TOK_STAR,
	    ",": TOK_COMMA,
	    ":": TOK_COLON,
	    "{": TOK_LBRACE,
	    "}": TOK_RBRACE,
	    "]": TOK_RBRACKET,
	    "(": TOK_LPAREN,
	    ")": TOK_RPAREN,
	    "@": TOK_CURRENT
	  };

	  var operatorStartToken = {
	      "<": true,
	      ">": true,
	      "=": true,
	      "!": true
	  };

	  var skipChars = {
	      " ": true,
	      "\t": true,
	      "\n": true
	  };


	  function isAlpha(ch) {
	      return (ch >= "a" && ch <= "z") ||
	             (ch >= "A" && ch <= "Z") ||
	             ch === "_";
	  }

	  function isNum(ch) {
	      return (ch >= "0" && ch <= "9") ||
	             ch === "-";
	  }
	  function isAlphaNum(ch) {
	      return (ch >= "a" && ch <= "z") ||
	             (ch >= "A" && ch <= "Z") ||
	             (ch >= "0" && ch <= "9") ||
	             ch === "_";
	  }

	  function Lexer() {
	  }
	  Lexer.prototype = {
	      tokenize: function(stream) {
	          var tokens = [];
	          this._current = 0;
	          var start;
	          var identifier;
	          var token;
	          while (this._current < stream.length) {
	              if (isAlpha(stream[this._current])) {
	                  start = this._current;
	                  identifier = this._consumeUnquotedIdentifier(stream);
	                  tokens.push({type: TOK_UNQUOTEDIDENTIFIER,
	                               value: identifier,
	                               start: start});
	              } else if (basicTokens[stream[this._current]] !== undefined) {
	                  tokens.push({type: basicTokens[stream[this._current]],
	                              value: stream[this._current],
	                              start: this._current});
	                  this._current++;
	              } else if (isNum(stream[this._current])) {
	                  token = this._consumeNumber(stream);
	                  tokens.push(token);
	              } else if (stream[this._current] === "[") {
	                  // No need to increment this._current.  This happens
	                  // in _consumeLBracket
	                  token = this._consumeLBracket(stream);
	                  tokens.push(token);
	              } else if (stream[this._current] === "\"") {
	                  start = this._current;
	                  identifier = this._consumeQuotedIdentifier(stream);
	                  tokens.push({type: TOK_QUOTEDIDENTIFIER,
	                               value: identifier,
	                               start: start});
	              } else if (stream[this._current] === "'") {
	                  start = this._current;
	                  identifier = this._consumeRawStringLiteral(stream);
	                  tokens.push({type: TOK_LITERAL,
	                               value: identifier,
	                               start: start});
	              } else if (stream[this._current] === "`") {
	                  start = this._current;
	                  var literal = this._consumeLiteral(stream);
	                  tokens.push({type: TOK_LITERAL,
	                               value: literal,
	                               start: start});
	              } else if (operatorStartToken[stream[this._current]] !== undefined) {
	                  tokens.push(this._consumeOperator(stream));
	              } else if (skipChars[stream[this._current]] !== undefined) {
	                  // Ignore whitespace.
	                  this._current++;
	              } else if (stream[this._current] === "&") {
	                  start = this._current;
	                  this._current++;
	                  if (stream[this._current] === "&") {
	                      this._current++;
	                      tokens.push({type: TOK_AND, value: "&&", start: start});
	                  } else {
	                      tokens.push({type: TOK_EXPREF, value: "&", start: start});
	                  }
	              } else if (stream[this._current] === "|") {
	                  start = this._current;
	                  this._current++;
	                  if (stream[this._current] === "|") {
	                      this._current++;
	                      tokens.push({type: TOK_OR, value: "||", start: start});
	                  } else {
	                      tokens.push({type: TOK_PIPE, value: "|", start: start});
	                  }
	              } else {
	                  var error = new Error("Unknown character:" + stream[this._current]);
	                  error.name = "LexerError";
	                  throw error;
	              }
	          }
	          return tokens;
	      },

	      _consumeUnquotedIdentifier: function(stream) {
	          var start = this._current;
	          this._current++;
	          while (this._current < stream.length && isAlphaNum(stream[this._current])) {
	              this._current++;
	          }
	          return stream.slice(start, this._current);
	      },

	      _consumeQuotedIdentifier: function(stream) {
	          var start = this._current;
	          this._current++;
	          var maxLength = stream.length;
	          while (stream[this._current] !== "\"" && this._current < maxLength) {
	              // You can escape a double quote and you can escape an escape.
	              var current = this._current;
	              if (stream[current] === "\\" && (stream[current + 1] === "\\" ||
	                                               stream[current + 1] === "\"")) {
	                  current += 2;
	              } else {
	                  current++;
	              }
	              this._current = current;
	          }
	          this._current++;
	          return JSON.parse(stream.slice(start, this._current));
	      },

	      _consumeRawStringLiteral: function(stream) {
	          var start = this._current;
	          this._current++;
	          var maxLength = stream.length;
	          while (stream[this._current] !== "'" && this._current < maxLength) {
	              // You can escape a single quote and you can escape an escape.
	              var current = this._current;
	              if (stream[current] === "\\" && (stream[current + 1] === "\\" ||
	                                               stream[current + 1] === "'")) {
	                  current += 2;
	              } else {
	                  current++;
	              }
	              this._current = current;
	          }
	          this._current++;
	          var literal = stream.slice(start + 1, this._current - 1);
	          return literal.replace("\\'", "'");
	      },

	      _consumeNumber: function(stream) {
	          var start = this._current;
	          this._current++;
	          var maxLength = stream.length;
	          while (isNum(stream[this._current]) && this._current < maxLength) {
	              this._current++;
	          }
	          var value = parseInt(stream.slice(start, this._current));
	          return {type: TOK_NUMBER, value: value, start: start};
	      },

	      _consumeLBracket: function(stream) {
	          var start = this._current;
	          this._current++;
	          if (stream[this._current] === "?") {
	              this._current++;
	              return {type: TOK_FILTER, value: "[?", start: start};
	          } else if (stream[this._current] === "]") {
	              this._current++;
	              return {type: TOK_FLATTEN, value: "[]", start: start};
	          } else {
	              return {type: TOK_LBRACKET, value: "[", start: start};
	          }
	      },

	      _consumeOperator: function(stream) {
	          var start = this._current;
	          var startingChar = stream[start];
	          this._current++;
	          if (startingChar === "!") {
	              if (stream[this._current] === "=") {
	                  this._current++;
	                  return {type: TOK_NE, value: "!=", start: start};
	              } else {
	                return {type: TOK_NOT, value: "!", start: start};
	              }
	          } else if (startingChar === "<") {
	              if (stream[this._current] === "=") {
	                  this._current++;
	                  return {type: TOK_LTE, value: "<=", start: start};
	              } else {
	                  return {type: TOK_LT, value: "<", start: start};
	              }
	          } else if (startingChar === ">") {
	              if (stream[this._current] === "=") {
	                  this._current++;
	                  return {type: TOK_GTE, value: ">=", start: start};
	              } else {
	                  return {type: TOK_GT, value: ">", start: start};
	              }
	          } else if (startingChar === "=") {
	              if (stream[this._current] === "=") {
	                  this._current++;
	                  return {type: TOK_EQ, value: "==", start: start};
	              }
	          }
	      },

	      _consumeLiteral: function(stream) {
	          this._current++;
	          var start = this._current;
	          var maxLength = stream.length;
	          var literal;
	          while(stream[this._current] !== "`" && this._current < maxLength) {
	              // You can escape a literal char or you can escape the escape.
	              var current = this._current;
	              if (stream[current] === "\\" && (stream[current + 1] === "\\" ||
	                                               stream[current + 1] === "`")) {
	                  current += 2;
	              } else {
	                  current++;
	              }
	              this._current = current;
	          }
	          var literalString = trimLeft(stream.slice(start, this._current));
	          literalString = literalString.replace("\\`", "`");
	          if (this._looksLikeJSON(literalString)) {
	              literal = JSON.parse(literalString);
	          } else {
	              // Try to JSON parse it as "<literal>"
	              literal = JSON.parse("\"" + literalString + "\"");
	          }
	          // +1 gets us to the ending "`", +1 to move on to the next char.
	          this._current++;
	          return literal;
	      },

	      _looksLikeJSON: function(literalString) {
	          var startingChars = "[{\"";
	          var jsonLiterals = ["true", "false", "null"];
	          var numberLooking = "-0123456789";

	          if (literalString === "") {
	              return false;
	          } else if (startingChars.indexOf(literalString[0]) >= 0) {
	              return true;
	          } else if (jsonLiterals.indexOf(literalString) >= 0) {
	              return true;
	          } else if (numberLooking.indexOf(literalString[0]) >= 0) {
	              try {
	                  JSON.parse(literalString);
	                  return true;
	              } catch (ex) {
	                  return false;
	              }
	          } else {
	              return false;
	          }
	      }
	  };

	      var bindingPower = {};
	      bindingPower[TOK_EOF] = 0;
	      bindingPower[TOK_UNQUOTEDIDENTIFIER] = 0;
	      bindingPower[TOK_QUOTEDIDENTIFIER] = 0;
	      bindingPower[TOK_RBRACKET] = 0;
	      bindingPower[TOK_RPAREN] = 0;
	      bindingPower[TOK_COMMA] = 0;
	      bindingPower[TOK_RBRACE] = 0;
	      bindingPower[TOK_NUMBER] = 0;
	      bindingPower[TOK_CURRENT] = 0;
	      bindingPower[TOK_EXPREF] = 0;
	      bindingPower[TOK_PIPE] = 1;
	      bindingPower[TOK_OR] = 2;
	      bindingPower[TOK_AND] = 3;
	      bindingPower[TOK_EQ] = 5;
	      bindingPower[TOK_GT] = 5;
	      bindingPower[TOK_LT] = 5;
	      bindingPower[TOK_GTE] = 5;
	      bindingPower[TOK_LTE] = 5;
	      bindingPower[TOK_NE] = 5;
	      bindingPower[TOK_FLATTEN] = 9;
	      bindingPower[TOK_STAR] = 20;
	      bindingPower[TOK_FILTER] = 21;
	      bindingPower[TOK_DOT] = 40;
	      bindingPower[TOK_NOT] = 45;
	      bindingPower[TOK_LBRACE] = 50;
	      bindingPower[TOK_LBRACKET] = 55;
	      bindingPower[TOK_LPAREN] = 60;

	  function Parser() {
	  }

	  Parser.prototype = {
	      parse: function(expression) {
	          this._loadTokens(expression);
	          this.index = 0;
	          var ast = this.expression(0);
	          if (this._lookahead(0) !== TOK_EOF) {
	              var t = this._lookaheadToken(0);
	              var error = new Error(
	                  "Unexpected token type: " + t.type + ", value: " + t.value);
	              error.name = "ParserError";
	              throw error;
	          }
	          return ast;
	      },

	      _loadTokens: function(expression) {
	          var lexer = new Lexer();
	          var tokens = lexer.tokenize(expression);
	          tokens.push({type: TOK_EOF, value: "", start: expression.length});
	          this.tokens = tokens;
	      },

	      expression: function(rbp) {
	          var leftToken = this._lookaheadToken(0);
	          this._advance();
	          var left = this.nud(leftToken);
	          var currentToken = this._lookahead(0);
	          while (rbp < bindingPower[currentToken]) {
	              this._advance();
	              left = this.led(currentToken, left);
	              currentToken = this._lookahead(0);
	          }
	          return left;
	      },

	      _lookahead: function(number) {
	          return this.tokens[this.index + number].type;
	      },

	      _lookaheadToken: function(number) {
	          return this.tokens[this.index + number];
	      },

	      _advance: function() {
	          this.index++;
	      },

	      nud: function(token) {
	        var left;
	        var right;
	        var expression;
	        switch (token.type) {
	          case TOK_LITERAL:
	            return {type: "Literal", value: token.value};
	          case TOK_UNQUOTEDIDENTIFIER:
	            return {type: "Field", name: token.value};
	          case TOK_QUOTEDIDENTIFIER:
	            var node = {type: "Field", name: token.value};
	            if (this._lookahead(0) === TOK_LPAREN) {
	                throw new Error("Quoted identifier not allowed for function names.");
	            } else {
	                return node;
	            }
	            break;
	          case TOK_NOT:
	            right = this.expression(bindingPower.Not);
	            return {type: "NotExpression", children: [right]};
	          case TOK_STAR:
	            left = {type: "Identity"};
	            right = null;
	            if (this._lookahead(0) === TOK_RBRACKET) {
	                // This can happen in a multiselect,
	                // [a, b, *]
	                right = {type: "Identity"};
	            } else {
	                right = this._parseProjectionRHS(bindingPower.Star);
	            }
	            return {type: "ValueProjection", children: [left, right]};
	          case TOK_FILTER:
	            return this.led(token.type, {type: "Identity"});
	          case TOK_LBRACE:
	            return this._parseMultiselectHash();
	          case TOK_FLATTEN:
	            left = {type: TOK_FLATTEN, children: [{type: "Identity"}]};
	            right = this._parseProjectionRHS(bindingPower.Flatten);
	            return {type: "Projection", children: [left, right]};
	          case TOK_LBRACKET:
	            if (this._lookahead(0) === TOK_NUMBER || this._lookahead(0) === TOK_COLON) {
	                right = this._parseIndexExpression();
	                return this._projectIfSlice({type: "Identity"}, right);
	            } else if (this._lookahead(0) === TOK_STAR &&
	                       this._lookahead(1) === TOK_RBRACKET) {
	                this._advance();
	                this._advance();
	                right = this._parseProjectionRHS(bindingPower.Star);
	                return {type: "Projection",
	                        children: [{type: "Identity"}, right]};
	            } else {
	                return this._parseMultiselectList();
	            }
	            break;
	          case TOK_CURRENT:
	            return {type: TOK_CURRENT};
	          case TOK_EXPREF:
	            expression = this.expression(bindingPower.Expref);
	            return {type: "ExpressionReference", children: [expression]};
	          case TOK_LPAREN:
	            var args = [];
	            while (this._lookahead(0) !== TOK_RPAREN) {
	              if (this._lookahead(0) === TOK_CURRENT) {
	                expression = {type: TOK_CURRENT};
	                this._advance();
	              } else {
	                expression = this.expression(0);
	              }
	              args.push(expression);
	            }
	            this._match(TOK_RPAREN);
	            return args[0];
	          default:
	            this._errorToken(token);
	        }
	      },

	      led: function(tokenName, left) {
	        var right;
	        switch(tokenName) {
	          case TOK_DOT:
	            var rbp = bindingPower.Dot;
	            if (this._lookahead(0) !== TOK_STAR) {
	                right = this._parseDotRHS(rbp);
	                return {type: "Subexpression", children: [left, right]};
	            } else {
	                // Creating a projection.
	                this._advance();
	                right = this._parseProjectionRHS(rbp);
	                return {type: "ValueProjection", children: [left, right]};
	            }
	            break;
	          case TOK_PIPE:
	            right = this.expression(bindingPower.Pipe);
	            return {type: TOK_PIPE, children: [left, right]};
	          case TOK_OR:
	            right = this.expression(bindingPower.Or);
	            return {type: "OrExpression", children: [left, right]};
	          case TOK_AND:
	            right = this.expression(bindingPower.And);
	            return {type: "AndExpression", children: [left, right]};
	          case TOK_LPAREN:
	            var name = left.name;
	            var args = [];
	            var expression, node;
	            while (this._lookahead(0) !== TOK_RPAREN) {
	              if (this._lookahead(0) === TOK_CURRENT) {
	                expression = {type: TOK_CURRENT};
	                this._advance();
	              } else {
	                expression = this.expression(0);
	              }
	              if (this._lookahead(0) === TOK_COMMA) {
	                this._match(TOK_COMMA);
	              }
	              args.push(expression);
	            }
	            this._match(TOK_RPAREN);
	            node = {type: "Function", name: name, children: args};
	            return node;
	          case TOK_FILTER:
	            var condition = this.expression(0);
	            this._match(TOK_RBRACKET);
	            if (this._lookahead(0) === TOK_FLATTEN) {
	              right = {type: "Identity"};
	            } else {
	              right = this._parseProjectionRHS(bindingPower.Filter);
	            }
	            return {type: "FilterProjection", children: [left, right, condition]};
	          case TOK_FLATTEN:
	            var leftNode = {type: TOK_FLATTEN, children: [left]};
	            var rightNode = this._parseProjectionRHS(bindingPower.Flatten);
	            return {type: "Projection", children: [leftNode, rightNode]};
	          case TOK_EQ:
	          case TOK_NE:
	          case TOK_GT:
	          case TOK_GTE:
	          case TOK_LT:
	          case TOK_LTE:
	            return this._parseComparator(left, tokenName);
	          case TOK_LBRACKET:
	            var token = this._lookaheadToken(0);
	            if (token.type === TOK_NUMBER || token.type === TOK_COLON) {
	                right = this._parseIndexExpression();
	                return this._projectIfSlice(left, right);
	            } else {
	                this._match(TOK_STAR);
	                this._match(TOK_RBRACKET);
	                right = this._parseProjectionRHS(bindingPower.Star);
	                return {type: "Projection", children: [left, right]};
	            }
	            break;
	          default:
	            this._errorToken(this._lookaheadToken(0));
	        }
	      },

	      _match: function(tokenType) {
	          if (this._lookahead(0) === tokenType) {
	              this._advance();
	          } else {
	              var t = this._lookaheadToken(0);
	              var error = new Error("Expected " + tokenType + ", got: " + t.type);
	              error.name = "ParserError";
	              throw error;
	          }
	      },

	      _errorToken: function(token) {
	          var error = new Error("Invalid token (" +
	                                token.type + "): \"" +
	                                token.value + "\"");
	          error.name = "ParserError";
	          throw error;
	      },


	      _parseIndexExpression: function() {
	          if (this._lookahead(0) === TOK_COLON || this._lookahead(1) === TOK_COLON) {
	              return this._parseSliceExpression();
	          } else {
	              var node = {
	                  type: "Index",
	                  value: this._lookaheadToken(0).value};
	              this._advance();
	              this._match(TOK_RBRACKET);
	              return node;
	          }
	      },

	      _projectIfSlice: function(left, right) {
	          var indexExpr = {type: "IndexExpression", children: [left, right]};
	          if (right.type === "Slice") {
	              return {
	                  type: "Projection",
	                  children: [indexExpr, this._parseProjectionRHS(bindingPower.Star)]
	              };
	          } else {
	              return indexExpr;
	          }
	      },

	      _parseSliceExpression: function() {
	          // [start:end:step] where each part is optional, as well as the last
	          // colon.
	          var parts = [null, null, null];
	          var index = 0;
	          var currentToken = this._lookahead(0);
	          while (currentToken !== TOK_RBRACKET && index < 3) {
	              if (currentToken === TOK_COLON) {
	                  index++;
	                  this._advance();
	              } else if (currentToken === TOK_NUMBER) {
	                  parts[index] = this._lookaheadToken(0).value;
	                  this._advance();
	              } else {
	                  var t = this._lookahead(0);
	                  var error = new Error("Syntax error, unexpected token: " +
	                                        t.value + "(" + t.type + ")");
	                  error.name = "Parsererror";
	                  throw error;
	              }
	              currentToken = this._lookahead(0);
	          }
	          this._match(TOK_RBRACKET);
	          return {
	              type: "Slice",
	              children: parts
	          };
	      },

	      _parseComparator: function(left, comparator) {
	        var right = this.expression(bindingPower[comparator]);
	        return {type: "Comparator", name: comparator, children: [left, right]};
	      },

	      _parseDotRHS: function(rbp) {
	          var lookahead = this._lookahead(0);
	          var exprTokens = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER, TOK_STAR];
	          if (exprTokens.indexOf(lookahead) >= 0) {
	              return this.expression(rbp);
	          } else if (lookahead === TOK_LBRACKET) {
	              this._match(TOK_LBRACKET);
	              return this._parseMultiselectList();
	          } else if (lookahead === TOK_LBRACE) {
	              this._match(TOK_LBRACE);
	              return this._parseMultiselectHash();
	          }
	      },

	      _parseProjectionRHS: function(rbp) {
	          var right;
	          if (bindingPower[this._lookahead(0)] < 10) {
	              right = {type: "Identity"};
	          } else if (this._lookahead(0) === TOK_LBRACKET) {
	              right = this.expression(rbp);
	          } else if (this._lookahead(0) === TOK_FILTER) {
	              right = this.expression(rbp);
	          } else if (this._lookahead(0) === TOK_DOT) {
	              this._match(TOK_DOT);
	              right = this._parseDotRHS(rbp);
	          } else {
	              var t = this._lookaheadToken(0);
	              var error = new Error("Sytanx error, unexpected token: " +
	                                    t.value + "(" + t.type + ")");
	              error.name = "ParserError";
	              throw error;
	          }
	          return right;
	      },

	      _parseMultiselectList: function() {
	          var expressions = [];
	          while (this._lookahead(0) !== TOK_RBRACKET) {
	              var expression = this.expression(0);
	              expressions.push(expression);
	              if (this._lookahead(0) === TOK_COMMA) {
	                  this._match(TOK_COMMA);
	                  if (this._lookahead(0) === TOK_RBRACKET) {
	                    throw new Error("Unexpected token Rbracket");
	                  }
	              }
	          }
	          this._match(TOK_RBRACKET);
	          return {type: "MultiSelectList", children: expressions};
	      },

	      _parseMultiselectHash: function() {
	        var pairs = [];
	        var identifierTypes = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER];
	        var keyToken, keyName, value, node;
	        for (;;) {
	          keyToken = this._lookaheadToken(0);
	          if (identifierTypes.indexOf(keyToken.type) < 0) {
	            throw new Error("Expecting an identifier token, got: " +
	                            keyToken.type);
	          }
	          keyName = keyToken.value;
	          this._advance();
	          this._match(TOK_COLON);
	          value = this.expression(0);
	          node = {type: "KeyValuePair", name: keyName, value: value};
	          pairs.push(node);
	          if (this._lookahead(0) === TOK_COMMA) {
	            this._match(TOK_COMMA);
	          } else if (this._lookahead(0) === TOK_RBRACE) {
	            this._match(TOK_RBRACE);
	            break;
	          }
	        }
	        return {type: "MultiSelectHash", children: pairs};
	      }
	  };


	  function TreeInterpreter(runtime) {
	    this.runtime = runtime;
	  }

	  TreeInterpreter.prototype = {
	      search: function(node, value) {
	          return this.visit(node, value);
	      },

	      visit: function(node, value) {
	          var matched, current, result, first, second, field, left, right, collected, i;
	          switch (node.type) {
	            case "Field":
	              if (value === null ) {
	                  return null;
	              } else if (isObject(value)) {
	                  field = value[node.name];
	                  if (field === undefined) {
	                      return null;
	                  } else {
	                      return field;
	                  }
	              } else {
	                return null;
	              }
	              break;
	            case "Subexpression":
	              result = this.visit(node.children[0], value);
	              for (i = 1; i < node.children.length; i++) {
	                  result = this.visit(node.children[1], result);
	                  if (result === null) {
	                      return null;
	                  }
	              }
	              return result;
	            case "IndexExpression":
	              left = this.visit(node.children[0], value);
	              right = this.visit(node.children[1], left);
	              return right;
	            case "Index":
	              if (!isArray(value)) {
	                return null;
	              }
	              var index = node.value;
	              if (index < 0) {
	                index = value.length + index;
	              }
	              result = value[index];
	              if (result === undefined) {
	                result = null;
	              }
	              return result;
	            case "Slice":
	              if (!isArray(value)) {
	                return null;
	              }
	              var sliceParams = node.children.slice(0);
	              var computed = this.computeSliceParams(value.length, sliceParams);
	              var start = computed[0];
	              var stop = computed[1];
	              var step = computed[2];
	              result = [];
	              if (step > 0) {
	                  for (i = start; i < stop; i += step) {
	                      result.push(value[i]);
	                  }
	              } else {
	                  for (i = start; i > stop; i += step) {
	                      result.push(value[i]);
	                  }
	              }
	              return result;
	            case "Projection":
	              // Evaluate left child.
	              var base = this.visit(node.children[0], value);
	              if (!isArray(base)) {
	                return null;
	              }
	              collected = [];
	              for (i = 0; i < base.length; i++) {
	                current = this.visit(node.children[1], base[i]);
	                if (current !== null) {
	                  collected.push(current);
	                }
	              }
	              return collected;
	            case "ValueProjection":
	              // Evaluate left child.
	              base = this.visit(node.children[0], value);
	              if (!isObject(base)) {
	                return null;
	              }
	              collected = [];
	              var values = objValues(base);
	              for (i = 0; i < values.length; i++) {
	                current = this.visit(node.children[1], values[i]);
	                if (current !== null) {
	                  collected.push(current);
	                }
	              }
	              return collected;
	            case "FilterProjection":
	              base = this.visit(node.children[0], value);
	              if (!isArray(base)) {
	                return null;
	              }
	              var filtered = [];
	              var finalResults = [];
	              for (i = 0; i < base.length; i++) {
	                matched = this.visit(node.children[2], base[i]);
	                if (!isFalse(matched)) {
	                  filtered.push(base[i]);
	                }
	              }
	              for (var j = 0; j < filtered.length; j++) {
	                current = this.visit(node.children[1], filtered[j]);
	                if (current !== null) {
	                  finalResults.push(current);
	                }
	              }
	              return finalResults;
	            case "Comparator":
	              first = this.visit(node.children[0], value);
	              second = this.visit(node.children[1], value);
	              switch(node.name) {
	                case TOK_EQ:
	                  result = strictDeepEqual(first, second);
	                  break;
	                case TOK_NE:
	                  result = !strictDeepEqual(first, second);
	                  break;
	                case TOK_GT:
	                  result = first > second;
	                  break;
	                case TOK_GTE:
	                  result = first >= second;
	                  break;
	                case TOK_LT:
	                  result = first < second;
	                  break;
	                case TOK_LTE:
	                  result = first <= second;
	                  break;
	                default:
	                  throw new Error("Unknown comparator: " + node.name);
	              }
	              return result;
	            case TOK_FLATTEN:
	              var original = this.visit(node.children[0], value);
	              if (!isArray(original)) {
	                return null;
	              }
	              var merged = [];
	              for (i = 0; i < original.length; i++) {
	                current = original[i];
	                if (isArray(current)) {
	                  merged.push.apply(merged, current);
	                } else {
	                  merged.push(current);
	                }
	              }
	              return merged;
	            case "Identity":
	              return value;
	            case "MultiSelectList":
	              if (value === null) {
	                return null;
	              }
	              collected = [];
	              for (i = 0; i < node.children.length; i++) {
	                  collected.push(this.visit(node.children[i], value));
	              }
	              return collected;
	            case "MultiSelectHash":
	              if (value === null) {
	                return null;
	              }
	              collected = {};
	              var child;
	              for (i = 0; i < node.children.length; i++) {
	                child = node.children[i];
	                collected[child.name] = this.visit(child.value, value);
	              }
	              return collected;
	            case "OrExpression":
	              matched = this.visit(node.children[0], value);
	              if (isFalse(matched)) {
	                  matched = this.visit(node.children[1], value);
	              }
	              return matched;
	            case "AndExpression":
	              first = this.visit(node.children[0], value);

	              if (isFalse(first) === true) {
	                return first;
	              }
	              return this.visit(node.children[1], value);
	            case "NotExpression":
	              first = this.visit(node.children[0], value);
	              return isFalse(first);
	            case "Literal":
	              return node.value;
	            case TOK_PIPE:
	              left = this.visit(node.children[0], value);
	              return this.visit(node.children[1], left);
	            case TOK_CURRENT:
	              return value;
	            case "Function":
	              var resolvedArgs = [];
	              for (i = 0; i < node.children.length; i++) {
	                  resolvedArgs.push(this.visit(node.children[i], value));
	              }
	              return this.runtime.callFunction(node.name, resolvedArgs);
	            case "ExpressionReference":
	              var refNode = node.children[0];
	              // Tag the node with a specific attribute so the type
	              // checker verify the type.
	              refNode.jmespathType = TOK_EXPREF;
	              return refNode;
	            default:
	              throw new Error("Unknown node type: " + node.type);
	          }
	      },

	      computeSliceParams: function(arrayLength, sliceParams) {
	        var start = sliceParams[0];
	        var stop = sliceParams[1];
	        var step = sliceParams[2];
	        var computed = [null, null, null];
	        if (step === null) {
	          step = 1;
	        } else if (step === 0) {
	          var error = new Error("Invalid slice, step cannot be 0");
	          error.name = "RuntimeError";
	          throw error;
	        }
	        var stepValueNegative = step < 0 ? true : false;

	        if (start === null) {
	            start = stepValueNegative ? arrayLength - 1 : 0;
	        } else {
	            start = this.capSliceRange(arrayLength, start, step);
	        }

	        if (stop === null) {
	            stop = stepValueNegative ? -1 : arrayLength;
	        } else {
	            stop = this.capSliceRange(arrayLength, stop, step);
	        }
	        computed[0] = start;
	        computed[1] = stop;
	        computed[2] = step;
	        return computed;
	      },

	      capSliceRange: function(arrayLength, actualValue, step) {
	          if (actualValue < 0) {
	              actualValue += arrayLength;
	              if (actualValue < 0) {
	                  actualValue = step < 0 ? -1 : 0;
	              }
	          } else if (actualValue >= arrayLength) {
	              actualValue = step < 0 ? arrayLength - 1 : arrayLength;
	          }
	          return actualValue;
	      }

	  };

	  function Runtime(interpreter) {
	    this._interpreter = interpreter;
	    this.functionTable = {
	        // name: [function, <signature>]
	        // The <signature> can be:
	        //
	        // {
	        //   args: [[type1, type2], [type1, type2]],
	        //   variadic: true|false
	        // }
	        //
	        // Each arg in the arg list is a list of valid types
	        // (if the function is overloaded and supports multiple
	        // types.  If the type is "any" then no type checking
	        // occurs on the argument.  Variadic is optional
	        // and if not provided is assumed to be false.
	        abs: {_func: this._functionAbs, _signature: [{types: [TYPE_NUMBER]}]},
	        avg: {_func: this._functionAvg, _signature: [{types: [TYPE_ARRAY_NUMBER]}]},
	        ceil: {_func: this._functionCeil, _signature: [{types: [TYPE_NUMBER]}]},
	        contains: {
	            _func: this._functionContains,
	            _signature: [{types: [TYPE_STRING, TYPE_ARRAY]},
	                        {types: [TYPE_ANY]}]},
	        "ends_with": {
	            _func: this._functionEndsWith,
	            _signature: [{types: [TYPE_STRING]}, {types: [TYPE_STRING]}]},
	        floor: {_func: this._functionFloor, _signature: [{types: [TYPE_NUMBER]}]},
	        length: {
	            _func: this._functionLength,
	            _signature: [{types: [TYPE_STRING, TYPE_ARRAY, TYPE_OBJECT]}]},
	        map: {
	            _func: this._functionMap,
	            _signature: [{types: [TYPE_EXPREF]}, {types: [TYPE_ARRAY]}]},
	        max: {
	            _func: this._functionMax,
	            _signature: [{types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING]}]},
	        "merge": {
	            _func: this._functionMerge,
	            _signature: [{types: [TYPE_OBJECT], variadic: true}]
	        },
	        "max_by": {
	          _func: this._functionMaxBy,
	          _signature: [{types: [TYPE_ARRAY]}, {types: [TYPE_EXPREF]}]
	        },
	        sum: {_func: this._functionSum, _signature: [{types: [TYPE_ARRAY_NUMBER]}]},
	        "starts_with": {
	            _func: this._functionStartsWith,
	            _signature: [{types: [TYPE_STRING]}, {types: [TYPE_STRING]}]},
	        min: {
	            _func: this._functionMin,
	            _signature: [{types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING]}]},
	        "min_by": {
	          _func: this._functionMinBy,
	          _signature: [{types: [TYPE_ARRAY]}, {types: [TYPE_EXPREF]}]
	        },
	        type: {_func: this._functionType, _signature: [{types: [TYPE_ANY]}]},
	        keys: {_func: this._functionKeys, _signature: [{types: [TYPE_OBJECT]}]},
	        values: {_func: this._functionValues, _signature: [{types: [TYPE_OBJECT]}]},
	        sort: {_func: this._functionSort, _signature: [{types: [TYPE_ARRAY_STRING, TYPE_ARRAY_NUMBER]}]},
	        "sort_by": {
	          _func: this._functionSortBy,
	          _signature: [{types: [TYPE_ARRAY]}, {types: [TYPE_EXPREF]}]
	        },
	        join: {
	            _func: this._functionJoin,
	            _signature: [
	                {types: [TYPE_STRING]},
	                {types: [TYPE_ARRAY_STRING]}
	            ]
	        },
	        reverse: {
	            _func: this._functionReverse,
	            _signature: [{types: [TYPE_STRING, TYPE_ARRAY]}]},
	        "to_array": {_func: this._functionToArray, _signature: [{types: [TYPE_ANY]}]},
	        "to_string": {_func: this._functionToString, _signature: [{types: [TYPE_ANY]}]},
	        "to_number": {_func: this._functionToNumber, _signature: [{types: [TYPE_ANY]}]},
	        "not_null": {
	            _func: this._functionNotNull,
	            _signature: [{types: [TYPE_ANY], variadic: true}]
	        }
	    };
	  }

	  Runtime.prototype = {
	    callFunction: function(name, resolvedArgs) {
	      var functionEntry = this.functionTable[name];
	      if (functionEntry === undefined) {
	          throw new Error("Unknown function: " + name + "()");
	      }
	      this._validateArgs(name, resolvedArgs, functionEntry._signature);
	      return functionEntry._func.call(this, resolvedArgs);
	    },

	    _validateArgs: function(name, args, signature) {
	        // Validating the args requires validating
	        // the correct arity and the correct type of each arg.
	        // If the last argument is declared as variadic, then we need
	        // a minimum number of args to be required.  Otherwise it has to
	        // be an exact amount.
	        var pluralized;
	        if (signature[signature.length - 1].variadic) {
	            if (args.length < signature.length) {
	                pluralized = signature.length === 1 ? " argument" : " arguments";
	                throw new Error("ArgumentError: " + name + "() " +
	                                "takes at least" + signature.length + pluralized +
	                                " but received " + args.length);
	            }
	        } else if (args.length !== signature.length) {
	            pluralized = signature.length === 1 ? " argument" : " arguments";
	            throw new Error("ArgumentError: " + name + "() " +
	                            "takes " + signature.length + pluralized +
	                            " but received " + args.length);
	        }
	        var currentSpec;
	        var actualType;
	        var typeMatched;
	        for (var i = 0; i < signature.length; i++) {
	            typeMatched = false;
	            currentSpec = signature[i].types;
	            actualType = this._getTypeName(args[i]);
	            for (var j = 0; j < currentSpec.length; j++) {
	                if (this._typeMatches(actualType, currentSpec[j], args[i])) {
	                    typeMatched = true;
	                    break;
	                }
	            }
	            if (!typeMatched) {
	                throw new Error("TypeError: " + name + "() " +
	                                "expected argument " + (i + 1) +
	                                " to be type " + currentSpec +
	                                " but received type " + actualType +
	                                " instead.");
	            }
	        }
	    },

	    _typeMatches: function(actual, expected, argValue) {
	        if (expected === TYPE_ANY) {
	            return true;
	        }
	        if (expected === TYPE_ARRAY_STRING ||
	            expected === TYPE_ARRAY_NUMBER ||
	            expected === TYPE_ARRAY) {
	            // The expected type can either just be array,
	            // or it can require a specific subtype (array of numbers).
	            //
	            // The simplest case is if "array" with no subtype is specified.
	            if (expected === TYPE_ARRAY) {
	                return actual === TYPE_ARRAY;
	            } else if (actual === TYPE_ARRAY) {
	                // Otherwise we need to check subtypes.
	                // I think this has potential to be improved.
	                var subtype;
	                if (expected === TYPE_ARRAY_NUMBER) {
	                  subtype = TYPE_NUMBER;
	                } else if (expected === TYPE_ARRAY_STRING) {
	                  subtype = TYPE_STRING;
	                }
	                for (var i = 0; i < argValue.length; i++) {
	                    if (!this._typeMatches(
	                            this._getTypeName(argValue[i]), subtype,
	                                             argValue[i])) {
	                        return false;
	                    }
	                }
	                return true;
	            }
	        } else {
	            return actual === expected;
	        }
	    },
	    _getTypeName: function(obj) {
	        switch (Object.prototype.toString.call(obj)) {
	            case "[object String]":
	              return TYPE_STRING;
	            case "[object Number]":
	              return TYPE_NUMBER;
	            case "[object Array]":
	              return TYPE_ARRAY;
	            case "[object Boolean]":
	              return TYPE_BOOLEAN;
	            case "[object Null]":
	              return TYPE_NULL;
	            case "[object Object]":
	              // Check if it's an expref.  If it has, it's been
	              // tagged with a jmespathType attr of 'Expref';
	              if (obj.jmespathType === TOK_EXPREF) {
	                return TYPE_EXPREF;
	              } else {
	                return TYPE_OBJECT;
	              }
	        }
	    },

	    _functionStartsWith: function(resolvedArgs) {
	        return resolvedArgs[0].lastIndexOf(resolvedArgs[1]) === 0;
	    },

	    _functionEndsWith: function(resolvedArgs) {
	        var searchStr = resolvedArgs[0];
	        var suffix = resolvedArgs[1];
	        return searchStr.indexOf(suffix, searchStr.length - suffix.length) !== -1;
	    },

	    _functionReverse: function(resolvedArgs) {
	        var typeName = this._getTypeName(resolvedArgs[0]);
	        if (typeName === TYPE_STRING) {
	          var originalStr = resolvedArgs[0];
	          var reversedStr = "";
	          for (var i = originalStr.length - 1; i >= 0; i--) {
	              reversedStr += originalStr[i];
	          }
	          return reversedStr;
	        } else {
	          var reversedArray = resolvedArgs[0].slice(0);
	          reversedArray.reverse();
	          return reversedArray;
	        }
	    },

	    _functionAbs: function(resolvedArgs) {
	      return Math.abs(resolvedArgs[0]);
	    },

	    _functionCeil: function(resolvedArgs) {
	        return Math.ceil(resolvedArgs[0]);
	    },

	    _functionAvg: function(resolvedArgs) {
	        var sum = 0;
	        var inputArray = resolvedArgs[0];
	        for (var i = 0; i < inputArray.length; i++) {
	            sum += inputArray[i];
	        }
	        return sum / inputArray.length;
	    },

	    _functionContains: function(resolvedArgs) {
	        return resolvedArgs[0].indexOf(resolvedArgs[1]) >= 0;
	    },

	    _functionFloor: function(resolvedArgs) {
	        return Math.floor(resolvedArgs[0]);
	    },

	    _functionLength: function(resolvedArgs) {
	       if (!isObject(resolvedArgs[0])) {
	         return resolvedArgs[0].length;
	       } else {
	         // As far as I can tell, there's no way to get the length
	         // of an object without O(n) iteration through the object.
	         return Object.keys(resolvedArgs[0]).length;
	       }
	    },

	    _functionMap: function(resolvedArgs) {
	      var mapped = [];
	      var interpreter = this._interpreter;
	      var exprefNode = resolvedArgs[0];
	      var elements = resolvedArgs[1];
	      for (var i = 0; i < elements.length; i++) {
	          mapped.push(interpreter.visit(exprefNode, elements[i]));
	      }
	      return mapped;
	    },

	    _functionMerge: function(resolvedArgs) {
	      var merged = {};
	      for (var i = 0; i < resolvedArgs.length; i++) {
	        var current = resolvedArgs[i];
	        for (var key in current) {
	          merged[key] = current[key];
	        }
	      }
	      return merged;
	    },

	    _functionMax: function(resolvedArgs) {
	      if (resolvedArgs[0].length > 0) {
	        var typeName = this._getTypeName(resolvedArgs[0][0]);
	        if (typeName === TYPE_NUMBER) {
	          return Math.max.apply(Math, resolvedArgs[0]);
	        } else {
	          var elements = resolvedArgs[0];
	          var maxElement = elements[0];
	          for (var i = 1; i < elements.length; i++) {
	              if (maxElement.localeCompare(elements[i]) < 0) {
	                  maxElement = elements[i];
	              }
	          }
	          return maxElement;
	        }
	      } else {
	          return null;
	      }
	    },

	    _functionMin: function(resolvedArgs) {
	      if (resolvedArgs[0].length > 0) {
	        var typeName = this._getTypeName(resolvedArgs[0][0]);
	        if (typeName === TYPE_NUMBER) {
	          return Math.min.apply(Math, resolvedArgs[0]);
	        } else {
	          var elements = resolvedArgs[0];
	          var minElement = elements[0];
	          for (var i = 1; i < elements.length; i++) {
	              if (elements[i].localeCompare(minElement) < 0) {
	                  minElement = elements[i];
	              }
	          }
	          return minElement;
	        }
	      } else {
	        return null;
	      }
	    },

	    _functionSum: function(resolvedArgs) {
	      var sum = 0;
	      var listToSum = resolvedArgs[0];
	      for (var i = 0; i < listToSum.length; i++) {
	        sum += listToSum[i];
	      }
	      return sum;
	    },

	    _functionType: function(resolvedArgs) {
	        switch (this._getTypeName(resolvedArgs[0])) {
	          case TYPE_NUMBER:
	            return "number";
	          case TYPE_STRING:
	            return "string";
	          case TYPE_ARRAY:
	            return "array";
	          case TYPE_OBJECT:
	            return "object";
	          case TYPE_BOOLEAN:
	            return "boolean";
	          case TYPE_EXPREF:
	            return "expref";
	          case TYPE_NULL:
	            return "null";
	        }
	    },

	    _functionKeys: function(resolvedArgs) {
	        return Object.keys(resolvedArgs[0]);
	    },

	    _functionValues: function(resolvedArgs) {
	        var obj = resolvedArgs[0];
	        var keys = Object.keys(obj);
	        var values = [];
	        for (var i = 0; i < keys.length; i++) {
	            values.push(obj[keys[i]]);
	        }
	        return values;
	    },

	    _functionJoin: function(resolvedArgs) {
	        var joinChar = resolvedArgs[0];
	        var listJoin = resolvedArgs[1];
	        return listJoin.join(joinChar);
	    },

	    _functionToArray: function(resolvedArgs) {
	        if (this._getTypeName(resolvedArgs[0]) === TYPE_ARRAY) {
	            return resolvedArgs[0];
	        } else {
	            return [resolvedArgs[0]];
	        }
	    },

	    _functionToString: function(resolvedArgs) {
	        if (this._getTypeName(resolvedArgs[0]) === TYPE_STRING) {
	            return resolvedArgs[0];
	        } else {
	            return JSON.stringify(resolvedArgs[0]);
	        }
	    },

	    _functionToNumber: function(resolvedArgs) {
	        var typeName = this._getTypeName(resolvedArgs[0]);
	        var convertedValue;
	        if (typeName === TYPE_NUMBER) {
	            return resolvedArgs[0];
	        } else if (typeName === TYPE_STRING) {
	            convertedValue = +resolvedArgs[0];
	            if (!isNaN(convertedValue)) {
	                return convertedValue;
	            }
	        }
	        return null;
	    },

	    _functionNotNull: function(resolvedArgs) {
	        for (var i = 0; i < resolvedArgs.length; i++) {
	            if (this._getTypeName(resolvedArgs[i]) !== TYPE_NULL) {
	                return resolvedArgs[i];
	            }
	        }
	        return null;
	    },

	    _functionSort: function(resolvedArgs) {
	        var sortedArray = resolvedArgs[0].slice(0);
	        sortedArray.sort();
	        return sortedArray;
	    },

	    _functionSortBy: function(resolvedArgs) {
	        var sortedArray = resolvedArgs[0].slice(0);
	        if (sortedArray.length === 0) {
	            return sortedArray;
	        }
	        var interpreter = this._interpreter;
	        var exprefNode = resolvedArgs[1];
	        var requiredType = this._getTypeName(
	            interpreter.visit(exprefNode, sortedArray[0]));
	        if ([TYPE_NUMBER, TYPE_STRING].indexOf(requiredType) < 0) {
	            throw new Error("TypeError");
	        }
	        var that = this;
	        // In order to get a stable sort out of an unstable
	        // sort algorithm, we decorate/sort/undecorate (DSU)
	        // by creating a new list of [index, element] pairs.
	        // In the cmp function, if the evaluated elements are
	        // equal, then the index will be used as the tiebreaker.
	        // After the decorated list has been sorted, it will be
	        // undecorated to extract the original elements.
	        var decorated = [];
	        for (var i = 0; i < sortedArray.length; i++) {
	          decorated.push([i, sortedArray[i]]);
	        }
	        decorated.sort(function(a, b) {
	          var exprA = interpreter.visit(exprefNode, a[1]);
	          var exprB = interpreter.visit(exprefNode, b[1]);
	          if (that._getTypeName(exprA) !== requiredType) {
	              throw new Error(
	                  "TypeError: expected " + requiredType + ", received " +
	                  that._getTypeName(exprA));
	          } else if (that._getTypeName(exprB) !== requiredType) {
	              throw new Error(
	                  "TypeError: expected " + requiredType + ", received " +
	                  that._getTypeName(exprB));
	          }
	          if (exprA > exprB) {
	            return 1;
	          } else if (exprA < exprB) {
	            return -1;
	          } else {
	            // If they're equal compare the items by their
	            // order to maintain relative order of equal keys
	            // (i.e. to get a stable sort).
	            return a[0] - b[0];
	          }
	        });
	        // Undecorate: extract out the original list elements.
	        for (var j = 0; j < decorated.length; j++) {
	          sortedArray[j] = decorated[j][1];
	        }
	        return sortedArray;
	    },

	    _functionMaxBy: function(resolvedArgs) {
	      var exprefNode = resolvedArgs[1];
	      var resolvedArray = resolvedArgs[0];
	      var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);
	      var maxNumber = -Infinity;
	      var maxRecord;
	      var current;
	      for (var i = 0; i < resolvedArray.length; i++) {
	        current = keyFunction(resolvedArray[i]);
	        if (current > maxNumber) {
	          maxNumber = current;
	          maxRecord = resolvedArray[i];
	        }
	      }
	      return maxRecord;
	    },

	    _functionMinBy: function(resolvedArgs) {
	      var exprefNode = resolvedArgs[1];
	      var resolvedArray = resolvedArgs[0];
	      var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);
	      var minNumber = Infinity;
	      var minRecord;
	      var current;
	      for (var i = 0; i < resolvedArray.length; i++) {
	        current = keyFunction(resolvedArray[i]);
	        if (current < minNumber) {
	          minNumber = current;
	          minRecord = resolvedArray[i];
	        }
	      }
	      return minRecord;
	    },

	    createKeyFunction: function(exprefNode, allowedTypes) {
	      var that = this;
	      var interpreter = this._interpreter;
	      var keyFunc = function(x) {
	        var current = interpreter.visit(exprefNode, x);
	        if (allowedTypes.indexOf(that._getTypeName(current)) < 0) {
	          var msg = "TypeError: expected one of " + allowedTypes +
	                    ", received " + that._getTypeName(current);
	          throw new Error(msg);
	        }
	        return current;
	      };
	      return keyFunc;
	    }

	  };

	  function compile(stream) {
	    var parser = new Parser();
	    var ast = parser.parse(stream);
	    return ast;
	  }

	  function tokenize(stream) {
	      var lexer = new Lexer();
	      return lexer.tokenize(stream);
	  }

	  function search(data, expression) {
	      var parser = new Parser();
	      // This needs to be improved.  Both the interpreter and runtime depend on
	      // each other.  The runtime needs the interpreter to support exprefs.
	      // There's likely a clean way to avoid the cyclic dependency.
	      var runtime = new Runtime();
	      var interpreter = new TreeInterpreter(runtime);
	      runtime._interpreter = interpreter;
	      var node = parser.parse(expression);
	      return interpreter.search(node, data);
	  }

	  exports.tokenize = tokenize;
	  exports.compile = compile;
	  exports.search = search;
	  exports.strictDeepEqual = strictDeepEqual;
	})( false ? this.jmespath = {} : exports);


/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(93);
	var inherit = AWS.util.inherit;
	var jmespath = __webpack_require__(197);

	/**
	 * This class encapsulates the response information
	 * from a service request operation sent through {AWS.Request}.
	 * The response object has two main properties for getting information
	 * back from a request:
	 *
	 * ## The `data` property
	 *
	 * The `response.data` property contains the serialized object data
	 * retrieved from the service request. For instance, for an
	 * Amazon DynamoDB `listTables` method call, the response data might
	 * look like:
	 *
	 * ```
	 * > resp.data
	 * { TableNames:
	 *    [ 'table1', 'table2', ... ] }
	 * ```
	 *
	 * The `data` property can be null if an error occurs (see below).
	 *
	 * ## The `error` property
	 *
	 * In the event of a service error (or transfer error), the
	 * `response.error` property will be filled with the given
	 * error data in the form:
	 *
	 * ```
	 * { code: 'SHORT_UNIQUE_ERROR_CODE',
	 *   message: 'Some human readable error message' }
	 * ```
	 *
	 * In the case of an error, the `data` property will be `null`.
	 * Note that if you handle events that can be in a failure state,
	 * you should always check whether `response.error` is set
	 * before attempting to access the `response.data` property.
	 *
	 * @!attribute data
	 *   @readonly
	 *   @!group Data Properties
	 *   @note Inside of a {AWS.Request~httpData} event, this
	 *     property contains a single raw packet instead of the
	 *     full de-serialized service response.
	 *   @return [Object] the de-serialized response data
	 *     from the service.
	 *
	 * @!attribute error
	 *   An structure containing information about a service
	 *   or networking error.
	 *   @readonly
	 *   @!group Data Properties
	 *   @note This attribute is only filled if a service or
	 *     networking error occurs.
	 *   @return [Error]
	 *     * code [String] a unique short code representing the
	 *       error that was emitted.
	 *     * message [String] a longer human readable error message
	 *     * retryable [Boolean] whether the error message is
	 *       retryable.
	 *     * statusCode [Numeric] in the case of a request that reached the service,
	 *       this value contains the response status code.
	 *     * time [Date] the date time object when the error occurred.
	 *     * hostname [String] set when a networking error occurs to easily
	 *       identify the endpoint of the request.
	 *     * region [String] set when a networking error occurs to easily
	 *       identify the region of the request.
	 *
	 * @!attribute requestId
	 *   @readonly
	 *   @!group Data Properties
	 *   @return [String] the unique request ID associated with the response.
	 *     Log this value when debugging requests for AWS support.
	 *
	 * @!attribute retryCount
	 *   @readonly
	 *   @!group Operation Properties
	 *   @return [Integer] the number of retries that were
	 *     attempted before the request was completed.
	 *
	 * @!attribute redirectCount
	 *   @readonly
	 *   @!group Operation Properties
	 *   @return [Integer] the number of redirects that were
	 *     followed before the request was completed.
	 *
	 * @!attribute httpResponse
	 *   @readonly
	 *   @!group HTTP Properties
	 *   @return [AWS.HttpResponse] the raw HTTP response object
	 *     containing the response headers and body information
	 *     from the server.
	 *
	 * @see AWS.Request
	 */
	AWS.Response = inherit({

	  /**
	   * @api private
	   */
	  constructor: function Response(request) {
	    this.request = request;
	    this.data = null;
	    this.error = null;
	    this.retryCount = 0;
	    this.redirectCount = 0;
	    this.httpResponse = new AWS.HttpResponse();
	    if (request) {
	      this.maxRetries = request.service.numRetries();
	      this.maxRedirects = request.service.config.maxRedirects;
	    }
	  },

	  /**
	   * Creates a new request for the next page of response data, calling the
	   * callback with the page data if a callback is provided.
	   *
	   * @callback callback function(err, data)
	   *   Called when a page of data is returned from the next request.
	   *
	   *   @param err [Error] an error object, if an error occurred in the request
	   *   @param data [Object] the next page of data, or null, if there are no
	   *     more pages left.
	   * @return [AWS.Request] the request object for the next page of data
	   * @return [null] if no callback is provided and there are no pages left
	   *   to retrieve.
	   * @since v1.4.0
	   */
	  nextPage: function nextPage(callback) {
	    var config;
	    var service = this.request.service;
	    var operation = this.request.operation;
	    try {
	      config = service.paginationConfig(operation, true);
	    } catch (e) { this.error = e; }

	    if (!this.hasNextPage()) {
	      if (callback) callback(this.error, null);
	      else if (this.error) throw this.error;
	      return null;
	    }

	    var params = AWS.util.copy(this.request.params);
	    if (!this.nextPageTokens) {
	      return callback ? callback(null, null) : null;
	    } else {
	      var inputTokens = config.inputToken;
	      if (typeof inputTokens === 'string') inputTokens = [inputTokens];
	      for (var i = 0; i < inputTokens.length; i++) {
	        params[inputTokens[i]] = this.nextPageTokens[i];
	      }
	      return service.makeRequest(this.request.operation, params, callback);
	    }
	  },

	  /**
	   * @return [Boolean] whether more pages of data can be returned by further
	   *   requests
	   * @since v1.4.0
	   */
	  hasNextPage: function hasNextPage() {
	    this.cacheNextPageTokens();
	    if (this.nextPageTokens) return true;
	    if (this.nextPageTokens === undefined) return undefined;
	    else return false;
	  },

	  /**
	   * @api private
	   */
	  cacheNextPageTokens: function cacheNextPageTokens() {
	    if (Object.prototype.hasOwnProperty.call(this, 'nextPageTokens')) return this.nextPageTokens;
	    this.nextPageTokens = undefined;

	    var config = this.request.service.paginationConfig(this.request.operation);
	    if (!config) return this.nextPageTokens;

	    this.nextPageTokens = null;
	    if (config.moreResults) {
	      if (!jmespath.search(this.data, config.moreResults)) {
	        return this.nextPageTokens;
	      }
	    }

	    var exprs = config.outputToken;
	    if (typeof exprs === 'string') exprs = [exprs];
	    AWS.util.arrayEach.call(this, exprs, function (expr) {
	      var output = jmespath.search(this.data, expr);
	      if (output) {
	        this.nextPageTokens = this.nextPageTokens || [];
	        this.nextPageTokens.push(output);
	      }
	    });

	    return this.nextPageTokens;
	  }

	});


/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2012-2013 Amazon.com, Inc. or its affiliates. All Rights Reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License"). You
	 * may not use this file except in compliance with the License. A copy of
	 * the License is located at
	 *
	 *     http://aws.amazon.com/apache2.0/
	 *
	 * or in the "license" file accompanying this file. This file is
	 * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
	 * ANY KIND, either express or implied. See the License for the specific
	 * language governing permissions and limitations under the License.
	 */

	var AWS = __webpack_require__(93);
	var inherit = AWS.util.inherit;
	var jmespath = __webpack_require__(197);

	/**
	 * @api private
	 */
	function CHECK_ACCEPTORS(resp) {
	  var waiter = resp.request._waiter;
	  var acceptors = waiter.config.acceptors;
	  var acceptorMatched = false;
	  var state = 'retry';

	  acceptors.forEach(function(acceptor) {
	    if (!acceptorMatched) {
	      var matcher = waiter.matchers[acceptor.matcher];
	      if (matcher && matcher(resp, acceptor.expected, acceptor.argument)) {
	        acceptorMatched = true;
	        state = acceptor.state;
	      }
	    }
	  });

	  if (!acceptorMatched && resp.error) state = 'failure';

	  if (state === 'success') {
	    waiter.setSuccess(resp);
	  } else {
	    waiter.setError(resp, state === 'retry');
	  }
	}

	/**
	 * @api private
	 */
	AWS.ResourceWaiter = inherit({
	  /**
	   * Waits for a given state on a service object
	   * @param service [Service] the service object to wait on
	   * @param state [String] the state (defined in waiter configuration) to wait
	   *   for.
	   * @example Create a waiter for running EC2 instances
	   *   var ec2 = new AWS.EC2;
	   *   var waiter = new AWS.ResourceWaiter(ec2, 'instanceRunning');
	   */
	  constructor: function constructor(service, state) {
	    this.service = service;
	    this.state = state;
	    this.loadWaiterConfig(this.state);
	  },

	  service: null,

	  state: null,

	  config: null,

	  matchers: {
	    path: function(resp, expected, argument) {
	      var result = jmespath.search(resp.data, argument);
	      return jmespath.strictDeepEqual(result,expected);
	    },

	    pathAll: function(resp, expected, argument) {
	      var results = jmespath.search(resp.data, argument);
	      if (!Array.isArray(results)) results = [results];
	      var numResults = results.length;
	      if (!numResults) return false;
	      for (var ind = 0 ; ind < numResults; ind++) {
	        if (!jmespath.strictDeepEqual(results[ind], expected)) {
	          return false;
	        }
	      }
	      return true;
	    },

	    pathAny: function(resp, expected, argument) {
	      var results = jmespath.search(resp.data, argument);
	      if (!Array.isArray(results)) results = [results];
	      var numResults = results.length;
	      for (var ind = 0 ; ind < numResults; ind++) {
	        if (jmespath.strictDeepEqual(results[ind], expected)) {
	          return true;
	        }
	      }
	      return false;
	    },

	    status: function(resp, expected) {
	      var statusCode = resp.httpResponse.statusCode;
	      return (typeof statusCode === 'number') && (statusCode === expected);
	    },

	    error: function(resp, expected) {
	      if (typeof expected === 'string' && resp.error) {
	        return expected === resp.error.code;
	      }
	      // if expected is not string, can be boolean indicating presence of error
	      return expected === !!resp.error;
	    }
	  },

	  listeners: new AWS.SequentialExecutor().addNamedListeners(function(add) {
	    add('RETRY_CHECK', 'retry', function(resp) {
	      var waiter = resp.request._waiter;
	      if (resp.error && resp.error.code === 'ResourceNotReady') {
	        resp.error.retryDelay = (waiter.config.delay || 0) * 1000;
	      }
	    });

	    add('CHECK_OUTPUT', 'extractData', CHECK_ACCEPTORS);

	    add('CHECK_ERROR', 'extractError', CHECK_ACCEPTORS);
	  }),

	  /**
	   * @return [AWS.Request]
	   */
	  wait: function wait(params, callback) {
	    if (typeof params === 'function') {
	      callback = params; params = undefined;
	    }

	    var request = this.service.makeRequest(this.config.operation, params);
	    request._waiter = this;
	    request.response.maxRetries = this.config.maxAttempts;
	    request.addListeners(this.listeners);

	    if (callback) request.send(callback);
	    return request;
	  },

	  setSuccess: function setSuccess(resp) {
	    resp.error = null;
	    resp.data = resp.data || {};
	    resp.request.removeAllListeners('extractData');
	  },

	  setError: function setError(resp, retryable) {
	    resp.data = null;
	    resp.error = AWS.util.error(resp.error || new Error(), {
	      code: 'ResourceNotReady',
	      message: 'Resource is not in the state ' + this.state,
	      retryable: retryable
	    });
	  },

	  /**
	   * Loads waiter configuration from API configuration
	   *
	   * @api private
	   */
	  loadWaiterConfig: function loadWaiterConfig(state) {
	    if (!this.service.api.waiters[state]) {
	      throw new AWS.util.error(new Error(), {
	        code: 'StateNotFoundError',
	        message: 'State ' + state + ' not found.'
	      });
	    }

	    this.config = this.service.api.waiters[state];
	  }
	});


/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(93);
	var inherit = AWS.util.inherit;

	/**
	 * @api private
	 */
	AWS.Signers.RequestSigner = inherit({
	  constructor: function RequestSigner(request) {
	    this.request = request;
	  },

	  setServiceClientId: function setServiceClientId(id) {
	    this.serviceClientId = id;
	  },

	  getServiceClientId: function getServiceClientId() {
	    return this.serviceClientId;
	  }
	});

	AWS.Signers.RequestSigner.getVersion = function getVersion(version) {
	  switch (version) {
	    case 'v2': return AWS.Signers.V2;
	    case 'v3': return AWS.Signers.V3;
	    case 'v4': return AWS.Signers.V4;
	    case 's3': return AWS.Signers.S3;
	    case 'v3https': return AWS.Signers.V3Https;
	  }
	  throw new Error('Unknown signing version ' + version);
	};

	__webpack_require__(201);
	__webpack_require__(202);
	__webpack_require__(203);
	__webpack_require__(204);
	__webpack_require__(205);
	__webpack_require__(206);


/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(93);
	var inherit = AWS.util.inherit;

	/**
	 * @api private
	 */
	AWS.Signers.V2 = inherit(AWS.Signers.RequestSigner, {
	  addAuthorization: function addAuthorization(credentials, date) {

	    if (!date) date = AWS.util.date.getDate();

	    var r = this.request;

	    r.params.Timestamp = AWS.util.date.iso8601(date);
	    r.params.SignatureVersion = '2';
	    r.params.SignatureMethod = 'HmacSHA256';
	    r.params.AWSAccessKeyId = credentials.accessKeyId;

	    if (credentials.sessionToken) {
	      r.params.SecurityToken = credentials.sessionToken;
	    }

	    delete r.params.Signature; // delete old Signature for re-signing
	    r.params.Signature = this.signature(credentials);

	    r.body = AWS.util.queryParamsToString(r.params);
	    r.headers['Content-Length'] = r.body.length;
	  },

	  signature: function signature(credentials) {
	    return AWS.util.crypto.hmac(credentials.secretAccessKey, this.stringToSign(), 'base64');
	  },

	  stringToSign: function stringToSign() {
	    var parts = [];
	    parts.push(this.request.method);
	    parts.push(this.request.endpoint.host.toLowerCase());
	    parts.push(this.request.pathname());
	    parts.push(AWS.util.queryParamsToString(this.request.params));
	    return parts.join('\n');
	  }

	});

	module.exports = AWS.Signers.V2;


/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(93);
	var inherit = AWS.util.inherit;

	/**
	 * @api private
	 */
	AWS.Signers.V3 = inherit(AWS.Signers.RequestSigner, {
	  addAuthorization: function addAuthorization(credentials, date) {

	    var datetime = AWS.util.date.rfc822(date);

	    this.request.headers['X-Amz-Date'] = datetime;

	    if (credentials.sessionToken) {
	      this.request.headers['x-amz-security-token'] = credentials.sessionToken;
	    }

	    this.request.headers['X-Amzn-Authorization'] =
	      this.authorization(credentials, datetime);

	  },

	  authorization: function authorization(credentials) {
	    return 'AWS3 ' +
	      'AWSAccessKeyId=' + credentials.accessKeyId + ',' +
	      'Algorithm=HmacSHA256,' +
	      'SignedHeaders=' + this.signedHeaders() + ',' +
	      'Signature=' + this.signature(credentials);
	  },

	  signedHeaders: function signedHeaders() {
	    var headers = [];
	    AWS.util.arrayEach(this.headersToSign(), function iterator(h) {
	      headers.push(h.toLowerCase());
	    });
	    return headers.sort().join(';');
	  },

	  canonicalHeaders: function canonicalHeaders() {
	    var headers = this.request.headers;
	    var parts = [];
	    AWS.util.arrayEach(this.headersToSign(), function iterator(h) {
	      parts.push(h.toLowerCase().trim() + ':' + String(headers[h]).trim());
	    });
	    return parts.sort().join('\n') + '\n';
	  },

	  headersToSign: function headersToSign() {
	    var headers = [];
	    AWS.util.each(this.request.headers, function iterator(k) {
	      if (k === 'Host' || k === 'Content-Encoding' || k.match(/^X-Amz/i)) {
	        headers.push(k);
	      }
	    });
	    return headers;
	  },

	  signature: function signature(credentials) {
	    return AWS.util.crypto.hmac(credentials.secretAccessKey, this.stringToSign(), 'base64');
	  },

	  stringToSign: function stringToSign() {
	    var parts = [];
	    parts.push(this.request.method);
	    parts.push('/');
	    parts.push('');
	    parts.push(this.canonicalHeaders());
	    parts.push(this.request.body);
	    return AWS.util.crypto.sha256(parts.join('\n'));
	  }

	});

	module.exports = AWS.Signers.V3;


/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(93);
	var inherit = AWS.util.inherit;

	__webpack_require__(202);

	/**
	 * @api private
	 */
	AWS.Signers.V3Https = inherit(AWS.Signers.V3, {
	  authorization: function authorization(credentials) {
	    return 'AWS3-HTTPS ' +
	      'AWSAccessKeyId=' + credentials.accessKeyId + ',' +
	      'Algorithm=HmacSHA256,' +
	      'Signature=' + this.signature(credentials);
	  },

	  stringToSign: function stringToSign() {
	    return this.request.headers['X-Amz-Date'];
	  }
	});

	module.exports = AWS.Signers.V3Https;


/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(93);
	var inherit = AWS.util.inherit;

	/**
	 * @api private
	 */
	var cachedSecret = {};

	/**
	 * @api private
	 */
	var cacheQueue = [];

	/**
	 * @api private
	 */
	var maxCacheEntries = 50;

	/**
	 * @api private
	 */
	var expiresHeader = 'presigned-expires';

	/**
	 * @api private
	 */
	AWS.Signers.V4 = inherit(AWS.Signers.RequestSigner, {
	  constructor: function V4(request, serviceName, signatureCache) {
	    AWS.Signers.RequestSigner.call(this, request);
	    this.serviceName = serviceName;
	    this.signatureCache = signatureCache;
	  },

	  algorithm: 'AWS4-HMAC-SHA256',

	  addAuthorization: function addAuthorization(credentials, date) {
	    var datetime = AWS.util.date.iso8601(date).replace(/[:\-]|\.\d{3}/g, '');

	    if (this.isPresigned()) {
	      this.updateForPresigned(credentials, datetime);
	    } else {
	      this.addHeaders(credentials, datetime);
	    }

	    this.request.headers['Authorization'] =
	      this.authorization(credentials, datetime);
	  },

	  addHeaders: function addHeaders(credentials, datetime) {
	    this.request.headers['X-Amz-Date'] = datetime;
	    if (credentials.sessionToken) {
	      this.request.headers['x-amz-security-token'] = credentials.sessionToken;
	    }
	  },

	  updateForPresigned: function updateForPresigned(credentials, datetime) {
	    var credString = this.credentialString(datetime);
	    var qs = {
	      'X-Amz-Date': datetime,
	      'X-Amz-Algorithm': this.algorithm,
	      'X-Amz-Credential': credentials.accessKeyId + '/' + credString,
	      'X-Amz-Expires': this.request.headers[expiresHeader],
	      'X-Amz-SignedHeaders': this.signedHeaders()
	    };

	    if (credentials.sessionToken) {
	      qs['X-Amz-Security-Token'] = credentials.sessionToken;
	    }

	    if (this.request.headers['Content-Type']) {
	      qs['Content-Type'] = this.request.headers['Content-Type'];
	    }
	    if (this.request.headers['Content-MD5']) {
	      qs['Content-MD5'] = this.request.headers['Content-MD5'];
	    }
	    if (this.request.headers['Cache-Control']) {
	      qs['Cache-Control'] = this.request.headers['Cache-Control'];
	    }

	    // need to pull in any other X-Amz-* headers
	    AWS.util.each.call(this, this.request.headers, function(key, value) {
	      if (key === expiresHeader) return;
	      if (this.isSignableHeader(key)) {
	        var lowerKey = key.toLowerCase();
	        // Metadata should be normalized
	        if (lowerKey.indexOf('x-amz-meta-') === 0) {
	          qs[lowerKey] = value;
	        } else if (lowerKey.indexOf('x-amz-') === 0) {
	          qs[key] = value;
	        }
	      }
	    });

	    var sep = this.request.path.indexOf('?') >= 0 ? '&' : '?';
	    this.request.path += sep + AWS.util.queryParamsToString(qs);
	  },

	  authorization: function authorization(credentials, datetime) {
	    var parts = [];
	    var credString = this.credentialString(datetime);
	    parts.push(this.algorithm + ' Credential=' +
	      credentials.accessKeyId + '/' + credString);
	    parts.push('SignedHeaders=' + this.signedHeaders());
	    parts.push('Signature=' + this.signature(credentials, datetime));
	    return parts.join(', ');
	  },

	  signature: function signature(credentials, datetime) {
	    var cache = null;
	    var cacheIdentifier = this.serviceName + (this.getServiceClientId() ? '_' + this.getServiceClientId() : '');
	    if (this.signatureCache) {
	      var cache = cachedSecret[cacheIdentifier];
	      // If there isn't already a cache entry, we'll be adding one
	      if (!cache) {
	        cacheQueue.push(cacheIdentifier);
	        if (cacheQueue.length > maxCacheEntries) {
	          // remove the oldest entry (may not be last one used)
	          delete cachedSecret[cacheQueue.shift()];
	        }
	      }

	    }
	    var date = datetime.substr(0, 8);

	    if (!cache ||
	        cache.akid !== credentials.accessKeyId ||
	        cache.region !== this.request.region ||
	        cache.date !== date) {

	      var kSecret = credentials.secretAccessKey;
	      var kDate = AWS.util.crypto.hmac('AWS4' + kSecret, date, 'buffer');
	      var kRegion = AWS.util.crypto.hmac(kDate, this.request.region, 'buffer');
	      var kService = AWS.util.crypto.hmac(kRegion, this.serviceName, 'buffer');
	      var kCredentials = AWS.util.crypto.hmac(kService, 'aws4_request', 'buffer');

	      if (!this.signatureCache) {
	        return AWS.util.crypto.hmac(kCredentials, this.stringToSign(datetime), 'hex');
	      }

	      cachedSecret[cacheIdentifier] = {
	        region: this.request.region, date: date,
	        key: kCredentials, akid: credentials.accessKeyId
	      };
	    }

	    var key = cachedSecret[cacheIdentifier].key;
	    return AWS.util.crypto.hmac(key, this.stringToSign(datetime), 'hex');
	  },

	  stringToSign: function stringToSign(datetime) {
	    var parts = [];
	    parts.push('AWS4-HMAC-SHA256');
	    parts.push(datetime);
	    parts.push(this.credentialString(datetime));
	    parts.push(this.hexEncodedHash(this.canonicalString()));
	    return parts.join('\n');
	  },

	  canonicalString: function canonicalString() {
	    var parts = [], pathname = this.request.pathname();
	    if (this.serviceName !== 's3') pathname = AWS.util.uriEscapePath(pathname);

	    parts.push(this.request.method);
	    parts.push(pathname);
	    parts.push(this.request.search());
	    parts.push(this.canonicalHeaders() + '\n');
	    parts.push(this.signedHeaders());
	    parts.push(this.hexEncodedBodyHash());
	    return parts.join('\n');
	  },

	  canonicalHeaders: function canonicalHeaders() {
	    var headers = [];
	    AWS.util.each.call(this, this.request.headers, function (key, item) {
	      headers.push([key, item]);
	    });
	    headers.sort(function (a, b) {
	      return a[0].toLowerCase() < b[0].toLowerCase() ? -1 : 1;
	    });
	    var parts = [];
	    AWS.util.arrayEach.call(this, headers, function (item) {
	      var key = item[0].toLowerCase();
	      if (this.isSignableHeader(key)) {
	        parts.push(key + ':' +
	          this.canonicalHeaderValues(item[1].toString()));
	      }
	    });
	    return parts.join('\n');
	  },

	  canonicalHeaderValues: function canonicalHeaderValues(values) {
	    return values.replace(/\s+/g, ' ').replace(/^\s+|\s+$/g, '');
	  },

	  signedHeaders: function signedHeaders() {
	    var keys = [];
	    AWS.util.each.call(this, this.request.headers, function (key) {
	      key = key.toLowerCase();
	      if (this.isSignableHeader(key)) keys.push(key);
	    });
	    return keys.sort().join(';');
	  },

	  credentialString: function credentialString(datetime) {
	    var parts = [];
	    parts.push(datetime.substr(0, 8));
	    parts.push(this.request.region);
	    parts.push(this.serviceName);
	    parts.push('aws4_request');
	    return parts.join('/');
	  },

	  hexEncodedHash: function hash(string) {
	    return AWS.util.crypto.sha256(string, 'hex');
	  },

	  hexEncodedBodyHash: function hexEncodedBodyHash() {
	    if (this.isPresigned() && this.serviceName === 's3' && !this.request.body) {
	      return 'UNSIGNED-PAYLOAD';
	    } else if (this.request.headers['X-Amz-Content-Sha256']) {
	      return this.request.headers['X-Amz-Content-Sha256'];
	    } else {
	      return this.hexEncodedHash(this.request.body || '');
	    }
	  },

	  unsignableHeaders: ['authorization', 'content-type', 'content-length',
	                      'user-agent', expiresHeader, 'expect'],

	  isSignableHeader: function isSignableHeader(key) {
	    if (key.toLowerCase().indexOf('x-amz-') === 0) return true;
	    return this.unsignableHeaders.indexOf(key) < 0;
	  },

	  isPresigned: function isPresigned() {
	    return this.request.headers[expiresHeader] ? true : false;
	  }

	});

	module.exports = AWS.Signers.V4;


/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(93);
	var inherit = AWS.util.inherit;

	/**
	 * @api private
	 */
	AWS.Signers.S3 = inherit(AWS.Signers.RequestSigner, {
	  /**
	   * When building the stringToSign, these sub resource params should be
	   * part of the canonical resource string with their NON-decoded values
	   */
	  subResources: {
	    'acl': 1,
	    'accelerate': 1,
	    'cors': 1,
	    'lifecycle': 1,
	    'delete': 1,
	    'location': 1,
	    'logging': 1,
	    'notification': 1,
	    'partNumber': 1,
	    'policy': 1,
	    'requestPayment': 1,
	    'replication': 1,
	    'restore': 1,
	    'tagging': 1,
	    'torrent': 1,
	    'uploadId': 1,
	    'uploads': 1,
	    'versionId': 1,
	    'versioning': 1,
	    'versions': 1,
	    'website': 1
	  },

	  // when building the stringToSign, these querystring params should be
	  // part of the canonical resource string with their NON-encoded values
	  responseHeaders: {
	    'response-content-type': 1,
	    'response-content-language': 1,
	    'response-expires': 1,
	    'response-cache-control': 1,
	    'response-content-disposition': 1,
	    'response-content-encoding': 1
	  },

	  addAuthorization: function addAuthorization(credentials, date) {
	    if (!this.request.headers['presigned-expires']) {
	      this.request.headers['X-Amz-Date'] = AWS.util.date.rfc822(date);
	    }

	    if (credentials.sessionToken) {
	      // presigned URLs require this header to be lowercased
	      this.request.headers['x-amz-security-token'] = credentials.sessionToken;
	    }

	    var signature = this.sign(credentials.secretAccessKey, this.stringToSign());
	    var auth = 'AWS ' + credentials.accessKeyId + ':' + signature;

	    this.request.headers['Authorization'] = auth;
	  },

	  stringToSign: function stringToSign() {
	    var r = this.request;

	    var parts = [];
	    parts.push(r.method);
	    parts.push(r.headers['Content-MD5'] || '');
	    parts.push(r.headers['Content-Type'] || '');

	    // This is the "Date" header, but we use X-Amz-Date.
	    // The S3 signing mechanism requires us to pass an empty
	    // string for this Date header regardless.
	    parts.push(r.headers['presigned-expires'] || '');

	    var headers = this.canonicalizedAmzHeaders();
	    if (headers) parts.push(headers);
	    parts.push(this.canonicalizedResource());

	    return parts.join('\n');

	  },

	  canonicalizedAmzHeaders: function canonicalizedAmzHeaders() {

	    var amzHeaders = [];

	    AWS.util.each(this.request.headers, function (name) {
	      if (name.match(/^x-amz-/i))
	        amzHeaders.push(name);
	    });

	    amzHeaders.sort(function (a, b) {
	      return a.toLowerCase() < b.toLowerCase() ? -1 : 1;
	    });

	    var parts = [];
	    AWS.util.arrayEach.call(this, amzHeaders, function (name) {
	      parts.push(name.toLowerCase() + ':' + String(this.request.headers[name]));
	    });

	    return parts.join('\n');

	  },

	  canonicalizedResource: function canonicalizedResource() {

	    var r = this.request;

	    var parts = r.path.split('?');
	    var path = parts[0];
	    var querystring = parts[1];

	    var resource = '';

	    if (r.virtualHostedBucket)
	      resource += '/' + r.virtualHostedBucket;

	    resource += path;

	    if (querystring) {

	      // collect a list of sub resources and query params that need to be signed
	      var resources = [];

	      AWS.util.arrayEach.call(this, querystring.split('&'), function (param) {
	        var name = param.split('=')[0];
	        var value = param.split('=')[1];
	        if (this.subResources[name] || this.responseHeaders[name]) {
	          var subresource = { name: name };
	          if (value !== undefined) {
	            if (this.subResources[name]) {
	              subresource.value = value;
	            } else {
	              subresource.value = decodeURIComponent(value);
	            }
	          }
	          resources.push(subresource);
	        }
	      });

	      resources.sort(function (a, b) { return a.name < b.name ? -1 : 1; });

	      if (resources.length) {

	        querystring = [];
	        AWS.util.arrayEach(resources, function (res) {
	          if (res.value === undefined) {
	            querystring.push(res.name);
	          } else {
	            querystring.push(res.name + '=' + res.value);
	          }
	        });

	        resource += '?' + querystring.join('&');
	      }

	    }

	    return resource;

	  },

	  sign: function sign(secret, string) {
	    return AWS.util.crypto.hmac(secret, string, 'base64', 'sha1');
	  }
	});

	module.exports = AWS.Signers.S3;


/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(93);
	var inherit = AWS.util.inherit;

	/**
	 * @api private
	 */
	var expiresHeader = 'presigned-expires';

	/**
	 * @api private
	 */
	function signedUrlBuilder(request) {
	  var expires = request.httpRequest.headers[expiresHeader];
	  var signerClass = request.service.getSignerClass(request);

	  delete request.httpRequest.headers['User-Agent'];
	  delete request.httpRequest.headers['X-Amz-User-Agent'];

	  if (signerClass === AWS.Signers.V4) {
	    if (expires > 604800) { // one week expiry is invalid
	      var message = 'Presigning does not support expiry time greater ' +
	                    'than a week with SigV4 signing.';
	      throw AWS.util.error(new Error(), {
	        code: 'InvalidExpiryTime', message: message, retryable: false
	      });
	    }
	    request.httpRequest.headers[expiresHeader] = expires;
	  } else if (signerClass === AWS.Signers.S3) {
	    request.httpRequest.headers[expiresHeader] = parseInt(
	      AWS.util.date.unixTimestamp() + expires, 10).toString();
	  } else {
	    throw AWS.util.error(new Error(), {
	      message: 'Presigning only supports S3 or SigV4 signing.',
	      code: 'UnsupportedSigner', retryable: false
	    });
	  }
	}

	/**
	 * @api private
	 */
	function signedUrlSigner(request) {
	  var endpoint = request.httpRequest.endpoint;
	  var parsedUrl = AWS.util.urlParse(request.httpRequest.path);
	  var queryParams = {};

	  if (parsedUrl.search) {
	    queryParams = AWS.util.queryStringParse(parsedUrl.search.substr(1));
	  }

	  AWS.util.each(request.httpRequest.headers, function (key, value) {
	    if (key === expiresHeader) key = 'Expires';
	    if (key.indexOf('x-amz-meta-') === 0) {
	      // Delete existing, potentially not normalized key
	      delete queryParams[key];
	      key = key.toLowerCase();
	    }
	    queryParams[key] = value;
	  });
	  delete request.httpRequest.headers[expiresHeader];

	  var auth = queryParams['Authorization'].split(' ');
	  if (auth[0] === 'AWS') {
	    auth = auth[1].split(':');
	    queryParams['AWSAccessKeyId'] = auth[0];
	    queryParams['Signature'] = auth[1];
	  } else if (auth[0] === 'AWS4-HMAC-SHA256') { // SigV4 signing
	    auth.shift();
	    var rest = auth.join(' ');
	    var signature = rest.match(/Signature=(.*?)(?:,|\s|\r?\n|$)/)[1];
	    queryParams['X-Amz-Signature'] = signature;
	    delete queryParams['Expires'];
	  }
	  delete queryParams['Authorization'];
	  delete queryParams['Host'];

	  // build URL
	  endpoint.pathname = parsedUrl.pathname;
	  endpoint.search = AWS.util.queryParamsToString(queryParams);
	}

	/**
	 * @api private
	 */
	AWS.Signers.Presign = inherit({
	  /**
	   * @api private
	   */
	  sign: function sign(request, expireTime, callback) {
	    request.httpRequest.headers[expiresHeader] = expireTime || 3600;
	    request.on('build', signedUrlBuilder);
	    request.on('sign', signedUrlSigner);
	    request.removeListener('afterBuild',
	      AWS.EventListeners.Core.SET_CONTENT_LENGTH);
	    request.removeListener('afterBuild',
	      AWS.EventListeners.Core.COMPUTE_SHA256);

	    request.emit('beforePresign', [request]);

	    if (callback) {
	      request.build(function() {
	        if (this.response.error) callback(this.response.error);
	        else {
	          callback(null, AWS.util.urlFormat(request.httpRequest.endpoint));
	        }
	      });
	    } else {
	      request.build();
	      if (request.response.error) throw request.response.error;
	      return AWS.util.urlFormat(request.httpRequest.endpoint);
	    }
	  }
	});

	module.exports = AWS.Signers.Presign;


/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(93);

	/**
	 * @api private
	 */
	AWS.ParamValidator = AWS.util.inherit({
	  /**
	   * Create a new validator object.
	   *
	   * @param validation [Boolean|map] whether input parameters should be
	   *     validated against the operation description before sending the
	   *     request. Pass a map to enable any of the following specific
	   *     validation features:
	   *
	   *     * **min** [Boolean] &mdash; Validates that a value meets the min
	   *       constraint. This is enabled by default when paramValidation is set
	   *       to `true`.
	   *     * **max** [Boolean] &mdash; Validates that a value meets the max
	   *       constraint.
	   *     * **pattern** [Boolean] &mdash; Validates that a string value matches a
	   *       regular expression.
	   *     * **enum** [Boolean] &mdash; Validates that a string value matches one
	   *       of the allowable enum values.
	   */
	  constructor: function ParamValidator(validation) {
	    if (validation === true || validation === undefined) {
	      validation = {'min': true};
	    }
	    this.validation = validation;
	  },

	  validate: function validate(shape, params, context) {
	    this.errors = [];
	    this.validateMember(shape, params || {}, context || 'params');

	    if (this.errors.length > 1) {
	      var msg = this.errors.join('\n* ');
	      msg = 'There were ' + this.errors.length +
	        ' validation errors:\n* ' + msg;
	      throw AWS.util.error(new Error(msg),
	        {code: 'MultipleValidationErrors', errors: this.errors});
	    } else if (this.errors.length === 1) {
	      throw this.errors[0];
	    } else {
	      return true;
	    }
	  },

	  fail: function fail(code, message) {
	    this.errors.push(AWS.util.error(new Error(message), {code: code}));
	  },

	  validateStructure: function validateStructure(shape, params, context) {
	    this.validateType(params, context, ['object'], 'structure');

	    var paramName;
	    for (var i = 0; shape.required && i < shape.required.length; i++) {
	      paramName = shape.required[i];
	      var value = params[paramName];
	      if (value === undefined || value === null) {
	        this.fail('MissingRequiredParameter',
	          'Missing required key \'' + paramName + '\' in ' + context);
	      }
	    }

	    // validate hash members
	    for (paramName in params) {
	      if (!Object.prototype.hasOwnProperty.call(params, paramName)) continue;

	      var paramValue = params[paramName],
	          memberShape = shape.members[paramName];

	      if (memberShape !== undefined) {
	        var memberContext = [context, paramName].join('.');
	        this.validateMember(memberShape, paramValue, memberContext);
	      } else {
	        this.fail('UnexpectedParameter',
	          'Unexpected key \'' + paramName + '\' found in ' + context);
	      }
	    }

	    return true;
	  },

	  validateMember: function validateMember(shape, param, context) {
	    switch (shape.type) {
	      case 'structure':
	        return this.validateStructure(shape, param, context);
	      case 'list':
	        return this.validateList(shape, param, context);
	      case 'map':
	        return this.validateMap(shape, param, context);
	      default:
	        return this.validateScalar(shape, param, context);
	    }
	  },

	  validateList: function validateList(shape, params, context) {
	    if (this.validateType(params, context, [Array])) {
	      this.validateRange(shape, params.length, context, 'list member count');
	      // validate array members
	      for (var i = 0; i < params.length; i++) {
	        this.validateMember(shape.member, params[i], context + '[' + i + ']');
	      }
	    }
	  },

	  validateMap: function validateMap(shape, params, context) {
	    if (this.validateType(params, context, ['object'], 'map')) {
	      // Build up a count of map members to validate range traits.
	      var mapCount = 0;
	      for (var param in params) {
	        if (!Object.prototype.hasOwnProperty.call(params, param)) continue;
	        // Validate any map key trait constraints
	        this.validateMember(shape.key, param,
	                            context + '[key=\'' + param + '\']')
	        this.validateMember(shape.value, params[param],
	                            context + '[\'' + param + '\']');
	        mapCount++;
	      }
	      this.validateRange(shape, mapCount, context, 'map member count');
	    }
	  },

	  validateScalar: function validateScalar(shape, value, context) {
	    switch (shape.type) {
	      case null:
	      case undefined:
	      case 'string':
	        return this.validateString(shape, value, context);
	      case 'base64':
	      case 'binary':
	        return this.validatePayload(value, context);
	      case 'integer':
	      case 'float':
	        return this.validateNumber(shape, value, context);
	      case 'boolean':
	        return this.validateType(value, context, ['boolean']);
	      case 'timestamp':
	        return this.validateType(value, context, [Date,
	          /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?Z$/, 'number'],
	          'Date object, ISO-8601 string, or a UNIX timestamp');
	      default:
	        return this.fail('UnkownType', 'Unhandled type ' +
	                         shape.type + ' for ' + context);
	    }
	  },

	  validateString: function validateString(shape, value, context) {
	    if (this.validateType(value, context, ['string'])) {
	      this.validateEnum(shape, value, context);
	      this.validateRange(shape, value.length, context, 'string length');
	      this.validatePattern(shape, value, context);
	    }
	  },

	  validatePattern: function validatePattern(shape, value, context) {
	    if (this.validation['pattern'] && shape['pattern'] !== undefined) {
	      if (!(new RegExp(shape['pattern'])).test(value)) {
	        this.fail('PatternMatchError', 'Provided value "' + value + '" '
	          + 'does not match regex pattern /' + shape['pattern'] + '/ for '
	          + context);
	      }
	    }
	  },

	  validateRange: function validateRange(shape, value, context, descriptor) {
	    if (this.validation['min']) {
	      if (shape['min'] !== undefined && value < shape['min']) {
	        this.fail('MinRangeError', 'Expected ' + descriptor + ' >= '
	          + shape['min'] + ', but found ' + value + ' for ' + context);
	      }
	    }
	    if (this.validation['max']) {
	      if (shape['max'] !== undefined && value > shape['max']) {
	        this.fail('MaxRangeError', 'Expected ' + descriptor + ' <= '
	          + shape['max'] + ', but found ' + value + ' for ' + context);
	      }
	    }
	  },

	  validateEnum: function validateRange(shape, value, context) {
	    if (this.validation['enum'] && shape['enum'] !== undefined) {
	      // Fail if the string value is not present in the enum list
	      if (shape['enum'].indexOf(value) === -1) {
	        this.fail('EnumError', 'Found string value of ' + value + ', but '
	          + 'expected ' + shape['enum'].join('|') + ' for ' + context);
	      }
	    }
	  },

	  validateType: function validateType(value, context, acceptedTypes, type) {
	    // We will not log an error for null or undefined, but we will return
	    // false so that callers know that the expected type was not strictly met.
	    if (value === null || value === undefined) return false;

	    var foundInvalidType = false;
	    for (var i = 0; i < acceptedTypes.length; i++) {
	      if (typeof acceptedTypes[i] === 'string') {
	        if (typeof value === acceptedTypes[i]) return true;
	      } else if (acceptedTypes[i] instanceof RegExp) {
	        if ((value || '').toString().match(acceptedTypes[i])) return true;
	      } else {
	        if (value instanceof acceptedTypes[i]) return true;
	        if (AWS.util.isType(value, acceptedTypes[i])) return true;
	        if (!type && !foundInvalidType) acceptedTypes = acceptedTypes.slice();
	        acceptedTypes[i] = AWS.util.typeName(acceptedTypes[i]);
	      }
	      foundInvalidType = true;
	    }

	    var acceptedType = type;
	    if (!acceptedType) {
	      acceptedType = acceptedTypes.join(', ').replace(/,([^,]+)$/, ', or$1');
	    }

	    var vowel = acceptedType.match(/^[aeiou]/i) ? 'n' : '';
	    this.fail('InvalidParameterType', 'Expected ' + context + ' to be a' +
	              vowel + ' ' + acceptedType);
	    return false;
	  },

	  validateNumber: function validateNumber(shape, value, context) {
	    if (value === null || value === undefined) return;
	    if (typeof value === 'string') {
	      var castedValue = parseFloat(value);
	      if (castedValue.toString() === value) value = castedValue;
	    }
	    if (this.validateType(value, context, ['number'])) {
	      this.validateRange(shape, value, context, 'numeric value');
	    }
	  },

	  validatePayload: function validatePayload(value, context) {
	    if (value === null || value === undefined) return;
	    if (typeof value === 'string') return;
	    if (value && typeof value.byteLength === 'number') return; // typed arrays
	    if (AWS.util.isNode()) { // special check for buffer/stream in Node.js
	      var Stream = AWS.util.stream.Stream;
	      if (AWS.util.Buffer.isBuffer(value) || value instanceof Stream) return;
	    }

	    var types = ['Buffer', 'Stream', 'File', 'Blob', 'ArrayBuffer', 'DataView'];
	    if (value) {
	      for (var i = 0; i < types.length; i++) {
	        if (AWS.util.isType(value, types[i])) return;
	        if (AWS.util.typeName(value.constructor) === types[i]) return;
	      }
	    }

	    this.fail('InvalidParameterType', 'Expected ' + context + ' to be a ' +
	      'string, Buffer, Stream, Blob, or typed array object');
	  }
	});


/***/ },
/* 208 */
/***/ function(module, exports) {

	module.exports = require("fs");

/***/ },
/* 209 */
/***/ function(module, exports) {

	module.exports = {
		"acm": {
			"name": "ACM",
			"cors": true
		},
		"apigateway": {
			"name": "APIGateway",
			"cors": true
		},
		"applicationautoscaling": {
			"prefix": "application-autoscaling",
			"name": "ApplicationAutoScaling",
			"cors": true
		},
		"autoscaling": {
			"name": "AutoScaling",
			"cors": true
		},
		"budgets": {
			"name": "Budgets"
		},
		"cloudformation": {
			"name": "CloudFormation",
			"cors": true
		},
		"cloudfront": {
			"name": "CloudFront",
			"versions": [
				"2013-05-12*",
				"2013-11-11*",
				"2014-05-31*",
				"2014-10-21*",
				"2014-11-06*",
				"2015-04-17*",
				"2015-07-27*",
				"2015-09-17*",
				"2016-01-13*",
				"2016-01-28*",
				"2016-08-01*",
				"2016-08-20*",
				"2016-09-07*"
			],
			"cors": true
		},
		"cloudhsm": {
			"name": "CloudHSM",
			"cors": true
		},
		"cloudsearch": {
			"name": "CloudSearch"
		},
		"cloudsearchdomain": {
			"name": "CloudSearchDomain"
		},
		"cloudtrail": {
			"name": "CloudTrail",
			"cors": true
		},
		"cloudwatch": {
			"prefix": "monitoring",
			"name": "CloudWatch",
			"cors": true
		},
		"cloudwatchevents": {
			"prefix": "events",
			"name": "CloudWatchEvents",
			"versions": [
				"2014-02-03*"
			],
			"cors": true
		},
		"cloudwatchlogs": {
			"prefix": "logs",
			"name": "CloudWatchLogs",
			"cors": true
		},
		"codecommit": {
			"name": "CodeCommit",
			"cors": true
		},
		"codedeploy": {
			"name": "CodeDeploy",
			"cors": true
		},
		"codepipeline": {
			"name": "CodePipeline",
			"cors": true
		},
		"cognitoidentity": {
			"prefix": "cognito-identity",
			"name": "CognitoIdentity",
			"cors": true
		},
		"cognitoidentityserviceprovider": {
			"prefix": "cognito-idp",
			"name": "CognitoIdentityServiceProvider",
			"cors": true
		},
		"cognitosync": {
			"prefix": "cognito-sync",
			"name": "CognitoSync",
			"cors": true
		},
		"configservice": {
			"prefix": "config",
			"name": "ConfigService",
			"cors": true
		},
		"datapipeline": {
			"name": "DataPipeline"
		},
		"devicefarm": {
			"name": "DeviceFarm",
			"cors": true
		},
		"directconnect": {
			"name": "DirectConnect",
			"cors": true
		},
		"directoryservice": {
			"prefix": "ds",
			"name": "DirectoryService"
		},
		"discovery": {
			"name": "Discovery"
		},
		"dms": {
			"name": "DMS"
		},
		"dynamodb": {
			"name": "DynamoDB",
			"cors": true
		},
		"dynamodbstreams": {
			"prefix": "streams.dynamodb",
			"name": "DynamoDBStreams",
			"cors": true
		},
		"ec2": {
			"name": "EC2",
			"versions": [
				"2013-06-15*",
				"2013-10-15*",
				"2014-02-01*",
				"2014-05-01*",
				"2014-06-15*",
				"2014-09-01*",
				"2014-10-01*",
				"2015-03-01*",
				"2015-04-15*",
				"2015-10-01*",
				"2016-04-01*"
			],
			"cors": true
		},
		"ecr": {
			"name": "ECR",
			"cors": true
		},
		"ecs": {
			"name": "ECS",
			"cors": true
		},
		"efs": {
			"prefix": "elasticfilesystem",
			"name": "EFS"
		},
		"elasticache": {
			"name": "ElastiCache",
			"versions": [
				"2012-11-15*",
				"2014-03-24*",
				"2014-07-15*",
				"2014-09-30*"
			],
			"cors": true
		},
		"elasticbeanstalk": {
			"name": "ElasticBeanstalk",
			"cors": true
		},
		"elb": {
			"prefix": "elasticloadbalancing",
			"name": "ELB",
			"cors": true
		},
		"elbv2": {
			"prefix": "elasticloadbalancingv2",
			"name": "ELBv2",
			"cors": true
		},
		"emr": {
			"prefix": "elasticmapreduce",
			"name": "EMR",
			"cors": true
		},
		"es": {
			"name": "ES"
		},
		"elastictranscoder": {
			"name": "ElasticTranscoder",
			"cors": true
		},
		"firehose": {
			"name": "Firehose",
			"cors": true
		},
		"gamelift": {
			"name": "GameLift",
			"cors": true
		},
		"glacier": {
			"name": "Glacier"
		},
		"iam": {
			"name": "IAM"
		},
		"importexport": {
			"name": "ImportExport"
		},
		"inspector": {
			"name": "Inspector",
			"versions": [
				"2015-08-18*"
			],
			"cors": true
		},
		"iot": {
			"name": "Iot",
			"cors": true
		},
		"iotdata": {
			"prefix": "iot-data",
			"name": "IotData",
			"cors": true
		},
		"kinesis": {
			"name": "Kinesis",
			"cors": true
		},
		"kinesisanalytics": {
			"name": "KinesisAnalytics"
		},
		"kms": {
			"name": "KMS",
			"cors": true
		},
		"lambda": {
			"name": "Lambda",
			"cors": true
		},
		"machinelearning": {
			"name": "MachineLearning",
			"cors": true
		},
		"marketplacecommerceanalytics": {
			"name": "MarketplaceCommerceAnalytics",
			"cors": true
		},
		"marketplacemetering": {
			"prefix": "meteringmarketplace",
			"name": "MarketplaceMetering"
		},
		"mobileanalytics": {
			"name": "MobileAnalytics",
			"cors": true
		},
		"opsworks": {
			"name": "OpsWorks",
			"cors": true
		},
		"rds": {
			"name": "RDS",
			"versions": [
				"2014-09-01*"
			],
			"cors": true
		},
		"redshift": {
			"name": "Redshift",
			"cors": true
		},
		"route53": {
			"name": "Route53",
			"cors": true
		},
		"route53domains": {
			"name": "Route53Domains",
			"cors": true
		},
		"s3": {
			"name": "S3",
			"dualstackAvailable": true,
			"cors": true
		},
		"servicecatalog": {
			"name": "ServiceCatalog",
			"cors": true
		},
		"ses": {
			"prefix": "email",
			"name": "SES",
			"cors": true
		},
		"simpledb": {
			"prefix": "sdb",
			"name": "SimpleDB"
		},
		"sms": {
			"name": "SMS"
		},
		"snowball": {
			"name": "Snowball"
		},
		"sns": {
			"name": "SNS",
			"cors": true
		},
		"sqs": {
			"name": "SQS",
			"cors": true
		},
		"ssm": {
			"name": "SSM",
			"cors": true
		},
		"storagegateway": {
			"name": "StorageGateway",
			"cors": true
		},
		"sts": {
			"name": "STS",
			"cors": true
		},
		"support": {
			"name": "Support"
		},
		"swf": {
			"name": "SWF"
		},
		"waf": {
			"name": "WAF",
			"cors": true
		},
		"workspaces": {
			"name": "WorkSpaces"
		}
	};

/***/ },
/* 210 */
/***/ function(module, exports) {

	module.exports = require("buffer");

/***/ },
/* 211 */
/***/ function(module, exports) {

	module.exports = require("domain");

/***/ },
/* 212 */
/***/ function(module, exports) {

	module.exports = require("stream");

/***/ },
/* 213 */
/***/ function(module, exports) {

	module.exports = require("url");

/***/ },
/* 214 */
/***/ function(module, exports) {

	module.exports = require("querystring");

/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	var util = __webpack_require__(92);
	var Shape = __webpack_require__(99);

	var xml2js = __webpack_require__(216);

	/**
	 * @api private
	 */
	var options = {  // options passed to xml2js parser
	  explicitCharkey: false, // undocumented
	  trim: false,            // trim the leading/trailing whitespace from text nodes
	  normalize: false,       // trim interior whitespace inside text nodes
	  explicitRoot: false,    // return the root node in the resulting object?
	  emptyTag: null,         // the default value for empty nodes
	  explicitArray: true,    // always put child nodes in an array
	  ignoreAttrs: false,     // ignore attributes, only create text nodes
	  mergeAttrs: false,      // merge attributes and child elements
	  validator: null         // a callable validator
	};

	function NodeXmlParser() { }

	NodeXmlParser.prototype.parse = function(xml, shape) {
	  shape = shape || {};

	  var result = null;
	  var error = null;

	  var parser = new xml2js.Parser(options);
	  parser.parseString(xml, function (e, r) {
	    error = e;
	    result = r;
	  });

	  if (result) {
	    var data = parseXml(result, shape);
	    if (result.ResponseMetadata) {
	      data.ResponseMetadata = parseXml(result.ResponseMetadata[0], {});
	    }
	    return data;
	  } else if (error) {
	    throw util.error(error, {code: 'XMLParserError', retryable: true});
	  } else { // empty xml document
	    return parseXml({}, shape);
	  }
	};

	function parseXml(xml, shape) {
	  switch (shape.type) {
	    case 'structure': return parseStructure(xml, shape);
	    case 'map': return parseMap(xml, shape);
	    case 'list': return parseList(xml, shape);
	    case undefined: case null: return parseUnknown(xml);
	    default: return parseScalar(xml, shape);
	  }
	}

	function parseStructure(xml, shape) {
	  var data = {};
	  if (xml === null) return data;

	  util.each(shape.members, function(memberName, memberShape) {
	    var xmlName = memberShape.name;
	    if (Object.prototype.hasOwnProperty.call(xml, xmlName) && Array.isArray(xml[xmlName])) {
	      var xmlChild = xml[xmlName];
	      if (!memberShape.flattened) xmlChild = xmlChild[0];

	      data[memberName] = parseXml(xmlChild, memberShape);
	    } else if (memberShape.isXmlAttribute &&
	               xml.$ && Object.prototype.hasOwnProperty.call(xml.$, xmlName)) {
	      data[memberName] = parseScalar(xml.$[xmlName], memberShape);
	    } else if (memberShape.type === 'list') {
	      data[memberName] = memberShape.defaultValue;
	    }
	  });

	  return data;
	}

	function parseMap(xml, shape) {
	  var data = {};
	  if (xml === null) return data;

	  var xmlKey = shape.key.name || 'key';
	  var xmlValue = shape.value.name || 'value';
	  var iterable = shape.flattened ? xml : xml.entry;

	  if (Array.isArray(iterable)) {
	    util.arrayEach(iterable, function(child) {
	      data[child[xmlKey][0]] = parseXml(child[xmlValue][0], shape.value);
	    });
	  }

	  return data;
	}

	function parseList(xml, shape) {
	  var data = [];
	  var name = shape.member.name || 'member';
	  if (shape.flattened) {
	    util.arrayEach(xml, function(xmlChild) {
	      data.push(parseXml(xmlChild, shape.member));
	    });
	  } else if (xml && Array.isArray(xml[name])) {
	    util.arrayEach(xml[name], function(child) {
	      data.push(parseXml(child, shape.member));
	    });
	  }

	  return data;
	}

	function parseScalar(text, shape) {
	  if (text && text.$ && text.$.encoding === 'base64') {
	    shape = new Shape.create({type: text.$.encoding});
	  }
	  if (text && text._) text = text._;

	  if (typeof shape.toType === 'function') {
	    return shape.toType(text);
	  } else {
	    return text;
	  }
	}

	function parseUnknown(xml) {
	  if (xml === undefined || xml === null) return '';
	  if (typeof xml === 'string') return xml;

	  // parse a list
	  if (Array.isArray(xml)) {
	    var arr = [];
	    for (i = 0; i < xml.length; i++) {
	      arr.push(parseXml(xml[i], {}));
	    }
	    return arr;
	  }

	  // empty object
	  var keys = Object.keys(xml), i;
	  if (keys.length === 0 || keys === ['$']) {
	    return {};
	  }

	  // object, parse as structure
	  var data = {};
	  for (i = 0; i < keys.length; i++) {
	    var key = keys[i], value = xml[key];
	    if (key === '$') continue;
	    if (value.length > 1) { // this member is a list
	      data[key] = parseList(value, {member: {}});
	    } else { // this member is a single item
	      data[key] = parseXml(value[0], {});
	    }
	  }
	  return data;
	}

	module.exports = NodeXmlParser;


/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.10.0
	(function() {
	  "use strict";
	  var bom, builder, escapeCDATA, events, isEmpty, processName, processors, requiresCDATA, sax, setImmediate, wrapCDATA,
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty,
	    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

	  sax = __webpack_require__(217);

	  events = __webpack_require__(219);

	  builder = __webpack_require__(105);

	  bom = __webpack_require__(220);

	  processors = __webpack_require__(221);

	  setImmediate = __webpack_require__(222).setImmediate;

	  isEmpty = function(thing) {
	    return typeof thing === "object" && (thing != null) && Object.keys(thing).length === 0;
	  };

	  processName = function(processors, processedName) {
	    var i, len, process;
	    for (i = 0, len = processors.length; i < len; i++) {
	      process = processors[i];
	      processedName = process(processedName);
	    }
	    return processedName;
	  };

	  requiresCDATA = function(entry) {
	    return entry.indexOf('&') >= 0 || entry.indexOf('>') >= 0 || entry.indexOf('<') >= 0;
	  };

	  wrapCDATA = function(entry) {
	    return "<![CDATA[" + (escapeCDATA(entry)) + "]]>";
	  };

	  escapeCDATA = function(entry) {
	    return entry.replace(']]>', ']]]]><![CDATA[>');
	  };

	  exports.processors = processors;

	  exports.defaults = {
	    "0.1": {
	      explicitCharkey: false,
	      trim: true,
	      normalize: true,
	      normalizeTags: false,
	      attrkey: "@",
	      charkey: "#",
	      explicitArray: false,
	      ignoreAttrs: false,
	      mergeAttrs: false,
	      explicitRoot: false,
	      validator: null,
	      xmlns: false,
	      explicitChildren: false,
	      childkey: '@@',
	      charsAsChildren: false,
	      async: false,
	      strict: true,
	      attrNameProcessors: null,
	      attrValueProcessors: null,
	      tagNameProcessors: null,
	      valueProcessors: null,
	      emptyTag: ''
	    },
	    "0.2": {
	      explicitCharkey: false,
	      trim: false,
	      normalize: false,
	      normalizeTags: false,
	      attrkey: "$",
	      charkey: "_",
	      explicitArray: true,
	      ignoreAttrs: false,
	      mergeAttrs: false,
	      explicitRoot: true,
	      validator: null,
	      xmlns: false,
	      explicitChildren: false,
	      preserveChildrenOrder: false,
	      childkey: '$$',
	      charsAsChildren: false,
	      async: false,
	      strict: true,
	      attrNameProcessors: null,
	      attrValueProcessors: null,
	      tagNameProcessors: null,
	      valueProcessors: null,
	      rootName: 'root',
	      xmldec: {
	        'version': '1.0',
	        'encoding': 'UTF-8',
	        'standalone': true
	      },
	      doctype: null,
	      renderOpts: {
	        'pretty': true,
	        'indent': '  ',
	        'newline': '\n'
	      },
	      headless: false,
	      chunkSize: 10000,
	      emptyTag: '',
	      cdata: false
	    }
	  };

	  exports.ValidationError = (function(superClass) {
	    extend(ValidationError, superClass);

	    function ValidationError(message) {
	      this.message = message;
	    }

	    return ValidationError;

	  })(Error);

	  exports.Builder = (function() {
	    function Builder(opts) {
	      var key, ref, value;
	      this.options = {};
	      ref = exports.defaults["0.2"];
	      for (key in ref) {
	        if (!hasProp.call(ref, key)) continue;
	        value = ref[key];
	        this.options[key] = value;
	      }
	      for (key in opts) {
	        if (!hasProp.call(opts, key)) continue;
	        value = opts[key];
	        this.options[key] = value;
	      }
	    }

	    Builder.prototype.buildObject = function(rootObj) {
	      var attrkey, charkey, render, rootElement, rootName;
	      attrkey = this.options.attrkey;
	      charkey = this.options.charkey;
	      if ((Object.keys(rootObj).length === 1) && (this.options.rootName === exports.defaults['0.2'].rootName)) {
	        rootName = Object.keys(rootObj)[0];
	        rootObj = rootObj[rootName];
	      } else {
	        rootName = this.options.rootName;
	      }
	      render = (function(_this) {
	        return function(element, obj) {
	          var attr, child, entry, index, key, value;
	          if (typeof obj !== 'object') {
	            if (_this.options.cdata && requiresCDATA(obj)) {
	              element.raw(wrapCDATA(obj));
	            } else {
	              element.txt(obj);
	            }
	          } else {
	            for (key in obj) {
	              if (!hasProp.call(obj, key)) continue;
	              child = obj[key];
	              if (key === attrkey) {
	                if (typeof child === "object") {
	                  for (attr in child) {
	                    value = child[attr];
	                    element = element.att(attr, value);
	                  }
	                }
	              } else if (key === charkey) {
	                if (_this.options.cdata && requiresCDATA(child)) {
	                  element = element.raw(wrapCDATA(child));
	                } else {
	                  element = element.txt(child);
	                }
	              } else if (Array.isArray(child)) {
	                for (index in child) {
	                  if (!hasProp.call(child, index)) continue;
	                  entry = child[index];
	                  if (typeof entry === 'string') {
	                    if (_this.options.cdata && requiresCDATA(entry)) {
	                      element = element.ele(key).raw(wrapCDATA(entry)).up();
	                    } else {
	                      element = element.ele(key, entry).up();
	                    }
	                  } else {
	                    element = render(element.ele(key), entry).up();
	                  }
	                }
	              } else if (typeof child === "object") {
	                element = render(element.ele(key), child).up();
	              } else {
	                if (typeof child === 'string' && _this.options.cdata && requiresCDATA(child)) {
	                  element = element.ele(key).raw(wrapCDATA(child)).up();
	                } else {
	                  if (child == null) {
	                    child = '';
	                  }
	                  element = element.ele(key, child.toString()).up();
	                }
	              }
	            }
	          }
	          return element;
	        };
	      })(this);
	      rootElement = builder.create(rootName, this.options.xmldec, this.options.doctype, {
	        headless: this.options.headless
	      });
	      return render(rootElement, rootObj).end(this.options.renderOpts);
	    };

	    return Builder;

	  })();

	  exports.Parser = (function(superClass) {
	    extend(Parser, superClass);

	    function Parser(opts) {
	      this.parseString = bind(this.parseString, this);
	      this.reset = bind(this.reset, this);
	      this.assignOrPush = bind(this.assignOrPush, this);
	      this.processAsync = bind(this.processAsync, this);
	      var key, ref, value;
	      if (!(this instanceof exports.Parser)) {
	        return new exports.Parser(opts);
	      }
	      this.options = {};
	      ref = exports.defaults["0.2"];
	      for (key in ref) {
	        if (!hasProp.call(ref, key)) continue;
	        value = ref[key];
	        this.options[key] = value;
	      }
	      for (key in opts) {
	        if (!hasProp.call(opts, key)) continue;
	        value = opts[key];
	        this.options[key] = value;
	      }
	      if (this.options.xmlns) {
	        this.options.xmlnskey = this.options.attrkey + "ns";
	      }
	      if (this.options.normalizeTags) {
	        if (!this.options.tagNameProcessors) {
	          this.options.tagNameProcessors = [];
	        }
	        this.options.tagNameProcessors.unshift(processors.normalize);
	      }
	      this.reset();
	    }

	    Parser.prototype.processAsync = function() {
	      var chunk, err, error1;
	      try {
	        if (this.remaining.length <= this.options.chunkSize) {
	          chunk = this.remaining;
	          this.remaining = '';
	          this.saxParser = this.saxParser.write(chunk);
	          return this.saxParser.close();
	        } else {
	          chunk = this.remaining.substr(0, this.options.chunkSize);
	          this.remaining = this.remaining.substr(this.options.chunkSize, this.remaining.length);
	          this.saxParser = this.saxParser.write(chunk);
	          return setImmediate(this.processAsync);
	        }
	      } catch (error1) {
	        err = error1;
	        if (!this.saxParser.errThrown) {
	          this.saxParser.errThrown = true;
	          return this.emit(err);
	        }
	      }
	    };

	    Parser.prototype.assignOrPush = function(obj, key, newValue) {
	      if (!(key in obj)) {
	        if (!this.options.explicitArray) {
	          return obj[key] = newValue;
	        } else {
	          return obj[key] = [newValue];
	        }
	      } else {
	        if (!(obj[key] instanceof Array)) {
	          obj[key] = [obj[key]];
	        }
	        return obj[key].push(newValue);
	      }
	    };

	    Parser.prototype.reset = function() {
	      var attrkey, charkey, ontext, stack;
	      this.removeAllListeners();
	      this.saxParser = sax.parser(this.options.strict, {
	        trim: false,
	        normalize: false,
	        xmlns: this.options.xmlns
	      });
	      this.saxParser.errThrown = false;
	      this.saxParser.onerror = (function(_this) {
	        return function(error) {
	          _this.saxParser.resume();
	          if (!_this.saxParser.errThrown) {
	            _this.saxParser.errThrown = true;
	            return _this.emit("error", error);
	          }
	        };
	      })(this);
	      this.saxParser.onend = (function(_this) {
	        return function() {
	          if (!_this.saxParser.ended) {
	            _this.saxParser.ended = true;
	            return _this.emit("end", _this.resultObject);
	          }
	        };
	      })(this);
	      this.saxParser.ended = false;
	      this.EXPLICIT_CHARKEY = this.options.explicitCharkey;
	      this.resultObject = null;
	      stack = [];
	      attrkey = this.options.attrkey;
	      charkey = this.options.charkey;
	      this.saxParser.onopentag = (function(_this) {
	        return function(node) {
	          var key, newValue, obj, processedKey, ref;
	          obj = {};
	          obj[charkey] = "";
	          if (!_this.options.ignoreAttrs) {
	            ref = node.attributes;
	            for (key in ref) {
	              if (!hasProp.call(ref, key)) continue;
	              if (!(attrkey in obj) && !_this.options.mergeAttrs) {
	                obj[attrkey] = {};
	              }
	              newValue = _this.options.attrValueProcessors ? processName(_this.options.attrValueProcessors, node.attributes[key]) : node.attributes[key];
	              processedKey = _this.options.attrNameProcessors ? processName(_this.options.attrNameProcessors, key) : key;
	              if (_this.options.mergeAttrs) {
	                _this.assignOrPush(obj, processedKey, newValue);
	              } else {
	                obj[attrkey][processedKey] = newValue;
	              }
	            }
	          }
	          obj["#name"] = _this.options.tagNameProcessors ? processName(_this.options.tagNameProcessors, node.name) : node.name;
	          if (_this.options.xmlns) {
	            obj[_this.options.xmlnskey] = {
	              uri: node.uri,
	              local: node.local
	            };
	          }
	          return stack.push(obj);
	        };
	      })(this);
	      this.saxParser.onclosetag = (function(_this) {
	        return function() {
	          var cdata, emptyStr, err, error1, key, node, nodeName, obj, objClone, old, s, xpath;
	          obj = stack.pop();
	          nodeName = obj["#name"];
	          if (!_this.options.explicitChildren || !_this.options.preserveChildrenOrder) {
	            delete obj["#name"];
	          }
	          if (obj.cdata === true) {
	            cdata = obj.cdata;
	            delete obj.cdata;
	          }
	          s = stack[stack.length - 1];
	          if (obj[charkey].match(/^\s*$/) && !cdata) {
	            emptyStr = obj[charkey];
	            delete obj[charkey];
	          } else {
	            if (_this.options.trim) {
	              obj[charkey] = obj[charkey].trim();
	            }
	            if (_this.options.normalize) {
	              obj[charkey] = obj[charkey].replace(/\s{2,}/g, " ").trim();
	            }
	            obj[charkey] = _this.options.valueProcessors ? processName(_this.options.valueProcessors, obj[charkey]) : obj[charkey];
	            if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
	              obj = obj[charkey];
	            }
	          }
	          if (isEmpty(obj)) {
	            obj = _this.options.emptyTag !== '' ? _this.options.emptyTag : emptyStr;
	          }
	          if (_this.options.validator != null) {
	            xpath = "/" + ((function() {
	              var i, len, results;
	              results = [];
	              for (i = 0, len = stack.length; i < len; i++) {
	                node = stack[i];
	                results.push(node["#name"]);
	              }
	              return results;
	            })()).concat(nodeName).join("/");
	            try {
	              obj = _this.options.validator(xpath, s && s[nodeName], obj);
	            } catch (error1) {
	              err = error1;
	              _this.emit("error", err);
	            }
	          }
	          if (_this.options.explicitChildren && !_this.options.mergeAttrs && typeof obj === 'object') {
	            if (!_this.options.preserveChildrenOrder) {
	              node = {};
	              if (_this.options.attrkey in obj) {
	                node[_this.options.attrkey] = obj[_this.options.attrkey];
	                delete obj[_this.options.attrkey];
	              }
	              if (!_this.options.charsAsChildren && _this.options.charkey in obj) {
	                node[_this.options.charkey] = obj[_this.options.charkey];
	                delete obj[_this.options.charkey];
	              }
	              if (Object.getOwnPropertyNames(obj).length > 0) {
	                node[_this.options.childkey] = obj;
	              }
	              obj = node;
	            } else if (s) {
	              s[_this.options.childkey] = s[_this.options.childkey] || [];
	              objClone = {};
	              for (key in obj) {
	                if (!hasProp.call(obj, key)) continue;
	                objClone[key] = obj[key];
	              }
	              s[_this.options.childkey].push(objClone);
	              delete obj["#name"];
	              if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
	                obj = obj[charkey];
	              }
	            }
	          }
	          if (stack.length > 0) {
	            return _this.assignOrPush(s, nodeName, obj);
	          } else {
	            if (_this.options.explicitRoot) {
	              old = obj;
	              obj = {};
	              obj[nodeName] = old;
	            }
	            _this.resultObject = obj;
	            _this.saxParser.ended = true;
	            return _this.emit("end", _this.resultObject);
	          }
	        };
	      })(this);
	      ontext = (function(_this) {
	        return function(text) {
	          var charChild, s;
	          s = stack[stack.length - 1];
	          if (s) {
	            s[charkey] += text;
	            if (_this.options.explicitChildren && _this.options.preserveChildrenOrder && _this.options.charsAsChildren && text.replace(/\\n/g, '').trim() !== '') {
	              s[_this.options.childkey] = s[_this.options.childkey] || [];
	              charChild = {
	                '#name': '__text__'
	              };
	              charChild[charkey] = text;
	              s[_this.options.childkey].push(charChild);
	            }
	            return s;
	          }
	        };
	      })(this);
	      this.saxParser.ontext = ontext;
	      return this.saxParser.oncdata = (function(_this) {
	        return function(text) {
	          var s;
	          s = ontext(text);
	          if (s) {
	            return s.cdata = true;
	          }
	        };
	      })(this);
	    };

	    Parser.prototype.parseString = function(str, cb) {
	      var err, error1;
	      if ((cb != null) && typeof cb === "function") {
	        this.on("end", function(result) {
	          this.reset();
	          return cb(null, result);
	        });
	        this.on("error", function(err) {
	          this.reset();
	          return cb(err);
	        });
	      }
	      try {
	        str = str.toString();
	        if (str.trim() === '') {
	          this.emit("end", null);
	          return true;
	        }
	        str = bom.stripBOM(str);
	        if (this.options.async) {
	          this.remaining = str;
	          setImmediate(this.processAsync);
	          return this.saxParser;
	        }
	        return this.saxParser.write(str).close();
	      } catch (error1) {
	        err = error1;
	        if (!(this.saxParser.errThrown || this.saxParser.ended)) {
	          this.emit('error', err);
	          return this.saxParser.errThrown = true;
	        } else if (this.saxParser.ended) {
	          throw err;
	        }
	      }
	    };

	    return Parser;

	  })(events.EventEmitter);

	  exports.parseString = function(str, a, b) {
	    var cb, options, parser;
	    if (b != null) {
	      if (typeof b === 'function') {
	        cb = b;
	      }
	      if (typeof a === 'object') {
	        options = a;
	      }
	    } else {
	      if (typeof a === 'function') {
	        cb = a;
	      }
	      options = {};
	    }
	    parser = new exports.Parser(options);
	    return parser.parseString(str, cb);
	  };

	}).call(this);


/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	;(function (sax) { // wrapper for non-node envs
	  sax.parser = function (strict, opt) { return new SAXParser(strict, opt) }
	  sax.SAXParser = SAXParser
	  sax.SAXStream = SAXStream
	  sax.createStream = createStream

	  // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.
	  // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),
	  // since that's the earliest that a buffer overrun could occur.  This way, checks are
	  // as rare as required, but as often as necessary to ensure never crossing this bound.
	  // Furthermore, buffers are only tested at most once per write(), so passing a very
	  // large string into write() might have undesirable effects, but this is manageable by
	  // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme
	  // edge case, result in creating at most one complete copy of the string passed in.
	  // Set to Infinity to have unlimited buffers.
	  sax.MAX_BUFFER_LENGTH = 64 * 1024

	  var buffers = [
	    'comment', 'sgmlDecl', 'textNode', 'tagName', 'doctype',
	    'procInstName', 'procInstBody', 'entity', 'attribName',
	    'attribValue', 'cdata', 'script'
	  ]

	  sax.EVENTS = [
	    'text',
	    'processinginstruction',
	    'sgmldeclaration',
	    'doctype',
	    'comment',
	    'attribute',
	    'opentag',
	    'closetag',
	    'opencdata',
	    'cdata',
	    'closecdata',
	    'error',
	    'end',
	    'ready',
	    'script',
	    'opennamespace',
	    'closenamespace'
	  ]

	  function SAXParser (strict, opt) {
	    if (!(this instanceof SAXParser)) {
	      return new SAXParser(strict, opt)
	    }

	    var parser = this
	    clearBuffers(parser)
	    parser.q = parser.c = ''
	    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH
	    parser.opt = opt || {}
	    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags
	    parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase'
	    parser.tags = []
	    parser.closed = parser.closedRoot = parser.sawRoot = false
	    parser.tag = parser.error = null
	    parser.strict = !!strict
	    parser.noscript = !!(strict || parser.opt.noscript)
	    parser.state = S.BEGIN
	    parser.strictEntities = parser.opt.strictEntities
	    parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES)
	    parser.attribList = []

	    // namespaces form a prototype chain.
	    // it always points at the current tag,
	    // which protos to its parent tag.
	    if (parser.opt.xmlns) {
	      parser.ns = Object.create(rootNS)
	    }

	    // mostly just for error reporting
	    parser.trackPosition = parser.opt.position !== false
	    if (parser.trackPosition) {
	      parser.position = parser.line = parser.column = 0
	    }
	    emit(parser, 'onready')
	  }

	  if (!Object.create) {
	    Object.create = function (o) {
	      function F () {}
	      F.prototype = o
	      var newf = new F()
	      return newf
	    }
	  }

	  if (!Object.keys) {
	    Object.keys = function (o) {
	      var a = []
	      for (var i in o) if (o.hasOwnProperty(i)) a.push(i)
	      return a
	    }
	  }

	  function checkBufferLength (parser) {
	    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10)
	    var maxActual = 0
	    for (var i = 0, l = buffers.length; i < l; i++) {
	      var len = parser[buffers[i]].length
	      if (len > maxAllowed) {
	        // Text/cdata nodes can get big, and since they're buffered,
	        // we can get here under normal conditions.
	        // Avoid issues by emitting the text node now,
	        // so at least it won't get any bigger.
	        switch (buffers[i]) {
	          case 'textNode':
	            closeText(parser)
	            break

	          case 'cdata':
	            emitNode(parser, 'oncdata', parser.cdata)
	            parser.cdata = ''
	            break

	          case 'script':
	            emitNode(parser, 'onscript', parser.script)
	            parser.script = ''
	            break

	          default:
	            error(parser, 'Max buffer length exceeded: ' + buffers[i])
	        }
	      }
	      maxActual = Math.max(maxActual, len)
	    }
	    // schedule the next check for the earliest possible buffer overrun.
	    var m = sax.MAX_BUFFER_LENGTH - maxActual
	    parser.bufferCheckPosition = m + parser.position
	  }

	  function clearBuffers (parser) {
	    for (var i = 0, l = buffers.length; i < l; i++) {
	      parser[buffers[i]] = ''
	    }
	  }

	  function flushBuffers (parser) {
	    closeText(parser)
	    if (parser.cdata !== '') {
	      emitNode(parser, 'oncdata', parser.cdata)
	      parser.cdata = ''
	    }
	    if (parser.script !== '') {
	      emitNode(parser, 'onscript', parser.script)
	      parser.script = ''
	    }
	  }

	  SAXParser.prototype = {
	    end: function () { end(this) },
	    write: write,
	    resume: function () { this.error = null; return this },
	    close: function () { return this.write(null) },
	    flush: function () { flushBuffers(this) }
	  }

	  var Stream
	  try {
	    Stream = __webpack_require__(212).Stream
	  } catch (ex) {
	    Stream = function () {}
	  }

	  var streamWraps = sax.EVENTS.filter(function (ev) {
	    return ev !== 'error' && ev !== 'end'
	  })

	  function createStream (strict, opt) {
	    return new SAXStream(strict, opt)
	  }

	  function SAXStream (strict, opt) {
	    if (!(this instanceof SAXStream)) {
	      return new SAXStream(strict, opt)
	    }

	    Stream.apply(this)

	    this._parser = new SAXParser(strict, opt)
	    this.writable = true
	    this.readable = true

	    var me = this

	    this._parser.onend = function () {
	      me.emit('end')
	    }

	    this._parser.onerror = function (er) {
	      me.emit('error', er)

	      // if didn't throw, then means error was handled.
	      // go ahead and clear error, so we can write again.
	      me._parser.error = null
	    }

	    this._decoder = null

	    streamWraps.forEach(function (ev) {
	      Object.defineProperty(me, 'on' + ev, {
	        get: function () {
	          return me._parser['on' + ev]
	        },
	        set: function (h) {
	          if (!h) {
	            me.removeAllListeners(ev)
	            me._parser['on' + ev] = h
	            return h
	          }
	          me.on(ev, h)
	        },
	        enumerable: true,
	        configurable: false
	      })
	    })
	  }

	  SAXStream.prototype = Object.create(Stream.prototype, {
	    constructor: {
	      value: SAXStream
	    }
	  })

	  SAXStream.prototype.write = function (data) {
	    if (typeof Buffer === 'function' &&
	      typeof Buffer.isBuffer === 'function' &&
	      Buffer.isBuffer(data)) {
	      if (!this._decoder) {
	        var SD = __webpack_require__(218).StringDecoder
	        this._decoder = new SD('utf8')
	      }
	      data = this._decoder.write(data)
	    }

	    this._parser.write(data.toString())
	    this.emit('data', data)
	    return true
	  }

	  SAXStream.prototype.end = function (chunk) {
	    if (chunk && chunk.length) {
	      this.write(chunk)
	    }
	    this._parser.end()
	    return true
	  }

	  SAXStream.prototype.on = function (ev, handler) {
	    var me = this
	    if (!me._parser['on' + ev] && streamWraps.indexOf(ev) !== -1) {
	      me._parser['on' + ev] = function () {
	        var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments)
	        args.splice(0, 0, ev)
	        me.emit.apply(me, args)
	      }
	    }

	    return Stream.prototype.on.call(me, ev, handler)
	  }

	  // character classes and tokens
	  var whitespace = '\r\n\t '

	  // this really needs to be replaced with character classes.
	  // XML allows all manner of ridiculous numbers and digits.
	  var number = '0124356789'
	  var letter = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'

	  // (Letter | "_" | ":")
	  var quote = '\'"'
	  var attribEnd = whitespace + '>'
	  var CDATA = '[CDATA['
	  var DOCTYPE = 'DOCTYPE'
	  var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace'
	  var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/'
	  var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE }

	  // turn all the string character sets into character class objects.
	  whitespace = charClass(whitespace)
	  number = charClass(number)
	  letter = charClass(letter)

	  // http://www.w3.org/TR/REC-xml/#NT-NameStartChar
	  // This implementation works on strings, a single character at a time
	  // as such, it cannot ever support astral-plane characters (10000-EFFFF)
	  // without a significant breaking change to either this  parser, or the
	  // JavaScript language.  Implementation of an emoji-capable xml parser
	  // is left as an exercise for the reader.
	  var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/

	  var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040\.\d-]/

	  var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/
	  var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040\.\d-]/

	  quote = charClass(quote)
	  attribEnd = charClass(attribEnd)

	  function charClass (str) {
	    return str.split('').reduce(function (s, c) {
	      s[c] = true
	      return s
	    }, {})
	  }

	  function isRegExp (c) {
	    return Object.prototype.toString.call(c) === '[object RegExp]'
	  }

	  function is (charclass, c) {
	    return isRegExp(charclass) ? !!c.match(charclass) : charclass[c]
	  }

	  function not (charclass, c) {
	    return !is(charclass, c)
	  }

	  var S = 0
	  sax.STATE = {
	    BEGIN: S++, // leading byte order mark or whitespace
	    BEGIN_WHITESPACE: S++, // leading whitespace
	    TEXT: S++, // general stuff
	    TEXT_ENTITY: S++, // &amp and such.
	    OPEN_WAKA: S++, // <
	    SGML_DECL: S++, // <!BLARG
	    SGML_DECL_QUOTED: S++, // <!BLARG foo "bar
	    DOCTYPE: S++, // <!DOCTYPE
	    DOCTYPE_QUOTED: S++, // <!DOCTYPE "//blah
	    DOCTYPE_DTD: S++, // <!DOCTYPE "//blah" [ ...
	    DOCTYPE_DTD_QUOTED: S++, // <!DOCTYPE "//blah" [ "foo
	    COMMENT_STARTING: S++, // <!-
	    COMMENT: S++, // <!--
	    COMMENT_ENDING: S++, // <!-- blah -
	    COMMENT_ENDED: S++, // <!-- blah --
	    CDATA: S++, // <![CDATA[ something
	    CDATA_ENDING: S++, // ]
	    CDATA_ENDING_2: S++, // ]]
	    PROC_INST: S++, // <?hi
	    PROC_INST_BODY: S++, // <?hi there
	    PROC_INST_ENDING: S++, // <?hi "there" ?
	    OPEN_TAG: S++, // <strong
	    OPEN_TAG_SLASH: S++, // <strong /
	    ATTRIB: S++, // <a
	    ATTRIB_NAME: S++, // <a foo
	    ATTRIB_NAME_SAW_WHITE: S++, // <a foo _
	    ATTRIB_VALUE: S++, // <a foo=
	    ATTRIB_VALUE_QUOTED: S++, // <a foo="bar
	    ATTRIB_VALUE_CLOSED: S++, // <a foo="bar"
	    ATTRIB_VALUE_UNQUOTED: S++, // <a foo=bar
	    ATTRIB_VALUE_ENTITY_Q: S++, // <foo bar="&quot;"
	    ATTRIB_VALUE_ENTITY_U: S++, // <foo bar=&quot
	    CLOSE_TAG: S++, // </a
	    CLOSE_TAG_SAW_WHITE: S++, // </a   >
	    SCRIPT: S++, // <script> ...
	    SCRIPT_ENDING: S++ // <script> ... <
	  }

	  sax.XML_ENTITIES = {
	    'amp': '&',
	    'gt': '>',
	    'lt': '<',
	    'quot': '"',
	    'apos': "'"
	  }

	  sax.ENTITIES = {
	    'amp': '&',
	    'gt': '>',
	    'lt': '<',
	    'quot': '"',
	    'apos': "'",
	    'AElig': 198,
	    'Aacute': 193,
	    'Acirc': 194,
	    'Agrave': 192,
	    'Aring': 197,
	    'Atilde': 195,
	    'Auml': 196,
	    'Ccedil': 199,
	    'ETH': 208,
	    'Eacute': 201,
	    'Ecirc': 202,
	    'Egrave': 200,
	    'Euml': 203,
	    'Iacute': 205,
	    'Icirc': 206,
	    'Igrave': 204,
	    'Iuml': 207,
	    'Ntilde': 209,
	    'Oacute': 211,
	    'Ocirc': 212,
	    'Ograve': 210,
	    'Oslash': 216,
	    'Otilde': 213,
	    'Ouml': 214,
	    'THORN': 222,
	    'Uacute': 218,
	    'Ucirc': 219,
	    'Ugrave': 217,
	    'Uuml': 220,
	    'Yacute': 221,
	    'aacute': 225,
	    'acirc': 226,
	    'aelig': 230,
	    'agrave': 224,
	    'aring': 229,
	    'atilde': 227,
	    'auml': 228,
	    'ccedil': 231,
	    'eacute': 233,
	    'ecirc': 234,
	    'egrave': 232,
	    'eth': 240,
	    'euml': 235,
	    'iacute': 237,
	    'icirc': 238,
	    'igrave': 236,
	    'iuml': 239,
	    'ntilde': 241,
	    'oacute': 243,
	    'ocirc': 244,
	    'ograve': 242,
	    'oslash': 248,
	    'otilde': 245,
	    'ouml': 246,
	    'szlig': 223,
	    'thorn': 254,
	    'uacute': 250,
	    'ucirc': 251,
	    'ugrave': 249,
	    'uuml': 252,
	    'yacute': 253,
	    'yuml': 255,
	    'copy': 169,
	    'reg': 174,
	    'nbsp': 160,
	    'iexcl': 161,
	    'cent': 162,
	    'pound': 163,
	    'curren': 164,
	    'yen': 165,
	    'brvbar': 166,
	    'sect': 167,
	    'uml': 168,
	    'ordf': 170,
	    'laquo': 171,
	    'not': 172,
	    'shy': 173,
	    'macr': 175,
	    'deg': 176,
	    'plusmn': 177,
	    'sup1': 185,
	    'sup2': 178,
	    'sup3': 179,
	    'acute': 180,
	    'micro': 181,
	    'para': 182,
	    'middot': 183,
	    'cedil': 184,
	    'ordm': 186,
	    'raquo': 187,
	    'frac14': 188,
	    'frac12': 189,
	    'frac34': 190,
	    'iquest': 191,
	    'times': 215,
	    'divide': 247,
	    'OElig': 338,
	    'oelig': 339,
	    'Scaron': 352,
	    'scaron': 353,
	    'Yuml': 376,
	    'fnof': 402,
	    'circ': 710,
	    'tilde': 732,
	    'Alpha': 913,
	    'Beta': 914,
	    'Gamma': 915,
	    'Delta': 916,
	    'Epsilon': 917,
	    'Zeta': 918,
	    'Eta': 919,
	    'Theta': 920,
	    'Iota': 921,
	    'Kappa': 922,
	    'Lambda': 923,
	    'Mu': 924,
	    'Nu': 925,
	    'Xi': 926,
	    'Omicron': 927,
	    'Pi': 928,
	    'Rho': 929,
	    'Sigma': 931,
	    'Tau': 932,
	    'Upsilon': 933,
	    'Phi': 934,
	    'Chi': 935,
	    'Psi': 936,
	    'Omega': 937,
	    'alpha': 945,
	    'beta': 946,
	    'gamma': 947,
	    'delta': 948,
	    'epsilon': 949,
	    'zeta': 950,
	    'eta': 951,
	    'theta': 952,
	    'iota': 953,
	    'kappa': 954,
	    'lambda': 955,
	    'mu': 956,
	    'nu': 957,
	    'xi': 958,
	    'omicron': 959,
	    'pi': 960,
	    'rho': 961,
	    'sigmaf': 962,
	    'sigma': 963,
	    'tau': 964,
	    'upsilon': 965,
	    'phi': 966,
	    'chi': 967,
	    'psi': 968,
	    'omega': 969,
	    'thetasym': 977,
	    'upsih': 978,
	    'piv': 982,
	    'ensp': 8194,
	    'emsp': 8195,
	    'thinsp': 8201,
	    'zwnj': 8204,
	    'zwj': 8205,
	    'lrm': 8206,
	    'rlm': 8207,
	    'ndash': 8211,
	    'mdash': 8212,
	    'lsquo': 8216,
	    'rsquo': 8217,
	    'sbquo': 8218,
	    'ldquo': 8220,
	    'rdquo': 8221,
	    'bdquo': 8222,
	    'dagger': 8224,
	    'Dagger': 8225,
	    'bull': 8226,
	    'hellip': 8230,
	    'permil': 8240,
	    'prime': 8242,
	    'Prime': 8243,
	    'lsaquo': 8249,
	    'rsaquo': 8250,
	    'oline': 8254,
	    'frasl': 8260,
	    'euro': 8364,
	    'image': 8465,
	    'weierp': 8472,
	    'real': 8476,
	    'trade': 8482,
	    'alefsym': 8501,
	    'larr': 8592,
	    'uarr': 8593,
	    'rarr': 8594,
	    'darr': 8595,
	    'harr': 8596,
	    'crarr': 8629,
	    'lArr': 8656,
	    'uArr': 8657,
	    'rArr': 8658,
	    'dArr': 8659,
	    'hArr': 8660,
	    'forall': 8704,
	    'part': 8706,
	    'exist': 8707,
	    'empty': 8709,
	    'nabla': 8711,
	    'isin': 8712,
	    'notin': 8713,
	    'ni': 8715,
	    'prod': 8719,
	    'sum': 8721,
	    'minus': 8722,
	    'lowast': 8727,
	    'radic': 8730,
	    'prop': 8733,
	    'infin': 8734,
	    'ang': 8736,
	    'and': 8743,
	    'or': 8744,
	    'cap': 8745,
	    'cup': 8746,
	    'int': 8747,
	    'there4': 8756,
	    'sim': 8764,
	    'cong': 8773,
	    'asymp': 8776,
	    'ne': 8800,
	    'equiv': 8801,
	    'le': 8804,
	    'ge': 8805,
	    'sub': 8834,
	    'sup': 8835,
	    'nsub': 8836,
	    'sube': 8838,
	    'supe': 8839,
	    'oplus': 8853,
	    'otimes': 8855,
	    'perp': 8869,
	    'sdot': 8901,
	    'lceil': 8968,
	    'rceil': 8969,
	    'lfloor': 8970,
	    'rfloor': 8971,
	    'lang': 9001,
	    'rang': 9002,
	    'loz': 9674,
	    'spades': 9824,
	    'clubs': 9827,
	    'hearts': 9829,
	    'diams': 9830
	  }

	  Object.keys(sax.ENTITIES).forEach(function (key) {
	    var e = sax.ENTITIES[key]
	    var s = typeof e === 'number' ? String.fromCharCode(e) : e
	    sax.ENTITIES[key] = s
	  })

	  for (var s in sax.STATE) {
	    sax.STATE[sax.STATE[s]] = s
	  }

	  // shorthand
	  S = sax.STATE

	  function emit (parser, event, data) {
	    parser[event] && parser[event](data)
	  }

	  function emitNode (parser, nodeType, data) {
	    if (parser.textNode) closeText(parser)
	    emit(parser, nodeType, data)
	  }

	  function closeText (parser) {
	    parser.textNode = textopts(parser.opt, parser.textNode)
	    if (parser.textNode) emit(parser, 'ontext', parser.textNode)
	    parser.textNode = ''
	  }

	  function textopts (opt, text) {
	    if (opt.trim) text = text.trim()
	    if (opt.normalize) text = text.replace(/\s+/g, ' ')
	    return text
	  }

	  function error (parser, er) {
	    closeText(parser)
	    if (parser.trackPosition) {
	      er += '\nLine: ' + parser.line +
	        '\nColumn: ' + parser.column +
	        '\nChar: ' + parser.c
	    }
	    er = new Error(er)
	    parser.error = er
	    emit(parser, 'onerror', er)
	    return parser
	  }

	  function end (parser) {
	    if (parser.sawRoot && !parser.closedRoot) strictFail(parser, 'Unclosed root tag')
	    if ((parser.state !== S.BEGIN) &&
	      (parser.state !== S.BEGIN_WHITESPACE) &&
	      (parser.state !== S.TEXT)) {
	      error(parser, 'Unexpected end')
	    }
	    closeText(parser)
	    parser.c = ''
	    parser.closed = true
	    emit(parser, 'onend')
	    SAXParser.call(parser, parser.strict, parser.opt)
	    return parser
	  }

	  function strictFail (parser, message) {
	    if (typeof parser !== 'object' || !(parser instanceof SAXParser)) {
	      throw new Error('bad call to strictFail')
	    }
	    if (parser.strict) {
	      error(parser, message)
	    }
	  }

	  function newTag (parser) {
	    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]()
	    var parent = parser.tags[parser.tags.length - 1] || parser
	    var tag = parser.tag = { name: parser.tagName, attributes: {} }

	    // will be overridden if tag contails an xmlns="foo" or xmlns:foo="bar"
	    if (parser.opt.xmlns) {
	      tag.ns = parent.ns
	    }
	    parser.attribList.length = 0
	  }

	  function qname (name, attribute) {
	    var i = name.indexOf(':')
	    var qualName = i < 0 ? [ '', name ] : name.split(':')
	    var prefix = qualName[0]
	    var local = qualName[1]

	    // <x "xmlns"="http://foo">
	    if (attribute && name === 'xmlns') {
	      prefix = 'xmlns'
	      local = ''
	    }

	    return { prefix: prefix, local: local }
	  }

	  function attrib (parser) {
	    if (!parser.strict) {
	      parser.attribName = parser.attribName[parser.looseCase]()
	    }

	    if (parser.attribList.indexOf(parser.attribName) !== -1 ||
	      parser.tag.attributes.hasOwnProperty(parser.attribName)) {
	      parser.attribName = parser.attribValue = ''
	      return
	    }

	    if (parser.opt.xmlns) {
	      var qn = qname(parser.attribName, true)
	      var prefix = qn.prefix
	      var local = qn.local

	      if (prefix === 'xmlns') {
	        // namespace binding attribute. push the binding into scope
	        if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) {
	          strictFail(parser,
	            'xml: prefix must be bound to ' + XML_NAMESPACE + '\n' +
	            'Actual: ' + parser.attribValue)
	        } else if (local === 'xmlns' && parser.attribValue !== XMLNS_NAMESPACE) {
	          strictFail(parser,
	            'xmlns: prefix must be bound to ' + XMLNS_NAMESPACE + '\n' +
	            'Actual: ' + parser.attribValue)
	        } else {
	          var tag = parser.tag
	          var parent = parser.tags[parser.tags.length - 1] || parser
	          if (tag.ns === parent.ns) {
	            tag.ns = Object.create(parent.ns)
	          }
	          tag.ns[local] = parser.attribValue
	        }
	      }

	      // defer onattribute events until all attributes have been seen
	      // so any new bindings can take effect. preserve attribute order
	      // so deferred events can be emitted in document order
	      parser.attribList.push([parser.attribName, parser.attribValue])
	    } else {
	      // in non-xmlns mode, we can emit the event right away
	      parser.tag.attributes[parser.attribName] = parser.attribValue
	      emitNode(parser, 'onattribute', {
	        name: parser.attribName,
	        value: parser.attribValue
	      })
	    }

	    parser.attribName = parser.attribValue = ''
	  }

	  function openTag (parser, selfClosing) {
	    if (parser.opt.xmlns) {
	      // emit namespace binding events
	      var tag = parser.tag

	      // add namespace info to tag
	      var qn = qname(parser.tagName)
	      tag.prefix = qn.prefix
	      tag.local = qn.local
	      tag.uri = tag.ns[qn.prefix] || ''

	      if (tag.prefix && !tag.uri) {
	        strictFail(parser, 'Unbound namespace prefix: ' +
	          JSON.stringify(parser.tagName))
	        tag.uri = qn.prefix
	      }

	      var parent = parser.tags[parser.tags.length - 1] || parser
	      if (tag.ns && parent.ns !== tag.ns) {
	        Object.keys(tag.ns).forEach(function (p) {
	          emitNode(parser, 'onopennamespace', {
	            prefix: p,
	            uri: tag.ns[p]
	          })
	        })
	      }

	      // handle deferred onattribute events
	      // Note: do not apply default ns to attributes:
	      //   http://www.w3.org/TR/REC-xml-names/#defaulting
	      for (var i = 0, l = parser.attribList.length; i < l; i++) {
	        var nv = parser.attribList[i]
	        var name = nv[0]
	        var value = nv[1]
	        var qualName = qname(name, true)
	        var prefix = qualName.prefix
	        var local = qualName.local
	        var uri = prefix === '' ? '' : (tag.ns[prefix] || '')
	        var a = {
	          name: name,
	          value: value,
	          prefix: prefix,
	          local: local,
	          uri: uri
	        }

	        // if there's any attributes with an undefined namespace,
	        // then fail on them now.
	        if (prefix && prefix !== 'xmlns' && !uri) {
	          strictFail(parser, 'Unbound namespace prefix: ' +
	            JSON.stringify(prefix))
	          a.uri = prefix
	        }
	        parser.tag.attributes[name] = a
	        emitNode(parser, 'onattribute', a)
	      }
	      parser.attribList.length = 0
	    }

	    parser.tag.isSelfClosing = !!selfClosing

	    // process the tag
	    parser.sawRoot = true
	    parser.tags.push(parser.tag)
	    emitNode(parser, 'onopentag', parser.tag)
	    if (!selfClosing) {
	      // special case for <script> in non-strict mode.
	      if (!parser.noscript && parser.tagName.toLowerCase() === 'script') {
	        parser.state = S.SCRIPT
	      } else {
	        parser.state = S.TEXT
	      }
	      parser.tag = null
	      parser.tagName = ''
	    }
	    parser.attribName = parser.attribValue = ''
	    parser.attribList.length = 0
	  }

	  function closeTag (parser) {
	    if (!parser.tagName) {
	      strictFail(parser, 'Weird empty close tag.')
	      parser.textNode += '</>'
	      parser.state = S.TEXT
	      return
	    }

	    if (parser.script) {
	      if (parser.tagName !== 'script') {
	        parser.script += '</' + parser.tagName + '>'
	        parser.tagName = ''
	        parser.state = S.SCRIPT
	        return
	      }
	      emitNode(parser, 'onscript', parser.script)
	      parser.script = ''
	    }

	    // first make sure that the closing tag actually exists.
	    // <a><b></c></b></a> will close everything, otherwise.
	    var t = parser.tags.length
	    var tagName = parser.tagName
	    if (!parser.strict) {
	      tagName = tagName[parser.looseCase]()
	    }
	    var closeTo = tagName
	    while (t--) {
	      var close = parser.tags[t]
	      if (close.name !== closeTo) {
	        // fail the first time in strict mode
	        strictFail(parser, 'Unexpected close tag')
	      } else {
	        break
	      }
	    }

	    // didn't find it.  we already failed for strict, so just abort.
	    if (t < 0) {
	      strictFail(parser, 'Unmatched closing tag: ' + parser.tagName)
	      parser.textNode += '</' + parser.tagName + '>'
	      parser.state = S.TEXT
	      return
	    }
	    parser.tagName = tagName
	    var s = parser.tags.length
	    while (s-- > t) {
	      var tag = parser.tag = parser.tags.pop()
	      parser.tagName = parser.tag.name
	      emitNode(parser, 'onclosetag', parser.tagName)

	      var x = {}
	      for (var i in tag.ns) {
	        x[i] = tag.ns[i]
	      }

	      var parent = parser.tags[parser.tags.length - 1] || parser
	      if (parser.opt.xmlns && tag.ns !== parent.ns) {
	        // remove namespace bindings introduced by tag
	        Object.keys(tag.ns).forEach(function (p) {
	          var n = tag.ns[p]
	          emitNode(parser, 'onclosenamespace', { prefix: p, uri: n })
	        })
	      }
	    }
	    if (t === 0) parser.closedRoot = true
	    parser.tagName = parser.attribValue = parser.attribName = ''
	    parser.attribList.length = 0
	    parser.state = S.TEXT
	  }

	  function parseEntity (parser) {
	    var entity = parser.entity
	    var entityLC = entity.toLowerCase()
	    var num
	    var numStr = ''

	    if (parser.ENTITIES[entity]) {
	      return parser.ENTITIES[entity]
	    }
	    if (parser.ENTITIES[entityLC]) {
	      return parser.ENTITIES[entityLC]
	    }
	    entity = entityLC
	    if (entity.charAt(0) === '#') {
	      if (entity.charAt(1) === 'x') {
	        entity = entity.slice(2)
	        num = parseInt(entity, 16)
	        numStr = num.toString(16)
	      } else {
	        entity = entity.slice(1)
	        num = parseInt(entity, 10)
	        numStr = num.toString(10)
	      }
	    }
	    entity = entity.replace(/^0+/, '')
	    if (numStr.toLowerCase() !== entity) {
	      strictFail(parser, 'Invalid character entity')
	      return '&' + parser.entity + ';'
	    }

	    return String.fromCodePoint(num)
	  }

	  function beginWhiteSpace (parser, c) {
	    if (c === '<') {
	      parser.state = S.OPEN_WAKA
	      parser.startTagPosition = parser.position
	    } else if (not(whitespace, c)) {
	      // have to process this as a text node.
	      // weird, but happens.
	      strictFail(parser, 'Non-whitespace before first tag.')
	      parser.textNode = c
	      parser.state = S.TEXT
	    }
	  }

	  function charAt (chunk, i) {
	    var result = ''
	    if (i < chunk.length) {
	      result = chunk.charAt(i)
	    }
	    return result
	  }

	  function write (chunk) {
	    var parser = this
	    if (this.error) {
	      throw this.error
	    }
	    if (parser.closed) {
	      return error(parser,
	        'Cannot write after close. Assign an onready handler.')
	    }
	    if (chunk === null) {
	      return end(parser)
	    }
	    var i = 0
	    var c = ''
	    while (true) {
	      c = charAt(chunk, i++)
	      parser.c = c
	      if (!c) {
	        break
	      }
	      if (parser.trackPosition) {
	        parser.position++
	        if (c === '\n') {
	          parser.line++
	          parser.column = 0
	        } else {
	          parser.column++
	        }
	      }
	      switch (parser.state) {
	        case S.BEGIN:
	          parser.state = S.BEGIN_WHITESPACE
	          if (c === '\uFEFF') {
	            continue
	          }
	          beginWhiteSpace(parser, c)
	          continue

	        case S.BEGIN_WHITESPACE:
	          beginWhiteSpace(parser, c)
	          continue

	        case S.TEXT:
	          if (parser.sawRoot && !parser.closedRoot) {
	            var starti = i - 1
	            while (c && c !== '<' && c !== '&') {
	              c = charAt(chunk, i++)
	              if (c && parser.trackPosition) {
	                parser.position++
	                if (c === '\n') {
	                  parser.line++
	                  parser.column = 0
	                } else {
	                  parser.column++
	                }
	              }
	            }
	            parser.textNode += chunk.substring(starti, i - 1)
	          }
	          if (c === '<' && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
	            parser.state = S.OPEN_WAKA
	            parser.startTagPosition = parser.position
	          } else {
	            if (not(whitespace, c) && (!parser.sawRoot || parser.closedRoot)) {
	              strictFail(parser, 'Text data outside of root node.')
	            }
	            if (c === '&') {
	              parser.state = S.TEXT_ENTITY
	            } else {
	              parser.textNode += c
	            }
	          }
	          continue

	        case S.SCRIPT:
	          // only non-strict
	          if (c === '<') {
	            parser.state = S.SCRIPT_ENDING
	          } else {
	            parser.script += c
	          }
	          continue

	        case S.SCRIPT_ENDING:
	          if (c === '/') {
	            parser.state = S.CLOSE_TAG
	          } else {
	            parser.script += '<' + c
	            parser.state = S.SCRIPT
	          }
	          continue

	        case S.OPEN_WAKA:
	          // either a /, ?, !, or text is coming next.
	          if (c === '!') {
	            parser.state = S.SGML_DECL
	            parser.sgmlDecl = ''
	          } else if (is(whitespace, c)) {
	            // wait for it...
	          } else if (is(nameStart, c)) {
	            parser.state = S.OPEN_TAG
	            parser.tagName = c
	          } else if (c === '/') {
	            parser.state = S.CLOSE_TAG
	            parser.tagName = ''
	          } else if (c === '?') {
	            parser.state = S.PROC_INST
	            parser.procInstName = parser.procInstBody = ''
	          } else {
	            strictFail(parser, 'Unencoded <')
	            // if there was some whitespace, then add that in.
	            if (parser.startTagPosition + 1 < parser.position) {
	              var pad = parser.position - parser.startTagPosition
	              c = new Array(pad).join(' ') + c
	            }
	            parser.textNode += '<' + c
	            parser.state = S.TEXT
	          }
	          continue

	        case S.SGML_DECL:
	          if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
	            emitNode(parser, 'onopencdata')
	            parser.state = S.CDATA
	            parser.sgmlDecl = ''
	            parser.cdata = ''
	          } else if (parser.sgmlDecl + c === '--') {
	            parser.state = S.COMMENT
	            parser.comment = ''
	            parser.sgmlDecl = ''
	          } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
	            parser.state = S.DOCTYPE
	            if (parser.doctype || parser.sawRoot) {
	              strictFail(parser,
	                'Inappropriately located doctype declaration')
	            }
	            parser.doctype = ''
	            parser.sgmlDecl = ''
	          } else if (c === '>') {
	            emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl)
	            parser.sgmlDecl = ''
	            parser.state = S.TEXT
	          } else if (is(quote, c)) {
	            parser.state = S.SGML_DECL_QUOTED
	            parser.sgmlDecl += c
	          } else {
	            parser.sgmlDecl += c
	          }
	          continue

	        case S.SGML_DECL_QUOTED:
	          if (c === parser.q) {
	            parser.state = S.SGML_DECL
	            parser.q = ''
	          }
	          parser.sgmlDecl += c
	          continue

	        case S.DOCTYPE:
	          if (c === '>') {
	            parser.state = S.TEXT
	            emitNode(parser, 'ondoctype', parser.doctype)
	            parser.doctype = true // just remember that we saw it.
	          } else {
	            parser.doctype += c
	            if (c === '[') {
	              parser.state = S.DOCTYPE_DTD
	            } else if (is(quote, c)) {
	              parser.state = S.DOCTYPE_QUOTED
	              parser.q = c
	            }
	          }
	          continue

	        case S.DOCTYPE_QUOTED:
	          parser.doctype += c
	          if (c === parser.q) {
	            parser.q = ''
	            parser.state = S.DOCTYPE
	          }
	          continue

	        case S.DOCTYPE_DTD:
	          parser.doctype += c
	          if (c === ']') {
	            parser.state = S.DOCTYPE
	          } else if (is(quote, c)) {
	            parser.state = S.DOCTYPE_DTD_QUOTED
	            parser.q = c
	          }
	          continue

	        case S.DOCTYPE_DTD_QUOTED:
	          parser.doctype += c
	          if (c === parser.q) {
	            parser.state = S.DOCTYPE_DTD
	            parser.q = ''
	          }
	          continue

	        case S.COMMENT:
	          if (c === '-') {
	            parser.state = S.COMMENT_ENDING
	          } else {
	            parser.comment += c
	          }
	          continue

	        case S.COMMENT_ENDING:
	          if (c === '-') {
	            parser.state = S.COMMENT_ENDED
	            parser.comment = textopts(parser.opt, parser.comment)
	            if (parser.comment) {
	              emitNode(parser, 'oncomment', parser.comment)
	            }
	            parser.comment = ''
	          } else {
	            parser.comment += '-' + c
	            parser.state = S.COMMENT
	          }
	          continue

	        case S.COMMENT_ENDED:
	          if (c !== '>') {
	            strictFail(parser, 'Malformed comment')
	            // allow <!-- blah -- bloo --> in non-strict mode,
	            // which is a comment of " blah -- bloo "
	            parser.comment += '--' + c
	            parser.state = S.COMMENT
	          } else {
	            parser.state = S.TEXT
	          }
	          continue

	        case S.CDATA:
	          if (c === ']') {
	            parser.state = S.CDATA_ENDING
	          } else {
	            parser.cdata += c
	          }
	          continue

	        case S.CDATA_ENDING:
	          if (c === ']') {
	            parser.state = S.CDATA_ENDING_2
	          } else {
	            parser.cdata += ']' + c
	            parser.state = S.CDATA
	          }
	          continue

	        case S.CDATA_ENDING_2:
	          if (c === '>') {
	            if (parser.cdata) {
	              emitNode(parser, 'oncdata', parser.cdata)
	            }
	            emitNode(parser, 'onclosecdata')
	            parser.cdata = ''
	            parser.state = S.TEXT
	          } else if (c === ']') {
	            parser.cdata += ']'
	          } else {
	            parser.cdata += ']]' + c
	            parser.state = S.CDATA
	          }
	          continue

	        case S.PROC_INST:
	          if (c === '?') {
	            parser.state = S.PROC_INST_ENDING
	          } else if (is(whitespace, c)) {
	            parser.state = S.PROC_INST_BODY
	          } else {
	            parser.procInstName += c
	          }
	          continue

	        case S.PROC_INST_BODY:
	          if (!parser.procInstBody && is(whitespace, c)) {
	            continue
	          } else if (c === '?') {
	            parser.state = S.PROC_INST_ENDING
	          } else {
	            parser.procInstBody += c
	          }
	          continue

	        case S.PROC_INST_ENDING:
	          if (c === '>') {
	            emitNode(parser, 'onprocessinginstruction', {
	              name: parser.procInstName,
	              body: parser.procInstBody
	            })
	            parser.procInstName = parser.procInstBody = ''
	            parser.state = S.TEXT
	          } else {
	            parser.procInstBody += '?' + c
	            parser.state = S.PROC_INST_BODY
	          }
	          continue

	        case S.OPEN_TAG:
	          if (is(nameBody, c)) {
	            parser.tagName += c
	          } else {
	            newTag(parser)
	            if (c === '>') {
	              openTag(parser)
	            } else if (c === '/') {
	              parser.state = S.OPEN_TAG_SLASH
	            } else {
	              if (not(whitespace, c)) {
	                strictFail(parser, 'Invalid character in tag name')
	              }
	              parser.state = S.ATTRIB
	            }
	          }
	          continue

	        case S.OPEN_TAG_SLASH:
	          if (c === '>') {
	            openTag(parser, true)
	            closeTag(parser)
	          } else {
	            strictFail(parser, 'Forward-slash in opening tag not followed by >')
	            parser.state = S.ATTRIB
	          }
	          continue

	        case S.ATTRIB:
	          // haven't read the attribute name yet.
	          if (is(whitespace, c)) {
	            continue
	          } else if (c === '>') {
	            openTag(parser)
	          } else if (c === '/') {
	            parser.state = S.OPEN_TAG_SLASH
	          } else if (is(nameStart, c)) {
	            parser.attribName = c
	            parser.attribValue = ''
	            parser.state = S.ATTRIB_NAME
	          } else {
	            strictFail(parser, 'Invalid attribute name')
	          }
	          continue

	        case S.ATTRIB_NAME:
	          if (c === '=') {
	            parser.state = S.ATTRIB_VALUE
	          } else if (c === '>') {
	            strictFail(parser, 'Attribute without value')
	            parser.attribValue = parser.attribName
	            attrib(parser)
	            openTag(parser)
	          } else if (is(whitespace, c)) {
	            parser.state = S.ATTRIB_NAME_SAW_WHITE
	          } else if (is(nameBody, c)) {
	            parser.attribName += c
	          } else {
	            strictFail(parser, 'Invalid attribute name')
	          }
	          continue

	        case S.ATTRIB_NAME_SAW_WHITE:
	          if (c === '=') {
	            parser.state = S.ATTRIB_VALUE
	          } else if (is(whitespace, c)) {
	            continue
	          } else {
	            strictFail(parser, 'Attribute without value')
	            parser.tag.attributes[parser.attribName] = ''
	            parser.attribValue = ''
	            emitNode(parser, 'onattribute', {
	              name: parser.attribName,
	              value: ''
	            })
	            parser.attribName = ''
	            if (c === '>') {
	              openTag(parser)
	            } else if (is(nameStart, c)) {
	              parser.attribName = c
	              parser.state = S.ATTRIB_NAME
	            } else {
	              strictFail(parser, 'Invalid attribute name')
	              parser.state = S.ATTRIB
	            }
	          }
	          continue

	        case S.ATTRIB_VALUE:
	          if (is(whitespace, c)) {
	            continue
	          } else if (is(quote, c)) {
	            parser.q = c
	            parser.state = S.ATTRIB_VALUE_QUOTED
	          } else {
	            strictFail(parser, 'Unquoted attribute value')
	            parser.state = S.ATTRIB_VALUE_UNQUOTED
	            parser.attribValue = c
	          }
	          continue

	        case S.ATTRIB_VALUE_QUOTED:
	          if (c !== parser.q) {
	            if (c === '&') {
	              parser.state = S.ATTRIB_VALUE_ENTITY_Q
	            } else {
	              parser.attribValue += c
	            }
	            continue
	          }
	          attrib(parser)
	          parser.q = ''
	          parser.state = S.ATTRIB_VALUE_CLOSED
	          continue

	        case S.ATTRIB_VALUE_CLOSED:
	          if (is(whitespace, c)) {
	            parser.state = S.ATTRIB
	          } else if (c === '>') {
	            openTag(parser)
	          } else if (c === '/') {
	            parser.state = S.OPEN_TAG_SLASH
	          } else if (is(nameStart, c)) {
	            strictFail(parser, 'No whitespace between attributes')
	            parser.attribName = c
	            parser.attribValue = ''
	            parser.state = S.ATTRIB_NAME
	          } else {
	            strictFail(parser, 'Invalid attribute name')
	          }
	          continue

	        case S.ATTRIB_VALUE_UNQUOTED:
	          if (not(attribEnd, c)) {
	            if (c === '&') {
	              parser.state = S.ATTRIB_VALUE_ENTITY_U
	            } else {
	              parser.attribValue += c
	            }
	            continue
	          }
	          attrib(parser)
	          if (c === '>') {
	            openTag(parser)
	          } else {
	            parser.state = S.ATTRIB
	          }
	          continue

	        case S.CLOSE_TAG:
	          if (!parser.tagName) {
	            if (is(whitespace, c)) {
	              continue
	            } else if (not(nameStart, c)) {
	              if (parser.script) {
	                parser.script += '</' + c
	                parser.state = S.SCRIPT
	              } else {
	                strictFail(parser, 'Invalid tagname in closing tag.')
	              }
	            } else {
	              parser.tagName = c
	            }
	          } else if (c === '>') {
	            closeTag(parser)
	          } else if (is(nameBody, c)) {
	            parser.tagName += c
	          } else if (parser.script) {
	            parser.script += '</' + parser.tagName
	            parser.tagName = ''
	            parser.state = S.SCRIPT
	          } else {
	            if (not(whitespace, c)) {
	              strictFail(parser, 'Invalid tagname in closing tag')
	            }
	            parser.state = S.CLOSE_TAG_SAW_WHITE
	          }
	          continue

	        case S.CLOSE_TAG_SAW_WHITE:
	          if (is(whitespace, c)) {
	            continue
	          }
	          if (c === '>') {
	            closeTag(parser)
	          } else {
	            strictFail(parser, 'Invalid characters in closing tag')
	          }
	          continue

	        case S.TEXT_ENTITY:
	        case S.ATTRIB_VALUE_ENTITY_Q:
	        case S.ATTRIB_VALUE_ENTITY_U:
	          var returnState
	          var buffer
	          switch (parser.state) {
	            case S.TEXT_ENTITY:
	              returnState = S.TEXT
	              buffer = 'textNode'
	              break

	            case S.ATTRIB_VALUE_ENTITY_Q:
	              returnState = S.ATTRIB_VALUE_QUOTED
	              buffer = 'attribValue'
	              break

	            case S.ATTRIB_VALUE_ENTITY_U:
	              returnState = S.ATTRIB_VALUE_UNQUOTED
	              buffer = 'attribValue'
	              break
	          }

	          if (c === ';') {
	            parser[buffer] += parseEntity(parser)
	            parser.entity = ''
	            parser.state = returnState
	          } else if (is(parser.entity.length ? entityBody : entityStart, c)) {
	            parser.entity += c
	          } else {
	            strictFail(parser, 'Invalid character in entity name')
	            parser[buffer] += '&' + parser.entity + c
	            parser.entity = ''
	            parser.state = returnState
	          }

	          continue

	        default:
	          throw new Error(parser, 'Unknown state: ' + parser.state)
	      }
	    } // while

	    if (parser.position >= parser.bufferCheckPosition) {
	      checkBufferLength(parser)
	    }
	    return parser
	  }

	  /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
	  if (!String.fromCodePoint) {
	    (function () {
	      var stringFromCharCode = String.fromCharCode
	      var floor = Math.floor
	      var fromCodePoint = function () {
	        var MAX_SIZE = 0x4000
	        var codeUnits = []
	        var highSurrogate
	        var lowSurrogate
	        var index = -1
	        var length = arguments.length
	        if (!length) {
	          return ''
	        }
	        var result = ''
	        while (++index < length) {
	          var codePoint = Number(arguments[index])
	          if (
	            !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
	            codePoint < 0 || // not a valid Unicode code point
	            codePoint > 0x10FFFF || // not a valid Unicode code point
	            floor(codePoint) !== codePoint // not an integer
	          ) {
	            throw RangeError('Invalid code point: ' + codePoint)
	          }
	          if (codePoint <= 0xFFFF) { // BMP code point
	            codeUnits.push(codePoint)
	          } else { // Astral code point; split in surrogate halves
	            // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
	            codePoint -= 0x10000
	            highSurrogate = (codePoint >> 10) + 0xD800
	            lowSurrogate = (codePoint % 0x400) + 0xDC00
	            codeUnits.push(highSurrogate, lowSurrogate)
	          }
	          if (index + 1 === length || codeUnits.length > MAX_SIZE) {
	            result += stringFromCharCode.apply(null, codeUnits)
	            codeUnits.length = 0
	          }
	        }
	        return result
	      }
	      if (Object.defineProperty) {
	        Object.defineProperty(String, 'fromCodePoint', {
	          value: fromCodePoint,
	          configurable: true,
	          writable: true
	        })
	      } else {
	        String.fromCodePoint = fromCodePoint
	      }
	    }())
	  }
	})( false ? this.sax = {} : exports)


/***/ },
/* 218 */
/***/ function(module, exports) {

	module.exports = require("string_decoder");

/***/ },
/* 219 */
/***/ function(module, exports) {

	module.exports = require("events");

/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.10.0
	(function() {
	  "use strict";
	  var xml2js;

	  xml2js = __webpack_require__(216);

	  exports.stripBOM = function(str) {
	    if (str[0] === '\uFEFF') {
	      return str.substring(1);
	    } else {
	      return str;
	    }
	  };

	}).call(this);


/***/ },
/* 221 */
/***/ function(module, exports) {

	// Generated by CoffeeScript 1.10.0
	(function() {
	  "use strict";
	  var prefixMatch;

	  prefixMatch = new RegExp(/(?!xmlns)^.*:/);

	  exports.normalize = function(str) {
	    return str.toLowerCase();
	  };

	  exports.firstCharLowerCase = function(str) {
	    return str.charAt(0).toLowerCase() + str.slice(1);
	  };

	  exports.stripPrefix = function(str) {
	    return str.replace(prefixMatch, '');
	  };

	  exports.parseNumbers = function(str) {
	    if (!isNaN(str)) {
	      str = str % 1 === 0 ? parseInt(str, 10) : parseFloat(str);
	    }
	    return str;
	  };

	  exports.parseBooleans = function(str) {
	    if (/^(?:true|false)$/i.test(str)) {
	      str = str.toLowerCase() === 'true';
	    }
	    return str;
	  };

	}).call(this);


/***/ },
/* 222 */
/***/ function(module, exports) {

	module.exports = require("timers");

/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(93);
	var Stream = AWS.util.stream.Stream;
	var TransformStream = AWS.util.stream.Transform;
	var ReadableStream = AWS.util.stream.Readable;
	__webpack_require__(191);

	/**
	 * @api private
	 */
	AWS.NodeHttpClient = AWS.util.inherit({
	  handleRequest: function handleRequest(httpRequest, httpOptions, callback, errCallback) {
	    var self = this;
	    var cbAlreadyCalled = false;
	    var endpoint = httpRequest.endpoint;
	    var pathPrefix = '';
	    if (!httpOptions) httpOptions = {};
	    if (httpOptions.proxy) {
	      pathPrefix = endpoint.protocol + '//' + endpoint.hostname;
	      if (endpoint.port !== 80 && endpoint.port !== 443) {
	        pathPrefix += ':' + endpoint.port;
	      }
	      endpoint = new AWS.Endpoint(httpOptions.proxy);
	    }

	    var useSSL = endpoint.protocol === 'https:';
	    var http = useSSL ? __webpack_require__(224) : __webpack_require__(225);
	    var options = {
	      host: endpoint.hostname,
	      port: endpoint.port,
	      method: httpRequest.method,
	      headers: httpRequest.headers,
	      path: pathPrefix + httpRequest.path
	    };

	    if (useSSL && !httpOptions.agent) {
	      options.agent = this.sslAgent();
	    }

	    AWS.util.update(options, httpOptions);
	    delete options.proxy; // proxy isn't an HTTP option
	    delete options.timeout; // timeout isn't an HTTP option

	    var stream = http.request(options, function (httpResp) {
	      if (cbAlreadyCalled) return; cbAlreadyCalled = true;

	      callback(httpResp);
	      httpResp.emit('headers', httpResp.statusCode, httpResp.headers);
	    });
	    httpRequest.stream = stream; // attach stream to httpRequest

	    // timeout support
	    stream.setTimeout(httpOptions.timeout || 0, function() {
	      if (cbAlreadyCalled) return; cbAlreadyCalled = true;

	      var msg = 'Connection timed out after ' + httpOptions.timeout + 'ms';
	      errCallback(AWS.util.error(new Error(msg), {code: 'TimeoutError'}));
	      stream.abort();
	    });

	    stream.on('error', function() {
	      if (cbAlreadyCalled) return; cbAlreadyCalled = true;
	      errCallback.apply(this, arguments);
	    });

	    var expect = httpRequest.headers.Expect || httpRequest.headers.expect;
	    if (expect === '100-continue') {
	      stream.on('continue', function() {
	        self.writeBody(stream, httpRequest);
	      });
	    } else {
	      this.writeBody(stream, httpRequest);
	    }

	    return stream;
	  },

	  writeBody: function writeBody(stream, httpRequest) {
	    var body = httpRequest.body;
	    var totalBytes = parseInt(httpRequest.headers['Content-Length'], 10);

	    if (body instanceof Stream) {
	      // For progress support of streaming content -
	      // pipe the data through a transform stream to emit 'sendProgress' events
	      var progressStream = this.progressStream(stream, totalBytes);
	      if (progressStream) {
	        body.pipe(progressStream).pipe(stream);
	      } else {
	        body.pipe(stream);
	      }
	    } else if (body) {
	      // The provided body is a buffer/string and is already fully available in memory -
	      // For performance it's best to send it as a whole by calling stream.end(body),
	      // Callers expect a 'sendProgress' event which is best emitted once
	      // the http request stream has been fully written and all data flushed.
	      // The use of totalBytes is important over body.length for strings where
	      // length is char length and not byte length.
	      stream.once('finish', function() {
	        stream.emit('sendProgress', {
	          loaded: totalBytes,
	          total: totalBytes
	        });
	      });
	      stream.end(body);
	    } else {
	      // no request body
	      stream.end();
	    }
	  },

	  sslAgent: function sslAgent() {
	    var https = __webpack_require__(224);

	    if (!AWS.NodeHttpClient.sslAgent) {
	      AWS.NodeHttpClient.sslAgent = new https.Agent({rejectUnauthorized: true});
	      AWS.NodeHttpClient.sslAgent.setMaxListeners(0);

	      // delegate maxSockets to globalAgent, set a default limit of 50 if current value is Infinity.
	      // Users can bypass this default by supplying their own Agent as part of SDK configuration.
	      Object.defineProperty(AWS.NodeHttpClient.sslAgent, 'maxSockets', {
	        enumerable: true,
	        get: function() {
	          var defaultMaxSockets = 50;
	          var globalAgent = https.globalAgent;
	          if (globalAgent && globalAgent.maxSockets !== Infinity && typeof globalAgent.maxSockets === 'number') {
	            return globalAgent.maxSockets;
	          }
	          return defaultMaxSockets;
	        }
	      });
	    }
	    return AWS.NodeHttpClient.sslAgent;
	  },

	  progressStream: function progressStream(stream, totalBytes) {
	    if (typeof TransformStream === 'undefined') {
	      // for node 0.8 there is no streaming progress
	      return;
	    }
	    var loadedBytes = 0;
	    var reporter = new TransformStream();
	    reporter._transform = function(chunk, encoding, callback) {
	      if (chunk) {
	        loadedBytes += chunk.length;
	        stream.emit('sendProgress', {
	          loaded: loadedBytes,
	          total: totalBytes
	        });
	      }
	      callback(null, chunk);
	    };
	    return reporter;
	  },

	  emitter: null
	});

	/**
	 * @!ignore
	 */

	/**
	 * @api private
	 */
	AWS.HttpClient.prototype = AWS.NodeHttpClient.prototype;

	/**
	 * @api private
	 */
	AWS.HttpClient.streamsApiVersion = ReadableStream ? 2 : 1;


/***/ },
/* 224 */
/***/ function(module, exports) {

	module.exports = require("https");

/***/ },
/* 225 */
/***/ function(module, exports) {

	module.exports = require("http");

/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(93);
	__webpack_require__(227);

	/**
	 * Represents credentials received from the metadata service on an EC2 instance.
	 *
	 * By default, this class will connect to the metadata service using
	 * {AWS.MetadataService} and attempt to load any available credentials. If it
	 * can connect, and credentials are available, these will be used with zero
	 * configuration.
	 *
	 * This credentials class will by default timeout after 1 second of inactivity
	 * and retry 3 times.
	 * If your requests to the EC2 metadata service are timing out, you can increase
	 * these values by configuring them directly:
	 *
	 * ```javascript
	 * AWS.config.credentials = new AWS.EC2MetadataCredentials({
	 *   httpOptions: { timeout: 5000 }, // 5 second timeout
	 *   maxRetries: 10, // retry 10 times
	 *   retryDelayOptions: { base: 200 } // see AWS.Config for information
	 * });
	 * ```
	 *
	 * @see AWS.Config.retryDelayOptions
	 *
	 * @!macro nobrowser
	 */
	AWS.EC2MetadataCredentials = AWS.util.inherit(AWS.Credentials, {
	  constructor: function EC2MetadataCredentials(options) {
	    AWS.Credentials.call(this);

	    options = options ? AWS.util.copy(options) : {};
	    options = AWS.util.merge(
	      {maxRetries: this.defaultMaxRetries}, options);
	    if (!options.httpOptions) options.httpOptions = {};
	    options.httpOptions = AWS.util.merge(
	      {timeout: this.defaultTimeout}, options.httpOptions);

	    this.metadataService = new AWS.MetadataService(options);
	    this.metadata = {};
	  },

	  /**
	   * @api private
	   */
	  defaultTimeout: 1000,

	  /**
	   * @api private
	   */
	  defaultMaxRetries: 3,

	  /**
	   * Loads the credentials from the instance metadata service
	   *
	   * @callback callback function(err)
	   *   Called when the instance metadata service responds (or fails). When
	   *   this callback is called with no error, it means that the credentials
	   *   information has been loaded into the object (as the `accessKeyId`,
	   *   `secretAccessKey`, and `sessionToken` properties).
	   *   @param err [Error] if an error occurred, this value will be filled
	   * @see get
	   */
	  refresh: function refresh(callback) {
	    var self = this;
	    if (!callback) callback = function(err) { if (err) throw err; };

	    self.metadataService.loadCredentials(function (err, creds) {
	      if (!err) {
	        self.expired = false;
	        self.metadata = creds;
	        self.accessKeyId = creds.AccessKeyId;
	        self.secretAccessKey = creds.SecretAccessKey;
	        self.sessionToken = creds.Token;
	        self.expireTime = new Date(creds.Expiration);
	      }
	      callback(err);
	    });
	  }
	});


/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(93);
	__webpack_require__(191);
	var inherit = AWS.util.inherit;

	/**
	 * Represents a metadata service available on EC2 instances. Using the
	 * {request} method, you can receieve metadata about any available resource
	 * on the metadata service.
	 *
	 * @!attribute [r] httpOptions
	 *   @return [map] a map of options to pass to the underlying HTTP request:
	 *
	 *     * **timeout** (Number) &mdash; a timeout value in milliseconds to wait
	 *       before aborting the connection. Set to 0 for no timeout.
	 *
	 * @!macro nobrowser
	 */
	AWS.MetadataService = inherit({
	  /**
	   * @return [String] the hostname of the instance metadata service
	   */
	  host: '169.254.169.254',

	  /**
	   * @!ignore
	   */

	  /**
	   * Default HTTP options. By default, the metadata service is set to not
	   * timeout on long requests. This means that on non-EC2 machines, this
	   * request will never return. If you are calling this operation from an
	   * environment that may not always run on EC2, set a `timeout` value so
	   * the SDK will abort the request after a given number of milliseconds.
	   */
	  httpOptions: { timeout: 0 },

	  /**
	   * Creates a new MetadataService object with a given set of options.
	   *
	   * @option options host [String] the hostname of the instance metadata
	   *   service
	   * @option options httpOptions [map] a map of options to pass to the
	   *   underlying HTTP request:
	   *
	   *   * **timeout** (Number) &mdash; a timeout value in milliseconds to wait
	   *     before aborting the connection. Set to 0 for no timeout.
	   * @option options maxRetries [Integer] the maximum number of retries to
	   *   perform for timeout errors
	   * @option options retryDelayOptions [map] A set of options to configure the
	   *   retry delay on retryable errors. See AWS.Config for details.
	   */
	  constructor: function MetadataService(options) {
	    AWS.util.update(this, options);
	  },

	  /**
	   * Sends a request to the instance metadata service for a given resource.
	   *
	   * @param path [String] the path of the resource to get
	   * @callback callback function(err, data)
	   *   Called when a response is available from the service.
	   *   @param err [Error, null] if an error occurred, this value will be set
	   *   @param data [String, null] if the request was successful, the body of
	   *     the response
	   */
	  request: function request(path, callback) {
	    path = path || '/';
	    var httpRequest = new AWS.HttpRequest('http://' + this.host + path);
	    httpRequest.method = 'GET';
	    AWS.util.handleRequestWithRetries(httpRequest, this, callback);
	  },

	  /**
	  * @api private
	  */
	  loadCredentialsCallbacks: [],

	  /**
	   * Loads a set of credentials stored in the instance metadata service
	   *
	   * @api private
	   * @callback callback function(err, credentials)
	   *   Called when credentials are loaded from the resource
	   *   @param err [Error] if an error occurred, this value will be set
	   *   @param credentials [Object] the raw JSON object containing all
	   *     metadata from the credentials resource
	   */
	  loadCredentials: function loadCredentials(callback) {
	    var self = this;
	    var basePath = '/latest/meta-data/iam/security-credentials/';
	    self.loadCredentialsCallbacks.push(callback);
	    if (self.loadCredentialsCallbacks.length > 1) { return; }

	    function callbacks(err, creds) {
	      var cb;
	      while ((cb = self.loadCredentialsCallbacks.shift()) !== undefined) {
	        cb(err, creds);
	      }
	    }

	    self.request(basePath, function (err, roleName) {
	      if (err) callbacks(err);
	      else {
	        roleName = roleName.split('\n')[0]; // grab first (and only) role
	        self.request(basePath + roleName, function (credErr, credData) {
	          if (credErr) callbacks(credErr);
	          else {
	            try {
	              var credentials = JSON.parse(credData);
	              callbacks(null, credentials);
	            } catch (parseError) {
	              callbacks(parseError);
	            }
	          }
	        });
	      }
	    });
	  }
	});

	module.exports = AWS.MetadataService;


/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(93);

	/**
	 * Represents credentials received from relative URI specified in the ECS container.
	 *
	 * This class will request refreshable credentials from the relative URI
	 * specified by the AWS_CONTAINER_CREDENTIALS_RELATIVE_URI environment variable
	 * in the container. If valid credentials are returned in the response, these
	 * will be used with zero configuration.
	 *
	 * This credentials class will by default timeout after 1 second of inactivity
	 * and retry 3 times.
	 * If your requests to the relative URI are timing out, you can increase
	 * the value by configuring them directly:
	 *
	 * ```javascript
	 * AWS.config.credentials = new AWS.ECSCredentials({
	 *   httpOptions: { timeout: 5000 }, // 5 second timeout
	 *   maxRetries: 10, // retry 10 times
	 *   retryDelayOptions: { base: 200 } // see AWS.Config for information
	 * });
	 * ```
	 *
	 * @see AWS.Config.retryDelayOptions
	 *
	 * @!macro nobrowser
	 */
	AWS.ECSCredentials = AWS.util.inherit(AWS.Credentials, {
	  constructor: function ECSCredentials(options) {
	    AWS.Credentials.call(this);
	    options = options ? AWS.util.copy(options) : {};
	    if (!options.httpOptions) options.httpOptions = {};
	    options.httpOptions = AWS.util.merge(
	      this.httpOptions, options.httpOptions);
	    AWS.util.update(this, options);
	  },

	  /**
	   * @api private
	   */
	  httpOptions: { timeout: 1000 },

	  /**
	   * @api private
	   */
	  host: '169.254.170.2',

	  /**
	   * @api private
	   */
	  maxRetries: 3,

	  /**
	   * Sets the name of the ECS environment variable to check for relative URI
	   * If changed, please change the name in the documentation for defaultProvider
	   * in credential_provider_chain.js and in all tests in test/credentials.spec.coffee
	   *
	   * @api private
	   */
	  environmentVar: 'AWS_CONTAINER_CREDENTIALS_RELATIVE_URI',

	  /**
	   * @api private
	   */
	  getECSRelativeUri: function getECSRelativeUri() {
	    if (process && process.env) return process.env[this.environmentVar];
	  },

	  /**
	   * @api private
	   */
	  credsFormatIsValid: function credsFormatIsValid(credData) {
	    return (!!credData.AccessKeyId && !!credData.SecretAccessKey &&
	      !!credData.Token && !!credData.Expiration);
	  },

	  /**
	   * @api private
	   */
	  request: function request(path, callback) {
	    path = path || '/';
	    var httpRequest = new AWS.HttpRequest('http://' + this.host + path);
	    httpRequest.method = 'GET';
	    httpRequest.headers.Accept = 'application/json';
	    AWS.util.handleRequestWithRetries(httpRequest, this, callback);
	  },

	  /**
	   * @api private
	   */
	  refreshQueue: [],

	  /**
	   * Loads the credentials from the relative URI specified by container
	   *
	   * @callback callback function(err)
	   *   Called when the request to the relative URI responds (or fails). When
	   *   this callback is called with no error, it means that the credentials
	   *   information has been loaded into the object (as the `accessKeyId`,
	   *   `secretAccessKey`, `sessionToken`, and `expireTime` properties).
	   *   @param err [Error] if an error occurred, this value will be filled
	   * @see get
	   */
	  refresh: function refresh(callback) {
	    var self = this;
	    var refreshQueue = self.refreshQueue;
	    if (!callback) callback = function(err) { if (err) throw err; };
	    refreshQueue.push({
	      provider: self,
	      errCallback: callback
	    });
	    if (refreshQueue.length > 1) { return; }

	    function callbacks(err, creds) {
	      var call, cb;
	      while ((call = refreshQueue.shift()) !== undefined) {
	        cb = call.errCallback;
	        if (!err) AWS.util.update(call.provider, creds);
	        cb(err);
	      }
	    }

	    if (process === undefined) {
	      callbacks(AWS.util.error(
	        new Error('No process info available'),
	        { code: 'ECSCredentialsProviderFailure' }
	      ));
	      return;
	    }
	    var relativeUri = this.getECSRelativeUri();
	    if (relativeUri === undefined) {
	      callbacks(AWS.util.error(
	        new Error('Variable ' + this.environmentVar + ' not set.'),
	        { code: 'ECSCredentialsProviderFailure' }
	      ));
	      return;
	    }

	    this.request(relativeUri, function(err, data) {
	      if (!err) {
	        try {
	          data = JSON.parse(data);
	          if (self.credsFormatIsValid(data)) {
	            var creds = {
	              expired: false,
	              accessKeyId: data.AccessKeyId,
	              secretAccessKey: data.SecretAccessKey,
	              sessionToken: data.Token,
	              expireTime: new Date(data.Expiration)
	            };
	          } else {
	            throw AWS.util.error(
	              new Error('Response data is not in valid format'),
	              { code: 'ECSCredentialsProviderFailure' }
	            );
	          }
	        } catch (dataError) {
	          err = dataError;
	        }
	      }
	      callbacks(err, creds);
	    });
	  }
	});


/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(93);

	/**
	 * Represents credentials from the environment.
	 *
	 * By default, this class will look for the matching environment variables
	 * prefixed by a given {envPrefix}. The un-prefixed environment variable names
	 * for each credential value is listed below:
	 *
	 * ```javascript
	 * accessKeyId: ACCESS_KEY_ID
	 * secretAccessKey: SECRET_ACCESS_KEY
	 * sessionToken: SESSION_TOKEN
	 * ```
	 *
	 * With the default prefix of 'AWS', the environment variables would be:
	 *
	 *     AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, AWS_SESSION_TOKEN
	 *
	 * @!attribute envPrefix
	 *   @readonly
	 *   @return [String] the prefix for the environment variable names excluding
	 *     the separating underscore ('_').
	 */
	AWS.EnvironmentCredentials = AWS.util.inherit(AWS.Credentials, {

	  /**
	   * Creates a new EnvironmentCredentials class with a given variable
	   * prefix {envPrefix}. For example, to load credentials using the 'AWS'
	   * prefix:
	   *
	   * ```javascript
	   * var creds = new AWS.EnvironmentCredentials('AWS');
	   * creds.accessKeyId == 'AKID' // from AWS_ACCESS_KEY_ID env var
	   * ```
	   *
	   * @param envPrefix [String] the prefix to use (e.g., 'AWS') for environment
	   *   variables. Do not include the separating underscore.
	   */
	  constructor: function EnvironmentCredentials(envPrefix) {
	    AWS.Credentials.call(this);
	    this.envPrefix = envPrefix;
	    this.get(function() {});
	  },

	  /**
	   * Loads credentials from the environment using the prefixed
	   * environment variables.
	   *
	   * @callback callback function(err)
	   *   Called after the (prefixed) ACCESS_KEY_ID, SECRET_ACCESS_KEY, and
	   *   SESSION_TOKEN environment variables are read. When this callback is
	   *   called with no error, it means that the credentials information has
	   *   been loaded into the object (as the `accessKeyId`, `secretAccessKey`,
	   *   and `sessionToken` properties).
	   *   @param err [Error] if an error occurred, this value will be filled
	   * @see get
	   */
	  refresh: function refresh(callback) {
	    if (!callback) callback = function(err) { if (err) throw err; };

	    if (!process || !process.env) {
	      callback(AWS.util.error(
	        new Error('No process info or environment variables available'),
	        { code: 'EnvironmentCredentialsProviderFailure' }
	      ));
	      return;
	    }

	    var keys = ['ACCESS_KEY_ID', 'SECRET_ACCESS_KEY', 'SESSION_TOKEN'];
	    var values = [];

	    for (var i = 0; i < keys.length; i++) {
	      var prefix = '';
	      if (this.envPrefix) prefix = this.envPrefix + '_';
	      values[i] = process.env[prefix + keys[i]];
	      if (!values[i] && keys[i] !== 'SESSION_TOKEN') {
	        callback(AWS.util.error(
	          new Error('Variable ' + prefix + keys[i] + ' not set.'),
	        { code: 'EnvironmentCredentialsProviderFailure' }
	        ));
	        return;
	      }
	    }

	    this.expired = false;
	    AWS.Credentials.apply(this, values);
	    callback();
	  }

	});


/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(93);

	/**
	 * Represents credentials from a JSON file on disk.
	 * If the credentials expire, the SDK can {refresh} the credentials
	 * from the file.
	 *
	 * The format of the file should be similar to the options passed to
	 * {AWS.Config}:
	 *
	 * ```javascript
	 * {accessKeyId: 'akid', secretAccessKey: 'secret', sessionToken: 'optional'}
	 * ```
	 *
	 * @example Loading credentials from disk
	 *   var creds = new AWS.FileSystemCredentials('./configuration.json');
	 *   creds.accessKeyId == 'AKID'
	 *
	 * @!attribute filename
	 *   @readonly
	 *   @return [String] the path to the JSON file on disk containing the
	 *     credentials.
	 * @!macro nobrowser
	 */
	AWS.FileSystemCredentials = AWS.util.inherit(AWS.Credentials, {

	  /**
	   * @overload AWS.FileSystemCredentials(filename)
	   *   Creates a new FileSystemCredentials object from a filename
	   *
	   *   @param filename [String] the path on disk to the JSON file to load.
	   */
	  constructor: function FileSystemCredentials(filename) {
	    AWS.Credentials.call(this);
	    this.filename = filename;
	    this.get(function() {});
	  },

	  /**
	   * Loads the credentials from the {filename} on disk.
	   *
	   * @callback callback function(err)
	   *   Called after the JSON file on disk is read and parsed. When this callback
	   *   is called with no error, it means that the credentials information
	   *   has been loaded into the object (as the `accessKeyId`, `secretAccessKey`,
	   *   and `sessionToken` properties).
	   *   @param err [Error] if an error occurred, this value will be filled
	   * @see get
	   */
	  refresh: function refresh(callback) {
	    if (!callback) callback = function(err) { if (err) throw err; };
	    try {
	      var creds = JSON.parse(AWS.util.readFileSync(this.filename));
	      AWS.Credentials.call(this, creds);
	      if (!this.accessKeyId || !this.secretAccessKey) {
	        throw AWS.util.error(
	          new Error('Credentials not set in ' + this.filename),
	        { code: 'FileSystemCredentialsProviderFailure' }
	        );
	      }
	      this.expired = false;
	      callback();
	    } catch (err) {
	      callback(err);
	    }
	  }

	});


/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(93);
	var path = __webpack_require__(232);
	var STS = __webpack_require__(180);

	/**
	 * Represents credentials loaded from shared credentials file
	 * (defaulting to ~/.aws/credentials).
	 *
	 * ## Using the shared credentials file
	 *
	 * This provider is checked by default in the Node.js environment. To use the
	 * credentials file provider, simply add your access and secret keys to the
	 * ~/.aws/credentials file in the following format:
	 *
	 *     [default]
	 *     aws_access_key_id = AKID...
	 *     aws_secret_access_key = YOUR_SECRET_KEY
	 *
	 * ## Using custom profiles
	 *
	 * The SDK supports loading credentials for separate profiles. This can be done
	 * in two ways:
	 *
	 * 1. Set the `AWS_PROFILE` environment variable in your process prior to
	 *    loading the SDK.
	 * 2. Directly load the AWS.SharedIniFileCredentials provider:
	 *
	 * ```javascript
	 * var creds = new AWS.SharedIniFileCredentials({profile: 'myprofile'});
	 * AWS.config.credentials = creds;
	 * ```
	 *
	 * @!macro nobrowser
	 */
	AWS.SharedIniFileCredentials = AWS.util.inherit(AWS.Credentials, {
	  /**
	   * Creates a new SharedIniFileCredentials object.
	   *
	   * @param options [map] a set of options
	   * @option options profile [String] (AWS_PROFILE env var or 'default')
	   *   the name of the profile to load.
	   * @option options filename [String] ('~/.aws/credentials') the filename
	   *   to use when loading credentials.
	   * @option options disableAssumeRole [Boolean] (false) True to disable
	   *   support for profiles that assume an IAM role. If true, and an assume
	   *   role profile is selected, an error is raised.
	   */
	  constructor: function SharedIniFileCredentials(options) {
	    AWS.Credentials.call(this);

	    options = options || {};

	    this.filename = options.filename;
	    this.profile = options.profile || process.env.AWS_PROFILE || 'default';
	    this.disableAssumeRole = !!options.disableAssumeRole;
	    this.get(function() {});
	  },

	  /**
	   * Loads the credentials from the shared credentials file
	   *
	   * @callback callback function(err)
	   *   Called after the shared INI file on disk is read and parsed. When this
	   *   callback is called with no error, it means that the credentials
	   *   information has been loaded into the object (as the `accessKeyId`,
	   *   `secretAccessKey`, and `sessionToken` properties).
	   *   @param err [Error] if an error occurred, this value will be filled
	   * @see get
	   */
	  refresh: function refresh(callback) {
	    if (!callback) callback = function(err) { if (err) throw err; };
	    try {
	      if (!this.filename) this.loadDefaultFilename();
	      var creds = AWS.util.ini.parse(AWS.util.readFileSync(this.filename));
	      var profile = creds[this.profile];

	      if (typeof profile !== 'object') {
	        throw AWS.util.error(
	          new Error('Profile ' + this.profile + ' not found in ' + this.filename),
	          { code: 'SharedIniFileCredentialsProviderFailure' }
	        );
	      }

	      if (profile['role_arn']) {
	        this.loadRoleProfile(creds, profile, callback);
	        return;
	      }

	      this.accessKeyId = profile['aws_access_key_id'];
	      this.secretAccessKey = profile['aws_secret_access_key'];
	      this.sessionToken = profile['aws_session_token'];

	      if (!this.accessKeyId || !this.secretAccessKey) {
	        throw AWS.util.error(
	          new Error('Credentials not set in ' + this.filename +
	                    ' using profile ' + this.profile),
	          { code: 'SharedIniFileCredentialsProviderFailure' }
	        );
	      }
	      this.expired = false;
	      callback();
	    } catch (err) {
	      callback(err);
	    }
	  },

	  /**
	   * @api private
	   */
	  loadRoleProfile: function loadRoleProfile(creds, roleProfile, callback) {
	    if (this.disableAssumeRole) {
	      throw AWS.util.error(
	        new Error('Role assumption profiles are disabled. ' +
	                  'Failed to load profile ' + this.profile + ' from ' +
	                  this.filename),
	        { code: 'SharedIniFileCredentialsProviderFailure' }
	      );
	    }

	    var self = this;
	    var roleArn = roleProfile['role_arn'];
	    var roleSessionName = roleProfile['role_session_name'];
	    var externalId = roleProfile['external_id'];
	    var sourceProfileName = roleProfile['source_profile'];

	    if (!sourceProfileName) {
	      throw AWS.util.error(
	        new Error('source_profile is not set in ' + this.filename +
	                  ' using profile ' + this.profile),
	        { code: 'SharedIniFileCredentialsProviderFailure' }
	      );
	    }

	    var sourceProfile = creds[sourceProfileName];

	    if (typeof sourceProfile !== 'object') {
	      throw AWS.util.error(
	        new Error('source_profile ' + sourceProfileName + ' set in ' +
	                  this.filename + ' using profile ' + this.profile +
	                  ' does not exist'),
	        { code: 'SharedIniFileCredentialsProviderFailure' }
	      );
	    }

	    var sourceCredentials = {
	      accessKeyId: sourceProfile['aws_access_key_id'],
	      secretAccessKey: sourceProfile['aws_secret_access_key'],
	      sessionToken: sourceProfile['aws_session_token']
	    };

	    if (!sourceCredentials.accessKeyId || !sourceCredentials.secretAccessKey) {
	      throw AWS.util.error(
	        new Error('Credentials not set in source_profile ' +
	                  sourceProfileName + ' set in ' + this.filename +
	                  ' using profile ' + this.profile),
	        { code: 'SharedIniFileCredentialsProviderFailure' }
	      );
	    }

	    var sts = new STS({
	      credentials: new AWS.Credentials(sourceCredentials)
	    });

	    var roleParams = {
	      RoleArn: roleArn,
	      RoleSessionName: roleSessionName || 'aws-sdk-js-' + Date.now()
	    };

	    if (externalId) {
	      roleParams.ExternalId = externalId;
	    }

	    sts.assumeRole(roleParams, function (err, data) {
	      if (err) {
	        callback(err);
	        return;
	      }

	      self.accessKeyId = data.Credentials.AccessKeyId;
	      self.secretAccessKey = data.Credentials.SecretAccessKey;
	      self.sessionToken = data.Credentials.SessionToken;
	      self.expireTime = data.Credentials.Expiration;
	      callback();
	    });
	  },

	  /**
	   * @api private
	   */
	  loadDefaultFilename: function loadDefaultFilename() {
	    var env = process.env;
	    var home = env.HOME ||
	               env.USERPROFILE ||
	               (env.HOMEPATH ? ((env.HOMEDRIVE || 'C:/') + env.HOMEPATH) : null);
	    if (!home) {
	      throw AWS.util.error(
	        new Error('Cannot load credentials, HOME path not set'),
	        { code: 'SharedIniFileCredentialsProviderFailure' }
	      );
	    }

	    this.filename = path.join(home, '.aws', 'credentials');
	  }
	});


/***/ },
/* 232 */
/***/ function(module, exports) {

	module.exports = require("path");

/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);

	module.exports = {
	  ACM: __webpack_require__(234),
	  APIGateway: __webpack_require__(237),
	  ApplicationAutoScaling: __webpack_require__(241),
	  AutoScaling: __webpack_require__(244),
	  Budgets: __webpack_require__(247),
	  CloudFormation: __webpack_require__(249),
	  CloudFront: __webpack_require__(253),
	  CloudHSM: __webpack_require__(259),
	  CloudSearch: __webpack_require__(261),
	  CloudSearchDomain: __webpack_require__(266),
	  CloudTrail: __webpack_require__(269),
	  CloudWatch: __webpack_require__(272),
	  CloudWatchEvents: __webpack_require__(276),
	  CloudWatchLogs: __webpack_require__(278),
	  CodeCommit: __webpack_require__(281),
	  CodeDeploy: __webpack_require__(284),
	  CodePipeline: __webpack_require__(288),
	  CognitoIdentity: __webpack_require__(186),
	  CognitoIdentityServiceProvider: __webpack_require__(290),
	  CognitoSync: __webpack_require__(292),
	  ConfigService: __webpack_require__(294),
	  DataPipeline: __webpack_require__(297),
	  DeviceFarm: __webpack_require__(300),
	  DirectConnect: __webpack_require__(303),
	  DirectoryService: __webpack_require__(306),
	  Discovery: __webpack_require__(308),
	  DMS: __webpack_require__(310),
	  DynamoDB: __webpack_require__(312),
	  DynamoDBStreams: __webpack_require__(325),
	  EC2: __webpack_require__(327),
	  ECR: __webpack_require__(332),
	  ECS: __webpack_require__(335),
	  EFS: __webpack_require__(339),
	  ElastiCache: __webpack_require__(341),
	  ElasticBeanstalk: __webpack_require__(345),
	  ELB: __webpack_require__(348),
	  ELBv2: __webpack_require__(352),
	  EMR: __webpack_require__(355),
	  ES: __webpack_require__(359),
	  ElasticTranscoder: __webpack_require__(361),
	  Firehose: __webpack_require__(365),
	  GameLift: __webpack_require__(367),
	  Glacier: __webpack_require__(369),
	  IAM: __webpack_require__(374),
	  ImportExport: __webpack_require__(378),
	  Inspector: __webpack_require__(381),
	  Iot: __webpack_require__(383),
	  IotData: __webpack_require__(385),
	  Kinesis: __webpack_require__(388),
	  KinesisAnalytics: __webpack_require__(392),
	  KMS: __webpack_require__(394),
	  Lambda: __webpack_require__(397),
	  MachineLearning: __webpack_require__(402),
	  MarketplaceCommerceAnalytics: __webpack_require__(407),
	  MarketplaceMetering: __webpack_require__(409),
	  MobileAnalytics: __webpack_require__(411),
	  OpsWorks: __webpack_require__(413),
	  RDS: __webpack_require__(417),
	  Redshift: __webpack_require__(428),
	  Route53: __webpack_require__(432),
	  Route53Domains: __webpack_require__(437),
	  S3: __webpack_require__(440),
	  ServiceCatalog: __webpack_require__(446),
	  SES: __webpack_require__(448),
	  SimpleDB: __webpack_require__(452),
	  SMS: __webpack_require__(455),
	  Snowball: __webpack_require__(458),
	  SNS: __webpack_require__(461),
	  SQS: __webpack_require__(464),
	  SSM: __webpack_require__(468),
	  StorageGateway: __webpack_require__(471),
	  STS: __webpack_require__(180),
	  Support: __webpack_require__(474),
	  SWF: __webpack_require__(477),
	  WAF: __webpack_require__(481),
	  WorkSpaces: __webpack_require__(483)
	};

/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['acm'] = {};
	AWS.ACM = Service.defineService('acm', ['2015-12-08']);
	Object.defineProperty(apiLoader.services['acm'], '2015-12-08', {
	  get: function get() {
	    var model = __webpack_require__(235);
	    model.paginators = __webpack_require__(236).pagination;
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.ACM;


/***/ },
/* 235 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2015-12-08",
			"endpointPrefix": "acm",
			"jsonVersion": "1.1",
			"protocol": "json",
			"serviceAbbreviation": "ACM",
			"serviceFullName": "AWS Certificate Manager",
			"signatureVersion": "v4",
			"targetPrefix": "CertificateManager"
		},
		"operations": {
			"AddTagsToCertificate": {
				"input": {
					"type": "structure",
					"required": [
						"CertificateArn",
						"Tags"
					],
					"members": {
						"CertificateArn": {},
						"Tags": {
							"shape": "S3"
						}
					}
				}
			},
			"DeleteCertificate": {
				"input": {
					"type": "structure",
					"required": [
						"CertificateArn"
					],
					"members": {
						"CertificateArn": {}
					}
				}
			},
			"DescribeCertificate": {
				"input": {
					"type": "structure",
					"required": [
						"CertificateArn"
					],
					"members": {
						"CertificateArn": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Certificate": {
							"type": "structure",
							"members": {
								"CertificateArn": {},
								"DomainName": {},
								"SubjectAlternativeNames": {
									"shape": "Sc"
								},
								"DomainValidationOptions": {
									"type": "list",
									"member": {
										"type": "structure",
										"required": [
											"DomainName"
										],
										"members": {
											"DomainName": {},
											"ValidationEmails": {
												"type": "list",
												"member": {}
											},
											"ValidationDomain": {}
										}
									}
								},
								"Serial": {},
								"Subject": {},
								"Issuer": {},
								"CreatedAt": {
									"type": "timestamp"
								},
								"IssuedAt": {
									"type": "timestamp"
								},
								"ImportedAt": {
									"type": "timestamp"
								},
								"Status": {},
								"RevokedAt": {
									"type": "timestamp"
								},
								"RevocationReason": {},
								"NotBefore": {
									"type": "timestamp"
								},
								"NotAfter": {
									"type": "timestamp"
								},
								"KeyAlgorithm": {},
								"SignatureAlgorithm": {},
								"InUseBy": {
									"type": "list",
									"member": {}
								},
								"FailureReason": {},
								"Type": {}
							}
						}
					}
				}
			},
			"GetCertificate": {
				"input": {
					"type": "structure",
					"required": [
						"CertificateArn"
					],
					"members": {
						"CertificateArn": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Certificate": {},
						"CertificateChain": {}
					}
				}
			},
			"ImportCertificate": {
				"input": {
					"type": "structure",
					"required": [
						"Certificate",
						"PrivateKey"
					],
					"members": {
						"CertificateArn": {},
						"Certificate": {
							"type": "blob"
						},
						"PrivateKey": {
							"type": "blob",
							"sensitive": true
						},
						"CertificateChain": {
							"type": "blob"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"CertificateArn": {}
					}
				}
			},
			"ListCertificates": {
				"input": {
					"type": "structure",
					"members": {
						"CertificateStatuses": {
							"type": "list",
							"member": {}
						},
						"NextToken": {},
						"MaxItems": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"NextToken": {},
						"CertificateSummaryList": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"CertificateArn": {},
									"DomainName": {}
								}
							}
						}
					}
				}
			},
			"ListTagsForCertificate": {
				"input": {
					"type": "structure",
					"required": [
						"CertificateArn"
					],
					"members": {
						"CertificateArn": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Tags": {
							"shape": "S3"
						}
					}
				}
			},
			"RemoveTagsFromCertificate": {
				"input": {
					"type": "structure",
					"required": [
						"CertificateArn",
						"Tags"
					],
					"members": {
						"CertificateArn": {},
						"Tags": {
							"shape": "S3"
						}
					}
				}
			},
			"RequestCertificate": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName"
					],
					"members": {
						"DomainName": {},
						"SubjectAlternativeNames": {
							"shape": "Sc"
						},
						"IdempotencyToken": {},
						"DomainValidationOptions": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"DomainName",
									"ValidationDomain"
								],
								"members": {
									"DomainName": {},
									"ValidationDomain": {}
								}
							}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"CertificateArn": {}
					}
				}
			},
			"ResendValidationEmail": {
				"input": {
					"type": "structure",
					"required": [
						"CertificateArn",
						"Domain",
						"ValidationDomain"
					],
					"members": {
						"CertificateArn": {},
						"Domain": {},
						"ValidationDomain": {}
					}
				}
			}
		},
		"shapes": {
			"S3": {
				"type": "list",
				"member": {
					"type": "structure",
					"required": [
						"Key"
					],
					"members": {
						"Key": {},
						"Value": {}
					}
				}
			},
			"Sc": {
				"type": "list",
				"member": {}
			}
		}
	};

/***/ },
/* 236 */
/***/ function(module, exports) {

	module.exports = {
		"pagination": {
			"ListCertificates": {
				"limit_key": "MaxItems",
				"input_token": "NextToken",
				"output_token": "NextToken",
				"result_key": "CertificateSummaryList"
			}
		}
	};

/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['apigateway'] = {};
	AWS.APIGateway = Service.defineService('apigateway', ['2015-07-09']);
	__webpack_require__(238);
	Object.defineProperty(apiLoader.services['apigateway'], '2015-07-09', {
	  get: function get() {
	    var model = __webpack_require__(239);
	    model.paginators = __webpack_require__(240).pagination;
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.APIGateway;


/***/ },
/* 238 */
/***/ function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(93);

	AWS.util.update(AWS.APIGateway.prototype, {
	/**
	 * Sets the Accept header to application/json.
	 *
	 * @api private
	 */
	  setAcceptHeader: function setAcceptHeader(req) {
	    var httpRequest = req.httpRequest;
	    httpRequest.headers['Accept'] = 'application/json';
	  },

	  /**
	   * @api private
	   */
	  setupRequestListeners: function setupRequestListeners(request) {
	    request.addListener('build', this.setAcceptHeader);
	    if (request.operation === 'getSdk') {
	      request.addListener('extractData', this.useRawPayload);
	    }
	  },

	  useRawPayload: function useRawPayload(resp) {
	    var req = resp.request;
	    var operation = req.operation;
	    var rules = req.service.api.operations[operation].output || {};
	    if (rules.payload) {
	      var body = resp.httpResponse.body;
	      resp.data[rules.payload] = body;
	    }
	  }
	});



/***/ },
/* 239 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2015-07-09",
			"endpointPrefix": "apigateway",
			"protocol": "rest-json",
			"serviceFullName": "Amazon API Gateway",
			"signatureVersion": "v4"
		},
		"operations": {
			"CreateApiKey": {
				"http": {
					"requestUri": "/apikeys",
					"responseCode": 201
				},
				"input": {
					"type": "structure",
					"members": {
						"name": {},
						"description": {},
						"enabled": {
							"type": "boolean"
						},
						"generateDistinctId": {
							"type": "boolean"
						},
						"value": {},
						"stageKeys": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"restApiId": {},
									"stageName": {}
								}
							}
						}
					}
				},
				"output": {
					"shape": "S6"
				}
			},
			"CreateAuthorizer": {
				"http": {
					"requestUri": "/restapis/{restapi_id}/authorizers",
					"responseCode": 201
				},
				"input": {
					"type": "structure",
					"required": [
						"restApiId",
						"name",
						"type",
						"identitySource"
					],
					"members": {
						"restApiId": {
							"location": "uri",
							"locationName": "restapi_id"
						},
						"name": {},
						"type": {},
						"providerARNs": {
							"shape": "Sb"
						},
						"authType": {},
						"authorizerUri": {},
						"authorizerCredentials": {},
						"identitySource": {},
						"identityValidationExpression": {},
						"authorizerResultTtlInSeconds": {
							"type": "integer"
						}
					}
				},
				"output": {
					"shape": "Se"
				}
			},
			"CreateBasePathMapping": {
				"http": {
					"requestUri": "/domainnames/{domain_name}/basepathmappings",
					"responseCode": 201
				},
				"input": {
					"type": "structure",
					"required": [
						"domainName",
						"restApiId"
					],
					"members": {
						"domainName": {
							"location": "uri",
							"locationName": "domain_name"
						},
						"basePath": {},
						"restApiId": {},
						"stage": {}
					}
				},
				"output": {
					"shape": "Sg"
				}
			},
			"CreateDeployment": {
				"http": {
					"requestUri": "/restapis/{restapi_id}/deployments",
					"responseCode": 201
				},
				"input": {
					"type": "structure",
					"required": [
						"restApiId",
						"stageName"
					],
					"members": {
						"restApiId": {
							"location": "uri",
							"locationName": "restapi_id"
						},
						"stageName": {},
						"stageDescription": {},
						"description": {},
						"cacheClusterEnabled": {
							"type": "boolean"
						},
						"cacheClusterSize": {},
						"variables": {
							"shape": "Sk"
						}
					}
				},
				"output": {
					"shape": "Sl"
				}
			},
			"CreateDomainName": {
				"http": {
					"requestUri": "/domainnames",
					"responseCode": 201
				},
				"input": {
					"type": "structure",
					"required": [
						"domainName",
						"certificateName",
						"certificateBody",
						"certificatePrivateKey",
						"certificateChain"
					],
					"members": {
						"domainName": {},
						"certificateName": {},
						"certificateBody": {},
						"certificatePrivateKey": {},
						"certificateChain": {}
					}
				},
				"output": {
					"shape": "Sq"
				}
			},
			"CreateModel": {
				"http": {
					"requestUri": "/restapis/{restapi_id}/models",
					"responseCode": 201
				},
				"input": {
					"type": "structure",
					"required": [
						"restApiId",
						"name",
						"contentType"
					],
					"members": {
						"restApiId": {
							"location": "uri",
							"locationName": "restapi_id"
						},
						"name": {},
						"description": {},
						"schema": {},
						"contentType": {}
					}
				},
				"output": {
					"shape": "Ss"
				}
			},
			"CreateResource": {
				"http": {
					"requestUri": "/restapis/{restapi_id}/resources/{parent_id}",
					"responseCode": 201
				},
				"input": {
					"type": "structure",
					"required": [
						"restApiId",
						"parentId",
						"pathPart"
					],
					"members": {
						"restApiId": {
							"location": "uri",
							"locationName": "restapi_id"
						},
						"parentId": {
							"location": "uri",
							"locationName": "parent_id"
						},
						"pathPart": {}
					}
				},
				"output": {
					"shape": "Su"
				}
			},
			"CreateRestApi": {
				"http": {
					"requestUri": "/restapis",
					"responseCode": 201
				},
				"input": {
					"type": "structure",
					"required": [
						"name"
					],
					"members": {
						"name": {},
						"description": {},
						"cloneFrom": {}
					}
				},
				"output": {
					"shape": "S16"
				}
			},
			"CreateStage": {
				"http": {
					"requestUri": "/restapis/{restapi_id}/stages",
					"responseCode": 201
				},
				"input": {
					"type": "structure",
					"required": [
						"restApiId",
						"stageName",
						"deploymentId"
					],
					"members": {
						"restApiId": {
							"location": "uri",
							"locationName": "restapi_id"
						},
						"stageName": {},
						"deploymentId": {},
						"description": {},
						"cacheClusterEnabled": {
							"type": "boolean"
						},
						"cacheClusterSize": {},
						"variables": {
							"shape": "Sk"
						}
					}
				},
				"output": {
					"shape": "S18"
				}
			},
			"CreateUsagePlan": {
				"http": {
					"requestUri": "/usageplans",
					"responseCode": 201
				},
				"input": {
					"type": "structure",
					"required": [
						"name"
					],
					"members": {
						"name": {},
						"description": {},
						"apiStages": {
							"shape": "S1g"
						},
						"throttle": {
							"shape": "S1i"
						},
						"quota": {
							"shape": "S1j"
						}
					}
				},
				"output": {
					"shape": "S1l"
				}
			},
			"CreateUsagePlanKey": {
				"http": {
					"requestUri": "/usageplans/{usageplanId}/keys",
					"responseCode": 201
				},
				"input": {
					"type": "structure",
					"required": [
						"usagePlanId",
						"keyId",
						"keyType"
					],
					"members": {
						"usagePlanId": {
							"location": "uri",
							"locationName": "usageplanId"
						},
						"keyId": {},
						"keyType": {}
					}
				},
				"output": {
					"shape": "S1n"
				}
			},
			"DeleteApiKey": {
				"http": {
					"method": "DELETE",
					"requestUri": "/apikeys/{api_Key}",
					"responseCode": 202
				},
				"input": {
					"type": "structure",
					"required": [
						"apiKey"
					],
					"members": {
						"apiKey": {
							"location": "uri",
							"locationName": "api_Key"
						}
					}
				}
			},
			"DeleteAuthorizer": {
				"http": {
					"method": "DELETE",
					"requestUri": "/restapis/{restapi_id}/authorizers/{authorizer_id}",
					"responseCode": 202
				},
				"input": {
					"type": "structure",
					"required": [
						"restApiId",
						"authorizerId"
					],
					"members": {
						"restApiId": {
							"location": "uri",
							"locationName": "restapi_id"
						},
						"authorizerId": {
							"location": "uri",
							"locationName": "authorizer_id"
						}
					}
				}
			},
			"DeleteBasePathMapping": {
				"http": {
					"method": "DELETE",
					"requestUri": "/domainnames/{domain_name}/basepathmappings/{base_path}",
					"responseCode": 202
				},
				"input": {
					"type": "structure",
					"required": [
						"domainName",
						"basePath"
					],
					"members": {
						"domainName": {
							"location": "uri",
							"locationName": "domain_name"
						},
						"basePath": {
							"location": "uri",
							"locationName": "base_path"
						}
					}
				}
			},
			"DeleteClientCertificate": {
				"http": {
					"method": "DELETE",
					"requestUri": "/clientcertificates/{clientcertificate_id}",
					"responseCode": 202
				},
				"input": {
					"type": "structure",
					"required": [
						"clientCertificateId"
					],
					"members": {
						"clientCertificateId": {
							"location": "uri",
							"locationName": "clientcertificate_id"
						}
					}
				}
			},
			"DeleteDeployment": {
				"http": {
					"method": "DELETE",
					"requestUri": "/restapis/{restapi_id}/deployments/{deployment_id}",
					"responseCode": 202
				},
				"input": {
					"type": "structure",
					"required": [
						"restApiId",
						"deploymentId"
					],
					"members": {
						"restApiId": {
							"location": "uri",
							"locationName": "restapi_id"
						},
						"deploymentId": {
							"location": "uri",
							"locationName": "deployment_id"
						}
					}
				}
			},
			"DeleteDomainName": {
				"http": {
					"method": "DELETE",
					"requestUri": "/domainnames/{domain_name}",
					"responseCode": 202
				},
				"input": {
					"type": "structure",
					"required": [
						"domainName"
					],
					"members": {
						"domainName": {
							"location": "uri",
							"locationName": "domain_name"
						}
					}
				}
			},
			"DeleteIntegration": {
				"http": {
					"method": "DELETE",
					"requestUri": "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/integration",
					"responseCode": 204
				},
				"input": {
					"type": "structure",
					"required": [
						"restApiId",
						"resourceId",
						"httpMethod"
					],
					"members": {
						"restApiId": {
							"location": "uri",
							"locationName": "restapi_id"
						},
						"resourceId": {
							"location": "uri",
							"locationName": "resource_id"
						},
						"httpMethod": {
							"location": "uri",
							"locationName": "http_method"
						}
					}
				}
			},
			"DeleteIntegrationResponse": {
				"http": {
					"method": "DELETE",
					"requestUri": "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/integration/responses/{status_code}",
					"responseCode": 204
				},
				"input": {
					"type": "structure",
					"required": [
						"restApiId",
						"resourceId",
						"httpMethod",
						"statusCode"
					],
					"members": {
						"restApiId": {
							"location": "uri",
							"locationName": "restapi_id"
						},
						"resourceId": {
							"location": "uri",
							"locationName": "resource_id"
						},
						"httpMethod": {
							"location": "uri",
							"locationName": "http_method"
						},
						"statusCode": {
							"location": "uri",
							"locationName": "status_code"
						}
					}
				}
			},
			"DeleteMethod": {
				"http": {
					"method": "DELETE",
					"requestUri": "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}",
					"responseCode": 204
				},
				"input": {
					"type": "structure",
					"required": [
						"restApiId",
						"resourceId",
						"httpMethod"
					],
					"members": {
						"restApiId": {
							"location": "uri",
							"locationName": "restapi_id"
						},
						"resourceId": {
							"location": "uri",
							"locationName": "resource_id"
						},
						"httpMethod": {
							"location": "uri",
							"locationName": "http_method"
						}
					}
				}
			},
			"DeleteMethodResponse": {
				"http": {
					"method": "DELETE",
					"requestUri": "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/responses/{status_code}",
					"responseCode": 204
				},
				"input": {
					"type": "structure",
					"required": [
						"restApiId",
						"resourceId",
						"httpMethod",
						"statusCode"
					],
					"members": {
						"restApiId": {
							"location": "uri",
							"locationName": "restapi_id"
						},
						"resourceId": {
							"location": "uri",
							"locationName": "resource_id"
						},
						"httpMethod": {
							"location": "uri",
							"locationName": "http_method"
						},
						"statusCode": {
							"location": "uri",
							"locationName": "status_code"
						}
					}
				}
			},
			"DeleteModel": {
				"http": {
					"method": "DELETE",
					"requestUri": "/restapis/{restapi_id}/models/{model_name}",
					"responseCode": 202
				},
				"input": {
					"type": "structure",
					"required": [
						"restApiId",
						"modelName"
					],
					"members": {
						"restApiId": {
							"location": "uri",
							"locationName": "restapi_id"
						},
						"modelName": {
							"location": "uri",
							"locationName": "model_name"
						}
					}
				}
			},
			"DeleteResource": {
				"http": {
					"method": "DELETE",
					"requestUri": "/restapis/{restapi_id}/resources/{resource_id}",
					"responseCode": 202
				},
				"input": {
					"type": "structure",
					"required": [
						"restApiId",
						"resourceId"
					],
					"members": {
						"restApiId": {
							"location": "uri",
							"locationName": "restapi_id"
						},
						"resourceId": {
							"location": "uri",
							"locationName": "resource_id"
						}
					}
				}
			},
			"DeleteRestApi": {
				"http": {
					"method": "DELETE",
					"requestUri": "/restapis/{restapi_id}",
					"responseCode": 202
				},
				"input": {
					"type": "structure",
					"required": [
						"restApiId"
					],
					"members": {
						"restApiId": {
							"location": "uri",
							"locationName": "restapi_id"
						}
					}
				}
			},
			"DeleteStage": {
				"http": {
					"method": "DELETE",
					"requestUri": "/restapis/{restapi_id}/stages/{stage_name}",
					"responseCode": 202
				},
				"input": {
					"type": "structure",
					"required": [
						"restApiId",
						"stageName"
					],
					"members": {
						"restApiId": {
							"location": "uri",
							"locationName": "restapi_id"
						},
						"stageName": {
							"location": "uri",
							"locationName": "stage_name"
						}
					}
				}
			},
			"DeleteUsagePlan": {
				"http": {
					"method": "DELETE",
					"requestUri": "/usageplans/{usageplanId}",
					"responseCode": 202
				},
				"input": {
					"type": "structure",
					"required": [
						"usagePlanId"
					],
					"members": {
						"usagePlanId": {
							"location": "uri",
							"locationName": "usageplanId"
						}
					}
				}
			},
			"DeleteUsagePlanKey": {
				"http": {
					"method": "DELETE",
					"requestUri": "/usageplans/{usageplanId}/keys/{keyId}",
					"responseCode": 202
				},
				"input": {
					"type": "structure",
					"required": [
						"usagePlanId",
						"keyId"
					],
					"members": {
						"usagePlanId": {
							"location": "uri",
							"locationName": "usageplanId"
						},
						"keyId": {
							"location": "uri",
							"locationName": "keyId"
						}
					}
				}
			},
			"FlushStageAuthorizersCache": {
				"http": {
					"method": "DELETE",
					"requestUri": "/restapis/{restapi_id}/stages/{stage_name}/cache/authorizers",
					"responseCode": 202
				},
				"input": {
					"type": "structure",
					"required": [
						"restApiId",
						"stageName"
					],
					"members": {
						"restApiId": {
							"location": "uri",
							"locationName": "restapi_id"
						},
						"stageName": {
							"location": "uri",
							"locationName": "stage_name"
						}
					}
				}
			},
			"FlushStageCache": {
				"http": {
					"method": "DELETE",
					"requestUri": "/restapis/{restapi_id}/stages/{stage_name}/cache/data",
					"responseCode": 202
				},
				"input": {
					"type": "structure",
					"required": [
						"restApiId",
						"stageName"
					],
					"members": {
						"restApiId": {
							"location": "uri",
							"locationName": "restapi_id"
						},
						"stageName": {
							"location": "uri",
							"locationName": "stage_name"
						}
					}
				}
			},
			"GenerateClientCertificate": {
				"http": {
					"requestUri": "/clientcertificates",
					"responseCode": 201
				},
				"input": {
					"type": "structure",
					"members": {
						"description": {}
					}
				},
				"output": {
					"shape": "S27"
				}
			},
			"GetAccount": {
				"http": {
					"method": "GET",
					"requestUri": "/account"
				},
				"input": {
					"type": "structure",
					"members": {}
				},
				"output": {
					"shape": "S29"
				}
			},
			"GetApiKey": {
				"http": {
					"method": "GET",
					"requestUri": "/apikeys/{api_Key}"
				},
				"input": {
					"type": "structure",
					"required": [
						"apiKey"
					],
					"members": {
						"apiKey": {
							"location": "uri",
							"locationName": "api_Key"
						},
						"includeValue": {
							"location": "querystring",
							"locationName": "includeValue",
							"type": "boolean"
						}
					}
				},
				"output": {
					"shape": "S6"
				}
			},
			"GetApiKeys": {
				"http": {
					"method": "GET",
					"requestUri": "/apikeys"
				},
				"input": {
					"type": "structure",
					"members": {
						"position": {
							"location": "querystring",
							"locationName": "position"
						},
						"limit": {
							"location": "querystring",
							"locationName": "limit",
							"type": "integer"
						},
						"nameQuery": {
							"location": "querystring",
							"locationName": "name"
						},
						"includeValues": {
							"location": "querystring",
							"locationName": "includeValues",
							"type": "boolean"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"warnings": {
							"shape": "S8"
						},
						"position": {},
						"items": {
							"locationName": "item",
							"type": "list",
							"member": {
								"shape": "S6"
							}
						}
					}
				}
			},
			"GetAuthorizer": {
				"http": {
					"method": "GET",
					"requestUri": "/restapis/{restapi_id}/authorizers/{authorizer_id}"
				},
				"input": {
					"type": "structure",
					"required": [
						"restApiId",
						"authorizerId"
					],
					"members": {
						"restApiId": {
							"location": "uri",
							"locationName": "restapi_id"
						},
						"authorizerId": {
							"location": "uri",
							"locationName": "authorizer_id"
						}
					}
				},
				"output": {
					"shape": "Se"
				}
			},
			"GetAuthorizers": {
				"http": {
					"method": "GET",
					"requestUri": "/restapis/{restapi_id}/authorizers"
				},
				"input": {
					"type": "structure",
					"required": [
						"restApiId"
					],
					"members": {
						"restApiId": {
							"location": "uri",
							"locationName": "restapi_id"
						},
						"position": {
							"location": "querystring",
							"locationName": "position"
						},
						"limit": {
							"location": "querystring",
							"locationName": "limit",
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"position": {},
						"items": {
							"locationName": "item",
							"type": "list",
							"member": {
								"shape": "Se"
							}
						}
					}
				}
			},
			"GetBasePathMapping": {
				"http": {
					"method": "GET",
					"requestUri": "/domainnames/{domain_name}/basepathmappings/{base_path}"
				},
				"input": {
					"type": "structure",
					"required": [
						"domainName",
						"basePath"
					],
					"members": {
						"domainName": {
							"location": "uri",
							"locationName": "domain_name"
						},
						"basePath": {
							"location": "uri",
							"locationName": "base_path"
						}
					}
				},
				"output": {
					"shape": "Sg"
				}
			},
			"GetBasePathMappings": {
				"http": {
					"method": "GET",
					"requestUri": "/domainnames/{domain_name}/basepathmappings"
				},
				"input": {
					"type": "structure",
					"required": [
						"domainName"
					],
					"members": {
						"domainName": {
							"location": "uri",
							"locationName": "domain_name"
						},
						"position": {
							"location": "querystring",
							"locationName": "position"
						},
						"limit": {
							"location": "querystring",
							"locationName": "limit",
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"position": {},
						"items": {
							"locationName": "item",
							"type": "list",
							"member": {
								"shape": "Sg"
							}
						}
					}
				}
			},
			"GetClientCertificate": {
				"http": {
					"method": "GET",
					"requestUri": "/clientcertificates/{clientcertificate_id}"
				},
				"input": {
					"type": "structure",
					"required": [
						"clientCertificateId"
					],
					"members": {
						"clientCertificateId": {
							"location": "uri",
							"locationName": "clientcertificate_id"
						}
					}
				},
				"output": {
					"shape": "S27"
				}
			},
			"GetClientCertificates": {
				"http": {
					"method": "GET",
					"requestUri": "/clientcertificates"
				},
				"input": {
					"type": "structure",
					"members": {
						"position": {
							"location": "querystring",
							"locationName": "position"
						},
						"limit": {
							"location": "querystring",
							"locationName": "limit",
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"position": {},
						"items": {
							"locationName": "item",
							"type": "list",
							"member": {
								"shape": "S27"
							}
						}
					}
				}
			},
			"GetDeployment": {
				"http": {
					"method": "GET",
					"requestUri": "/restapis/{restapi_id}/deployments/{deployment_id}"
				},
				"input": {
					"type": "structure",
					"required": [
						"restApiId",
						"deploymentId"
					],
					"members": {
						"restApiId": {
							"location": "uri",
							"locationName": "restapi_id"
						},
						"deploymentId": {
							"location": "uri",
							"locationName": "deployment_id"
						}
					}
				},
				"output": {
					"shape": "Sl"
				}
			},
			"GetDeployments": {
				"http": {
					"method": "GET",
					"requestUri": "/restapis/{restapi_id}/deployments"
				},
				"input": {
					"type": "structure",
					"required": [
						"restApiId"
					],
					"members": {
						"restApiId": {
							"location": "uri",
							"locationName": "restapi_id"
						},
						"position": {
							"location": "querystring",
							"locationName": "position"
						},
						"limit": {
							"location": "querystring",
							"locationName": "limit",
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"position": {},
						"items": {
							"locationName": "item",
							"type": "list",
							"member": {
								"shape": "Sl"
							}
						}
					}
				}
			},
			"GetDomainName": {
				"http": {
					"method": "GET",
					"requestUri": "/domainnames/{domain_name}"
				},
				"input": {
					"type": "structure",
					"required": [
						"domainName"
					],
					"members": {
						"domainName": {
							"location": "uri",
							"locationName": "domain_name"
						}
					}
				},
				"output": {
					"shape": "Sq"
				}
			},
			"GetDomainNames": {
				"http": {
					"method": "GET",
					"requestUri": "/domainnames"
				},
				"input": {
					"type": "structure",
					"members": {
						"position": {
							"location": "querystring",
							"locationName": "position"
						},
						"limit": {
							"location": "querystring",
							"locationName": "limit",
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"position": {},
						"items": {
							"locationName": "item",
							"type": "list",
							"member": {
								"shape": "Sq"
							}
						}
					}
				}
			},
			"GetExport": {
				"http": {
					"method": "GET",
					"requestUri": "/restapis/{restapi_id}/stages/{stage_name}/exports/{export_type}",
					"responseCode": 200
				},
				"input": {
					"type": "structure",
					"required": [
						"restApiId",
						"stageName",
						"exportType"
					],
					"members": {
						"restApiId": {
							"location": "uri",
							"locationName": "restapi_id"
						},
						"stageName": {
							"location": "uri",
							"locationName": "stage_name"
						},
						"exportType": {
							"location": "uri",
							"locationName": "export_type"
						},
						"parameters": {
							"shape": "Sk",
							"location": "querystring"
						},
						"accepts": {
							"location": "header",
							"locationName": "Accept"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"contentType": {
							"location": "header",
							"locationName": "Content-Type"
						},
						"contentDisposition": {
							"location": "header",
							"locationName": "Content-Disposition"
						},
						"body": {
							"type": "blob"
						}
					},
					"payload": "body"
				}
			},
			"GetIntegration": {
				"http": {
					"method": "GET",
					"requestUri": "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/integration"
				},
				"input": {
					"type": "structure",
					"required": [
						"restApiId",
						"resourceId",
						"httpMethod"
					],
					"members": {
						"restApiId": {
							"location": "uri",
							"locationName": "restapi_id"
						},
						"resourceId": {
							"location": "uri",
							"locationName": "resource_id"
						},
						"httpMethod": {
							"location": "uri",
							"locationName": "http_method"
						}
					}
				},
				"output": {
					"shape": "S11"
				}
			},
			"GetIntegrationResponse": {
				"http": {
					"method": "GET",
					"requestUri": "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/integration/responses/{status_code}"
				},
				"input": {
					"type": "structure",
					"required": [
						"restApiId",
						"resourceId",
						"httpMethod",
						"statusCode"
					],
					"members": {
						"restApiId": {
							"location": "uri",
							"locationName": "restapi_id"
						},
						"resourceId": {
							"location": "uri",
							"locationName": "resource_id"
						},
						"httpMethod": {
							"location": "uri",
							"locationName": "http_method"
						},
						"statusCode": {
							"location": "uri",
							"locationName": "status_code"
						}
					}
				},
				"output": {
					"shape": "S14"
				}
			},
			"GetMethod": {
				"http": {
					"method": "GET",
					"requestUri": "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}"
				},
				"input": {
					"type": "structure",
					"required": [
						"restApiId",
						"resourceId",
						"httpMethod"
					],
					"members": {
						"restApiId": {
							"location": "uri",
							"locationName": "restapi_id"
						},
						"resourceId": {
							"location": "uri",
							"locationName": "resource_id"
						},
						"httpMethod": {
							"location": "uri",
							"locationName": "http_method"
						}
					}
				},
				"output": {
					"shape": "Sw"
				}
			},
			"GetMethodResponse": {
				"http": {
					"method": "GET",
					"requestUri": "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/responses/{status_code}"
				},
				"input": {
					"type": "structure",
					"required": [
						"restApiId",
						"resourceId",
						"httpMethod",
						"statusCode"
					],
					"members": {
						"restApiId": {
							"location": "uri",
							"locationName": "restapi_id"
						},
						"resourceId": {
							"location": "uri",
							"locationName": "resource_id"
						},
						"httpMethod": {
							"location": "uri",
							"locationName": "http_method"
						},
						"statusCode": {
							"location": "uri",
							"locationName": "status_code"
						}
					}
				},
				"output": {
					"shape": "Sz"
				}
			},
			"GetModel": {
				"http": {
					"method": "GET",
					"requestUri": "/restapis/{restapi_id}/models/{model_name}"
				},
				"input": {
					"type": "structure",
					"required": [
						"restApiId",
						"modelName"
					],
					"members": {
						"restApiId": {
							"location": "uri",
							"locationName": "restapi_id"
						},
						"modelName": {
							"location": "uri",
							"locationName": "model_name"
						},
						"flatten": {
							"location": "querystring",
							"locationName": "flatten",
							"type": "boolean"
						}
					}
				},
				"output": {
					"shape": "Ss"
				}
			},
			"GetModelTemplate": {
				"http": {
					"method": "GET",
					"requestUri": "/restapis/{restapi_id}/models/{model_name}/default_template"
				},
				"input": {
					"type": "structure",
					"required": [
						"restApiId",
						"modelName"
					],
					"members": {
						"restApiId": {
							"location": "uri",
							"locationName": "restapi_id"
						},
						"modelName": {
							"location": "uri",
							"locationName": "model_name"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"value": {}
					}
				}
			},
			"GetModels": {
				"http": {
					"method": "GET",
					"requestUri": "/restapis/{restapi_id}/models"
				},
				"input": {
					"type": "structure",
					"required": [
						"restApiId"
					],
					"members": {
						"restApiId": {
							"location": "uri",
							"locationName": "restapi_id"
						},
						"position": {
							"location": "querystring",
							"locationName": "position"
						},
						"limit": {
							"location": "querystring",
							"locationName": "limit",
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"position": {},
						"items": {
							"locationName": "item",
							"type": "list",
							"member": {
								"shape": "Ss"
							}
						}
					}
				}
			},
			"GetResource": {
				"http": {
					"method": "GET",
					"requestUri": "/restapis/{restapi_id}/resources/{resource_id}"
				},
				"input": {
					"type": "structure",
					"required": [
						"restApiId",
						"resourceId"
					],
					"members": {
						"restApiId": {
							"location": "uri",
							"locationName": "restapi_id"
						},
						"resourceId": {
							"location": "uri",
							"locationName": "resource_id"
						}
					}
				},
				"output": {
					"shape": "Su"
				}
			},
			"GetResources": {
				"http": {
					"method": "GET",
					"requestUri": "/restapis/{restapi_id}/resources"
				},
				"input": {
					"type": "structure",
					"required": [
						"restApiId"
					],
					"members": {
						"restApiId": {
							"location": "uri",
							"locationName": "restapi_id"
						},
						"position": {
							"location": "querystring",
							"locationName": "position"
						},
						"limit": {
							"location": "querystring",
							"locationName": "limit",
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"position": {},
						"items": {
							"locationName": "item",
							"type": "list",
							"member": {
								"shape": "Su"
							}
						}
					}
				}
			},
			"GetRestApi": {
				"http": {
					"method": "GET",
					"requestUri": "/restapis/{restapi_id}"
				},
				"input": {
					"type": "structure",
					"required": [
						"restApiId"
					],
					"members": {
						"restApiId": {
							"location": "uri",
							"locationName": "restapi_id"
						}
					}
				},
				"output": {
					"shape": "S16"
				}
			},
			"GetRestApis": {
				"http": {
					"method": "GET",
					"requestUri": "/restapis"
				},
				"input": {
					"type": "structure",
					"members": {
						"position": {
							"location": "querystring",
							"locationName": "position"
						},
						"limit": {
							"location": "querystring",
							"locationName": "limit",
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"position": {},
						"items": {
							"locationName": "item",
							"type": "list",
							"member": {
								"shape": "S16"
							}
						}
					}
				}
			},
			"GetSdk": {
				"http": {
					"method": "GET",
					"requestUri": "/restapis/{restapi_id}/stages/{stage_name}/sdks/{sdk_type}",
					"responseCode": 200
				},
				"input": {
					"type": "structure",
					"required": [
						"restApiId",
						"stageName",
						"sdkType"
					],
					"members": {
						"restApiId": {
							"location": "uri",
							"locationName": "restapi_id"
						},
						"stageName": {
							"location": "uri",
							"locationName": "stage_name"
						},
						"sdkType": {
							"location": "uri",
							"locationName": "sdk_type"
						},
						"parameters": {
							"shape": "Sk",
							"location": "querystring"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"contentType": {
							"location": "header",
							"locationName": "Content-Type"
						},
						"contentDisposition": {
							"location": "header",
							"locationName": "Content-Disposition"
						},
						"body": {
							"type": "blob"
						}
					},
					"payload": "body"
				}
			},
			"GetStage": {
				"http": {
					"method": "GET",
					"requestUri": "/restapis/{restapi_id}/stages/{stage_name}"
				},
				"input": {
					"type": "structure",
					"required": [
						"restApiId",
						"stageName"
					],
					"members": {
						"restApiId": {
							"location": "uri",
							"locationName": "restapi_id"
						},
						"stageName": {
							"location": "uri",
							"locationName": "stage_name"
						}
					}
				},
				"output": {
					"shape": "S18"
				}
			},
			"GetStages": {
				"http": {
					"method": "GET",
					"requestUri": "/restapis/{restapi_id}/stages"
				},
				"input": {
					"type": "structure",
					"required": [
						"restApiId"
					],
					"members": {
						"restApiId": {
							"location": "uri",
							"locationName": "restapi_id"
						},
						"deploymentId": {
							"location": "querystring",
							"locationName": "deploymentId"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"item": {
							"type": "list",
							"member": {
								"shape": "S18"
							}
						}
					}
				}
			},
			"GetUsage": {
				"http": {
					"method": "GET",
					"requestUri": "/usageplans/{usageplanId}/usage"
				},
				"input": {
					"type": "structure",
					"required": [
						"usagePlanId",
						"startDate",
						"endDate"
					],
					"members": {
						"usagePlanId": {
							"location": "uri",
							"locationName": "usageplanId"
						},
						"keyId": {
							"location": "querystring",
							"locationName": "keyId"
						},
						"startDate": {
							"location": "querystring",
							"locationName": "startDate"
						},
						"endDate": {
							"location": "querystring",
							"locationName": "endDate"
						},
						"position": {
							"location": "querystring",
							"locationName": "position"
						},
						"limit": {
							"location": "querystring",
							"locationName": "limit",
							"type": "integer"
						}
					}
				},
				"output": {
					"shape": "S3q"
				}
			},
			"GetUsagePlan": {
				"http": {
					"method": "GET",
					"requestUri": "/usageplans/{usageplanId}"
				},
				"input": {
					"type": "structure",
					"required": [
						"usagePlanId"
					],
					"members": {
						"usagePlanId": {
							"location": "uri",
							"locationName": "usageplanId"
						}
					}
				},
				"output": {
					"shape": "S1l"
				}
			},
			"GetUsagePlanKey": {
				"http": {
					"method": "GET",
					"requestUri": "/usageplans/{usageplanId}/keys/{keyId}",
					"responseCode": 200
				},
				"input": {
					"type": "structure",
					"required": [
						"usagePlanId",
						"keyId"
					],
					"members": {
						"usagePlanId": {
							"location": "uri",
							"locationName": "usageplanId"
						},
						"keyId": {
							"location": "uri",
							"locationName": "keyId"
						}
					}
				},
				"output": {
					"shape": "S1n"
				}
			},
			"GetUsagePlanKeys": {
				"http": {
					"method": "GET",
					"requestUri": "/usageplans/{usageplanId}/keys"
				},
				"input": {
					"type": "structure",
					"required": [
						"usagePlanId"
					],
					"members": {
						"usagePlanId": {
							"location": "uri",
							"locationName": "usageplanId"
						},
						"position": {
							"location": "querystring",
							"locationName": "position"
						},
						"limit": {
							"location": "querystring",
							"locationName": "limit",
							"type": "integer"
						},
						"nameQuery": {
							"location": "querystring",
							"locationName": "name"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"position": {},
						"items": {
							"locationName": "item",
							"type": "list",
							"member": {
								"shape": "S1n"
							}
						}
					}
				}
			},
			"GetUsagePlans": {
				"http": {
					"method": "GET",
					"requestUri": "/usageplans"
				},
				"input": {
					"type": "structure",
					"members": {
						"position": {
							"location": "querystring",
							"locationName": "position"
						},
						"keyId": {
							"location": "querystring",
							"locationName": "keyId"
						},
						"limit": {
							"location": "querystring",
							"locationName": "limit",
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"position": {},
						"items": {
							"locationName": "item",
							"type": "list",
							"member": {
								"shape": "S1l"
							}
						}
					}
				}
			},
			"ImportApiKeys": {
				"http": {
					"requestUri": "/apikeys?mode=import",
					"responseCode": 201
				},
				"input": {
					"type": "structure",
					"required": [
						"body",
						"format"
					],
					"members": {
						"body": {
							"type": "blob"
						},
						"format": {
							"location": "querystring",
							"locationName": "format"
						},
						"failOnWarnings": {
							"location": "querystring",
							"locationName": "failonwarnings",
							"type": "boolean"
						}
					},
					"payload": "body"
				},
				"output": {
					"type": "structure",
					"members": {
						"ids": {
							"shape": "S8"
						},
						"warnings": {
							"shape": "S8"
						}
					}
				}
			},
			"ImportRestApi": {
				"http": {
					"requestUri": "/restapis?mode=import",
					"responseCode": 201
				},
				"input": {
					"type": "structure",
					"required": [
						"body"
					],
					"members": {
						"failOnWarnings": {
							"location": "querystring",
							"locationName": "failonwarnings",
							"type": "boolean"
						},
						"parameters": {
							"shape": "Sk",
							"location": "querystring"
						},
						"body": {
							"type": "blob"
						}
					},
					"payload": "body"
				},
				"output": {
					"shape": "S16"
				}
			},
			"PutIntegration": {
				"http": {
					"method": "PUT",
					"requestUri": "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/integration",
					"responseCode": 201
				},
				"input": {
					"type": "structure",
					"required": [
						"restApiId",
						"resourceId",
						"httpMethod",
						"type"
					],
					"members": {
						"restApiId": {
							"location": "uri",
							"locationName": "restapi_id"
						},
						"resourceId": {
							"location": "uri",
							"locationName": "resource_id"
						},
						"httpMethod": {
							"location": "uri",
							"locationName": "http_method"
						},
						"type": {},
						"integrationHttpMethod": {
							"locationName": "httpMethod"
						},
						"uri": {},
						"credentials": {},
						"requestParameters": {
							"shape": "Sk"
						},
						"requestTemplates": {
							"shape": "Sk"
						},
						"passthroughBehavior": {},
						"cacheNamespace": {},
						"cacheKeyParameters": {
							"shape": "S8"
						}
					}
				},
				"output": {
					"shape": "S11"
				}
			},
			"PutIntegrationResponse": {
				"http": {
					"method": "PUT",
					"requestUri": "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/integration/responses/{status_code}",
					"responseCode": 201
				},
				"input": {
					"type": "structure",
					"required": [
						"restApiId",
						"resourceId",
						"httpMethod",
						"statusCode"
					],
					"members": {
						"restApiId": {
							"location": "uri",
							"locationName": "restapi_id"
						},
						"resourceId": {
							"location": "uri",
							"locationName": "resource_id"
						},
						"httpMethod": {
							"location": "uri",
							"locationName": "http_method"
						},
						"statusCode": {
							"location": "uri",
							"locationName": "status_code"
						},
						"selectionPattern": {},
						"responseParameters": {
							"shape": "Sk"
						},
						"responseTemplates": {
							"shape": "Sk"
						}
					}
				},
				"output": {
					"shape": "S14"
				}
			},
			"PutMethod": {
				"http": {
					"method": "PUT",
					"requestUri": "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}",
					"responseCode": 201
				},
				"input": {
					"type": "structure",
					"required": [
						"restApiId",
						"resourceId",
						"httpMethod",
						"authorizationType"
					],
					"members": {
						"restApiId": {
							"location": "uri",
							"locationName": "restapi_id"
						},
						"resourceId": {
							"location": "uri",
							"locationName": "resource_id"
						},
						"httpMethod": {
							"location": "uri",
							"locationName": "http_method"
						},
						"authorizationType": {},
						"authorizerId": {},
						"apiKeyRequired": {
							"type": "boolean"
						},
						"requestParameters": {
							"shape": "Sx"
						},
						"requestModels": {
							"shape": "Sk"
						}
					}
				},
				"output": {
					"shape": "Sw"
				}
			},
			"PutMethodResponse": {
				"http": {
					"method": "PUT",
					"requestUri": "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/responses/{status_code}",
					"responseCode": 201
				},
				"input": {
					"type": "structure",
					"required": [
						"restApiId",
						"resourceId",
						"httpMethod",
						"statusCode"
					],
					"members": {
						"restApiId": {
							"location": "uri",
							"locationName": "restapi_id"
						},
						"resourceId": {
							"location": "uri",
							"locationName": "resource_id"
						},
						"httpMethod": {
							"location": "uri",
							"locationName": "http_method"
						},
						"statusCode": {
							"location": "uri",
							"locationName": "status_code"
						},
						"responseParameters": {
							"shape": "Sx"
						},
						"responseModels": {
							"shape": "Sk"
						}
					}
				},
				"output": {
					"shape": "Sz"
				}
			},
			"PutRestApi": {
				"http": {
					"method": "PUT",
					"requestUri": "/restapis/{restapi_id}"
				},
				"input": {
					"type": "structure",
					"required": [
						"restApiId",
						"body"
					],
					"members": {
						"restApiId": {
							"location": "uri",
							"locationName": "restapi_id"
						},
						"mode": {
							"location": "querystring",
							"locationName": "mode"
						},
						"failOnWarnings": {
							"location": "querystring",
							"locationName": "failonwarnings",
							"type": "boolean"
						},
						"parameters": {
							"shape": "Sk",
							"location": "querystring"
						},
						"body": {
							"type": "blob"
						}
					},
					"payload": "body"
				},
				"output": {
					"shape": "S16"
				}
			},
			"TestInvokeAuthorizer": {
				"http": {
					"requestUri": "/restapis/{restapi_id}/authorizers/{authorizer_id}"
				},
				"input": {
					"type": "structure",
					"required": [
						"restApiId",
						"authorizerId"
					],
					"members": {
						"restApiId": {
							"location": "uri",
							"locationName": "restapi_id"
						},
						"authorizerId": {
							"location": "uri",
							"locationName": "authorizer_id"
						},
						"headers": {
							"shape": "S4e"
						},
						"pathWithQueryString": {},
						"body": {},
						"stageVariables": {
							"shape": "Sk"
						},
						"additionalContext": {
							"shape": "Sk"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"clientStatus": {
							"type": "integer"
						},
						"log": {},
						"latency": {
							"type": "long"
						},
						"principalId": {},
						"policy": {},
						"authorization": {
							"type": "map",
							"key": {},
							"value": {
								"shape": "S8"
							}
						},
						"claims": {
							"shape": "Sk"
						}
					}
				}
			},
			"TestInvokeMethod": {
				"http": {
					"requestUri": "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}"
				},
				"input": {
					"type": "structure",
					"required": [
						"restApiId",
						"resourceId",
						"httpMethod"
					],
					"members": {
						"restApiId": {
							"location": "uri",
							"locationName": "restapi_id"
						},
						"resourceId": {
							"location": "uri",
							"locationName": "resource_id"
						},
						"httpMethod": {
							"location": "uri",
							"locationName": "http_method"
						},
						"pathWithQueryString": {},
						"body": {},
						"headers": {
							"shape": "S4e"
						},
						"clientCertificateId": {},
						"stageVariables": {
							"shape": "Sk"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"status": {
							"type": "integer"
						},
						"body": {},
						"headers": {
							"shape": "S4e"
						},
						"log": {},
						"latency": {
							"type": "long"
						}
					}
				}
			},
			"UpdateAccount": {
				"http": {
					"method": "PATCH",
					"requestUri": "/account"
				},
				"input": {
					"type": "structure",
					"members": {
						"patchOperations": {
							"shape": "S4k"
						}
					}
				},
				"output": {
					"shape": "S29"
				}
			},
			"UpdateApiKey": {
				"http": {
					"method": "PATCH",
					"requestUri": "/apikeys/{api_Key}"
				},
				"input": {
					"type": "structure",
					"required": [
						"apiKey"
					],
					"members": {
						"apiKey": {
							"location": "uri",
							"locationName": "api_Key"
						},
						"patchOperations": {
							"shape": "S4k"
						}
					}
				},
				"output": {
					"shape": "S6"
				}
			},
			"UpdateAuthorizer": {
				"http": {
					"method": "PATCH",
					"requestUri": "/restapis/{restapi_id}/authorizers/{authorizer_id}"
				},
				"input": {
					"type": "structure",
					"required": [
						"restApiId",
						"authorizerId"
					],
					"members": {
						"restApiId": {
							"location": "uri",
							"locationName": "restapi_id"
						},
						"authorizerId": {
							"location": "uri",
							"locationName": "authorizer_id"
						},
						"patchOperations": {
							"shape": "S4k"
						}
					}
				},
				"output": {
					"shape": "Se"
				}
			},
			"UpdateBasePathMapping": {
				"http": {
					"method": "PATCH",
					"requestUri": "/domainnames/{domain_name}/basepathmappings/{base_path}"
				},
				"input": {
					"type": "structure",
					"required": [
						"domainName",
						"basePath"
					],
					"members": {
						"domainName": {
							"location": "uri",
							"locationName": "domain_name"
						},
						"basePath": {
							"location": "uri",
							"locationName": "base_path"
						},
						"patchOperations": {
							"shape": "S4k"
						}
					}
				},
				"output": {
					"shape": "Sg"
				}
			},
			"UpdateClientCertificate": {
				"http": {
					"method": "PATCH",
					"requestUri": "/clientcertificates/{clientcertificate_id}"
				},
				"input": {
					"type": "structure",
					"required": [
						"clientCertificateId"
					],
					"members": {
						"clientCertificateId": {
							"location": "uri",
							"locationName": "clientcertificate_id"
						},
						"patchOperations": {
							"shape": "S4k"
						}
					}
				},
				"output": {
					"shape": "S27"
				}
			},
			"UpdateDeployment": {
				"http": {
					"method": "PATCH",
					"requestUri": "/restapis/{restapi_id}/deployments/{deployment_id}"
				},
				"input": {
					"type": "structure",
					"required": [
						"restApiId",
						"deploymentId"
					],
					"members": {
						"restApiId": {
							"location": "uri",
							"locationName": "restapi_id"
						},
						"deploymentId": {
							"location": "uri",
							"locationName": "deployment_id"
						},
						"patchOperations": {
							"shape": "S4k"
						}
					}
				},
				"output": {
					"shape": "Sl"
				}
			},
			"UpdateDomainName": {
				"http": {
					"method": "PATCH",
					"requestUri": "/domainnames/{domain_name}"
				},
				"input": {
					"type": "structure",
					"required": [
						"domainName"
					],
					"members": {
						"domainName": {
							"location": "uri",
							"locationName": "domain_name"
						},
						"patchOperations": {
							"shape": "S4k"
						}
					}
				},
				"output": {
					"shape": "Sq"
				}
			},
			"UpdateIntegration": {
				"http": {
					"method": "PATCH",
					"requestUri": "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/integration"
				},
				"input": {
					"type": "structure",
					"required": [
						"restApiId",
						"resourceId",
						"httpMethod"
					],
					"members": {
						"restApiId": {
							"location": "uri",
							"locationName": "restapi_id"
						},
						"resourceId": {
							"location": "uri",
							"locationName": "resource_id"
						},
						"httpMethod": {
							"location": "uri",
							"locationName": "http_method"
						},
						"patchOperations": {
							"shape": "S4k"
						}
					}
				},
				"output": {
					"shape": "S11"
				}
			},
			"UpdateIntegrationResponse": {
				"http": {
					"method": "PATCH",
					"requestUri": "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/integration/responses/{status_code}"
				},
				"input": {
					"type": "structure",
					"required": [
						"restApiId",
						"resourceId",
						"httpMethod",
						"statusCode"
					],
					"members": {
						"restApiId": {
							"location": "uri",
							"locationName": "restapi_id"
						},
						"resourceId": {
							"location": "uri",
							"locationName": "resource_id"
						},
						"httpMethod": {
							"location": "uri",
							"locationName": "http_method"
						},
						"statusCode": {
							"location": "uri",
							"locationName": "status_code"
						},
						"patchOperations": {
							"shape": "S4k"
						}
					}
				},
				"output": {
					"shape": "S14"
				}
			},
			"UpdateMethod": {
				"http": {
					"method": "PATCH",
					"requestUri": "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}"
				},
				"input": {
					"type": "structure",
					"required": [
						"restApiId",
						"resourceId",
						"httpMethod"
					],
					"members": {
						"restApiId": {
							"location": "uri",
							"locationName": "restapi_id"
						},
						"resourceId": {
							"location": "uri",
							"locationName": "resource_id"
						},
						"httpMethod": {
							"location": "uri",
							"locationName": "http_method"
						},
						"patchOperations": {
							"shape": "S4k"
						}
					}
				},
				"output": {
					"shape": "Sw"
				}
			},
			"UpdateMethodResponse": {
				"http": {
					"method": "PATCH",
					"requestUri": "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/responses/{status_code}",
					"responseCode": 201
				},
				"input": {
					"type": "structure",
					"required": [
						"restApiId",
						"resourceId",
						"httpMethod",
						"statusCode"
					],
					"members": {
						"restApiId": {
							"location": "uri",
							"locationName": "restapi_id"
						},
						"resourceId": {
							"location": "uri",
							"locationName": "resource_id"
						},
						"httpMethod": {
							"location": "uri",
							"locationName": "http_method"
						},
						"statusCode": {
							"location": "uri",
							"locationName": "status_code"
						},
						"patchOperations": {
							"shape": "S4k"
						}
					}
				},
				"output": {
					"shape": "Sz"
				}
			},
			"UpdateModel": {
				"http": {
					"method": "PATCH",
					"requestUri": "/restapis/{restapi_id}/models/{model_name}"
				},
				"input": {
					"type": "structure",
					"required": [
						"restApiId",
						"modelName"
					],
					"members": {
						"restApiId": {
							"location": "uri",
							"locationName": "restapi_id"
						},
						"modelName": {
							"location": "uri",
							"locationName": "model_name"
						},
						"patchOperations": {
							"shape": "S4k"
						}
					}
				},
				"output": {
					"shape": "Ss"
				}
			},
			"UpdateResource": {
				"http": {
					"method": "PATCH",
					"requestUri": "/restapis/{restapi_id}/resources/{resource_id}"
				},
				"input": {
					"type": "structure",
					"required": [
						"restApiId",
						"resourceId"
					],
					"members": {
						"restApiId": {
							"location": "uri",
							"locationName": "restapi_id"
						},
						"resourceId": {
							"location": "uri",
							"locationName": "resource_id"
						},
						"patchOperations": {
							"shape": "S4k"
						}
					}
				},
				"output": {
					"shape": "Su"
				}
			},
			"UpdateRestApi": {
				"http": {
					"method": "PATCH",
					"requestUri": "/restapis/{restapi_id}"
				},
				"input": {
					"type": "structure",
					"required": [
						"restApiId"
					],
					"members": {
						"restApiId": {
							"location": "uri",
							"locationName": "restapi_id"
						},
						"patchOperations": {
							"shape": "S4k"
						}
					}
				},
				"output": {
					"shape": "S16"
				}
			},
			"UpdateStage": {
				"http": {
					"method": "PATCH",
					"requestUri": "/restapis/{restapi_id}/stages/{stage_name}"
				},
				"input": {
					"type": "structure",
					"required": [
						"restApiId",
						"stageName"
					],
					"members": {
						"restApiId": {
							"location": "uri",
							"locationName": "restapi_id"
						},
						"stageName": {
							"location": "uri",
							"locationName": "stage_name"
						},
						"patchOperations": {
							"shape": "S4k"
						}
					}
				},
				"output": {
					"shape": "S18"
				}
			},
			"UpdateUsage": {
				"http": {
					"method": "PATCH",
					"requestUri": "/usageplans/{usageplanId}/keys/{keyId}/usage"
				},
				"input": {
					"type": "structure",
					"required": [
						"usagePlanId",
						"keyId"
					],
					"members": {
						"usagePlanId": {
							"location": "uri",
							"locationName": "usageplanId"
						},
						"keyId": {
							"location": "uri",
							"locationName": "keyId"
						},
						"patchOperations": {
							"shape": "S4k"
						}
					}
				},
				"output": {
					"shape": "S3q"
				}
			},
			"UpdateUsagePlan": {
				"http": {
					"method": "PATCH",
					"requestUri": "/usageplans/{usageplanId}"
				},
				"input": {
					"type": "structure",
					"required": [
						"usagePlanId"
					],
					"members": {
						"usagePlanId": {
							"location": "uri",
							"locationName": "usageplanId"
						},
						"patchOperations": {
							"shape": "S4k"
						}
					}
				},
				"output": {
					"shape": "S1l"
				}
			}
		},
		"shapes": {
			"S6": {
				"type": "structure",
				"members": {
					"id": {},
					"value": {},
					"name": {},
					"description": {},
					"enabled": {
						"type": "boolean"
					},
					"createdDate": {
						"type": "timestamp"
					},
					"lastUpdatedDate": {
						"type": "timestamp"
					},
					"stageKeys": {
						"shape": "S8"
					}
				}
			},
			"S8": {
				"type": "list",
				"member": {}
			},
			"Sb": {
				"type": "list",
				"member": {}
			},
			"Se": {
				"type": "structure",
				"members": {
					"id": {},
					"name": {},
					"type": {},
					"providerARNs": {
						"shape": "Sb"
					},
					"authType": {},
					"authorizerUri": {},
					"authorizerCredentials": {},
					"identitySource": {},
					"identityValidationExpression": {},
					"authorizerResultTtlInSeconds": {
						"type": "integer"
					}
				}
			},
			"Sg": {
				"type": "structure",
				"members": {
					"basePath": {},
					"restApiId": {},
					"stage": {}
				}
			},
			"Sk": {
				"type": "map",
				"key": {},
				"value": {}
			},
			"Sl": {
				"type": "structure",
				"members": {
					"id": {},
					"description": {},
					"createdDate": {
						"type": "timestamp"
					},
					"apiSummary": {
						"type": "map",
						"key": {},
						"value": {
							"type": "map",
							"key": {},
							"value": {
								"type": "structure",
								"members": {
									"authorizationType": {},
									"apiKeyRequired": {
										"type": "boolean"
									}
								}
							}
						}
					}
				}
			},
			"Sq": {
				"type": "structure",
				"members": {
					"domainName": {},
					"certificateName": {},
					"certificateUploadDate": {
						"type": "timestamp"
					},
					"distributionDomainName": {}
				}
			},
			"Ss": {
				"type": "structure",
				"members": {
					"id": {},
					"name": {},
					"description": {},
					"schema": {},
					"contentType": {}
				}
			},
			"Su": {
				"type": "structure",
				"members": {
					"id": {},
					"parentId": {},
					"pathPart": {},
					"path": {},
					"resourceMethods": {
						"type": "map",
						"key": {},
						"value": {
							"shape": "Sw"
						}
					}
				}
			},
			"Sw": {
				"type": "structure",
				"members": {
					"httpMethod": {},
					"authorizationType": {},
					"authorizerId": {},
					"apiKeyRequired": {
						"type": "boolean"
					},
					"requestParameters": {
						"shape": "Sx"
					},
					"requestModels": {
						"shape": "Sk"
					},
					"methodResponses": {
						"type": "map",
						"key": {},
						"value": {
							"shape": "Sz"
						}
					},
					"methodIntegration": {
						"shape": "S11"
					}
				}
			},
			"Sx": {
				"type": "map",
				"key": {},
				"value": {
					"type": "boolean"
				}
			},
			"Sz": {
				"type": "structure",
				"members": {
					"statusCode": {},
					"responseParameters": {
						"shape": "Sx"
					},
					"responseModels": {
						"shape": "Sk"
					}
				}
			},
			"S11": {
				"type": "structure",
				"members": {
					"type": {},
					"httpMethod": {},
					"uri": {},
					"credentials": {},
					"requestParameters": {
						"shape": "Sk"
					},
					"requestTemplates": {
						"shape": "Sk"
					},
					"passthroughBehavior": {},
					"cacheNamespace": {},
					"cacheKeyParameters": {
						"shape": "S8"
					},
					"integrationResponses": {
						"type": "map",
						"key": {},
						"value": {
							"shape": "S14"
						}
					}
				}
			},
			"S14": {
				"type": "structure",
				"members": {
					"statusCode": {},
					"selectionPattern": {},
					"responseParameters": {
						"shape": "Sk"
					},
					"responseTemplates": {
						"shape": "Sk"
					}
				}
			},
			"S16": {
				"type": "structure",
				"members": {
					"id": {},
					"name": {},
					"description": {},
					"createdDate": {
						"type": "timestamp"
					},
					"warnings": {
						"shape": "S8"
					}
				}
			},
			"S18": {
				"type": "structure",
				"members": {
					"deploymentId": {},
					"clientCertificateId": {},
					"stageName": {},
					"description": {},
					"cacheClusterEnabled": {
						"type": "boolean"
					},
					"cacheClusterSize": {},
					"cacheClusterStatus": {},
					"methodSettings": {
						"type": "map",
						"key": {},
						"value": {
							"type": "structure",
							"members": {
								"metricsEnabled": {
									"type": "boolean"
								},
								"loggingLevel": {},
								"dataTraceEnabled": {
									"type": "boolean"
								},
								"throttlingBurstLimit": {
									"type": "integer"
								},
								"throttlingRateLimit": {
									"type": "double"
								},
								"cachingEnabled": {
									"type": "boolean"
								},
								"cacheTtlInSeconds": {
									"type": "integer"
								},
								"cacheDataEncrypted": {
									"type": "boolean"
								},
								"requireAuthorizationForCacheControl": {
									"type": "boolean"
								},
								"unauthorizedCacheControlHeaderStrategy": {}
							}
						}
					},
					"variables": {
						"shape": "Sk"
					},
					"createdDate": {
						"type": "timestamp"
					},
					"lastUpdatedDate": {
						"type": "timestamp"
					}
				}
			},
			"S1g": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"apiId": {},
						"stage": {}
					}
				}
			},
			"S1i": {
				"type": "structure",
				"members": {
					"burstLimit": {
						"type": "integer"
					},
					"rateLimit": {
						"type": "double"
					}
				}
			},
			"S1j": {
				"type": "structure",
				"members": {
					"limit": {
						"type": "integer"
					},
					"offset": {
						"type": "integer"
					},
					"period": {}
				}
			},
			"S1l": {
				"type": "structure",
				"members": {
					"id": {},
					"name": {},
					"description": {},
					"apiStages": {
						"shape": "S1g"
					},
					"throttle": {
						"shape": "S1i"
					},
					"quota": {
						"shape": "S1j"
					}
				}
			},
			"S1n": {
				"type": "structure",
				"members": {
					"id": {},
					"type": {},
					"value": {},
					"name": {}
				}
			},
			"S27": {
				"type": "structure",
				"members": {
					"clientCertificateId": {},
					"description": {},
					"pemEncodedCertificate": {},
					"createdDate": {
						"type": "timestamp"
					},
					"expirationDate": {
						"type": "timestamp"
					}
				}
			},
			"S29": {
				"type": "structure",
				"members": {
					"cloudwatchRoleArn": {},
					"throttleSettings": {
						"shape": "S1i"
					},
					"features": {
						"shape": "S8"
					},
					"apiKeyVersion": {}
				}
			},
			"S3q": {
				"type": "structure",
				"members": {
					"usagePlanId": {},
					"startDate": {},
					"endDate": {},
					"position": {},
					"items": {
						"locationName": "values",
						"type": "map",
						"key": {},
						"value": {
							"type": "list",
							"member": {
								"type": "list",
								"member": {
									"type": "long"
								}
							}
						}
					}
				}
			},
			"S4e": {
				"type": "map",
				"key": {},
				"value": {}
			},
			"S4k": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"op": {},
						"path": {},
						"value": {},
						"from": {}
					}
				}
			}
		}
	};

/***/ },
/* 240 */
/***/ function(module, exports) {

	module.exports = {
		"pagination": {
			"GetApiKeys": {
				"input_token": "position",
				"output_token": "position",
				"limit_key": "limit",
				"result_key": "items"
			},
			"GetBasePathMappings": {
				"input_token": "position",
				"output_token": "position",
				"limit_key": "limit",
				"result_key": "items"
			},
			"GetClientCertificates": {
				"input_token": "position",
				"output_token": "position",
				"limit_key": "limit",
				"result_key": "items"
			},
			"GetDeployments": {
				"input_token": "position",
				"output_token": "position",
				"limit_key": "limit",
				"result_key": "items"
			},
			"GetDomainNames": {
				"input_token": "position",
				"output_token": "position",
				"limit_key": "limit",
				"result_key": "items"
			},
			"GetModels": {
				"input_token": "position",
				"output_token": "position",
				"limit_key": "limit",
				"result_key": "items"
			},
			"GetResources": {
				"input_token": "position",
				"output_token": "position",
				"limit_key": "limit",
				"result_key": "items"
			},
			"GetRestApis": {
				"input_token": "position",
				"output_token": "position",
				"limit_key": "limit",
				"result_key": "items"
			},
			"GetUsage": {
				"input_token": "position",
				"output_token": "position",
				"limit_key": "limit",
				"result_key": "items"
			},
			"GetUsagePlans": {
				"input_token": "position",
				"output_token": "position",
				"limit_key": "limit",
				"result_key": "items"
			},
			"GetUsagePlanKeys": {
				"input_token": "position",
				"output_token": "position",
				"limit_key": "limit",
				"result_key": "items"
			}
		}
	};

/***/ },
/* 241 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['applicationautoscaling'] = {};
	AWS.ApplicationAutoScaling = Service.defineService('applicationautoscaling', ['2016-02-06']);
	Object.defineProperty(apiLoader.services['applicationautoscaling'], '2016-02-06', {
	  get: function get() {
	    var model = __webpack_require__(242);
	    model.paginators = __webpack_require__(243).pagination;
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.ApplicationAutoScaling;


/***/ },
/* 242 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2016-02-06",
			"endpointPrefix": "autoscaling",
			"jsonVersion": "1.1",
			"protocol": "json",
			"serviceFullName": "Application Auto Scaling",
			"signatureVersion": "v4",
			"signingName": "application-autoscaling",
			"targetPrefix": "AnyScaleFrontendService"
		},
		"operations": {
			"DeleteScalingPolicy": {
				"input": {
					"type": "structure",
					"required": [
						"PolicyName",
						"ServiceNamespace",
						"ResourceId",
						"ScalableDimension"
					],
					"members": {
						"PolicyName": {},
						"ServiceNamespace": {},
						"ResourceId": {},
						"ScalableDimension": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"DeregisterScalableTarget": {
				"input": {
					"type": "structure",
					"required": [
						"ServiceNamespace",
						"ResourceId",
						"ScalableDimension"
					],
					"members": {
						"ServiceNamespace": {},
						"ResourceId": {},
						"ScalableDimension": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"DescribeScalableTargets": {
				"input": {
					"type": "structure",
					"required": [
						"ServiceNamespace"
					],
					"members": {
						"ServiceNamespace": {},
						"ResourceIds": {
							"shape": "S9"
						},
						"ScalableDimension": {},
						"MaxResults": {
							"type": "integer"
						},
						"NextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ScalableTargets": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"ServiceNamespace",
									"ResourceId",
									"ScalableDimension",
									"MinCapacity",
									"MaxCapacity",
									"RoleARN",
									"CreationTime"
								],
								"members": {
									"ServiceNamespace": {},
									"ResourceId": {},
									"ScalableDimension": {},
									"MinCapacity": {
										"type": "integer"
									},
									"MaxCapacity": {
										"type": "integer"
									},
									"RoleARN": {},
									"CreationTime": {
										"type": "timestamp"
									}
								}
							}
						},
						"NextToken": {}
					}
				}
			},
			"DescribeScalingActivities": {
				"input": {
					"type": "structure",
					"required": [
						"ServiceNamespace"
					],
					"members": {
						"ServiceNamespace": {},
						"ResourceId": {},
						"ScalableDimension": {},
						"MaxResults": {
							"type": "integer"
						},
						"NextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ScalingActivities": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"ActivityId",
									"ServiceNamespace",
									"ResourceId",
									"ScalableDimension",
									"Description",
									"Cause",
									"StartTime",
									"StatusCode"
								],
								"members": {
									"ActivityId": {},
									"ServiceNamespace": {},
									"ResourceId": {},
									"ScalableDimension": {},
									"Description": {},
									"Cause": {},
									"StartTime": {
										"type": "timestamp"
									},
									"EndTime": {
										"type": "timestamp"
									},
									"StatusCode": {},
									"StatusMessage": {},
									"Details": {}
								}
							}
						},
						"NextToken": {}
					}
				}
			},
			"DescribeScalingPolicies": {
				"input": {
					"type": "structure",
					"required": [
						"ServiceNamespace"
					],
					"members": {
						"PolicyNames": {
							"shape": "S9"
						},
						"ServiceNamespace": {},
						"ResourceId": {},
						"ScalableDimension": {},
						"MaxResults": {
							"type": "integer"
						},
						"NextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ScalingPolicies": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"PolicyARN",
									"PolicyName",
									"ServiceNamespace",
									"ResourceId",
									"ScalableDimension",
									"PolicyType",
									"CreationTime"
								],
								"members": {
									"PolicyARN": {},
									"PolicyName": {},
									"ServiceNamespace": {},
									"ResourceId": {},
									"ScalableDimension": {},
									"PolicyType": {},
									"StepScalingPolicyConfiguration": {
										"shape": "St"
									},
									"Alarms": {
										"type": "list",
										"member": {
											"type": "structure",
											"required": [
												"AlarmName",
												"AlarmARN"
											],
											"members": {
												"AlarmName": {},
												"AlarmARN": {}
											}
										}
									},
									"CreationTime": {
										"type": "timestamp"
									}
								}
							}
						},
						"NextToken": {}
					}
				}
			},
			"PutScalingPolicy": {
				"input": {
					"type": "structure",
					"required": [
						"PolicyName",
						"ServiceNamespace",
						"ResourceId",
						"ScalableDimension"
					],
					"members": {
						"PolicyName": {},
						"ServiceNamespace": {},
						"ResourceId": {},
						"ScalableDimension": {},
						"PolicyType": {},
						"StepScalingPolicyConfiguration": {
							"shape": "St"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"PolicyARN"
					],
					"members": {
						"PolicyARN": {}
					}
				}
			},
			"RegisterScalableTarget": {
				"input": {
					"type": "structure",
					"required": [
						"ServiceNamespace",
						"ResourceId",
						"ScalableDimension"
					],
					"members": {
						"ServiceNamespace": {},
						"ResourceId": {},
						"ScalableDimension": {},
						"MinCapacity": {
							"type": "integer"
						},
						"MaxCapacity": {
							"type": "integer"
						},
						"RoleARN": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			}
		},
		"shapes": {
			"S9": {
				"type": "list",
				"member": {}
			},
			"St": {
				"type": "structure",
				"members": {
					"AdjustmentType": {},
					"StepAdjustments": {
						"type": "list",
						"member": {
							"type": "structure",
							"required": [
								"ScalingAdjustment"
							],
							"members": {
								"MetricIntervalLowerBound": {
									"type": "double"
								},
								"MetricIntervalUpperBound": {
									"type": "double"
								},
								"ScalingAdjustment": {
									"type": "integer"
								}
							}
						}
					},
					"MinAdjustmentMagnitude": {
						"type": "integer"
					},
					"Cooldown": {
						"type": "integer"
					},
					"MetricAggregationType": {}
				}
			}
		}
	};

/***/ },
/* 243 */
/***/ function(module, exports) {

	module.exports = {
		"pagination": {
			"DescribeScalableTargets": {
				"input_token": "NextToken",
				"output_token": "NextToken",
				"limit_key": "MaxResults",
				"result_key": "ScalableTargets"
			},
			"DescribeScalingPolicies": {
				"input_token": "NextToken",
				"output_token": "NextToken",
				"limit_key": "MaxResults",
				"result_key": "ScalingPolicies"
			},
			"DescribeScalingActivities": {
				"input_token": "NextToken",
				"output_token": "NextToken",
				"limit_key": "MaxResults",
				"result_key": "ScalingActivities"
			}
		}
	};

/***/ },
/* 244 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['autoscaling'] = {};
	AWS.AutoScaling = Service.defineService('autoscaling', ['2011-01-01']);
	Object.defineProperty(apiLoader.services['autoscaling'], '2011-01-01', {
	  get: function get() {
	    var model = __webpack_require__(245);
	    model.paginators = __webpack_require__(246).pagination;
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.AutoScaling;


/***/ },
/* 245 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2011-01-01",
			"endpointPrefix": "autoscaling",
			"protocol": "query",
			"serviceFullName": "Auto Scaling",
			"signatureVersion": "v4",
			"xmlNamespace": "http://autoscaling.amazonaws.com/doc/2011-01-01/"
		},
		"operations": {
			"AttachInstances": {
				"input": {
					"type": "structure",
					"required": [
						"AutoScalingGroupName"
					],
					"members": {
						"InstanceIds": {
							"shape": "S2"
						},
						"AutoScalingGroupName": {}
					}
				}
			},
			"AttachLoadBalancerTargetGroups": {
				"input": {
					"type": "structure",
					"required": [
						"AutoScalingGroupName",
						"TargetGroupARNs"
					],
					"members": {
						"AutoScalingGroupName": {},
						"TargetGroupARNs": {
							"shape": "S6"
						}
					}
				},
				"output": {
					"resultWrapper": "AttachLoadBalancerTargetGroupsResult",
					"type": "structure",
					"members": {}
				}
			},
			"AttachLoadBalancers": {
				"input": {
					"type": "structure",
					"required": [
						"AutoScalingGroupName",
						"LoadBalancerNames"
					],
					"members": {
						"AutoScalingGroupName": {},
						"LoadBalancerNames": {
							"shape": "Sa"
						}
					}
				},
				"output": {
					"resultWrapper": "AttachLoadBalancersResult",
					"type": "structure",
					"members": {}
				}
			},
			"CompleteLifecycleAction": {
				"input": {
					"type": "structure",
					"required": [
						"LifecycleHookName",
						"AutoScalingGroupName",
						"LifecycleActionResult"
					],
					"members": {
						"LifecycleHookName": {},
						"AutoScalingGroupName": {},
						"LifecycleActionToken": {},
						"LifecycleActionResult": {},
						"InstanceId": {}
					}
				},
				"output": {
					"resultWrapper": "CompleteLifecycleActionResult",
					"type": "structure",
					"members": {}
				}
			},
			"CreateAutoScalingGroup": {
				"input": {
					"type": "structure",
					"required": [
						"AutoScalingGroupName",
						"MinSize",
						"MaxSize"
					],
					"members": {
						"AutoScalingGroupName": {},
						"LaunchConfigurationName": {},
						"InstanceId": {},
						"MinSize": {
							"type": "integer"
						},
						"MaxSize": {
							"type": "integer"
						},
						"DesiredCapacity": {
							"type": "integer"
						},
						"DefaultCooldown": {
							"type": "integer"
						},
						"AvailabilityZones": {
							"shape": "Sn"
						},
						"LoadBalancerNames": {
							"shape": "Sa"
						},
						"TargetGroupARNs": {
							"shape": "S6"
						},
						"HealthCheckType": {},
						"HealthCheckGracePeriod": {
							"type": "integer"
						},
						"PlacementGroup": {},
						"VPCZoneIdentifier": {},
						"TerminationPolicies": {
							"shape": "Sr"
						},
						"NewInstancesProtectedFromScaleIn": {
							"type": "boolean"
						},
						"Tags": {
							"shape": "Su"
						}
					}
				}
			},
			"CreateLaunchConfiguration": {
				"input": {
					"type": "structure",
					"required": [
						"LaunchConfigurationName"
					],
					"members": {
						"LaunchConfigurationName": {},
						"ImageId": {},
						"KeyName": {},
						"SecurityGroups": {
							"shape": "S11"
						},
						"ClassicLinkVPCId": {},
						"ClassicLinkVPCSecurityGroups": {
							"shape": "S12"
						},
						"UserData": {},
						"InstanceId": {},
						"InstanceType": {},
						"KernelId": {},
						"RamdiskId": {},
						"BlockDeviceMappings": {
							"shape": "S14"
						},
						"InstanceMonitoring": {
							"shape": "S1d"
						},
						"SpotPrice": {},
						"IamInstanceProfile": {},
						"EbsOptimized": {
							"type": "boolean"
						},
						"AssociatePublicIpAddress": {
							"type": "boolean"
						},
						"PlacementTenancy": {}
					}
				}
			},
			"CreateOrUpdateTags": {
				"input": {
					"type": "structure",
					"required": [
						"Tags"
					],
					"members": {
						"Tags": {
							"shape": "Su"
						}
					}
				}
			},
			"DeleteAutoScalingGroup": {
				"input": {
					"type": "structure",
					"required": [
						"AutoScalingGroupName"
					],
					"members": {
						"AutoScalingGroupName": {},
						"ForceDelete": {
							"type": "boolean"
						}
					}
				}
			},
			"DeleteLaunchConfiguration": {
				"input": {
					"type": "structure",
					"required": [
						"LaunchConfigurationName"
					],
					"members": {
						"LaunchConfigurationName": {}
					}
				}
			},
			"DeleteLifecycleHook": {
				"input": {
					"type": "structure",
					"required": [
						"LifecycleHookName",
						"AutoScalingGroupName"
					],
					"members": {
						"LifecycleHookName": {},
						"AutoScalingGroupName": {}
					}
				},
				"output": {
					"resultWrapper": "DeleteLifecycleHookResult",
					"type": "structure",
					"members": {}
				}
			},
			"DeleteNotificationConfiguration": {
				"input": {
					"type": "structure",
					"required": [
						"AutoScalingGroupName",
						"TopicARN"
					],
					"members": {
						"AutoScalingGroupName": {},
						"TopicARN": {}
					}
				}
			},
			"DeletePolicy": {
				"input": {
					"type": "structure",
					"required": [
						"PolicyName"
					],
					"members": {
						"AutoScalingGroupName": {},
						"PolicyName": {}
					}
				}
			},
			"DeleteScheduledAction": {
				"input": {
					"type": "structure",
					"required": [
						"AutoScalingGroupName",
						"ScheduledActionName"
					],
					"members": {
						"AutoScalingGroupName": {},
						"ScheduledActionName": {}
					}
				}
			},
			"DeleteTags": {
				"input": {
					"type": "structure",
					"required": [
						"Tags"
					],
					"members": {
						"Tags": {
							"shape": "Su"
						}
					}
				}
			},
			"DescribeAccountLimits": {
				"output": {
					"resultWrapper": "DescribeAccountLimitsResult",
					"type": "structure",
					"members": {
						"MaxNumberOfAutoScalingGroups": {
							"type": "integer"
						},
						"MaxNumberOfLaunchConfigurations": {
							"type": "integer"
						},
						"NumberOfAutoScalingGroups": {
							"type": "integer"
						},
						"NumberOfLaunchConfigurations": {
							"type": "integer"
						}
					}
				}
			},
			"DescribeAdjustmentTypes": {
				"output": {
					"resultWrapper": "DescribeAdjustmentTypesResult",
					"type": "structure",
					"members": {
						"AdjustmentTypes": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"AdjustmentType": {}
								}
							}
						}
					}
				}
			},
			"DescribeAutoScalingGroups": {
				"input": {
					"type": "structure",
					"members": {
						"AutoScalingGroupNames": {
							"shape": "S22"
						},
						"NextToken": {},
						"MaxRecords": {
							"type": "integer"
						}
					}
				},
				"output": {
					"resultWrapper": "DescribeAutoScalingGroupsResult",
					"type": "structure",
					"required": [
						"AutoScalingGroups"
					],
					"members": {
						"AutoScalingGroups": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"AutoScalingGroupName",
									"MinSize",
									"MaxSize",
									"DesiredCapacity",
									"DefaultCooldown",
									"AvailabilityZones",
									"HealthCheckType",
									"CreatedTime"
								],
								"members": {
									"AutoScalingGroupName": {},
									"AutoScalingGroupARN": {},
									"LaunchConfigurationName": {},
									"MinSize": {
										"type": "integer"
									},
									"MaxSize": {
										"type": "integer"
									},
									"DesiredCapacity": {
										"type": "integer"
									},
									"DefaultCooldown": {
										"type": "integer"
									},
									"AvailabilityZones": {
										"shape": "Sn"
									},
									"LoadBalancerNames": {
										"shape": "Sa"
									},
									"TargetGroupARNs": {
										"shape": "S6"
									},
									"HealthCheckType": {},
									"HealthCheckGracePeriod": {
										"type": "integer"
									},
									"Instances": {
										"type": "list",
										"member": {
											"type": "structure",
											"required": [
												"InstanceId",
												"AvailabilityZone",
												"LifecycleState",
												"HealthStatus",
												"LaunchConfigurationName",
												"ProtectedFromScaleIn"
											],
											"members": {
												"InstanceId": {},
												"AvailabilityZone": {},
												"LifecycleState": {},
												"HealthStatus": {},
												"LaunchConfigurationName": {},
												"ProtectedFromScaleIn": {
													"type": "boolean"
												}
											}
										}
									},
									"CreatedTime": {
										"type": "timestamp"
									},
									"SuspendedProcesses": {
										"type": "list",
										"member": {
											"type": "structure",
											"members": {
												"ProcessName": {},
												"SuspensionReason": {}
											}
										}
									},
									"PlacementGroup": {},
									"VPCZoneIdentifier": {},
									"EnabledMetrics": {
										"type": "list",
										"member": {
											"type": "structure",
											"members": {
												"Metric": {},
												"Granularity": {}
											}
										}
									},
									"Status": {},
									"Tags": {
										"shape": "S2f"
									},
									"TerminationPolicies": {
										"shape": "Sr"
									},
									"NewInstancesProtectedFromScaleIn": {
										"type": "boolean"
									}
								}
							}
						},
						"NextToken": {}
					}
				}
			},
			"DescribeAutoScalingInstances": {
				"input": {
					"type": "structure",
					"members": {
						"InstanceIds": {
							"shape": "S2"
						},
						"MaxRecords": {
							"type": "integer"
						},
						"NextToken": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeAutoScalingInstancesResult",
					"type": "structure",
					"members": {
						"AutoScalingInstances": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"InstanceId",
									"AutoScalingGroupName",
									"AvailabilityZone",
									"LifecycleState",
									"HealthStatus",
									"LaunchConfigurationName",
									"ProtectedFromScaleIn"
								],
								"members": {
									"InstanceId": {},
									"AutoScalingGroupName": {},
									"AvailabilityZone": {},
									"LifecycleState": {},
									"HealthStatus": {},
									"LaunchConfigurationName": {},
									"ProtectedFromScaleIn": {
										"type": "boolean"
									}
								}
							}
						},
						"NextToken": {}
					}
				}
			},
			"DescribeAutoScalingNotificationTypes": {
				"output": {
					"resultWrapper": "DescribeAutoScalingNotificationTypesResult",
					"type": "structure",
					"members": {
						"AutoScalingNotificationTypes": {
							"shape": "S2m"
						}
					}
				}
			},
			"DescribeLaunchConfigurations": {
				"input": {
					"type": "structure",
					"members": {
						"LaunchConfigurationNames": {
							"type": "list",
							"member": {}
						},
						"NextToken": {},
						"MaxRecords": {
							"type": "integer"
						}
					}
				},
				"output": {
					"resultWrapper": "DescribeLaunchConfigurationsResult",
					"type": "structure",
					"required": [
						"LaunchConfigurations"
					],
					"members": {
						"LaunchConfigurations": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"LaunchConfigurationName",
									"ImageId",
									"InstanceType",
									"CreatedTime"
								],
								"members": {
									"LaunchConfigurationName": {},
									"LaunchConfigurationARN": {},
									"ImageId": {},
									"KeyName": {},
									"SecurityGroups": {
										"shape": "S11"
									},
									"ClassicLinkVPCId": {},
									"ClassicLinkVPCSecurityGroups": {
										"shape": "S12"
									},
									"UserData": {},
									"InstanceType": {},
									"KernelId": {},
									"RamdiskId": {},
									"BlockDeviceMappings": {
										"shape": "S14"
									},
									"InstanceMonitoring": {
										"shape": "S1d"
									},
									"SpotPrice": {},
									"IamInstanceProfile": {},
									"CreatedTime": {
										"type": "timestamp"
									},
									"EbsOptimized": {
										"type": "boolean"
									},
									"AssociatePublicIpAddress": {
										"type": "boolean"
									},
									"PlacementTenancy": {}
								}
							}
						},
						"NextToken": {}
					}
				}
			},
			"DescribeLifecycleHookTypes": {
				"output": {
					"resultWrapper": "DescribeLifecycleHookTypesResult",
					"type": "structure",
					"members": {
						"LifecycleHookTypes": {
							"shape": "S2m"
						}
					}
				}
			},
			"DescribeLifecycleHooks": {
				"input": {
					"type": "structure",
					"required": [
						"AutoScalingGroupName"
					],
					"members": {
						"AutoScalingGroupName": {},
						"LifecycleHookNames": {
							"type": "list",
							"member": {}
						}
					}
				},
				"output": {
					"resultWrapper": "DescribeLifecycleHooksResult",
					"type": "structure",
					"members": {
						"LifecycleHooks": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"LifecycleHookName": {},
									"AutoScalingGroupName": {},
									"LifecycleTransition": {},
									"NotificationTargetARN": {},
									"RoleARN": {},
									"NotificationMetadata": {},
									"HeartbeatTimeout": {
										"type": "integer"
									},
									"GlobalTimeout": {
										"type": "integer"
									},
									"DefaultResult": {}
								}
							}
						}
					}
				}
			},
			"DescribeLoadBalancerTargetGroups": {
				"input": {
					"type": "structure",
					"required": [
						"AutoScalingGroupName"
					],
					"members": {
						"AutoScalingGroupName": {},
						"NextToken": {},
						"MaxRecords": {
							"type": "integer"
						}
					}
				},
				"output": {
					"resultWrapper": "DescribeLoadBalancerTargetGroupsResult",
					"type": "structure",
					"members": {
						"LoadBalancerTargetGroups": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"LoadBalancerTargetGroupARN": {},
									"State": {}
								}
							}
						},
						"NextToken": {}
					}
				}
			},
			"DescribeLoadBalancers": {
				"input": {
					"type": "structure",
					"required": [
						"AutoScalingGroupName"
					],
					"members": {
						"AutoScalingGroupName": {},
						"NextToken": {},
						"MaxRecords": {
							"type": "integer"
						}
					}
				},
				"output": {
					"resultWrapper": "DescribeLoadBalancersResult",
					"type": "structure",
					"members": {
						"LoadBalancers": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"LoadBalancerName": {},
									"State": {}
								}
							}
						},
						"NextToken": {}
					}
				}
			},
			"DescribeMetricCollectionTypes": {
				"output": {
					"resultWrapper": "DescribeMetricCollectionTypesResult",
					"type": "structure",
					"members": {
						"Metrics": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"Metric": {}
								}
							}
						},
						"Granularities": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"Granularity": {}
								}
							}
						}
					}
				}
			},
			"DescribeNotificationConfigurations": {
				"input": {
					"type": "structure",
					"members": {
						"AutoScalingGroupNames": {
							"shape": "S22"
						},
						"NextToken": {},
						"MaxRecords": {
							"type": "integer"
						}
					}
				},
				"output": {
					"resultWrapper": "DescribeNotificationConfigurationsResult",
					"type": "structure",
					"required": [
						"NotificationConfigurations"
					],
					"members": {
						"NotificationConfigurations": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"AutoScalingGroupName": {},
									"TopicARN": {},
									"NotificationType": {}
								}
							}
						},
						"NextToken": {}
					}
				}
			},
			"DescribePolicies": {
				"input": {
					"type": "structure",
					"members": {
						"AutoScalingGroupName": {},
						"PolicyNames": {
							"type": "list",
							"member": {}
						},
						"PolicyTypes": {
							"type": "list",
							"member": {}
						},
						"NextToken": {},
						"MaxRecords": {
							"type": "integer"
						}
					}
				},
				"output": {
					"resultWrapper": "DescribePoliciesResult",
					"type": "structure",
					"members": {
						"ScalingPolicies": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"AutoScalingGroupName": {},
									"PolicyName": {},
									"PolicyARN": {},
									"PolicyType": {},
									"AdjustmentType": {},
									"MinAdjustmentStep": {
										"shape": "S3p"
									},
									"MinAdjustmentMagnitude": {
										"type": "integer"
									},
									"ScalingAdjustment": {
										"type": "integer"
									},
									"Cooldown": {
										"type": "integer"
									},
									"StepAdjustments": {
										"shape": "S3s"
									},
									"MetricAggregationType": {},
									"EstimatedInstanceWarmup": {
										"type": "integer"
									},
									"Alarms": {
										"type": "list",
										"member": {
											"type": "structure",
											"members": {
												"AlarmName": {},
												"AlarmARN": {}
											}
										}
									}
								}
							}
						},
						"NextToken": {}
					}
				}
			},
			"DescribeScalingActivities": {
				"input": {
					"type": "structure",
					"members": {
						"ActivityIds": {
							"type": "list",
							"member": {}
						},
						"AutoScalingGroupName": {},
						"MaxRecords": {
							"type": "integer"
						},
						"NextToken": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeScalingActivitiesResult",
					"type": "structure",
					"required": [
						"Activities"
					],
					"members": {
						"Activities": {
							"shape": "S41"
						},
						"NextToken": {}
					}
				}
			},
			"DescribeScalingProcessTypes": {
				"output": {
					"resultWrapper": "DescribeScalingProcessTypesResult",
					"type": "structure",
					"members": {
						"Processes": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"ProcessName"
								],
								"members": {
									"ProcessName": {}
								}
							}
						}
					}
				}
			},
			"DescribeScheduledActions": {
				"input": {
					"type": "structure",
					"members": {
						"AutoScalingGroupName": {},
						"ScheduledActionNames": {
							"type": "list",
							"member": {}
						},
						"StartTime": {
							"type": "timestamp"
						},
						"EndTime": {
							"type": "timestamp"
						},
						"NextToken": {},
						"MaxRecords": {
							"type": "integer"
						}
					}
				},
				"output": {
					"resultWrapper": "DescribeScheduledActionsResult",
					"type": "structure",
					"members": {
						"ScheduledUpdateGroupActions": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"AutoScalingGroupName": {},
									"ScheduledActionName": {},
									"ScheduledActionARN": {},
									"Time": {
										"type": "timestamp"
									},
									"StartTime": {
										"type": "timestamp"
									},
									"EndTime": {
										"type": "timestamp"
									},
									"Recurrence": {},
									"MinSize": {
										"type": "integer"
									},
									"MaxSize": {
										"type": "integer"
									},
									"DesiredCapacity": {
										"type": "integer"
									}
								}
							}
						},
						"NextToken": {}
					}
				}
			},
			"DescribeTags": {
				"input": {
					"type": "structure",
					"members": {
						"Filters": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"Name": {},
									"Values": {
										"type": "list",
										"member": {}
									}
								}
							}
						},
						"NextToken": {},
						"MaxRecords": {
							"type": "integer"
						}
					}
				},
				"output": {
					"resultWrapper": "DescribeTagsResult",
					"type": "structure",
					"members": {
						"Tags": {
							"shape": "S2f"
						},
						"NextToken": {}
					}
				}
			},
			"DescribeTerminationPolicyTypes": {
				"output": {
					"resultWrapper": "DescribeTerminationPolicyTypesResult",
					"type": "structure",
					"members": {
						"TerminationPolicyTypes": {
							"shape": "Sr"
						}
					}
				}
			},
			"DetachInstances": {
				"input": {
					"type": "structure",
					"required": [
						"AutoScalingGroupName",
						"ShouldDecrementDesiredCapacity"
					],
					"members": {
						"InstanceIds": {
							"shape": "S2"
						},
						"AutoScalingGroupName": {},
						"ShouldDecrementDesiredCapacity": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"resultWrapper": "DetachInstancesResult",
					"type": "structure",
					"members": {
						"Activities": {
							"shape": "S41"
						}
					}
				}
			},
			"DetachLoadBalancerTargetGroups": {
				"input": {
					"type": "structure",
					"required": [
						"AutoScalingGroupName",
						"TargetGroupARNs"
					],
					"members": {
						"AutoScalingGroupName": {},
						"TargetGroupARNs": {
							"shape": "S6"
						}
					}
				},
				"output": {
					"resultWrapper": "DetachLoadBalancerTargetGroupsResult",
					"type": "structure",
					"members": {}
				}
			},
			"DetachLoadBalancers": {
				"input": {
					"type": "structure",
					"required": [
						"AutoScalingGroupName",
						"LoadBalancerNames"
					],
					"members": {
						"AutoScalingGroupName": {},
						"LoadBalancerNames": {
							"shape": "Sa"
						}
					}
				},
				"output": {
					"resultWrapper": "DetachLoadBalancersResult",
					"type": "structure",
					"members": {}
				}
			},
			"DisableMetricsCollection": {
				"input": {
					"type": "structure",
					"required": [
						"AutoScalingGroupName"
					],
					"members": {
						"AutoScalingGroupName": {},
						"Metrics": {
							"shape": "S4r"
						}
					}
				}
			},
			"EnableMetricsCollection": {
				"input": {
					"type": "structure",
					"required": [
						"AutoScalingGroupName",
						"Granularity"
					],
					"members": {
						"AutoScalingGroupName": {},
						"Metrics": {
							"shape": "S4r"
						},
						"Granularity": {}
					}
				}
			},
			"EnterStandby": {
				"input": {
					"type": "structure",
					"required": [
						"AutoScalingGroupName",
						"ShouldDecrementDesiredCapacity"
					],
					"members": {
						"InstanceIds": {
							"shape": "S2"
						},
						"AutoScalingGroupName": {},
						"ShouldDecrementDesiredCapacity": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"resultWrapper": "EnterStandbyResult",
					"type": "structure",
					"members": {
						"Activities": {
							"shape": "S41"
						}
					}
				}
			},
			"ExecutePolicy": {
				"input": {
					"type": "structure",
					"required": [
						"PolicyName"
					],
					"members": {
						"AutoScalingGroupName": {},
						"PolicyName": {},
						"HonorCooldown": {
							"type": "boolean"
						},
						"MetricValue": {
							"type": "double"
						},
						"BreachThreshold": {
							"type": "double"
						}
					}
				}
			},
			"ExitStandby": {
				"input": {
					"type": "structure",
					"required": [
						"AutoScalingGroupName"
					],
					"members": {
						"InstanceIds": {
							"shape": "S2"
						},
						"AutoScalingGroupName": {}
					}
				},
				"output": {
					"resultWrapper": "ExitStandbyResult",
					"type": "structure",
					"members": {
						"Activities": {
							"shape": "S41"
						}
					}
				}
			},
			"PutLifecycleHook": {
				"input": {
					"type": "structure",
					"required": [
						"LifecycleHookName",
						"AutoScalingGroupName"
					],
					"members": {
						"LifecycleHookName": {},
						"AutoScalingGroupName": {},
						"LifecycleTransition": {},
						"RoleARN": {},
						"NotificationTargetARN": {},
						"NotificationMetadata": {},
						"HeartbeatTimeout": {
							"type": "integer"
						},
						"DefaultResult": {}
					}
				},
				"output": {
					"resultWrapper": "PutLifecycleHookResult",
					"type": "structure",
					"members": {}
				}
			},
			"PutNotificationConfiguration": {
				"input": {
					"type": "structure",
					"required": [
						"AutoScalingGroupName",
						"TopicARN",
						"NotificationTypes"
					],
					"members": {
						"AutoScalingGroupName": {},
						"TopicARN": {},
						"NotificationTypes": {
							"shape": "S2m"
						}
					}
				}
			},
			"PutScalingPolicy": {
				"input": {
					"type": "structure",
					"required": [
						"AutoScalingGroupName",
						"PolicyName",
						"AdjustmentType"
					],
					"members": {
						"AutoScalingGroupName": {},
						"PolicyName": {},
						"PolicyType": {},
						"AdjustmentType": {},
						"MinAdjustmentStep": {
							"shape": "S3p"
						},
						"MinAdjustmentMagnitude": {
							"type": "integer"
						},
						"ScalingAdjustment": {
							"type": "integer"
						},
						"Cooldown": {
							"type": "integer"
						},
						"MetricAggregationType": {},
						"StepAdjustments": {
							"shape": "S3s"
						},
						"EstimatedInstanceWarmup": {
							"type": "integer"
						}
					}
				},
				"output": {
					"resultWrapper": "PutScalingPolicyResult",
					"type": "structure",
					"members": {
						"PolicyARN": {}
					}
				}
			},
			"PutScheduledUpdateGroupAction": {
				"input": {
					"type": "structure",
					"required": [
						"AutoScalingGroupName",
						"ScheduledActionName"
					],
					"members": {
						"AutoScalingGroupName": {},
						"ScheduledActionName": {},
						"Time": {
							"type": "timestamp"
						},
						"StartTime": {
							"type": "timestamp"
						},
						"EndTime": {
							"type": "timestamp"
						},
						"Recurrence": {},
						"MinSize": {
							"type": "integer"
						},
						"MaxSize": {
							"type": "integer"
						},
						"DesiredCapacity": {
							"type": "integer"
						}
					}
				}
			},
			"RecordLifecycleActionHeartbeat": {
				"input": {
					"type": "structure",
					"required": [
						"LifecycleHookName",
						"AutoScalingGroupName"
					],
					"members": {
						"LifecycleHookName": {},
						"AutoScalingGroupName": {},
						"LifecycleActionToken": {},
						"InstanceId": {}
					}
				},
				"output": {
					"resultWrapper": "RecordLifecycleActionHeartbeatResult",
					"type": "structure",
					"members": {}
				}
			},
			"ResumeProcesses": {
				"input": {
					"shape": "S58"
				}
			},
			"SetDesiredCapacity": {
				"input": {
					"type": "structure",
					"required": [
						"AutoScalingGroupName",
						"DesiredCapacity"
					],
					"members": {
						"AutoScalingGroupName": {},
						"DesiredCapacity": {
							"type": "integer"
						},
						"HonorCooldown": {
							"type": "boolean"
						}
					}
				}
			},
			"SetInstanceHealth": {
				"input": {
					"type": "structure",
					"required": [
						"InstanceId",
						"HealthStatus"
					],
					"members": {
						"InstanceId": {},
						"HealthStatus": {},
						"ShouldRespectGracePeriod": {
							"type": "boolean"
						}
					}
				}
			},
			"SetInstanceProtection": {
				"input": {
					"type": "structure",
					"required": [
						"InstanceIds",
						"AutoScalingGroupName",
						"ProtectedFromScaleIn"
					],
					"members": {
						"InstanceIds": {
							"shape": "S2"
						},
						"AutoScalingGroupName": {},
						"ProtectedFromScaleIn": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"resultWrapper": "SetInstanceProtectionResult",
					"type": "structure",
					"members": {}
				}
			},
			"SuspendProcesses": {
				"input": {
					"shape": "S58"
				}
			},
			"TerminateInstanceInAutoScalingGroup": {
				"input": {
					"type": "structure",
					"required": [
						"InstanceId",
						"ShouldDecrementDesiredCapacity"
					],
					"members": {
						"InstanceId": {},
						"ShouldDecrementDesiredCapacity": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"resultWrapper": "TerminateInstanceInAutoScalingGroupResult",
					"type": "structure",
					"members": {
						"Activity": {
							"shape": "S42"
						}
					}
				}
			},
			"UpdateAutoScalingGroup": {
				"input": {
					"type": "structure",
					"required": [
						"AutoScalingGroupName"
					],
					"members": {
						"AutoScalingGroupName": {},
						"LaunchConfigurationName": {},
						"MinSize": {
							"type": "integer"
						},
						"MaxSize": {
							"type": "integer"
						},
						"DesiredCapacity": {
							"type": "integer"
						},
						"DefaultCooldown": {
							"type": "integer"
						},
						"AvailabilityZones": {
							"shape": "Sn"
						},
						"HealthCheckType": {},
						"HealthCheckGracePeriod": {
							"type": "integer"
						},
						"PlacementGroup": {},
						"VPCZoneIdentifier": {},
						"TerminationPolicies": {
							"shape": "Sr"
						},
						"NewInstancesProtectedFromScaleIn": {
							"type": "boolean"
						}
					}
				}
			}
		},
		"shapes": {
			"S2": {
				"type": "list",
				"member": {}
			},
			"S6": {
				"type": "list",
				"member": {}
			},
			"Sa": {
				"type": "list",
				"member": {}
			},
			"Sn": {
				"type": "list",
				"member": {}
			},
			"Sr": {
				"type": "list",
				"member": {}
			},
			"Su": {
				"type": "list",
				"member": {
					"type": "structure",
					"required": [
						"Key"
					],
					"members": {
						"ResourceId": {},
						"ResourceType": {},
						"Key": {},
						"Value": {},
						"PropagateAtLaunch": {
							"type": "boolean"
						}
					}
				}
			},
			"S11": {
				"type": "list",
				"member": {}
			},
			"S12": {
				"type": "list",
				"member": {}
			},
			"S14": {
				"type": "list",
				"member": {
					"type": "structure",
					"required": [
						"DeviceName"
					],
					"members": {
						"VirtualName": {},
						"DeviceName": {},
						"Ebs": {
							"type": "structure",
							"members": {
								"SnapshotId": {},
								"VolumeSize": {
									"type": "integer"
								},
								"VolumeType": {},
								"DeleteOnTermination": {
									"type": "boolean"
								},
								"Iops": {
									"type": "integer"
								},
								"Encrypted": {
									"type": "boolean"
								}
							}
						},
						"NoDevice": {
							"type": "boolean"
						}
					}
				}
			},
			"S1d": {
				"type": "structure",
				"members": {
					"Enabled": {
						"type": "boolean"
					}
				}
			},
			"S22": {
				"type": "list",
				"member": {}
			},
			"S2f": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"ResourceId": {},
						"ResourceType": {},
						"Key": {},
						"Value": {},
						"PropagateAtLaunch": {
							"type": "boolean"
						}
					}
				}
			},
			"S2m": {
				"type": "list",
				"member": {}
			},
			"S3p": {
				"type": "integer",
				"deprecated": true
			},
			"S3s": {
				"type": "list",
				"member": {
					"type": "structure",
					"required": [
						"ScalingAdjustment"
					],
					"members": {
						"MetricIntervalLowerBound": {
							"type": "double"
						},
						"MetricIntervalUpperBound": {
							"type": "double"
						},
						"ScalingAdjustment": {
							"type": "integer"
						}
					}
				}
			},
			"S41": {
				"type": "list",
				"member": {
					"shape": "S42"
				}
			},
			"S42": {
				"type": "structure",
				"required": [
					"ActivityId",
					"AutoScalingGroupName",
					"Cause",
					"StartTime",
					"StatusCode"
				],
				"members": {
					"ActivityId": {},
					"AutoScalingGroupName": {},
					"Description": {},
					"Cause": {},
					"StartTime": {
						"type": "timestamp"
					},
					"EndTime": {
						"type": "timestamp"
					},
					"StatusCode": {},
					"StatusMessage": {},
					"Progress": {
						"type": "integer"
					},
					"Details": {}
				}
			},
			"S4r": {
				"type": "list",
				"member": {}
			},
			"S58": {
				"type": "structure",
				"required": [
					"AutoScalingGroupName"
				],
				"members": {
					"AutoScalingGroupName": {},
					"ScalingProcesses": {
						"type": "list",
						"member": {}
					}
				}
			}
		}
	};

/***/ },
/* 246 */
/***/ function(module, exports) {

	module.exports = {
		"pagination": {
			"DescribeAutoScalingGroups": {
				"input_token": "NextToken",
				"output_token": "NextToken",
				"limit_key": "MaxRecords",
				"result_key": "AutoScalingGroups"
			},
			"DescribeAutoScalingInstances": {
				"input_token": "NextToken",
				"output_token": "NextToken",
				"limit_key": "MaxRecords",
				"result_key": "AutoScalingInstances"
			},
			"DescribeLaunchConfigurations": {
				"input_token": "NextToken",
				"output_token": "NextToken",
				"limit_key": "MaxRecords",
				"result_key": "LaunchConfigurations"
			},
			"DescribeNotificationConfigurations": {
				"input_token": "NextToken",
				"output_token": "NextToken",
				"limit_key": "MaxRecords",
				"result_key": "NotificationConfigurations"
			},
			"DescribePolicies": {
				"input_token": "NextToken",
				"output_token": "NextToken",
				"limit_key": "MaxRecords",
				"result_key": "ScalingPolicies"
			},
			"DescribeScalingActivities": {
				"input_token": "NextToken",
				"output_token": "NextToken",
				"limit_key": "MaxRecords",
				"result_key": "Activities"
			},
			"DescribeScheduledActions": {
				"input_token": "NextToken",
				"output_token": "NextToken",
				"limit_key": "MaxRecords",
				"result_key": "ScheduledUpdateGroupActions"
			},
			"DescribeTags": {
				"input_token": "NextToken",
				"output_token": "NextToken",
				"limit_key": "MaxRecords",
				"result_key": "Tags"
			}
		}
	};

/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['budgets'] = {};
	AWS.Budgets = Service.defineService('budgets', ['2016-10-20']);
	Object.defineProperty(apiLoader.services['budgets'], '2016-10-20', {
	  get: function get() {
	    var model = __webpack_require__(248);
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.Budgets;


/***/ },
/* 248 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2016-10-20",
			"endpointPrefix": "budgets",
			"jsonVersion": "1.1",
			"protocol": "json",
			"serviceAbbreviation": "AWSBudgets",
			"serviceFullName": "AWS Budgets",
			"signatureVersion": "v4",
			"targetPrefix": "AWSBudgetServiceGateway"
		},
		"operations": {
			"CreateBudget": {
				"input": {
					"type": "structure",
					"required": [
						"AccountId",
						"Budget"
					],
					"members": {
						"AccountId": {},
						"Budget": {
							"shape": "S3"
						},
						"NotificationsWithSubscribers": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"Notification",
									"Subscribers"
								],
								"members": {
									"Notification": {
										"shape": "Sj"
									},
									"Subscribers": {
										"shape": "Sn"
									}
								}
							}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"CreateNotification": {
				"input": {
					"type": "structure",
					"required": [
						"AccountId",
						"BudgetName",
						"Notification",
						"Subscribers"
					],
					"members": {
						"AccountId": {},
						"BudgetName": {},
						"Notification": {
							"shape": "Sj"
						},
						"Subscribers": {
							"shape": "Sn"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"CreateSubscriber": {
				"input": {
					"type": "structure",
					"required": [
						"AccountId",
						"BudgetName",
						"Notification",
						"Subscriber"
					],
					"members": {
						"AccountId": {},
						"BudgetName": {},
						"Notification": {
							"shape": "Sj"
						},
						"Subscriber": {
							"shape": "So"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"DeleteBudget": {
				"input": {
					"type": "structure",
					"required": [
						"AccountId",
						"BudgetName"
					],
					"members": {
						"AccountId": {},
						"BudgetName": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"DeleteNotification": {
				"input": {
					"type": "structure",
					"required": [
						"AccountId",
						"BudgetName",
						"Notification"
					],
					"members": {
						"AccountId": {},
						"BudgetName": {},
						"Notification": {
							"shape": "Sj"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"DeleteSubscriber": {
				"input": {
					"type": "structure",
					"required": [
						"AccountId",
						"BudgetName",
						"Notification",
						"Subscriber"
					],
					"members": {
						"AccountId": {},
						"BudgetName": {},
						"Notification": {
							"shape": "Sj"
						},
						"Subscriber": {
							"shape": "So"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"DescribeBudget": {
				"input": {
					"type": "structure",
					"required": [
						"AccountId",
						"BudgetName"
					],
					"members": {
						"AccountId": {},
						"BudgetName": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Budget": {
							"shape": "S3"
						}
					}
				}
			},
			"DescribeBudgets": {
				"input": {
					"type": "structure",
					"required": [
						"AccountId"
					],
					"members": {
						"AccountId": {},
						"MaxResults": {
							"type": "integer"
						},
						"NextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Budgets": {
							"type": "list",
							"member": {
								"shape": "S3"
							}
						},
						"NextToken": {}
					}
				}
			},
			"DescribeNotificationsForBudget": {
				"input": {
					"type": "structure",
					"required": [
						"AccountId",
						"BudgetName"
					],
					"members": {
						"AccountId": {},
						"BudgetName": {},
						"MaxResults": {
							"type": "integer"
						},
						"NextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Notifications": {
							"type": "list",
							"member": {
								"shape": "Sj"
							}
						},
						"NextToken": {}
					}
				}
			},
			"DescribeSubscribersForNotification": {
				"input": {
					"type": "structure",
					"required": [
						"AccountId",
						"BudgetName",
						"Notification"
					],
					"members": {
						"AccountId": {},
						"BudgetName": {},
						"Notification": {
							"shape": "Sj"
						},
						"MaxResults": {
							"type": "integer"
						},
						"NextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Subscribers": {
							"shape": "Sn"
						},
						"NextToken": {}
					}
				}
			},
			"UpdateBudget": {
				"input": {
					"type": "structure",
					"required": [
						"AccountId",
						"NewBudget"
					],
					"members": {
						"AccountId": {},
						"NewBudget": {
							"shape": "S3"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"UpdateNotification": {
				"input": {
					"type": "structure",
					"required": [
						"AccountId",
						"BudgetName",
						"OldNotification",
						"NewNotification"
					],
					"members": {
						"AccountId": {},
						"BudgetName": {},
						"OldNotification": {
							"shape": "Sj"
						},
						"NewNotification": {
							"shape": "Sj"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"UpdateSubscriber": {
				"input": {
					"type": "structure",
					"required": [
						"AccountId",
						"BudgetName",
						"Notification",
						"OldSubscriber",
						"NewSubscriber"
					],
					"members": {
						"AccountId": {},
						"BudgetName": {},
						"Notification": {
							"shape": "Sj"
						},
						"OldSubscriber": {
							"shape": "So"
						},
						"NewSubscriber": {
							"shape": "So"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			}
		},
		"shapes": {
			"S3": {
				"type": "structure",
				"required": [
					"BudgetName",
					"BudgetLimit",
					"CostTypes",
					"TimeUnit",
					"TimePeriod",
					"BudgetType"
				],
				"members": {
					"BudgetName": {},
					"BudgetLimit": {
						"shape": "S5"
					},
					"CostFilters": {
						"type": "map",
						"key": {},
						"value": {
							"type": "list",
							"member": {}
						}
					},
					"CostTypes": {
						"type": "structure",
						"required": [
							"IncludeTax",
							"IncludeSubscription",
							"UseBlended"
						],
						"members": {
							"IncludeTax": {
								"type": "boolean"
							},
							"IncludeSubscription": {
								"type": "boolean"
							},
							"UseBlended": {
								"type": "boolean"
							}
						}
					},
					"TimeUnit": {},
					"TimePeriod": {
						"type": "structure",
						"required": [
							"Start",
							"End"
						],
						"members": {
							"Start": {
								"type": "timestamp"
							},
							"End": {
								"type": "timestamp"
							}
						}
					},
					"CalculatedSpend": {
						"type": "structure",
						"required": [
							"ActualSpend"
						],
						"members": {
							"ActualSpend": {
								"shape": "S5"
							},
							"ForecastedSpend": {
								"shape": "S5"
							}
						}
					},
					"BudgetType": {}
				}
			},
			"S5": {
				"type": "structure",
				"required": [
					"Amount",
					"Unit"
				],
				"members": {
					"Amount": {},
					"Unit": {}
				}
			},
			"Sj": {
				"type": "structure",
				"required": [
					"NotificationType",
					"ComparisonOperator",
					"Threshold"
				],
				"members": {
					"NotificationType": {},
					"ComparisonOperator": {},
					"Threshold": {
						"type": "double"
					}
				}
			},
			"Sn": {
				"type": "list",
				"member": {
					"shape": "So"
				}
			},
			"So": {
				"type": "structure",
				"required": [
					"SubscriptionType",
					"Address"
				],
				"members": {
					"SubscriptionType": {},
					"Address": {}
				}
			}
		}
	};

/***/ },
/* 249 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['cloudformation'] = {};
	AWS.CloudFormation = Service.defineService('cloudformation', ['2010-05-15']);
	Object.defineProperty(apiLoader.services['cloudformation'], '2010-05-15', {
	  get: function get() {
	    var model = __webpack_require__(250);
	    model.paginators = __webpack_require__(251).pagination;
	    model.waiters = __webpack_require__(252).waiters;
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.CloudFormation;


/***/ },
/* 250 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2010-05-15",
			"endpointPrefix": "cloudformation",
			"protocol": "query",
			"serviceFullName": "AWS CloudFormation",
			"signatureVersion": "v4",
			"xmlNamespace": "http://cloudformation.amazonaws.com/doc/2010-05-15/"
		},
		"operations": {
			"CancelUpdateStack": {
				"input": {
					"type": "structure",
					"required": [
						"StackName"
					],
					"members": {
						"StackName": {}
					}
				}
			},
			"ContinueUpdateRollback": {
				"input": {
					"type": "structure",
					"required": [
						"StackName"
					],
					"members": {
						"StackName": {},
						"RoleARN": {},
						"ResourcesToSkip": {
							"type": "list",
							"member": {}
						}
					}
				},
				"output": {
					"resultWrapper": "ContinueUpdateRollbackResult",
					"type": "structure",
					"members": {}
				}
			},
			"CreateChangeSet": {
				"input": {
					"type": "structure",
					"required": [
						"StackName",
						"ChangeSetName"
					],
					"members": {
						"StackName": {},
						"TemplateBody": {},
						"TemplateURL": {},
						"UsePreviousTemplate": {
							"type": "boolean"
						},
						"Parameters": {
							"shape": "Sd"
						},
						"Capabilities": {
							"shape": "Si"
						},
						"ResourceTypes": {
							"shape": "Sk"
						},
						"RoleARN": {},
						"NotificationARNs": {
							"shape": "Sm"
						},
						"Tags": {
							"shape": "So"
						},
						"ChangeSetName": {},
						"ClientToken": {},
						"Description": {},
						"ChangeSetType": {}
					}
				},
				"output": {
					"resultWrapper": "CreateChangeSetResult",
					"type": "structure",
					"members": {
						"Id": {},
						"StackId": {}
					}
				}
			},
			"CreateStack": {
				"input": {
					"type": "structure",
					"required": [
						"StackName"
					],
					"members": {
						"StackName": {},
						"TemplateBody": {},
						"TemplateURL": {},
						"Parameters": {
							"shape": "Sd"
						},
						"DisableRollback": {
							"type": "boolean"
						},
						"TimeoutInMinutes": {
							"type": "integer"
						},
						"NotificationARNs": {
							"shape": "Sm"
						},
						"Capabilities": {
							"shape": "Si"
						},
						"ResourceTypes": {
							"shape": "Sk"
						},
						"RoleARN": {},
						"OnFailure": {},
						"StackPolicyBody": {},
						"StackPolicyURL": {},
						"Tags": {
							"shape": "So"
						}
					}
				},
				"output": {
					"resultWrapper": "CreateStackResult",
					"type": "structure",
					"members": {
						"StackId": {}
					}
				}
			},
			"DeleteChangeSet": {
				"input": {
					"type": "structure",
					"required": [
						"ChangeSetName"
					],
					"members": {
						"ChangeSetName": {},
						"StackName": {}
					}
				},
				"output": {
					"resultWrapper": "DeleteChangeSetResult",
					"type": "structure",
					"members": {}
				}
			},
			"DeleteStack": {
				"input": {
					"type": "structure",
					"required": [
						"StackName"
					],
					"members": {
						"StackName": {},
						"RetainResources": {
							"type": "list",
							"member": {}
						},
						"RoleARN": {}
					}
				}
			},
			"DescribeAccountLimits": {
				"input": {
					"type": "structure",
					"members": {
						"NextToken": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeAccountLimitsResult",
					"type": "structure",
					"members": {
						"AccountLimits": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"Name": {},
									"Value": {
										"type": "integer"
									}
								}
							}
						},
						"NextToken": {}
					}
				}
			},
			"DescribeChangeSet": {
				"input": {
					"type": "structure",
					"required": [
						"ChangeSetName"
					],
					"members": {
						"ChangeSetName": {},
						"StackName": {},
						"NextToken": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeChangeSetResult",
					"type": "structure",
					"members": {
						"ChangeSetName": {},
						"ChangeSetId": {},
						"StackId": {},
						"StackName": {},
						"Description": {},
						"Parameters": {
							"shape": "Sd"
						},
						"CreationTime": {
							"type": "timestamp"
						},
						"ExecutionStatus": {},
						"Status": {},
						"StatusReason": {},
						"NotificationARNs": {
							"shape": "Sm"
						},
						"Capabilities": {
							"shape": "Si"
						},
						"Tags": {
							"shape": "So"
						},
						"Changes": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"Type": {},
									"ResourceChange": {
										"type": "structure",
										"members": {
											"Action": {},
											"LogicalResourceId": {},
											"PhysicalResourceId": {},
											"ResourceType": {},
											"Replacement": {},
											"Scope": {
												"type": "list",
												"member": {}
											},
											"Details": {
												"type": "list",
												"member": {
													"type": "structure",
													"members": {
														"Target": {
															"type": "structure",
															"members": {
																"Attribute": {},
																"Name": {},
																"RequiresRecreation": {}
															}
														},
														"Evaluation": {},
														"ChangeSource": {},
														"CausingEntity": {}
													}
												}
											}
										}
									}
								}
							}
						},
						"NextToken": {}
					}
				}
			},
			"DescribeStackEvents": {
				"input": {
					"type": "structure",
					"members": {
						"StackName": {},
						"NextToken": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeStackEventsResult",
					"type": "structure",
					"members": {
						"StackEvents": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"StackId",
									"EventId",
									"StackName",
									"Timestamp"
								],
								"members": {
									"StackId": {},
									"EventId": {},
									"StackName": {},
									"LogicalResourceId": {},
									"PhysicalResourceId": {},
									"ResourceType": {},
									"Timestamp": {
										"type": "timestamp"
									},
									"ResourceStatus": {},
									"ResourceStatusReason": {},
									"ResourceProperties": {}
								}
							}
						},
						"NextToken": {}
					}
				}
			},
			"DescribeStackResource": {
				"input": {
					"type": "structure",
					"required": [
						"StackName",
						"LogicalResourceId"
					],
					"members": {
						"StackName": {},
						"LogicalResourceId": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeStackResourceResult",
					"type": "structure",
					"members": {
						"StackResourceDetail": {
							"type": "structure",
							"required": [
								"LogicalResourceId",
								"ResourceType",
								"LastUpdatedTimestamp",
								"ResourceStatus"
							],
							"members": {
								"StackName": {},
								"StackId": {},
								"LogicalResourceId": {},
								"PhysicalResourceId": {},
								"ResourceType": {},
								"LastUpdatedTimestamp": {
									"type": "timestamp"
								},
								"ResourceStatus": {},
								"ResourceStatusReason": {},
								"Description": {},
								"Metadata": {}
							}
						}
					}
				}
			},
			"DescribeStackResources": {
				"input": {
					"type": "structure",
					"members": {
						"StackName": {},
						"LogicalResourceId": {},
						"PhysicalResourceId": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeStackResourcesResult",
					"type": "structure",
					"members": {
						"StackResources": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"LogicalResourceId",
									"ResourceType",
									"Timestamp",
									"ResourceStatus"
								],
								"members": {
									"StackName": {},
									"StackId": {},
									"LogicalResourceId": {},
									"PhysicalResourceId": {},
									"ResourceType": {},
									"Timestamp": {
										"type": "timestamp"
									},
									"ResourceStatus": {},
									"ResourceStatusReason": {},
									"Description": {}
								}
							}
						}
					}
				}
			},
			"DescribeStacks": {
				"input": {
					"type": "structure",
					"members": {
						"StackName": {},
						"NextToken": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeStacksResult",
					"type": "structure",
					"members": {
						"Stacks": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"StackName",
									"CreationTime",
									"StackStatus"
								],
								"members": {
									"StackId": {},
									"StackName": {},
									"ChangeSetId": {},
									"Description": {},
									"Parameters": {
										"shape": "Sd"
									},
									"CreationTime": {
										"type": "timestamp"
									},
									"LastUpdatedTime": {
										"type": "timestamp"
									},
									"StackStatus": {},
									"StackStatusReason": {},
									"DisableRollback": {
										"type": "boolean"
									},
									"NotificationARNs": {
										"shape": "Sm"
									},
									"TimeoutInMinutes": {
										"type": "integer"
									},
									"Capabilities": {
										"shape": "Si"
									},
									"Outputs": {
										"type": "list",
										"member": {
											"type": "structure",
											"members": {
												"OutputKey": {},
												"OutputValue": {},
												"Description": {}
											}
										}
									},
									"RoleARN": {},
									"Tags": {
										"shape": "So"
									}
								}
							}
						},
						"NextToken": {}
					}
				}
			},
			"EstimateTemplateCost": {
				"input": {
					"type": "structure",
					"members": {
						"TemplateBody": {},
						"TemplateURL": {},
						"Parameters": {
							"shape": "Sd"
						}
					}
				},
				"output": {
					"resultWrapper": "EstimateTemplateCostResult",
					"type": "structure",
					"members": {
						"Url": {}
					}
				}
			},
			"ExecuteChangeSet": {
				"input": {
					"type": "structure",
					"required": [
						"ChangeSetName"
					],
					"members": {
						"ChangeSetName": {},
						"StackName": {}
					}
				},
				"output": {
					"resultWrapper": "ExecuteChangeSetResult",
					"type": "structure",
					"members": {}
				}
			},
			"GetStackPolicy": {
				"input": {
					"type": "structure",
					"required": [
						"StackName"
					],
					"members": {
						"StackName": {}
					}
				},
				"output": {
					"resultWrapper": "GetStackPolicyResult",
					"type": "structure",
					"members": {
						"StackPolicyBody": {}
					}
				}
			},
			"GetTemplate": {
				"input": {
					"type": "structure",
					"members": {
						"StackName": {},
						"ChangeSetName": {},
						"TemplateStage": {}
					}
				},
				"output": {
					"resultWrapper": "GetTemplateResult",
					"type": "structure",
					"members": {
						"TemplateBody": {},
						"StagesAvailable": {
							"type": "list",
							"member": {}
						}
					}
				}
			},
			"GetTemplateSummary": {
				"input": {
					"type": "structure",
					"members": {
						"TemplateBody": {},
						"TemplateURL": {},
						"StackName": {}
					}
				},
				"output": {
					"resultWrapper": "GetTemplateSummaryResult",
					"type": "structure",
					"members": {
						"Parameters": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"ParameterKey": {},
									"DefaultValue": {},
									"ParameterType": {},
									"NoEcho": {
										"type": "boolean"
									},
									"Description": {},
									"ParameterConstraints": {
										"type": "structure",
										"members": {
											"AllowedValues": {
												"type": "list",
												"member": {}
											}
										}
									}
								}
							}
						},
						"Description": {},
						"Capabilities": {
							"shape": "Si"
						},
						"CapabilitiesReason": {},
						"ResourceTypes": {
							"shape": "Sk"
						},
						"Version": {},
						"Metadata": {},
						"DeclaredTransforms": {
							"shape": "S3k"
						}
					}
				}
			},
			"ListChangeSets": {
				"input": {
					"type": "structure",
					"required": [
						"StackName"
					],
					"members": {
						"StackName": {},
						"NextToken": {}
					}
				},
				"output": {
					"resultWrapper": "ListChangeSetsResult",
					"type": "structure",
					"members": {
						"Summaries": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"StackId": {},
									"StackName": {},
									"ChangeSetId": {},
									"ChangeSetName": {},
									"ExecutionStatus": {},
									"Status": {},
									"StatusReason": {},
									"CreationTime": {
										"type": "timestamp"
									},
									"Description": {}
								}
							}
						},
						"NextToken": {}
					}
				}
			},
			"ListExports": {
				"input": {
					"type": "structure",
					"members": {
						"NextToken": {}
					}
				},
				"output": {
					"resultWrapper": "ListExportsResult",
					"type": "structure",
					"members": {
						"Exports": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"ExportingStackId": {},
									"Name": {},
									"Value": {}
								}
							}
						},
						"NextToken": {}
					}
				}
			},
			"ListStackResources": {
				"input": {
					"type": "structure",
					"required": [
						"StackName"
					],
					"members": {
						"StackName": {},
						"NextToken": {}
					}
				},
				"output": {
					"resultWrapper": "ListStackResourcesResult",
					"type": "structure",
					"members": {
						"StackResourceSummaries": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"LogicalResourceId",
									"ResourceType",
									"LastUpdatedTimestamp",
									"ResourceStatus"
								],
								"members": {
									"LogicalResourceId": {},
									"PhysicalResourceId": {},
									"ResourceType": {},
									"LastUpdatedTimestamp": {
										"type": "timestamp"
									},
									"ResourceStatus": {},
									"ResourceStatusReason": {}
								}
							}
						},
						"NextToken": {}
					}
				}
			},
			"ListStacks": {
				"input": {
					"type": "structure",
					"members": {
						"NextToken": {},
						"StackStatusFilter": {
							"type": "list",
							"member": {}
						}
					}
				},
				"output": {
					"resultWrapper": "ListStacksResult",
					"type": "structure",
					"members": {
						"StackSummaries": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"StackName",
									"CreationTime",
									"StackStatus"
								],
								"members": {
									"StackId": {},
									"StackName": {},
									"TemplateDescription": {},
									"CreationTime": {
										"type": "timestamp"
									},
									"LastUpdatedTime": {
										"type": "timestamp"
									},
									"DeletionTime": {
										"type": "timestamp"
									},
									"StackStatus": {},
									"StackStatusReason": {}
								}
							}
						},
						"NextToken": {}
					}
				}
			},
			"SetStackPolicy": {
				"input": {
					"type": "structure",
					"required": [
						"StackName"
					],
					"members": {
						"StackName": {},
						"StackPolicyBody": {},
						"StackPolicyURL": {}
					}
				}
			},
			"SignalResource": {
				"input": {
					"type": "structure",
					"required": [
						"StackName",
						"LogicalResourceId",
						"UniqueId",
						"Status"
					],
					"members": {
						"StackName": {},
						"LogicalResourceId": {},
						"UniqueId": {},
						"Status": {}
					}
				}
			},
			"UpdateStack": {
				"input": {
					"type": "structure",
					"required": [
						"StackName"
					],
					"members": {
						"StackName": {},
						"TemplateBody": {},
						"TemplateURL": {},
						"UsePreviousTemplate": {
							"type": "boolean"
						},
						"StackPolicyDuringUpdateBody": {},
						"StackPolicyDuringUpdateURL": {},
						"Parameters": {
							"shape": "Sd"
						},
						"Capabilities": {
							"shape": "Si"
						},
						"ResourceTypes": {
							"shape": "Sk"
						},
						"RoleARN": {},
						"StackPolicyBody": {},
						"StackPolicyURL": {},
						"NotificationARNs": {
							"shape": "Sm"
						},
						"Tags": {
							"shape": "So"
						}
					}
				},
				"output": {
					"resultWrapper": "UpdateStackResult",
					"type": "structure",
					"members": {
						"StackId": {}
					}
				}
			},
			"ValidateTemplate": {
				"input": {
					"type": "structure",
					"members": {
						"TemplateBody": {},
						"TemplateURL": {}
					}
				},
				"output": {
					"resultWrapper": "ValidateTemplateResult",
					"type": "structure",
					"members": {
						"Parameters": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"ParameterKey": {},
									"DefaultValue": {},
									"NoEcho": {
										"type": "boolean"
									},
									"Description": {}
								}
							}
						},
						"Description": {},
						"Capabilities": {
							"shape": "Si"
						},
						"CapabilitiesReason": {},
						"DeclaredTransforms": {
							"shape": "S3k"
						}
					}
				}
			}
		},
		"shapes": {
			"Sd": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"ParameterKey": {},
						"ParameterValue": {},
						"UsePreviousValue": {
							"type": "boolean"
						}
					}
				}
			},
			"Si": {
				"type": "list",
				"member": {}
			},
			"Sk": {
				"type": "list",
				"member": {}
			},
			"Sm": {
				"type": "list",
				"member": {}
			},
			"So": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"Key": {},
						"Value": {}
					}
				}
			},
			"S3k": {
				"type": "list",
				"member": {}
			}
		}
	};

/***/ },
/* 251 */
/***/ function(module, exports) {

	module.exports = {
		"pagination": {
			"DescribeStackEvents": {
				"input_token": "NextToken",
				"output_token": "NextToken",
				"result_key": "StackEvents"
			},
			"DescribeStackResources": {
				"result_key": "StackResources"
			},
			"DescribeStacks": {
				"input_token": "NextToken",
				"output_token": "NextToken",
				"result_key": "Stacks"
			},
			"ListStackResources": {
				"input_token": "NextToken",
				"output_token": "NextToken",
				"result_key": "StackResourceSummaries"
			},
			"ListStacks": {
				"input_token": "NextToken",
				"output_token": "NextToken",
				"result_key": "StackSummaries"
			}
		}
	};

/***/ },
/* 252 */
/***/ function(module, exports) {

	module.exports = {
		"version": 2,
		"waiters": {
			"StackExists": {
				"delay": 5,
				"operation": "DescribeStacks",
				"maxAttempts": 20,
				"acceptors": [
					{
						"matcher": "status",
						"expected": 200,
						"state": "success"
					},
					{
						"matcher": "error",
						"expected": "ValidationError",
						"state": "retry"
					}
				]
			},
			"StackCreateComplete": {
				"delay": 30,
				"operation": "DescribeStacks",
				"maxAttempts": 120,
				"description": "Wait until stack status is CREATE_COMPLETE.",
				"acceptors": [
					{
						"argument": "Stacks[].StackStatus",
						"expected": "CREATE_COMPLETE",
						"matcher": "pathAll",
						"state": "success"
					},
					{
						"argument": "Stacks[].StackStatus",
						"expected": "CREATE_FAILED",
						"matcher": "pathAny",
						"state": "failure"
					},
					{
						"argument": "Stacks[].StackStatus",
						"expected": "DELETE_COMPLETE",
						"matcher": "pathAny",
						"state": "failure"
					},
					{
						"argument": "Stacks[].StackStatus",
						"expected": "DELETE_FAILED",
						"matcher": "pathAny",
						"state": "failure"
					},
					{
						"argument": "Stacks[].StackStatus",
						"expected": "ROLLBACK_FAILED",
						"matcher": "pathAny",
						"state": "failure"
					},
					{
						"argument": "Stacks[].StackStatus",
						"expected": "ROLLBACK_COMPLETE",
						"matcher": "pathAny",
						"state": "failure"
					},
					{
						"expected": "ValidationError",
						"matcher": "error",
						"state": "failure"
					}
				]
			},
			"StackDeleteComplete": {
				"delay": 30,
				"operation": "DescribeStacks",
				"maxAttempts": 120,
				"description": "Wait until stack status is DELETE_COMPLETE.",
				"acceptors": [
					{
						"argument": "Stacks[].StackStatus",
						"expected": "DELETE_COMPLETE",
						"matcher": "pathAll",
						"state": "success"
					},
					{
						"expected": "ValidationError",
						"matcher": "error",
						"state": "success"
					},
					{
						"argument": "Stacks[].StackStatus",
						"expected": "DELETE_FAILED",
						"matcher": "pathAny",
						"state": "failure"
					},
					{
						"argument": "Stacks[].StackStatus",
						"expected": "CREATE_FAILED",
						"matcher": "pathAny",
						"state": "failure"
					},
					{
						"argument": "Stacks[].StackStatus",
						"expected": "ROLLBACK_FAILED",
						"matcher": "pathAny",
						"state": "failure"
					},
					{
						"argument": "Stacks[].StackStatus",
						"expected": "UPDATE_ROLLBACK_FAILED",
						"matcher": "pathAny",
						"state": "failure"
					},
					{
						"argument": "Stacks[].StackStatus",
						"expected": "UPDATE_ROLLBACK_IN_PROGRESS",
						"matcher": "pathAny",
						"state": "failure"
					}
				]
			},
			"StackUpdateComplete": {
				"delay": 30,
				"maxAttempts": 120,
				"operation": "DescribeStacks",
				"description": "Wait until stack status is UPDATE_COMPLETE.",
				"acceptors": [
					{
						"argument": "Stacks[].StackStatus",
						"expected": "UPDATE_COMPLETE",
						"matcher": "pathAll",
						"state": "success"
					},
					{
						"expected": "UPDATE_FAILED",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "Stacks[].StackStatus"
					},
					{
						"argument": "Stacks[].StackStatus",
						"expected": "UPDATE_ROLLBACK_FAILED",
						"matcher": "pathAny",
						"state": "failure"
					},
					{
						"expected": "UPDATE_ROLLBACK_COMPLETE",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "Stacks[].StackStatus"
					},
					{
						"expected": "ValidationError",
						"matcher": "error",
						"state": "failure"
					}
				]
			}
		}
	};

/***/ },
/* 253 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['cloudfront'] = {};
	AWS.CloudFront = Service.defineService('cloudfront', ['2013-05-12*', '2013-11-11*', '2014-05-31*', '2014-10-21*', '2014-11-06*', '2015-04-17*', '2015-07-27*', '2015-09-17*', '2016-01-13*', '2016-01-28*', '2016-08-01*', '2016-08-20*', '2016-09-07*', '2016-09-29']);
	__webpack_require__(254);
	Object.defineProperty(apiLoader.services['cloudfront'], '2016-09-29', {
	  get: function get() {
	    var model = __webpack_require__(256);
	    model.paginators = __webpack_require__(257).pagination;
	    model.waiters = __webpack_require__(258).waiters;
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.CloudFront;


/***/ },
/* 254 */
/***/ function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(93);

	// pull in CloudFront signer
	__webpack_require__(255);

	AWS.util.update(AWS.CloudFront.prototype, {

	  setupRequestListeners: function setupRequestListeners(request) {
	    request.addListener('extractData', AWS.util.hoistPayloadMember);
	  }

	});


/***/ },
/* 255 */
/***/ function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(93),
	    url = AWS.util.url,
	    crypto = AWS.util.crypto.lib,
	    base64Encode = AWS.util.base64.encode,
	    inherit = AWS.util.inherit;

	var queryEncode = function (string) {
	    var replacements = {
	        '+': '-',
	        '=': '_',
	        '/': '~'
	    };
	    return string.replace(/[\+=\/]/g, function (match) {
	        return replacements[match];
	    });
	};

	var signPolicy = function (policy, privateKey) {
	    var sign = crypto.createSign('RSA-SHA1');
	    sign.write(policy);
	    return queryEncode(sign.sign(privateKey, 'base64'))
	};

	var signWithCannedPolicy = function (url, expires, keyPairId, privateKey) {
	    var policy = JSON.stringify({
	        Statement: [
	            {
	                Resource: url,
	                Condition: { DateLessThan: { 'AWS:EpochTime': expires } }
	            }
	        ]
	    });

	    return {
	        Expires: expires,
	        'Key-Pair-Id': keyPairId,
	        Signature: signPolicy(policy.toString(), privateKey)
	    };
	};

	var signWithCustomPolicy = function (policy, keyPairId, privateKey) {
	    policy = policy.replace(/\s/mg, policy);

	    return {
	        Policy: queryEncode(base64Encode(policy)),
	        'Key-Pair-Id': keyPairId,
	        Signature: signPolicy(policy, privateKey)
	    }
	};

	var determineScheme = function (url) {
	    var parts = url.split('://');
	    if (parts.length < 2) {
	        throw new Error('Invalid URL.');
	    }

	    return parts[0].replace('*', '');
	};

	var getRtmpUrl = function (rtmpUrl) {
	    var parsed = url.parse(rtmpUrl);
	    return parsed.path.replace(/^\//, '') + (parsed.hash || '');
	};

	var getResource = function (url) {
	    switch (determineScheme(url)) {
	        case 'http':
	        case 'https':
	            return url;
	        case 'rtmp':
	            return getRtmpUrl(url);
	        default:
	            throw new Error('Invalid URI scheme. Scheme must be one of'
	                + ' http, https, or rtmp');
	    }
	};

	var handleError = function (err, callback) {
	    if (!callback || typeof callback !== 'function') {
	        throw err;
	    }

	    callback(err);
	};

	var handleSuccess = function (result, callback) {
	    if (!callback || typeof callback !== 'function') {
	        return result;
	    }

	    callback(null, result);
	};

	AWS.CloudFront.Signer = inherit({
	    /**
	     * A signer object can be used to generate signed URLs and cookies for granting
	     * access to content on restricted CloudFront distributions.
	     *
	     * @see http://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html
	     *
	     * @param keyPairId [String]    (Required) The ID of the CloudFront key pair
	     *                              being used.
	     * @param privateKey [String]   (Required) A private key in RSA format.
	     */
	    constructor: function Signer(keyPairId, privateKey) {
	        if (keyPairId === void 0 || privateKey === void 0) {
	            throw new Error('A key pair ID and private key are required');
	        }

	        this.keyPairId = keyPairId;
	        this.privateKey = privateKey;
	    },

	    /**
	     * Create a signed Amazon CloudFront Cookie.
	     *
	     * @param options [Object]            The options to create a signed cookie.
	     * @option options url [String]     The URL to which the signature will grant
	     *                                  access. Required unless you pass in a full
	     *                                  policy.
	     * @option options expires [Number] A Unix UTC timestamp indicating when the
	     *                                  signature should expire. Required unless you
	     *                                  pass in a full policy.
	     * @option options policy [String]  A CloudFront JSON policy. Required unless
	     *                                  you pass in a url and an expiry time.
	     *
	     * @param cb [Function] if a callback is provided, this function will
	     *   pass the hash as the second parameter (after the error parameter) to
	     *   the callback function.
	     *
	     * @return [Object] if called synchronously (with no callback), returns the
	     *   signed cookie parameters.
	     * @return [null] nothing is returned if a callback is provided.
	     */
	    getSignedCookie: function (options, cb) {
	        var signatureHash = 'policy' in options
	            ? signWithCustomPolicy(options.policy, this.keyPairId, this.privateKey)
	            : signWithCannedPolicy(options.url, options.expires, this.keyPairId, this.privateKey);

	        var cookieHash = {};
	        for (var key in signatureHash) {
	            if (Object.prototype.hasOwnProperty.call(signatureHash, key)) {
	                cookieHash['CloudFront-' + key] = signatureHash[key];
	            }
	        }

	        return handleSuccess(cookieHash, cb);
	    },

	    /**
	     * Create a signed Amazon CloudFront URL.
	     *
	     * Keep in mind that URLs meant for use in media/flash players may have
	     * different requirements for URL formats (e.g. some require that the
	     * extension be removed, some require the file name to be prefixed
	     * - mp4:<path>, some require you to add "/cfx/st" into your URL).
	     *
	     * @param options [Object]          The options to create a signed URL.
	     * @option options url [String]     The URL to which the signature will grant
	     *                                  access. Required.
	     * @option options expires [Number] A Unix UTC timestamp indicating when the
	     *                                  signature should expire. Required unless you
	     *                                  pass in a full policy.
	     * @option options policy [String]  A CloudFront JSON policy. Required unless
	     *                                  you pass in a url and an expiry time.
	     *
	     * @param cb [Function] if a callback is provided, this function will
	     *   pass the URL as the second parameter (after the error parameter) to
	     *   the callback function.
	     *
	     * @return [String] if called synchronously (with no callback), returns the
	     *   signed URL.
	     * @return [null] nothing is returned if a callback is provided.
	     */
	    getSignedUrl: function (options, cb) {
	        try {
	            var resource = getResource(options.url);
	        } catch (err) {
	            return handleError(err, cb);
	        }

	        var parsedUrl = url.parse(options.url, true),
	            signatureHash = Object.prototype.hasOwnProperty.call(options, 'policy')
	                ? signWithCustomPolicy(options.policy, this.keyPairId, this.privateKey)
	                : signWithCannedPolicy(resource, options.expires, this.keyPairId, this.privateKey);

	        parsedUrl.search = null;
	        for (var key in signatureHash) {
	            if (Object.prototype.hasOwnProperty.call(signatureHash, key)) {
	                parsedUrl.query[key] = signatureHash[key];
	            }
	        }

	        try {
	            var signedUrl = determineScheme(options.url) === 'rtmp'
	                    ? getRtmpUrl(url.format(parsedUrl))
	                    : url.format(parsedUrl);
	        } catch (err) {
	            return handleError(err, cb);
	        }

	        return handleSuccess(signedUrl, cb);
	    }
	});

	module.exports = AWS.CloudFront.Signer;


/***/ },
/* 256 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2016-09-29",
			"endpointPrefix": "cloudfront",
			"globalEndpoint": "cloudfront.amazonaws.com",
			"protocol": "rest-xml",
			"serviceAbbreviation": "CloudFront",
			"serviceFullName": "Amazon CloudFront",
			"signatureVersion": "v4"
		},
		"operations": {
			"CreateCloudFrontOriginAccessIdentity": {
				"http": {
					"requestUri": "/2016-09-29/origin-access-identity/cloudfront",
					"responseCode": 201
				},
				"input": {
					"type": "structure",
					"required": [
						"CloudFrontOriginAccessIdentityConfig"
					],
					"members": {
						"CloudFrontOriginAccessIdentityConfig": {
							"shape": "S2",
							"locationName": "CloudFrontOriginAccessIdentityConfig",
							"xmlNamespace": {
								"uri": "http://cloudfront.amazonaws.com/doc/2016-09-29/"
							}
						}
					},
					"payload": "CloudFrontOriginAccessIdentityConfig"
				},
				"output": {
					"type": "structure",
					"members": {
						"CloudFrontOriginAccessIdentity": {
							"shape": "S5"
						},
						"Location": {
							"location": "header",
							"locationName": "Location"
						},
						"ETag": {
							"location": "header",
							"locationName": "ETag"
						}
					},
					"payload": "CloudFrontOriginAccessIdentity"
				}
			},
			"CreateDistribution": {
				"http": {
					"requestUri": "/2016-09-29/distribution",
					"responseCode": 201
				},
				"input": {
					"type": "structure",
					"required": [
						"DistributionConfig"
					],
					"members": {
						"DistributionConfig": {
							"shape": "S7",
							"locationName": "DistributionConfig",
							"xmlNamespace": {
								"uri": "http://cloudfront.amazonaws.com/doc/2016-09-29/"
							}
						}
					},
					"payload": "DistributionConfig"
				},
				"output": {
					"type": "structure",
					"members": {
						"Distribution": {
							"shape": "S1o"
						},
						"Location": {
							"location": "header",
							"locationName": "Location"
						},
						"ETag": {
							"location": "header",
							"locationName": "ETag"
						}
					},
					"payload": "Distribution"
				}
			},
			"CreateDistributionWithTags": {
				"http": {
					"requestUri": "/2016-09-29/distribution?WithTags",
					"responseCode": 201
				},
				"input": {
					"type": "structure",
					"required": [
						"DistributionConfigWithTags"
					],
					"members": {
						"DistributionConfigWithTags": {
							"locationName": "DistributionConfigWithTags",
							"xmlNamespace": {
								"uri": "http://cloudfront.amazonaws.com/doc/2016-09-29/"
							},
							"type": "structure",
							"required": [
								"DistributionConfig",
								"Tags"
							],
							"members": {
								"DistributionConfig": {
									"shape": "S7"
								},
								"Tags": {
									"shape": "S1x"
								}
							}
						}
					},
					"payload": "DistributionConfigWithTags"
				},
				"output": {
					"type": "structure",
					"members": {
						"Distribution": {
							"shape": "S1o"
						},
						"Location": {
							"location": "header",
							"locationName": "Location"
						},
						"ETag": {
							"location": "header",
							"locationName": "ETag"
						}
					},
					"payload": "Distribution"
				}
			},
			"CreateInvalidation": {
				"http": {
					"requestUri": "/2016-09-29/distribution/{DistributionId}/invalidation",
					"responseCode": 201
				},
				"input": {
					"type": "structure",
					"required": [
						"DistributionId",
						"InvalidationBatch"
					],
					"members": {
						"DistributionId": {
							"location": "uri",
							"locationName": "DistributionId"
						},
						"InvalidationBatch": {
							"shape": "S24",
							"locationName": "InvalidationBatch",
							"xmlNamespace": {
								"uri": "http://cloudfront.amazonaws.com/doc/2016-09-29/"
							}
						}
					},
					"payload": "InvalidationBatch"
				},
				"output": {
					"type": "structure",
					"members": {
						"Location": {
							"location": "header",
							"locationName": "Location"
						},
						"Invalidation": {
							"shape": "S28"
						}
					},
					"payload": "Invalidation"
				}
			},
			"CreateStreamingDistribution": {
				"http": {
					"requestUri": "/2016-09-29/streaming-distribution",
					"responseCode": 201
				},
				"input": {
					"type": "structure",
					"required": [
						"StreamingDistributionConfig"
					],
					"members": {
						"StreamingDistributionConfig": {
							"shape": "S2a",
							"locationName": "StreamingDistributionConfig",
							"xmlNamespace": {
								"uri": "http://cloudfront.amazonaws.com/doc/2016-09-29/"
							}
						}
					},
					"payload": "StreamingDistributionConfig"
				},
				"output": {
					"type": "structure",
					"members": {
						"StreamingDistribution": {
							"shape": "S2e"
						},
						"Location": {
							"location": "header",
							"locationName": "Location"
						},
						"ETag": {
							"location": "header",
							"locationName": "ETag"
						}
					},
					"payload": "StreamingDistribution"
				}
			},
			"CreateStreamingDistributionWithTags": {
				"http": {
					"requestUri": "/2016-09-29/streaming-distribution?WithTags",
					"responseCode": 201
				},
				"input": {
					"type": "structure",
					"required": [
						"StreamingDistributionConfigWithTags"
					],
					"members": {
						"StreamingDistributionConfigWithTags": {
							"locationName": "StreamingDistributionConfigWithTags",
							"xmlNamespace": {
								"uri": "http://cloudfront.amazonaws.com/doc/2016-09-29/"
							},
							"type": "structure",
							"required": [
								"StreamingDistributionConfig",
								"Tags"
							],
							"members": {
								"StreamingDistributionConfig": {
									"shape": "S2a"
								},
								"Tags": {
									"shape": "S1x"
								}
							}
						}
					},
					"payload": "StreamingDistributionConfigWithTags"
				},
				"output": {
					"type": "structure",
					"members": {
						"StreamingDistribution": {
							"shape": "S2e"
						},
						"Location": {
							"location": "header",
							"locationName": "Location"
						},
						"ETag": {
							"location": "header",
							"locationName": "ETag"
						}
					},
					"payload": "StreamingDistribution"
				}
			},
			"DeleteCloudFrontOriginAccessIdentity": {
				"http": {
					"method": "DELETE",
					"requestUri": "/2016-09-29/origin-access-identity/cloudfront/{Id}",
					"responseCode": 204
				},
				"input": {
					"type": "structure",
					"required": [
						"Id"
					],
					"members": {
						"Id": {
							"location": "uri",
							"locationName": "Id"
						},
						"IfMatch": {
							"location": "header",
							"locationName": "If-Match"
						}
					}
				}
			},
			"DeleteDistribution": {
				"http": {
					"method": "DELETE",
					"requestUri": "/2016-09-29/distribution/{Id}",
					"responseCode": 204
				},
				"input": {
					"type": "structure",
					"required": [
						"Id"
					],
					"members": {
						"Id": {
							"location": "uri",
							"locationName": "Id"
						},
						"IfMatch": {
							"location": "header",
							"locationName": "If-Match"
						}
					}
				}
			},
			"DeleteStreamingDistribution": {
				"http": {
					"method": "DELETE",
					"requestUri": "/2016-09-29/streaming-distribution/{Id}",
					"responseCode": 204
				},
				"input": {
					"type": "structure",
					"required": [
						"Id"
					],
					"members": {
						"Id": {
							"location": "uri",
							"locationName": "Id"
						},
						"IfMatch": {
							"location": "header",
							"locationName": "If-Match"
						}
					}
				}
			},
			"GetCloudFrontOriginAccessIdentity": {
				"http": {
					"method": "GET",
					"requestUri": "/2016-09-29/origin-access-identity/cloudfront/{Id}"
				},
				"input": {
					"type": "structure",
					"required": [
						"Id"
					],
					"members": {
						"Id": {
							"location": "uri",
							"locationName": "Id"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"CloudFrontOriginAccessIdentity": {
							"shape": "S5"
						},
						"ETag": {
							"location": "header",
							"locationName": "ETag"
						}
					},
					"payload": "CloudFrontOriginAccessIdentity"
				}
			},
			"GetCloudFrontOriginAccessIdentityConfig": {
				"http": {
					"method": "GET",
					"requestUri": "/2016-09-29/origin-access-identity/cloudfront/{Id}/config"
				},
				"input": {
					"type": "structure",
					"required": [
						"Id"
					],
					"members": {
						"Id": {
							"location": "uri",
							"locationName": "Id"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"CloudFrontOriginAccessIdentityConfig": {
							"shape": "S2"
						},
						"ETag": {
							"location": "header",
							"locationName": "ETag"
						}
					},
					"payload": "CloudFrontOriginAccessIdentityConfig"
				}
			},
			"GetDistribution": {
				"http": {
					"method": "GET",
					"requestUri": "/2016-09-29/distribution/{Id}"
				},
				"input": {
					"type": "structure",
					"required": [
						"Id"
					],
					"members": {
						"Id": {
							"location": "uri",
							"locationName": "Id"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Distribution": {
							"shape": "S1o"
						},
						"ETag": {
							"location": "header",
							"locationName": "ETag"
						}
					},
					"payload": "Distribution"
				}
			},
			"GetDistributionConfig": {
				"http": {
					"method": "GET",
					"requestUri": "/2016-09-29/distribution/{Id}/config"
				},
				"input": {
					"type": "structure",
					"required": [
						"Id"
					],
					"members": {
						"Id": {
							"location": "uri",
							"locationName": "Id"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"DistributionConfig": {
							"shape": "S7"
						},
						"ETag": {
							"location": "header",
							"locationName": "ETag"
						}
					},
					"payload": "DistributionConfig"
				}
			},
			"GetInvalidation": {
				"http": {
					"method": "GET",
					"requestUri": "/2016-09-29/distribution/{DistributionId}/invalidation/{Id}"
				},
				"input": {
					"type": "structure",
					"required": [
						"DistributionId",
						"Id"
					],
					"members": {
						"DistributionId": {
							"location": "uri",
							"locationName": "DistributionId"
						},
						"Id": {
							"location": "uri",
							"locationName": "Id"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Invalidation": {
							"shape": "S28"
						}
					},
					"payload": "Invalidation"
				}
			},
			"GetStreamingDistribution": {
				"http": {
					"method": "GET",
					"requestUri": "/2016-09-29/streaming-distribution/{Id}"
				},
				"input": {
					"type": "structure",
					"required": [
						"Id"
					],
					"members": {
						"Id": {
							"location": "uri",
							"locationName": "Id"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"StreamingDistribution": {
							"shape": "S2e"
						},
						"ETag": {
							"location": "header",
							"locationName": "ETag"
						}
					},
					"payload": "StreamingDistribution"
				}
			},
			"GetStreamingDistributionConfig": {
				"http": {
					"method": "GET",
					"requestUri": "/2016-09-29/streaming-distribution/{Id}/config"
				},
				"input": {
					"type": "structure",
					"required": [
						"Id"
					],
					"members": {
						"Id": {
							"location": "uri",
							"locationName": "Id"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"StreamingDistributionConfig": {
							"shape": "S2a"
						},
						"ETag": {
							"location": "header",
							"locationName": "ETag"
						}
					},
					"payload": "StreamingDistributionConfig"
				}
			},
			"ListCloudFrontOriginAccessIdentities": {
				"http": {
					"method": "GET",
					"requestUri": "/2016-09-29/origin-access-identity/cloudfront"
				},
				"input": {
					"type": "structure",
					"members": {
						"Marker": {
							"location": "querystring",
							"locationName": "Marker"
						},
						"MaxItems": {
							"location": "querystring",
							"locationName": "MaxItems"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"CloudFrontOriginAccessIdentityList": {
							"type": "structure",
							"required": [
								"Marker",
								"MaxItems",
								"IsTruncated",
								"Quantity"
							],
							"members": {
								"Marker": {},
								"NextMarker": {},
								"MaxItems": {
									"type": "integer"
								},
								"IsTruncated": {
									"type": "boolean"
								},
								"Quantity": {
									"type": "integer"
								},
								"Items": {
									"type": "list",
									"member": {
										"locationName": "CloudFrontOriginAccessIdentitySummary",
										"type": "structure",
										"required": [
											"Id",
											"S3CanonicalUserId",
											"Comment"
										],
										"members": {
											"Id": {},
											"S3CanonicalUserId": {},
											"Comment": {}
										}
									}
								}
							}
						}
					},
					"payload": "CloudFrontOriginAccessIdentityList"
				}
			},
			"ListDistributions": {
				"http": {
					"method": "GET",
					"requestUri": "/2016-09-29/distribution"
				},
				"input": {
					"type": "structure",
					"members": {
						"Marker": {
							"location": "querystring",
							"locationName": "Marker"
						},
						"MaxItems": {
							"location": "querystring",
							"locationName": "MaxItems"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"DistributionList": {
							"shape": "S36"
						}
					},
					"payload": "DistributionList"
				}
			},
			"ListDistributionsByWebACLId": {
				"http": {
					"method": "GET",
					"requestUri": "/2016-09-29/distributionsByWebACLId/{WebACLId}"
				},
				"input": {
					"type": "structure",
					"required": [
						"WebACLId"
					],
					"members": {
						"Marker": {
							"location": "querystring",
							"locationName": "Marker"
						},
						"MaxItems": {
							"location": "querystring",
							"locationName": "MaxItems"
						},
						"WebACLId": {
							"location": "uri",
							"locationName": "WebACLId"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"DistributionList": {
							"shape": "S36"
						}
					},
					"payload": "DistributionList"
				}
			},
			"ListInvalidations": {
				"http": {
					"method": "GET",
					"requestUri": "/2016-09-29/distribution/{DistributionId}/invalidation"
				},
				"input": {
					"type": "structure",
					"required": [
						"DistributionId"
					],
					"members": {
						"DistributionId": {
							"location": "uri",
							"locationName": "DistributionId"
						},
						"Marker": {
							"location": "querystring",
							"locationName": "Marker"
						},
						"MaxItems": {
							"location": "querystring",
							"locationName": "MaxItems"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"InvalidationList": {
							"type": "structure",
							"required": [
								"Marker",
								"MaxItems",
								"IsTruncated",
								"Quantity"
							],
							"members": {
								"Marker": {},
								"NextMarker": {},
								"MaxItems": {
									"type": "integer"
								},
								"IsTruncated": {
									"type": "boolean"
								},
								"Quantity": {
									"type": "integer"
								},
								"Items": {
									"type": "list",
									"member": {
										"locationName": "InvalidationSummary",
										"type": "structure",
										"required": [
											"Id",
											"CreateTime",
											"Status"
										],
										"members": {
											"Id": {},
											"CreateTime": {
												"type": "timestamp"
											},
											"Status": {}
										}
									}
								}
							}
						}
					},
					"payload": "InvalidationList"
				}
			},
			"ListStreamingDistributions": {
				"http": {
					"method": "GET",
					"requestUri": "/2016-09-29/streaming-distribution"
				},
				"input": {
					"type": "structure",
					"members": {
						"Marker": {
							"location": "querystring",
							"locationName": "Marker"
						},
						"MaxItems": {
							"location": "querystring",
							"locationName": "MaxItems"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"StreamingDistributionList": {
							"type": "structure",
							"required": [
								"Marker",
								"MaxItems",
								"IsTruncated",
								"Quantity"
							],
							"members": {
								"Marker": {},
								"NextMarker": {},
								"MaxItems": {
									"type": "integer"
								},
								"IsTruncated": {
									"type": "boolean"
								},
								"Quantity": {
									"type": "integer"
								},
								"Items": {
									"type": "list",
									"member": {
										"locationName": "StreamingDistributionSummary",
										"type": "structure",
										"required": [
											"Id",
											"ARN",
											"Status",
											"LastModifiedTime",
											"DomainName",
											"S3Origin",
											"Aliases",
											"TrustedSigners",
											"Comment",
											"PriceClass",
											"Enabled"
										],
										"members": {
											"Id": {},
											"ARN": {},
											"Status": {},
											"LastModifiedTime": {
												"type": "timestamp"
											},
											"DomainName": {},
											"S3Origin": {
												"shape": "S2b"
											},
											"Aliases": {
												"shape": "S8"
											},
											"TrustedSigners": {
												"shape": "Sy"
											},
											"Comment": {},
											"PriceClass": {},
											"Enabled": {
												"type": "boolean"
											}
										}
									}
								}
							}
						}
					},
					"payload": "StreamingDistributionList"
				}
			},
			"ListTagsForResource": {
				"http": {
					"method": "GET",
					"requestUri": "/2016-09-29/tagging"
				},
				"input": {
					"type": "structure",
					"required": [
						"Resource"
					],
					"members": {
						"Resource": {
							"location": "querystring",
							"locationName": "Resource"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"Tags"
					],
					"members": {
						"Tags": {
							"shape": "S1x"
						}
					},
					"payload": "Tags"
				}
			},
			"TagResource": {
				"http": {
					"requestUri": "/2016-09-29/tagging?Operation=Tag",
					"responseCode": 204
				},
				"input": {
					"type": "structure",
					"required": [
						"Resource",
						"Tags"
					],
					"members": {
						"Resource": {
							"location": "querystring",
							"locationName": "Resource"
						},
						"Tags": {
							"shape": "S1x",
							"locationName": "Tags",
							"xmlNamespace": {
								"uri": "http://cloudfront.amazonaws.com/doc/2016-09-29/"
							}
						}
					},
					"payload": "Tags"
				}
			},
			"UntagResource": {
				"http": {
					"requestUri": "/2016-09-29/tagging?Operation=Untag",
					"responseCode": 204
				},
				"input": {
					"type": "structure",
					"required": [
						"Resource",
						"TagKeys"
					],
					"members": {
						"Resource": {
							"location": "querystring",
							"locationName": "Resource"
						},
						"TagKeys": {
							"locationName": "TagKeys",
							"xmlNamespace": {
								"uri": "http://cloudfront.amazonaws.com/doc/2016-09-29/"
							},
							"type": "structure",
							"members": {
								"Items": {
									"type": "list",
									"member": {
										"locationName": "Key"
									}
								}
							}
						}
					},
					"payload": "TagKeys"
				}
			},
			"UpdateCloudFrontOriginAccessIdentity": {
				"http": {
					"method": "PUT",
					"requestUri": "/2016-09-29/origin-access-identity/cloudfront/{Id}/config"
				},
				"input": {
					"type": "structure",
					"required": [
						"CloudFrontOriginAccessIdentityConfig",
						"Id"
					],
					"members": {
						"CloudFrontOriginAccessIdentityConfig": {
							"shape": "S2",
							"locationName": "CloudFrontOriginAccessIdentityConfig",
							"xmlNamespace": {
								"uri": "http://cloudfront.amazonaws.com/doc/2016-09-29/"
							}
						},
						"Id": {
							"location": "uri",
							"locationName": "Id"
						},
						"IfMatch": {
							"location": "header",
							"locationName": "If-Match"
						}
					},
					"payload": "CloudFrontOriginAccessIdentityConfig"
				},
				"output": {
					"type": "structure",
					"members": {
						"CloudFrontOriginAccessIdentity": {
							"shape": "S5"
						},
						"ETag": {
							"location": "header",
							"locationName": "ETag"
						}
					},
					"payload": "CloudFrontOriginAccessIdentity"
				}
			},
			"UpdateDistribution": {
				"http": {
					"method": "PUT",
					"requestUri": "/2016-09-29/distribution/{Id}/config"
				},
				"input": {
					"type": "structure",
					"required": [
						"DistributionConfig",
						"Id"
					],
					"members": {
						"DistributionConfig": {
							"shape": "S7",
							"locationName": "DistributionConfig",
							"xmlNamespace": {
								"uri": "http://cloudfront.amazonaws.com/doc/2016-09-29/"
							}
						},
						"Id": {
							"location": "uri",
							"locationName": "Id"
						},
						"IfMatch": {
							"location": "header",
							"locationName": "If-Match"
						}
					},
					"payload": "DistributionConfig"
				},
				"output": {
					"type": "structure",
					"members": {
						"Distribution": {
							"shape": "S1o"
						},
						"ETag": {
							"location": "header",
							"locationName": "ETag"
						}
					},
					"payload": "Distribution"
				}
			},
			"UpdateStreamingDistribution": {
				"http": {
					"method": "PUT",
					"requestUri": "/2016-09-29/streaming-distribution/{Id}/config"
				},
				"input": {
					"type": "structure",
					"required": [
						"StreamingDistributionConfig",
						"Id"
					],
					"members": {
						"StreamingDistributionConfig": {
							"shape": "S2a",
							"locationName": "StreamingDistributionConfig",
							"xmlNamespace": {
								"uri": "http://cloudfront.amazonaws.com/doc/2016-09-29/"
							}
						},
						"Id": {
							"location": "uri",
							"locationName": "Id"
						},
						"IfMatch": {
							"location": "header",
							"locationName": "If-Match"
						}
					},
					"payload": "StreamingDistributionConfig"
				},
				"output": {
					"type": "structure",
					"members": {
						"StreamingDistribution": {
							"shape": "S2e"
						},
						"ETag": {
							"location": "header",
							"locationName": "ETag"
						}
					},
					"payload": "StreamingDistribution"
				}
			}
		},
		"shapes": {
			"S2": {
				"type": "structure",
				"required": [
					"CallerReference",
					"Comment"
				],
				"members": {
					"CallerReference": {},
					"Comment": {}
				}
			},
			"S5": {
				"type": "structure",
				"required": [
					"Id",
					"S3CanonicalUserId"
				],
				"members": {
					"Id": {},
					"S3CanonicalUserId": {},
					"CloudFrontOriginAccessIdentityConfig": {
						"shape": "S2"
					}
				}
			},
			"S7": {
				"type": "structure",
				"required": [
					"CallerReference",
					"Origins",
					"DefaultCacheBehavior",
					"Comment",
					"Enabled"
				],
				"members": {
					"CallerReference": {},
					"Aliases": {
						"shape": "S8"
					},
					"DefaultRootObject": {},
					"Origins": {
						"shape": "Sb"
					},
					"DefaultCacheBehavior": {
						"shape": "Sn"
					},
					"CacheBehaviors": {
						"shape": "S16"
					},
					"CustomErrorResponses": {
						"shape": "S19"
					},
					"Comment": {},
					"Logging": {
						"type": "structure",
						"required": [
							"Enabled",
							"IncludeCookies",
							"Bucket",
							"Prefix"
						],
						"members": {
							"Enabled": {
								"type": "boolean"
							},
							"IncludeCookies": {
								"type": "boolean"
							},
							"Bucket": {},
							"Prefix": {}
						}
					},
					"PriceClass": {},
					"Enabled": {
						"type": "boolean"
					},
					"ViewerCertificate": {
						"shape": "S1e"
					},
					"Restrictions": {
						"shape": "S1i"
					},
					"WebACLId": {},
					"HttpVersion": {},
					"IsIPV6Enabled": {
						"type": "boolean"
					}
				}
			},
			"S8": {
				"type": "structure",
				"required": [
					"Quantity"
				],
				"members": {
					"Quantity": {
						"type": "integer"
					},
					"Items": {
						"type": "list",
						"member": {
							"locationName": "CNAME"
						}
					}
				}
			},
			"Sb": {
				"type": "structure",
				"required": [
					"Quantity"
				],
				"members": {
					"Quantity": {
						"type": "integer"
					},
					"Items": {
						"type": "list",
						"member": {
							"locationName": "Origin",
							"type": "structure",
							"required": [
								"Id",
								"DomainName"
							],
							"members": {
								"Id": {},
								"DomainName": {},
								"OriginPath": {},
								"CustomHeaders": {
									"type": "structure",
									"required": [
										"Quantity"
									],
									"members": {
										"Quantity": {
											"type": "integer"
										},
										"Items": {
											"type": "list",
											"member": {
												"locationName": "OriginCustomHeader",
												"type": "structure",
												"required": [
													"HeaderName",
													"HeaderValue"
												],
												"members": {
													"HeaderName": {},
													"HeaderValue": {}
												}
											}
										}
									}
								},
								"S3OriginConfig": {
									"type": "structure",
									"required": [
										"OriginAccessIdentity"
									],
									"members": {
										"OriginAccessIdentity": {}
									}
								},
								"CustomOriginConfig": {
									"type": "structure",
									"required": [
										"HTTPPort",
										"HTTPSPort",
										"OriginProtocolPolicy"
									],
									"members": {
										"HTTPPort": {
											"type": "integer"
										},
										"HTTPSPort": {
											"type": "integer"
										},
										"OriginProtocolPolicy": {},
										"OriginSslProtocols": {
											"type": "structure",
											"required": [
												"Quantity",
												"Items"
											],
											"members": {
												"Quantity": {
													"type": "integer"
												},
												"Items": {
													"type": "list",
													"member": {
														"locationName": "SslProtocol"
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			},
			"Sn": {
				"type": "structure",
				"required": [
					"TargetOriginId",
					"ForwardedValues",
					"TrustedSigners",
					"ViewerProtocolPolicy",
					"MinTTL"
				],
				"members": {
					"TargetOriginId": {},
					"ForwardedValues": {
						"shape": "So"
					},
					"TrustedSigners": {
						"shape": "Sy"
					},
					"ViewerProtocolPolicy": {},
					"MinTTL": {
						"type": "long"
					},
					"AllowedMethods": {
						"shape": "S12"
					},
					"SmoothStreaming": {
						"type": "boolean"
					},
					"DefaultTTL": {
						"type": "long"
					},
					"MaxTTL": {
						"type": "long"
					},
					"Compress": {
						"type": "boolean"
					}
				}
			},
			"So": {
				"type": "structure",
				"required": [
					"QueryString",
					"Cookies"
				],
				"members": {
					"QueryString": {
						"type": "boolean"
					},
					"Cookies": {
						"type": "structure",
						"required": [
							"Forward"
						],
						"members": {
							"Forward": {},
							"WhitelistedNames": {
								"type": "structure",
								"required": [
									"Quantity"
								],
								"members": {
									"Quantity": {
										"type": "integer"
									},
									"Items": {
										"type": "list",
										"member": {
											"locationName": "Name"
										}
									}
								}
							}
						}
					},
					"Headers": {
						"type": "structure",
						"required": [
							"Quantity"
						],
						"members": {
							"Quantity": {
								"type": "integer"
							},
							"Items": {
								"type": "list",
								"member": {
									"locationName": "Name"
								}
							}
						}
					},
					"QueryStringCacheKeys": {
						"type": "structure",
						"required": [
							"Quantity"
						],
						"members": {
							"Quantity": {
								"type": "integer"
							},
							"Items": {
								"type": "list",
								"member": {
									"locationName": "Name"
								}
							}
						}
					}
				}
			},
			"Sy": {
				"type": "structure",
				"required": [
					"Enabled",
					"Quantity"
				],
				"members": {
					"Enabled": {
						"type": "boolean"
					},
					"Quantity": {
						"type": "integer"
					},
					"Items": {
						"type": "list",
						"member": {
							"locationName": "AwsAccountNumber"
						}
					}
				}
			},
			"S12": {
				"type": "structure",
				"required": [
					"Quantity",
					"Items"
				],
				"members": {
					"Quantity": {
						"type": "integer"
					},
					"Items": {
						"shape": "S13"
					},
					"CachedMethods": {
						"type": "structure",
						"required": [
							"Quantity",
							"Items"
						],
						"members": {
							"Quantity": {
								"type": "integer"
							},
							"Items": {
								"shape": "S13"
							}
						}
					}
				}
			},
			"S13": {
				"type": "list",
				"member": {
					"locationName": "Method"
				}
			},
			"S16": {
				"type": "structure",
				"required": [
					"Quantity"
				],
				"members": {
					"Quantity": {
						"type": "integer"
					},
					"Items": {
						"type": "list",
						"member": {
							"locationName": "CacheBehavior",
							"type": "structure",
							"required": [
								"PathPattern",
								"TargetOriginId",
								"ForwardedValues",
								"TrustedSigners",
								"ViewerProtocolPolicy",
								"MinTTL"
							],
							"members": {
								"PathPattern": {},
								"TargetOriginId": {},
								"ForwardedValues": {
									"shape": "So"
								},
								"TrustedSigners": {
									"shape": "Sy"
								},
								"ViewerProtocolPolicy": {},
								"MinTTL": {
									"type": "long"
								},
								"AllowedMethods": {
									"shape": "S12"
								},
								"SmoothStreaming": {
									"type": "boolean"
								},
								"DefaultTTL": {
									"type": "long"
								},
								"MaxTTL": {
									"type": "long"
								},
								"Compress": {
									"type": "boolean"
								}
							}
						}
					}
				}
			},
			"S19": {
				"type": "structure",
				"required": [
					"Quantity"
				],
				"members": {
					"Quantity": {
						"type": "integer"
					},
					"Items": {
						"type": "list",
						"member": {
							"locationName": "CustomErrorResponse",
							"type": "structure",
							"required": [
								"ErrorCode"
							],
							"members": {
								"ErrorCode": {
									"type": "integer"
								},
								"ResponsePagePath": {},
								"ResponseCode": {},
								"ErrorCachingMinTTL": {
									"type": "long"
								}
							}
						}
					}
				}
			},
			"S1e": {
				"type": "structure",
				"members": {
					"CloudFrontDefaultCertificate": {
						"type": "boolean"
					},
					"IAMCertificateId": {},
					"ACMCertificateArn": {},
					"SSLSupportMethod": {},
					"MinimumProtocolVersion": {},
					"Certificate": {
						"deprecated": true
					},
					"CertificateSource": {
						"deprecated": true
					}
				}
			},
			"S1i": {
				"type": "structure",
				"required": [
					"GeoRestriction"
				],
				"members": {
					"GeoRestriction": {
						"type": "structure",
						"required": [
							"RestrictionType",
							"Quantity"
						],
						"members": {
							"RestrictionType": {},
							"Quantity": {
								"type": "integer"
							},
							"Items": {
								"type": "list",
								"member": {
									"locationName": "Location"
								}
							}
						}
					}
				}
			},
			"S1o": {
				"type": "structure",
				"required": [
					"Id",
					"ARN",
					"Status",
					"LastModifiedTime",
					"InProgressInvalidationBatches",
					"DomainName",
					"ActiveTrustedSigners",
					"DistributionConfig"
				],
				"members": {
					"Id": {},
					"ARN": {},
					"Status": {},
					"LastModifiedTime": {
						"type": "timestamp"
					},
					"InProgressInvalidationBatches": {
						"type": "integer"
					},
					"DomainName": {},
					"ActiveTrustedSigners": {
						"shape": "S1q"
					},
					"DistributionConfig": {
						"shape": "S7"
					}
				}
			},
			"S1q": {
				"type": "structure",
				"required": [
					"Enabled",
					"Quantity"
				],
				"members": {
					"Enabled": {
						"type": "boolean"
					},
					"Quantity": {
						"type": "integer"
					},
					"Items": {
						"type": "list",
						"member": {
							"locationName": "Signer",
							"type": "structure",
							"members": {
								"AwsAccountNumber": {},
								"KeyPairIds": {
									"type": "structure",
									"required": [
										"Quantity"
									],
									"members": {
										"Quantity": {
											"type": "integer"
										},
										"Items": {
											"type": "list",
											"member": {
												"locationName": "KeyPairId"
											}
										}
									}
								}
							}
						}
					}
				}
			},
			"S1x": {
				"type": "structure",
				"members": {
					"Items": {
						"type": "list",
						"member": {
							"locationName": "Tag",
							"type": "structure",
							"required": [
								"Key"
							],
							"members": {
								"Key": {},
								"Value": {}
							}
						}
					}
				}
			},
			"S24": {
				"type": "structure",
				"required": [
					"Paths",
					"CallerReference"
				],
				"members": {
					"Paths": {
						"type": "structure",
						"required": [
							"Quantity"
						],
						"members": {
							"Quantity": {
								"type": "integer"
							},
							"Items": {
								"type": "list",
								"member": {
									"locationName": "Path"
								}
							}
						}
					},
					"CallerReference": {}
				}
			},
			"S28": {
				"type": "structure",
				"required": [
					"Id",
					"Status",
					"CreateTime",
					"InvalidationBatch"
				],
				"members": {
					"Id": {},
					"Status": {},
					"CreateTime": {
						"type": "timestamp"
					},
					"InvalidationBatch": {
						"shape": "S24"
					}
				}
			},
			"S2a": {
				"type": "structure",
				"required": [
					"CallerReference",
					"S3Origin",
					"Comment",
					"TrustedSigners",
					"Enabled"
				],
				"members": {
					"CallerReference": {},
					"S3Origin": {
						"shape": "S2b"
					},
					"Aliases": {
						"shape": "S8"
					},
					"Comment": {},
					"Logging": {
						"type": "structure",
						"required": [
							"Enabled",
							"Bucket",
							"Prefix"
						],
						"members": {
							"Enabled": {
								"type": "boolean"
							},
							"Bucket": {},
							"Prefix": {}
						}
					},
					"TrustedSigners": {
						"shape": "Sy"
					},
					"PriceClass": {},
					"Enabled": {
						"type": "boolean"
					}
				}
			},
			"S2b": {
				"type": "structure",
				"required": [
					"DomainName",
					"OriginAccessIdentity"
				],
				"members": {
					"DomainName": {},
					"OriginAccessIdentity": {}
				}
			},
			"S2e": {
				"type": "structure",
				"required": [
					"Id",
					"ARN",
					"Status",
					"DomainName",
					"ActiveTrustedSigners",
					"StreamingDistributionConfig"
				],
				"members": {
					"Id": {},
					"ARN": {},
					"Status": {},
					"LastModifiedTime": {
						"type": "timestamp"
					},
					"DomainName": {},
					"ActiveTrustedSigners": {
						"shape": "S1q"
					},
					"StreamingDistributionConfig": {
						"shape": "S2a"
					}
				}
			},
			"S36": {
				"type": "structure",
				"required": [
					"Marker",
					"MaxItems",
					"IsTruncated",
					"Quantity"
				],
				"members": {
					"Marker": {},
					"NextMarker": {},
					"MaxItems": {
						"type": "integer"
					},
					"IsTruncated": {
						"type": "boolean"
					},
					"Quantity": {
						"type": "integer"
					},
					"Items": {
						"type": "list",
						"member": {
							"locationName": "DistributionSummary",
							"type": "structure",
							"required": [
								"Id",
								"ARN",
								"Status",
								"LastModifiedTime",
								"DomainName",
								"Aliases",
								"Origins",
								"DefaultCacheBehavior",
								"CacheBehaviors",
								"CustomErrorResponses",
								"Comment",
								"PriceClass",
								"Enabled",
								"ViewerCertificate",
								"Restrictions",
								"WebACLId",
								"HttpVersion",
								"IsIPV6Enabled"
							],
							"members": {
								"Id": {},
								"ARN": {},
								"Status": {},
								"LastModifiedTime": {
									"type": "timestamp"
								},
								"DomainName": {},
								"Aliases": {
									"shape": "S8"
								},
								"Origins": {
									"shape": "Sb"
								},
								"DefaultCacheBehavior": {
									"shape": "Sn"
								},
								"CacheBehaviors": {
									"shape": "S16"
								},
								"CustomErrorResponses": {
									"shape": "S19"
								},
								"Comment": {},
								"PriceClass": {},
								"Enabled": {
									"type": "boolean"
								},
								"ViewerCertificate": {
									"shape": "S1e"
								},
								"Restrictions": {
									"shape": "S1i"
								},
								"WebACLId": {},
								"HttpVersion": {},
								"IsIPV6Enabled": {
									"type": "boolean"
								}
							}
						}
					}
				}
			}
		}
	};

/***/ },
/* 257 */
/***/ function(module, exports) {

	module.exports = {
		"pagination": {
			"ListCloudFrontOriginAccessIdentities": {
				"input_token": "Marker",
				"output_token": "CloudFrontOriginAccessIdentityList.NextMarker",
				"limit_key": "MaxItems",
				"more_results": "CloudFrontOriginAccessIdentityList.IsTruncated",
				"result_key": "CloudFrontOriginAccessIdentityList.Items"
			},
			"ListDistributions": {
				"input_token": "Marker",
				"output_token": "DistributionList.NextMarker",
				"limit_key": "MaxItems",
				"more_results": "DistributionList.IsTruncated",
				"result_key": "DistributionList.Items"
			},
			"ListInvalidations": {
				"input_token": "Marker",
				"output_token": "InvalidationList.NextMarker",
				"limit_key": "MaxItems",
				"more_results": "InvalidationList.IsTruncated",
				"result_key": "InvalidationList.Items"
			},
			"ListStreamingDistributions": {
				"input_token": "Marker",
				"output_token": "StreamingDistributionList.NextMarker",
				"limit_key": "MaxItems",
				"more_results": "StreamingDistributionList.IsTruncated",
				"result_key": "StreamingDistributionList.Items"
			}
		}
	};

/***/ },
/* 258 */
/***/ function(module, exports) {

	module.exports = {
		"version": 2,
		"waiters": {
			"DistributionDeployed": {
				"delay": 60,
				"operation": "GetDistribution",
				"maxAttempts": 25,
				"description": "Wait until a distribution is deployed.",
				"acceptors": [
					{
						"expected": "Deployed",
						"matcher": "path",
						"state": "success",
						"argument": "Distribution.Status"
					}
				]
			},
			"InvalidationCompleted": {
				"delay": 20,
				"operation": "GetInvalidation",
				"maxAttempts": 30,
				"description": "Wait until an invalidation has completed.",
				"acceptors": [
					{
						"expected": "Completed",
						"matcher": "path",
						"state": "success",
						"argument": "Invalidation.Status"
					}
				]
			},
			"StreamingDistributionDeployed": {
				"delay": 60,
				"operation": "GetStreamingDistribution",
				"maxAttempts": 25,
				"description": "Wait until a streaming distribution is deployed.",
				"acceptors": [
					{
						"expected": "Deployed",
						"matcher": "path",
						"state": "success",
						"argument": "StreamingDistribution.Status"
					}
				]
			}
		}
	};

/***/ },
/* 259 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['cloudhsm'] = {};
	AWS.CloudHSM = Service.defineService('cloudhsm', ['2014-05-30']);
	Object.defineProperty(apiLoader.services['cloudhsm'], '2014-05-30', {
	  get: function get() {
	    var model = __webpack_require__(260);
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.CloudHSM;


/***/ },
/* 260 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2014-05-30",
			"endpointPrefix": "cloudhsm",
			"jsonVersion": "1.1",
			"protocol": "json",
			"serviceAbbreviation": "CloudHSM",
			"serviceFullName": "Amazon CloudHSM",
			"signatureVersion": "v4",
			"targetPrefix": "CloudHsmFrontendService"
		},
		"operations": {
			"AddTagsToResource": {
				"input": {
					"type": "structure",
					"required": [
						"ResourceArn",
						"TagList"
					],
					"members": {
						"ResourceArn": {},
						"TagList": {
							"shape": "S3"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"Status"
					],
					"members": {
						"Status": {}
					}
				}
			},
			"CreateHapg": {
				"input": {
					"type": "structure",
					"required": [
						"Label"
					],
					"members": {
						"Label": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"HapgArn": {}
					}
				}
			},
			"CreateHsm": {
				"input": {
					"type": "structure",
					"required": [
						"SubnetId",
						"SshKey",
						"IamRoleArn",
						"SubscriptionType"
					],
					"members": {
						"SubnetId": {
							"locationName": "SubnetId"
						},
						"SshKey": {
							"locationName": "SshKey"
						},
						"EniIp": {
							"locationName": "EniIp"
						},
						"IamRoleArn": {
							"locationName": "IamRoleArn"
						},
						"ExternalId": {
							"locationName": "ExternalId"
						},
						"SubscriptionType": {
							"locationName": "SubscriptionType"
						},
						"ClientToken": {
							"locationName": "ClientToken"
						},
						"SyslogIp": {
							"locationName": "SyslogIp"
						}
					},
					"locationName": "CreateHsmRequest"
				},
				"output": {
					"type": "structure",
					"members": {
						"HsmArn": {}
					}
				}
			},
			"CreateLunaClient": {
				"input": {
					"type": "structure",
					"required": [
						"Certificate"
					],
					"members": {
						"Label": {},
						"Certificate": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ClientArn": {}
					}
				}
			},
			"DeleteHapg": {
				"input": {
					"type": "structure",
					"required": [
						"HapgArn"
					],
					"members": {
						"HapgArn": {}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"Status"
					],
					"members": {
						"Status": {}
					}
				}
			},
			"DeleteHsm": {
				"input": {
					"type": "structure",
					"required": [
						"HsmArn"
					],
					"members": {
						"HsmArn": {
							"locationName": "HsmArn"
						}
					},
					"locationName": "DeleteHsmRequest"
				},
				"output": {
					"type": "structure",
					"required": [
						"Status"
					],
					"members": {
						"Status": {}
					}
				}
			},
			"DeleteLunaClient": {
				"input": {
					"type": "structure",
					"required": [
						"ClientArn"
					],
					"members": {
						"ClientArn": {}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"Status"
					],
					"members": {
						"Status": {}
					}
				}
			},
			"DescribeHapg": {
				"input": {
					"type": "structure",
					"required": [
						"HapgArn"
					],
					"members": {
						"HapgArn": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"HapgArn": {},
						"HapgSerial": {},
						"HsmsLastActionFailed": {
							"shape": "Sz"
						},
						"HsmsPendingDeletion": {
							"shape": "Sz"
						},
						"HsmsPendingRegistration": {
							"shape": "Sz"
						},
						"Label": {},
						"LastModifiedTimestamp": {},
						"PartitionSerialList": {
							"shape": "S11"
						},
						"State": {}
					}
				}
			},
			"DescribeHsm": {
				"input": {
					"type": "structure",
					"members": {
						"HsmArn": {},
						"HsmSerialNumber": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"HsmArn": {},
						"Status": {},
						"StatusDetails": {},
						"AvailabilityZone": {},
						"EniId": {},
						"EniIp": {},
						"SubscriptionType": {},
						"SubscriptionStartDate": {},
						"SubscriptionEndDate": {},
						"VpcId": {},
						"SubnetId": {},
						"IamRoleArn": {},
						"SerialNumber": {},
						"VendorName": {},
						"HsmType": {},
						"SoftwareVersion": {},
						"SshPublicKey": {},
						"SshKeyLastUpdated": {},
						"ServerCertUri": {},
						"ServerCertLastUpdated": {},
						"Partitions": {
							"type": "list",
							"member": {}
						}
					}
				}
			},
			"DescribeLunaClient": {
				"input": {
					"type": "structure",
					"members": {
						"ClientArn": {},
						"CertificateFingerprint": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ClientArn": {},
						"Certificate": {},
						"CertificateFingerprint": {},
						"LastModifiedTimestamp": {},
						"Label": {}
					}
				}
			},
			"GetConfig": {
				"input": {
					"type": "structure",
					"required": [
						"ClientArn",
						"ClientVersion",
						"HapgList"
					],
					"members": {
						"ClientArn": {},
						"ClientVersion": {},
						"HapgList": {
							"shape": "S1i"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ConfigType": {},
						"ConfigFile": {},
						"ConfigCred": {}
					}
				}
			},
			"ListAvailableZones": {
				"input": {
					"type": "structure",
					"members": {}
				},
				"output": {
					"type": "structure",
					"members": {
						"AZList": {
							"type": "list",
							"member": {}
						}
					}
				}
			},
			"ListHapgs": {
				"input": {
					"type": "structure",
					"members": {
						"NextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"HapgList"
					],
					"members": {
						"HapgList": {
							"shape": "S1i"
						},
						"NextToken": {}
					}
				}
			},
			"ListHsms": {
				"input": {
					"type": "structure",
					"members": {
						"NextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"HsmList": {
							"shape": "Sz"
						},
						"NextToken": {}
					}
				}
			},
			"ListLunaClients": {
				"input": {
					"type": "structure",
					"members": {
						"NextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"ClientList"
					],
					"members": {
						"ClientList": {
							"type": "list",
							"member": {}
						},
						"NextToken": {}
					}
				}
			},
			"ListTagsForResource": {
				"input": {
					"type": "structure",
					"required": [
						"ResourceArn"
					],
					"members": {
						"ResourceArn": {}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"TagList"
					],
					"members": {
						"TagList": {
							"shape": "S3"
						}
					}
				}
			},
			"ModifyHapg": {
				"input": {
					"type": "structure",
					"required": [
						"HapgArn"
					],
					"members": {
						"HapgArn": {},
						"Label": {},
						"PartitionSerialList": {
							"shape": "S11"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"HapgArn": {}
					}
				}
			},
			"ModifyHsm": {
				"input": {
					"type": "structure",
					"required": [
						"HsmArn"
					],
					"members": {
						"HsmArn": {
							"locationName": "HsmArn"
						},
						"SubnetId": {
							"locationName": "SubnetId"
						},
						"EniIp": {
							"locationName": "EniIp"
						},
						"IamRoleArn": {
							"locationName": "IamRoleArn"
						},
						"ExternalId": {
							"locationName": "ExternalId"
						},
						"SyslogIp": {
							"locationName": "SyslogIp"
						}
					},
					"locationName": "ModifyHsmRequest"
				},
				"output": {
					"type": "structure",
					"members": {
						"HsmArn": {}
					}
				}
			},
			"ModifyLunaClient": {
				"input": {
					"type": "structure",
					"required": [
						"ClientArn",
						"Certificate"
					],
					"members": {
						"ClientArn": {},
						"Certificate": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ClientArn": {}
					}
				}
			},
			"RemoveTagsFromResource": {
				"input": {
					"type": "structure",
					"required": [
						"ResourceArn",
						"TagKeyList"
					],
					"members": {
						"ResourceArn": {},
						"TagKeyList": {
							"type": "list",
							"member": {}
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"Status"
					],
					"members": {
						"Status": {}
					}
				}
			}
		},
		"shapes": {
			"S3": {
				"type": "list",
				"member": {
					"type": "structure",
					"required": [
						"Key",
						"Value"
					],
					"members": {
						"Key": {},
						"Value": {}
					}
				}
			},
			"Sz": {
				"type": "list",
				"member": {}
			},
			"S11": {
				"type": "list",
				"member": {}
			},
			"S1i": {
				"type": "list",
				"member": {}
			}
		}
	};

/***/ },
/* 261 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['cloudsearch'] = {};
	AWS.CloudSearch = Service.defineService('cloudsearch', ['2011-02-01', '2013-01-01']);
	Object.defineProperty(apiLoader.services['cloudsearch'], '2011-02-01', {
	  get: function get() {
	    var model = __webpack_require__(262);
	    model.paginators = __webpack_require__(263).pagination;
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});
	Object.defineProperty(apiLoader.services['cloudsearch'], '2013-01-01', {
	  get: function get() {
	    var model = __webpack_require__(264);
	    model.paginators = __webpack_require__(265).pagination;
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.CloudSearch;


/***/ },
/* 262 */
/***/ function(module, exports) {

	module.exports = {
		"metadata": {
			"apiVersion": "2011-02-01",
			"endpointPrefix": "cloudsearch",
			"serviceFullName": "Amazon CloudSearch",
			"signatureVersion": "v4",
			"xmlNamespace": "http://cloudsearch.amazonaws.com/doc/2011-02-01/",
			"protocol": "query"
		},
		"operations": {
			"CreateDomain": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName"
					],
					"members": {
						"DomainName": {}
					}
				},
				"output": {
					"resultWrapper": "CreateDomainResult",
					"type": "structure",
					"members": {
						"DomainStatus": {
							"shape": "S4"
						}
					}
				}
			},
			"DefineIndexField": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName",
						"IndexField"
					],
					"members": {
						"DomainName": {},
						"IndexField": {
							"shape": "Sf"
						}
					}
				},
				"output": {
					"resultWrapper": "DefineIndexFieldResult",
					"type": "structure",
					"required": [
						"IndexField"
					],
					"members": {
						"IndexField": {
							"shape": "Sx"
						}
					}
				}
			},
			"DefineRankExpression": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName",
						"RankExpression"
					],
					"members": {
						"DomainName": {},
						"RankExpression": {
							"shape": "S12"
						}
					}
				},
				"output": {
					"resultWrapper": "DefineRankExpressionResult",
					"type": "structure",
					"required": [
						"RankExpression"
					],
					"members": {
						"RankExpression": {
							"shape": "S15"
						}
					}
				}
			},
			"DeleteDomain": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName"
					],
					"members": {
						"DomainName": {}
					}
				},
				"output": {
					"resultWrapper": "DeleteDomainResult",
					"type": "structure",
					"members": {
						"DomainStatus": {
							"shape": "S4"
						}
					}
				}
			},
			"DeleteIndexField": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName",
						"IndexFieldName"
					],
					"members": {
						"DomainName": {},
						"IndexFieldName": {}
					}
				},
				"output": {
					"resultWrapper": "DeleteIndexFieldResult",
					"type": "structure",
					"required": [
						"IndexField"
					],
					"members": {
						"IndexField": {
							"shape": "Sx"
						}
					}
				}
			},
			"DeleteRankExpression": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName",
						"RankName"
					],
					"members": {
						"DomainName": {},
						"RankName": {}
					}
				},
				"output": {
					"resultWrapper": "DeleteRankExpressionResult",
					"type": "structure",
					"required": [
						"RankExpression"
					],
					"members": {
						"RankExpression": {
							"shape": "S15"
						}
					}
				}
			},
			"DescribeAvailabilityOptions": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName"
					],
					"members": {
						"DomainName": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeAvailabilityOptionsResult",
					"type": "structure",
					"members": {
						"AvailabilityOptions": {
							"shape": "S1e"
						}
					}
				}
			},
			"DescribeDefaultSearchField": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName"
					],
					"members": {
						"DomainName": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeDefaultSearchFieldResult",
					"type": "structure",
					"required": [
						"DefaultSearchField"
					],
					"members": {
						"DefaultSearchField": {
							"shape": "S1i"
						}
					}
				}
			},
			"DescribeDomains": {
				"input": {
					"type": "structure",
					"members": {
						"DomainNames": {
							"type": "list",
							"member": {}
						}
					}
				},
				"output": {
					"resultWrapper": "DescribeDomainsResult",
					"type": "structure",
					"required": [
						"DomainStatusList"
					],
					"members": {
						"DomainStatusList": {
							"type": "list",
							"member": {
								"shape": "S4"
							}
						}
					}
				}
			},
			"DescribeIndexFields": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName"
					],
					"members": {
						"DomainName": {},
						"FieldNames": {
							"shape": "S1o"
						}
					}
				},
				"output": {
					"resultWrapper": "DescribeIndexFieldsResult",
					"type": "structure",
					"required": [
						"IndexFields"
					],
					"members": {
						"IndexFields": {
							"type": "list",
							"member": {
								"shape": "Sx"
							}
						}
					}
				}
			},
			"DescribeRankExpressions": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName"
					],
					"members": {
						"DomainName": {},
						"RankNames": {
							"shape": "S1o"
						}
					}
				},
				"output": {
					"resultWrapper": "DescribeRankExpressionsResult",
					"type": "structure",
					"required": [
						"RankExpressions"
					],
					"members": {
						"RankExpressions": {
							"type": "list",
							"member": {
								"shape": "S15"
							}
						}
					}
				}
			},
			"DescribeServiceAccessPolicies": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName"
					],
					"members": {
						"DomainName": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeServiceAccessPoliciesResult",
					"type": "structure",
					"required": [
						"AccessPolicies"
					],
					"members": {
						"AccessPolicies": {
							"shape": "S1w"
						}
					}
				}
			},
			"DescribeStemmingOptions": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName"
					],
					"members": {
						"DomainName": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeStemmingOptionsResult",
					"type": "structure",
					"required": [
						"Stems"
					],
					"members": {
						"Stems": {
							"shape": "S20"
						}
					}
				}
			},
			"DescribeStopwordOptions": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName"
					],
					"members": {
						"DomainName": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeStopwordOptionsResult",
					"type": "structure",
					"required": [
						"Stopwords"
					],
					"members": {
						"Stopwords": {
							"shape": "S24"
						}
					}
				}
			},
			"DescribeSynonymOptions": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName"
					],
					"members": {
						"DomainName": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeSynonymOptionsResult",
					"type": "structure",
					"required": [
						"Synonyms"
					],
					"members": {
						"Synonyms": {
							"shape": "S28"
						}
					}
				}
			},
			"IndexDocuments": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName"
					],
					"members": {
						"DomainName": {}
					}
				},
				"output": {
					"resultWrapper": "IndexDocumentsResult",
					"type": "structure",
					"members": {
						"FieldNames": {
							"shape": "S1o"
						}
					}
				}
			},
			"UpdateAvailabilityOptions": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName",
						"MultiAZ"
					],
					"members": {
						"DomainName": {},
						"MultiAZ": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"resultWrapper": "UpdateAvailabilityOptionsResult",
					"type": "structure",
					"members": {
						"AvailabilityOptions": {
							"shape": "S1e"
						}
					}
				}
			},
			"UpdateDefaultSearchField": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName",
						"DefaultSearchField"
					],
					"members": {
						"DomainName": {},
						"DefaultSearchField": {}
					}
				},
				"output": {
					"resultWrapper": "UpdateDefaultSearchFieldResult",
					"type": "structure",
					"required": [
						"DefaultSearchField"
					],
					"members": {
						"DefaultSearchField": {
							"shape": "S1i"
						}
					}
				}
			},
			"UpdateServiceAccessPolicies": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName",
						"AccessPolicies"
					],
					"members": {
						"DomainName": {},
						"AccessPolicies": {}
					}
				},
				"output": {
					"resultWrapper": "UpdateServiceAccessPoliciesResult",
					"type": "structure",
					"required": [
						"AccessPolicies"
					],
					"members": {
						"AccessPolicies": {
							"shape": "S1w"
						}
					}
				}
			},
			"UpdateStemmingOptions": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName",
						"Stems"
					],
					"members": {
						"DomainName": {},
						"Stems": {}
					}
				},
				"output": {
					"resultWrapper": "UpdateStemmingOptionsResult",
					"type": "structure",
					"required": [
						"Stems"
					],
					"members": {
						"Stems": {
							"shape": "S20"
						}
					}
				}
			},
			"UpdateStopwordOptions": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName",
						"Stopwords"
					],
					"members": {
						"DomainName": {},
						"Stopwords": {}
					}
				},
				"output": {
					"resultWrapper": "UpdateStopwordOptionsResult",
					"type": "structure",
					"required": [
						"Stopwords"
					],
					"members": {
						"Stopwords": {
							"shape": "S24"
						}
					}
				}
			},
			"UpdateSynonymOptions": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName",
						"Synonyms"
					],
					"members": {
						"DomainName": {},
						"Synonyms": {}
					}
				},
				"output": {
					"resultWrapper": "UpdateSynonymOptionsResult",
					"type": "structure",
					"required": [
						"Synonyms"
					],
					"members": {
						"Synonyms": {
							"shape": "S28"
						}
					}
				}
			}
		},
		"shapes": {
			"S4": {
				"type": "structure",
				"required": [
					"DomainId",
					"DomainName",
					"RequiresIndexDocuments"
				],
				"members": {
					"DomainId": {},
					"DomainName": {},
					"Created": {
						"type": "boolean"
					},
					"Deleted": {
						"type": "boolean"
					},
					"NumSearchableDocs": {
						"type": "long"
					},
					"DocService": {
						"shape": "S8"
					},
					"SearchService": {
						"shape": "S8"
					},
					"RequiresIndexDocuments": {
						"type": "boolean"
					},
					"Processing": {
						"type": "boolean"
					},
					"SearchInstanceType": {},
					"SearchPartitionCount": {
						"type": "integer"
					},
					"SearchInstanceCount": {
						"type": "integer"
					}
				}
			},
			"S8": {
				"type": "structure",
				"members": {
					"Arn": {},
					"Endpoint": {}
				}
			},
			"Sf": {
				"type": "structure",
				"required": [
					"IndexFieldName",
					"IndexFieldType"
				],
				"members": {
					"IndexFieldName": {},
					"IndexFieldType": {},
					"UIntOptions": {
						"type": "structure",
						"members": {
							"DefaultValue": {
								"type": "integer"
							}
						}
					},
					"LiteralOptions": {
						"type": "structure",
						"members": {
							"DefaultValue": {},
							"SearchEnabled": {
								"type": "boolean"
							},
							"FacetEnabled": {
								"type": "boolean"
							},
							"ResultEnabled": {
								"type": "boolean"
							}
						}
					},
					"TextOptions": {
						"type": "structure",
						"members": {
							"DefaultValue": {},
							"FacetEnabled": {
								"type": "boolean"
							},
							"ResultEnabled": {
								"type": "boolean"
							},
							"TextProcessor": {}
						}
					},
					"SourceAttributes": {
						"type": "list",
						"member": {
							"type": "structure",
							"required": [
								"SourceDataFunction"
							],
							"members": {
								"SourceDataFunction": {},
								"SourceDataCopy": {
									"type": "structure",
									"required": [
										"SourceName"
									],
									"members": {
										"SourceName": {},
										"DefaultValue": {}
									}
								},
								"SourceDataTrimTitle": {
									"type": "structure",
									"required": [
										"SourceName"
									],
									"members": {
										"SourceName": {},
										"DefaultValue": {},
										"Separator": {},
										"Language": {}
									}
								},
								"SourceDataMap": {
									"type": "structure",
									"required": [
										"SourceName"
									],
									"members": {
										"SourceName": {},
										"DefaultValue": {},
										"Cases": {
											"type": "map",
											"key": {},
											"value": {}
										}
									}
								}
							}
						}
					}
				}
			},
			"Sx": {
				"type": "structure",
				"required": [
					"Options",
					"Status"
				],
				"members": {
					"Options": {
						"shape": "Sf"
					},
					"Status": {
						"shape": "Sy"
					}
				}
			},
			"Sy": {
				"type": "structure",
				"required": [
					"CreationDate",
					"UpdateDate",
					"State"
				],
				"members": {
					"CreationDate": {
						"type": "timestamp"
					},
					"UpdateDate": {
						"type": "timestamp"
					},
					"UpdateVersion": {
						"type": "integer"
					},
					"State": {},
					"PendingDeletion": {
						"type": "boolean"
					}
				}
			},
			"S12": {
				"type": "structure",
				"required": [
					"RankName",
					"RankExpression"
				],
				"members": {
					"RankName": {},
					"RankExpression": {}
				}
			},
			"S15": {
				"type": "structure",
				"required": [
					"Options",
					"Status"
				],
				"members": {
					"Options": {
						"shape": "S12"
					},
					"Status": {
						"shape": "Sy"
					}
				}
			},
			"S1e": {
				"type": "structure",
				"required": [
					"Options",
					"Status"
				],
				"members": {
					"Options": {
						"type": "boolean"
					},
					"Status": {
						"shape": "Sy"
					}
				}
			},
			"S1i": {
				"type": "structure",
				"required": [
					"Options",
					"Status"
				],
				"members": {
					"Options": {},
					"Status": {
						"shape": "Sy"
					}
				}
			},
			"S1o": {
				"type": "list",
				"member": {}
			},
			"S1w": {
				"type": "structure",
				"required": [
					"Options",
					"Status"
				],
				"members": {
					"Options": {},
					"Status": {
						"shape": "Sy"
					}
				}
			},
			"S20": {
				"type": "structure",
				"required": [
					"Options",
					"Status"
				],
				"members": {
					"Options": {},
					"Status": {
						"shape": "Sy"
					}
				}
			},
			"S24": {
				"type": "structure",
				"required": [
					"Options",
					"Status"
				],
				"members": {
					"Options": {},
					"Status": {
						"shape": "Sy"
					}
				}
			},
			"S28": {
				"type": "structure",
				"required": [
					"Options",
					"Status"
				],
				"members": {
					"Options": {},
					"Status": {
						"shape": "Sy"
					}
				}
			}
		}
	};

/***/ },
/* 263 */
/***/ function(module, exports) {

	module.exports = {
		"pagination": {
			"DescribeDomains": {
				"result_key": "DomainStatusList"
			},
			"DescribeIndexFields": {
				"result_key": "IndexFields"
			},
			"DescribeRankExpressions": {
				"result_key": "RankExpressions"
			}
		}
	};

/***/ },
/* 264 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2013-01-01",
			"endpointPrefix": "cloudsearch",
			"serviceFullName": "Amazon CloudSearch",
			"signatureVersion": "v4",
			"xmlNamespace": "http://cloudsearch.amazonaws.com/doc/2013-01-01/",
			"protocol": "query"
		},
		"operations": {
			"BuildSuggesters": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName"
					],
					"members": {
						"DomainName": {}
					}
				},
				"output": {
					"resultWrapper": "BuildSuggestersResult",
					"type": "structure",
					"members": {
						"FieldNames": {
							"shape": "S4"
						}
					}
				}
			},
			"CreateDomain": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName"
					],
					"members": {
						"DomainName": {}
					}
				},
				"output": {
					"resultWrapper": "CreateDomainResult",
					"type": "structure",
					"members": {
						"DomainStatus": {
							"shape": "S8"
						}
					}
				}
			},
			"DefineAnalysisScheme": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName",
						"AnalysisScheme"
					],
					"members": {
						"DomainName": {},
						"AnalysisScheme": {
							"shape": "Sl"
						}
					}
				},
				"output": {
					"resultWrapper": "DefineAnalysisSchemeResult",
					"type": "structure",
					"required": [
						"AnalysisScheme"
					],
					"members": {
						"AnalysisScheme": {
							"shape": "Ss"
						}
					}
				}
			},
			"DefineExpression": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName",
						"Expression"
					],
					"members": {
						"DomainName": {},
						"Expression": {
							"shape": "Sy"
						}
					}
				},
				"output": {
					"resultWrapper": "DefineExpressionResult",
					"type": "structure",
					"required": [
						"Expression"
					],
					"members": {
						"Expression": {
							"shape": "S11"
						}
					}
				}
			},
			"DefineIndexField": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName",
						"IndexField"
					],
					"members": {
						"DomainName": {},
						"IndexField": {
							"shape": "S13"
						}
					}
				},
				"output": {
					"resultWrapper": "DefineIndexFieldResult",
					"type": "structure",
					"required": [
						"IndexField"
					],
					"members": {
						"IndexField": {
							"shape": "S1n"
						}
					}
				}
			},
			"DefineSuggester": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName",
						"Suggester"
					],
					"members": {
						"DomainName": {},
						"Suggester": {
							"shape": "S1p"
						}
					}
				},
				"output": {
					"resultWrapper": "DefineSuggesterResult",
					"type": "structure",
					"required": [
						"Suggester"
					],
					"members": {
						"Suggester": {
							"shape": "S1t"
						}
					}
				}
			},
			"DeleteAnalysisScheme": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName",
						"AnalysisSchemeName"
					],
					"members": {
						"DomainName": {},
						"AnalysisSchemeName": {}
					}
				},
				"output": {
					"resultWrapper": "DeleteAnalysisSchemeResult",
					"type": "structure",
					"required": [
						"AnalysisScheme"
					],
					"members": {
						"AnalysisScheme": {
							"shape": "Ss"
						}
					}
				}
			},
			"DeleteDomain": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName"
					],
					"members": {
						"DomainName": {}
					}
				},
				"output": {
					"resultWrapper": "DeleteDomainResult",
					"type": "structure",
					"members": {
						"DomainStatus": {
							"shape": "S8"
						}
					}
				}
			},
			"DeleteExpression": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName",
						"ExpressionName"
					],
					"members": {
						"DomainName": {},
						"ExpressionName": {}
					}
				},
				"output": {
					"resultWrapper": "DeleteExpressionResult",
					"type": "structure",
					"required": [
						"Expression"
					],
					"members": {
						"Expression": {
							"shape": "S11"
						}
					}
				}
			},
			"DeleteIndexField": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName",
						"IndexFieldName"
					],
					"members": {
						"DomainName": {},
						"IndexFieldName": {}
					}
				},
				"output": {
					"resultWrapper": "DeleteIndexFieldResult",
					"type": "structure",
					"required": [
						"IndexField"
					],
					"members": {
						"IndexField": {
							"shape": "S1n"
						}
					}
				}
			},
			"DeleteSuggester": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName",
						"SuggesterName"
					],
					"members": {
						"DomainName": {},
						"SuggesterName": {}
					}
				},
				"output": {
					"resultWrapper": "DeleteSuggesterResult",
					"type": "structure",
					"required": [
						"Suggester"
					],
					"members": {
						"Suggester": {
							"shape": "S1t"
						}
					}
				}
			},
			"DescribeAnalysisSchemes": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName"
					],
					"members": {
						"DomainName": {},
						"AnalysisSchemeNames": {
							"shape": "S25"
						},
						"Deployed": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"resultWrapper": "DescribeAnalysisSchemesResult",
					"type": "structure",
					"required": [
						"AnalysisSchemes"
					],
					"members": {
						"AnalysisSchemes": {
							"type": "list",
							"member": {
								"shape": "Ss"
							}
						}
					}
				}
			},
			"DescribeAvailabilityOptions": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName"
					],
					"members": {
						"DomainName": {},
						"Deployed": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"resultWrapper": "DescribeAvailabilityOptionsResult",
					"type": "structure",
					"members": {
						"AvailabilityOptions": {
							"shape": "S2a"
						}
					}
				}
			},
			"DescribeDomains": {
				"input": {
					"type": "structure",
					"members": {
						"DomainNames": {
							"type": "list",
							"member": {}
						}
					}
				},
				"output": {
					"resultWrapper": "DescribeDomainsResult",
					"type": "structure",
					"required": [
						"DomainStatusList"
					],
					"members": {
						"DomainStatusList": {
							"type": "list",
							"member": {
								"shape": "S8"
							}
						}
					}
				}
			},
			"DescribeExpressions": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName"
					],
					"members": {
						"DomainName": {},
						"ExpressionNames": {
							"shape": "S25"
						},
						"Deployed": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"resultWrapper": "DescribeExpressionsResult",
					"type": "structure",
					"required": [
						"Expressions"
					],
					"members": {
						"Expressions": {
							"type": "list",
							"member": {
								"shape": "S11"
							}
						}
					}
				}
			},
			"DescribeIndexFields": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName"
					],
					"members": {
						"DomainName": {},
						"FieldNames": {
							"type": "list",
							"member": {}
						},
						"Deployed": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"resultWrapper": "DescribeIndexFieldsResult",
					"type": "structure",
					"required": [
						"IndexFields"
					],
					"members": {
						"IndexFields": {
							"type": "list",
							"member": {
								"shape": "S1n"
							}
						}
					}
				}
			},
			"DescribeScalingParameters": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName"
					],
					"members": {
						"DomainName": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeScalingParametersResult",
					"type": "structure",
					"required": [
						"ScalingParameters"
					],
					"members": {
						"ScalingParameters": {
							"shape": "S2p"
						}
					}
				}
			},
			"DescribeServiceAccessPolicies": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName"
					],
					"members": {
						"DomainName": {},
						"Deployed": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"resultWrapper": "DescribeServiceAccessPoliciesResult",
					"type": "structure",
					"required": [
						"AccessPolicies"
					],
					"members": {
						"AccessPolicies": {
							"shape": "S2u"
						}
					}
				}
			},
			"DescribeSuggesters": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName"
					],
					"members": {
						"DomainName": {},
						"SuggesterNames": {
							"shape": "S25"
						},
						"Deployed": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"resultWrapper": "DescribeSuggestersResult",
					"type": "structure",
					"required": [
						"Suggesters"
					],
					"members": {
						"Suggesters": {
							"type": "list",
							"member": {
								"shape": "S1t"
							}
						}
					}
				}
			},
			"IndexDocuments": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName"
					],
					"members": {
						"DomainName": {}
					}
				},
				"output": {
					"resultWrapper": "IndexDocumentsResult",
					"type": "structure",
					"members": {
						"FieldNames": {
							"shape": "S4"
						}
					}
				}
			},
			"ListDomainNames": {
				"output": {
					"resultWrapper": "ListDomainNamesResult",
					"type": "structure",
					"members": {
						"DomainNames": {
							"type": "map",
							"key": {},
							"value": {}
						}
					}
				}
			},
			"UpdateAvailabilityOptions": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName",
						"MultiAZ"
					],
					"members": {
						"DomainName": {},
						"MultiAZ": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"resultWrapper": "UpdateAvailabilityOptionsResult",
					"type": "structure",
					"members": {
						"AvailabilityOptions": {
							"shape": "S2a"
						}
					}
				}
			},
			"UpdateScalingParameters": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName",
						"ScalingParameters"
					],
					"members": {
						"DomainName": {},
						"ScalingParameters": {
							"shape": "S2q"
						}
					}
				},
				"output": {
					"resultWrapper": "UpdateScalingParametersResult",
					"type": "structure",
					"required": [
						"ScalingParameters"
					],
					"members": {
						"ScalingParameters": {
							"shape": "S2p"
						}
					}
				}
			},
			"UpdateServiceAccessPolicies": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName",
						"AccessPolicies"
					],
					"members": {
						"DomainName": {},
						"AccessPolicies": {}
					}
				},
				"output": {
					"resultWrapper": "UpdateServiceAccessPoliciesResult",
					"type": "structure",
					"required": [
						"AccessPolicies"
					],
					"members": {
						"AccessPolicies": {
							"shape": "S2u"
						}
					}
				}
			}
		},
		"shapes": {
			"S4": {
				"type": "list",
				"member": {}
			},
			"S8": {
				"type": "structure",
				"required": [
					"DomainId",
					"DomainName",
					"RequiresIndexDocuments"
				],
				"members": {
					"DomainId": {},
					"DomainName": {},
					"ARN": {},
					"Created": {
						"type": "boolean"
					},
					"Deleted": {
						"type": "boolean"
					},
					"DocService": {
						"shape": "Sc"
					},
					"SearchService": {
						"shape": "Sc"
					},
					"RequiresIndexDocuments": {
						"type": "boolean"
					},
					"Processing": {
						"type": "boolean"
					},
					"SearchInstanceType": {},
					"SearchPartitionCount": {
						"type": "integer"
					},
					"SearchInstanceCount": {
						"type": "integer"
					},
					"Limits": {
						"type": "structure",
						"required": [
							"MaximumReplicationCount",
							"MaximumPartitionCount"
						],
						"members": {
							"MaximumReplicationCount": {
								"type": "integer"
							},
							"MaximumPartitionCount": {
								"type": "integer"
							}
						}
					}
				}
			},
			"Sc": {
				"type": "structure",
				"members": {
					"Endpoint": {}
				}
			},
			"Sl": {
				"type": "structure",
				"required": [
					"AnalysisSchemeName",
					"AnalysisSchemeLanguage"
				],
				"members": {
					"AnalysisSchemeName": {},
					"AnalysisSchemeLanguage": {},
					"AnalysisOptions": {
						"type": "structure",
						"members": {
							"Synonyms": {},
							"Stopwords": {},
							"StemmingDictionary": {},
							"JapaneseTokenizationDictionary": {},
							"AlgorithmicStemming": {}
						}
					}
				}
			},
			"Ss": {
				"type": "structure",
				"required": [
					"Options",
					"Status"
				],
				"members": {
					"Options": {
						"shape": "Sl"
					},
					"Status": {
						"shape": "St"
					}
				}
			},
			"St": {
				"type": "structure",
				"required": [
					"CreationDate",
					"UpdateDate",
					"State"
				],
				"members": {
					"CreationDate": {
						"type": "timestamp"
					},
					"UpdateDate": {
						"type": "timestamp"
					},
					"UpdateVersion": {
						"type": "integer"
					},
					"State": {},
					"PendingDeletion": {
						"type": "boolean"
					}
				}
			},
			"Sy": {
				"type": "structure",
				"required": [
					"ExpressionName",
					"ExpressionValue"
				],
				"members": {
					"ExpressionName": {},
					"ExpressionValue": {}
				}
			},
			"S11": {
				"type": "structure",
				"required": [
					"Options",
					"Status"
				],
				"members": {
					"Options": {
						"shape": "Sy"
					},
					"Status": {
						"shape": "St"
					}
				}
			},
			"S13": {
				"type": "structure",
				"required": [
					"IndexFieldName",
					"IndexFieldType"
				],
				"members": {
					"IndexFieldName": {},
					"IndexFieldType": {},
					"IntOptions": {
						"type": "structure",
						"members": {
							"DefaultValue": {
								"type": "long"
							},
							"SourceField": {},
							"FacetEnabled": {
								"type": "boolean"
							},
							"SearchEnabled": {
								"type": "boolean"
							},
							"ReturnEnabled": {
								"type": "boolean"
							},
							"SortEnabled": {
								"type": "boolean"
							}
						}
					},
					"DoubleOptions": {
						"type": "structure",
						"members": {
							"DefaultValue": {
								"type": "double"
							},
							"SourceField": {},
							"FacetEnabled": {
								"type": "boolean"
							},
							"SearchEnabled": {
								"type": "boolean"
							},
							"ReturnEnabled": {
								"type": "boolean"
							},
							"SortEnabled": {
								"type": "boolean"
							}
						}
					},
					"LiteralOptions": {
						"type": "structure",
						"members": {
							"DefaultValue": {},
							"SourceField": {},
							"FacetEnabled": {
								"type": "boolean"
							},
							"SearchEnabled": {
								"type": "boolean"
							},
							"ReturnEnabled": {
								"type": "boolean"
							},
							"SortEnabled": {
								"type": "boolean"
							}
						}
					},
					"TextOptions": {
						"type": "structure",
						"members": {
							"DefaultValue": {},
							"SourceField": {},
							"ReturnEnabled": {
								"type": "boolean"
							},
							"SortEnabled": {
								"type": "boolean"
							},
							"HighlightEnabled": {
								"type": "boolean"
							},
							"AnalysisScheme": {}
						}
					},
					"DateOptions": {
						"type": "structure",
						"members": {
							"DefaultValue": {},
							"SourceField": {},
							"FacetEnabled": {
								"type": "boolean"
							},
							"SearchEnabled": {
								"type": "boolean"
							},
							"ReturnEnabled": {
								"type": "boolean"
							},
							"SortEnabled": {
								"type": "boolean"
							}
						}
					},
					"LatLonOptions": {
						"type": "structure",
						"members": {
							"DefaultValue": {},
							"SourceField": {},
							"FacetEnabled": {
								"type": "boolean"
							},
							"SearchEnabled": {
								"type": "boolean"
							},
							"ReturnEnabled": {
								"type": "boolean"
							},
							"SortEnabled": {
								"type": "boolean"
							}
						}
					},
					"IntArrayOptions": {
						"type": "structure",
						"members": {
							"DefaultValue": {
								"type": "long"
							},
							"SourceFields": {},
							"FacetEnabled": {
								"type": "boolean"
							},
							"SearchEnabled": {
								"type": "boolean"
							},
							"ReturnEnabled": {
								"type": "boolean"
							}
						}
					},
					"DoubleArrayOptions": {
						"type": "structure",
						"members": {
							"DefaultValue": {
								"type": "double"
							},
							"SourceFields": {},
							"FacetEnabled": {
								"type": "boolean"
							},
							"SearchEnabled": {
								"type": "boolean"
							},
							"ReturnEnabled": {
								"type": "boolean"
							}
						}
					},
					"LiteralArrayOptions": {
						"type": "structure",
						"members": {
							"DefaultValue": {},
							"SourceFields": {},
							"FacetEnabled": {
								"type": "boolean"
							},
							"SearchEnabled": {
								"type": "boolean"
							},
							"ReturnEnabled": {
								"type": "boolean"
							}
						}
					},
					"TextArrayOptions": {
						"type": "structure",
						"members": {
							"DefaultValue": {},
							"SourceFields": {},
							"ReturnEnabled": {
								"type": "boolean"
							},
							"HighlightEnabled": {
								"type": "boolean"
							},
							"AnalysisScheme": {}
						}
					},
					"DateArrayOptions": {
						"type": "structure",
						"members": {
							"DefaultValue": {},
							"SourceFields": {},
							"FacetEnabled": {
								"type": "boolean"
							},
							"SearchEnabled": {
								"type": "boolean"
							},
							"ReturnEnabled": {
								"type": "boolean"
							}
						}
					}
				}
			},
			"S1n": {
				"type": "structure",
				"required": [
					"Options",
					"Status"
				],
				"members": {
					"Options": {
						"shape": "S13"
					},
					"Status": {
						"shape": "St"
					}
				}
			},
			"S1p": {
				"type": "structure",
				"required": [
					"SuggesterName",
					"DocumentSuggesterOptions"
				],
				"members": {
					"SuggesterName": {},
					"DocumentSuggesterOptions": {
						"type": "structure",
						"required": [
							"SourceField"
						],
						"members": {
							"SourceField": {},
							"FuzzyMatching": {},
							"SortExpression": {}
						}
					}
				}
			},
			"S1t": {
				"type": "structure",
				"required": [
					"Options",
					"Status"
				],
				"members": {
					"Options": {
						"shape": "S1p"
					},
					"Status": {
						"shape": "St"
					}
				}
			},
			"S25": {
				"type": "list",
				"member": {}
			},
			"S2a": {
				"type": "structure",
				"required": [
					"Options",
					"Status"
				],
				"members": {
					"Options": {
						"type": "boolean"
					},
					"Status": {
						"shape": "St"
					}
				}
			},
			"S2p": {
				"type": "structure",
				"required": [
					"Options",
					"Status"
				],
				"members": {
					"Options": {
						"shape": "S2q"
					},
					"Status": {
						"shape": "St"
					}
				}
			},
			"S2q": {
				"type": "structure",
				"members": {
					"DesiredInstanceType": {},
					"DesiredReplicationCount": {
						"type": "integer"
					},
					"DesiredPartitionCount": {
						"type": "integer"
					}
				}
			},
			"S2u": {
				"type": "structure",
				"required": [
					"Options",
					"Status"
				],
				"members": {
					"Options": {},
					"Status": {
						"shape": "St"
					}
				}
			}
		}
	};

/***/ },
/* 265 */
/***/ function(module, exports) {

	module.exports = {
		"pagination": {
			"DescribeAnalysisSchemes": {
				"result_key": "AnalysisSchemes"
			},
			"DescribeDomains": {
				"result_key": "DomainStatusList"
			},
			"DescribeExpressions": {
				"result_key": "Expressions"
			},
			"DescribeIndexFields": {
				"result_key": "IndexFields"
			},
			"DescribeSuggesters": {
				"result_key": "Suggesters"
			}
		}
	};

/***/ },
/* 266 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['cloudsearchdomain'] = {};
	AWS.CloudSearchDomain = Service.defineService('cloudsearchdomain', ['2013-01-01']);
	__webpack_require__(267);
	Object.defineProperty(apiLoader.services['cloudsearchdomain'], '2013-01-01', {
	  get: function get() {
	    var model = __webpack_require__(268);
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.CloudSearchDomain;


/***/ },
/* 267 */
/***/ function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(93);

	/**
	 * Constructs a service interface object. Each API operation is exposed as a
	 * function on service.
	 *
	 * ### Sending a Request Using CloudSearchDomain
	 *
	 * ```javascript
	 * var csd = new AWS.CloudSearchDomain({endpoint: 'my.host.tld'});
	 * csd.search(params, function (err, data) {
	 *   if (err) console.log(err, err.stack); // an error occurred
	 *   else     console.log(data);           // successful response
	 * });
	 * ```
	 *
	 * ### Locking the API Version
	 *
	 * In order to ensure that the CloudSearchDomain object uses this specific API,
	 * you can construct the object by passing the `apiVersion` option to the
	 * constructor:
	 *
	 * ```javascript
	 * var csd = new AWS.CloudSearchDomain({
	 *   endpoint: 'my.host.tld',
	 *   apiVersion: '2013-01-01'
	 * });
	 * ```
	 *
	 * You can also set the API version globally in `AWS.config.apiVersions` using
	 * the **cloudsearchdomain** service identifier:
	 *
	 * ```javascript
	 * AWS.config.apiVersions = {
	 *   cloudsearchdomain: '2013-01-01',
	 *   // other service API versions
	 * };
	 *
	 * var csd = new AWS.CloudSearchDomain({endpoint: 'my.host.tld'});
	 * ```
	 *
	 * @note You *must* provide an `endpoint` configuration parameter when
	 *   constructing this service. See {constructor} for more information.
	 *
	 * @!method constructor(options = {})
	 *   Constructs a service object. This object has one method for each
	 *   API operation.
	 *
	 *   @example Constructing a CloudSearchDomain object
	 *     var csd = new AWS.CloudSearchDomain({endpoint: 'my.host.tld'});
	 *   @note You *must* provide an `endpoint` when constructing this service.
	 *   @option (see AWS.Config.constructor)
	 *
	 * @service cloudsearchdomain
	 * @version 2013-01-01
	 */
	AWS.util.update(AWS.CloudSearchDomain.prototype, {
	  /**
	   * @api private
	   */
	  validateService: function validateService() {
	    if (!this.config.endpoint || this.config.endpoint.indexOf('{') >= 0) {
	      var msg = 'AWS.CloudSearchDomain requires an explicit ' +
	                '`endpoint\' configuration option.';
	      throw AWS.util.error(new Error(),
	        {name: 'InvalidEndpoint', message: msg});
	    }
	  },

	  /**
	   * @api private
	   */
	  setupRequestListeners: function setupRequestListeners(request) {
	    request.removeListener('validate',
	      AWS.EventListeners.Core.VALIDATE_CREDENTIALS
	    );
	    request.onAsync('validate', this.validateCredentials);
	    request.addListener('validate', this.updateRegion);
	    if (request.operation === 'search') {
	      request.addListener('build', this.convertGetToPost);
	    }
	  },

	  /**
	   * @api private
	   */
	  validateCredentials: function(req, done) {
	    if (!req.service.api.signatureVersion) return done(); // none
	    req.service.config.getCredentials(function(err) {
	      if (err) {
	        req.removeListener('sign', AWS.EventListeners.Core.SIGN);
	      }
	      done();
	    });
	  },

	  /**
	   * @api private
	   */
	  convertGetToPost: function(request) {
	    var httpRequest = request.httpRequest
	    // convert queries to POST to avoid length restrictions
	    var path = httpRequest.path.split('?')
	    httpRequest.method = 'POST'
	    httpRequest.path = path[0]
	    httpRequest.body = path[1]
	    httpRequest.headers['Content-Length'] = httpRequest.body.length
	    httpRequest.headers['Content-Type'] = 'application/x-www-form-urlencoded'
	  },

	  /**
	   * @api private
	   */
	  updateRegion: function updateRegion(request) {
	    var endpoint = request.httpRequest.endpoint.hostname;
	    var zones = endpoint.split('.');
	    request.httpRequest.region = zones[1] || request.httpRequest.region;
	  }

	});


/***/ },
/* 268 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2013-01-01",
			"endpointPrefix": "cloudsearchdomain",
			"jsonVersion": "1.1",
			"protocol": "rest-json",
			"serviceFullName": "Amazon CloudSearch Domain",
			"signatureVersion": "v4",
			"signingName": "cloudsearch"
		},
		"operations": {
			"Search": {
				"http": {
					"method": "GET",
					"requestUri": "/2013-01-01/search?format=sdk&pretty=true"
				},
				"input": {
					"type": "structure",
					"required": [
						"query"
					],
					"members": {
						"cursor": {
							"location": "querystring",
							"locationName": "cursor"
						},
						"expr": {
							"location": "querystring",
							"locationName": "expr"
						},
						"facet": {
							"location": "querystring",
							"locationName": "facet"
						},
						"filterQuery": {
							"location": "querystring",
							"locationName": "fq"
						},
						"highlight": {
							"location": "querystring",
							"locationName": "highlight"
						},
						"partial": {
							"location": "querystring",
							"locationName": "partial",
							"type": "boolean"
						},
						"query": {
							"location": "querystring",
							"locationName": "q"
						},
						"queryOptions": {
							"location": "querystring",
							"locationName": "q.options"
						},
						"queryParser": {
							"location": "querystring",
							"locationName": "q.parser"
						},
						"return": {
							"location": "querystring",
							"locationName": "return"
						},
						"size": {
							"location": "querystring",
							"locationName": "size",
							"type": "long"
						},
						"sort": {
							"location": "querystring",
							"locationName": "sort"
						},
						"start": {
							"location": "querystring",
							"locationName": "start",
							"type": "long"
						},
						"stats": {
							"location": "querystring",
							"locationName": "stats"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"status": {
							"type": "structure",
							"members": {
								"timems": {
									"type": "long"
								},
								"rid": {}
							}
						},
						"hits": {
							"type": "structure",
							"members": {
								"found": {
									"type": "long"
								},
								"start": {
									"type": "long"
								},
								"cursor": {},
								"hit": {
									"type": "list",
									"member": {
										"type": "structure",
										"members": {
											"id": {},
											"fields": {
												"type": "map",
												"key": {},
												"value": {
													"type": "list",
													"member": {}
												}
											},
											"exprs": {
												"type": "map",
												"key": {},
												"value": {}
											},
											"highlights": {
												"type": "map",
												"key": {},
												"value": {}
											}
										}
									}
								}
							}
						},
						"facets": {
							"type": "map",
							"key": {},
							"value": {
								"type": "structure",
								"members": {
									"buckets": {
										"type": "list",
										"member": {
											"type": "structure",
											"members": {
												"value": {},
												"count": {
													"type": "long"
												}
											}
										}
									}
								}
							}
						},
						"stats": {
							"type": "map",
							"key": {},
							"value": {
								"type": "structure",
								"members": {
									"min": {},
									"max": {},
									"count": {
										"type": "long"
									},
									"missing": {
										"type": "long"
									},
									"sum": {
										"type": "double"
									},
									"sumOfSquares": {
										"type": "double"
									},
									"mean": {},
									"stddev": {
										"type": "double"
									}
								}
							}
						}
					}
				}
			},
			"Suggest": {
				"http": {
					"method": "GET",
					"requestUri": "/2013-01-01/suggest?format=sdk&pretty=true"
				},
				"input": {
					"type": "structure",
					"required": [
						"query",
						"suggester"
					],
					"members": {
						"query": {
							"location": "querystring",
							"locationName": "q"
						},
						"suggester": {
							"location": "querystring",
							"locationName": "suggester"
						},
						"size": {
							"location": "querystring",
							"locationName": "size",
							"type": "long"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"status": {
							"type": "structure",
							"members": {
								"timems": {
									"type": "long"
								},
								"rid": {}
							}
						},
						"suggest": {
							"type": "structure",
							"members": {
								"query": {},
								"found": {
									"type": "long"
								},
								"suggestions": {
									"type": "list",
									"member": {
										"type": "structure",
										"members": {
											"suggestion": {},
											"score": {
												"type": "long"
											},
											"id": {}
										}
									}
								}
							}
						}
					}
				}
			},
			"UploadDocuments": {
				"http": {
					"requestUri": "/2013-01-01/documents/batch?format=sdk"
				},
				"input": {
					"type": "structure",
					"required": [
						"documents",
						"contentType"
					],
					"members": {
						"documents": {
							"type": "blob",
							"streaming": true
						},
						"contentType": {
							"location": "header",
							"locationName": "Content-Type"
						}
					},
					"payload": "documents"
				},
				"output": {
					"type": "structure",
					"members": {
						"status": {},
						"adds": {
							"type": "long"
						},
						"deletes": {
							"type": "long"
						},
						"warnings": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"message": {}
								}
							}
						}
					}
				}
			}
		},
		"shapes": {}
	};

/***/ },
/* 269 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['cloudtrail'] = {};
	AWS.CloudTrail = Service.defineService('cloudtrail', ['2013-11-01']);
	Object.defineProperty(apiLoader.services['cloudtrail'], '2013-11-01', {
	  get: function get() {
	    var model = __webpack_require__(270);
	    model.paginators = __webpack_require__(271).pagination;
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.CloudTrail;


/***/ },
/* 270 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2013-11-01",
			"endpointPrefix": "cloudtrail",
			"jsonVersion": "1.1",
			"protocol": "json",
			"serviceAbbreviation": "CloudTrail",
			"serviceFullName": "AWS CloudTrail",
			"signatureVersion": "v4",
			"targetPrefix": "com.amazonaws.cloudtrail.v20131101.CloudTrail_20131101"
		},
		"operations": {
			"AddTags": {
				"input": {
					"type": "structure",
					"required": [
						"ResourceId"
					],
					"members": {
						"ResourceId": {},
						"TagsList": {
							"shape": "S3"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				},
				"idempotent": true
			},
			"CreateTrail": {
				"input": {
					"type": "structure",
					"required": [
						"Name",
						"S3BucketName"
					],
					"members": {
						"Name": {},
						"S3BucketName": {},
						"S3KeyPrefix": {},
						"SnsTopicName": {},
						"IncludeGlobalServiceEvents": {
							"type": "boolean"
						},
						"IsMultiRegionTrail": {
							"type": "boolean"
						},
						"EnableLogFileValidation": {
							"type": "boolean"
						},
						"CloudWatchLogsLogGroupArn": {},
						"CloudWatchLogsRoleArn": {},
						"KmsKeyId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Name": {},
						"S3BucketName": {},
						"S3KeyPrefix": {},
						"SnsTopicName": {
							"deprecated": true
						},
						"SnsTopicARN": {},
						"IncludeGlobalServiceEvents": {
							"type": "boolean"
						},
						"IsMultiRegionTrail": {
							"type": "boolean"
						},
						"TrailARN": {},
						"LogFileValidationEnabled": {
							"type": "boolean"
						},
						"CloudWatchLogsLogGroupArn": {},
						"CloudWatchLogsRoleArn": {},
						"KmsKeyId": {}
					}
				},
				"idempotent": true
			},
			"DeleteTrail": {
				"input": {
					"type": "structure",
					"required": [
						"Name"
					],
					"members": {
						"Name": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				},
				"idempotent": true
			},
			"DescribeTrails": {
				"input": {
					"type": "structure",
					"members": {
						"trailNameList": {
							"type": "list",
							"member": {}
						},
						"includeShadowTrails": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"trailList": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"Name": {},
									"S3BucketName": {},
									"S3KeyPrefix": {},
									"SnsTopicName": {
										"deprecated": true
									},
									"SnsTopicARN": {},
									"IncludeGlobalServiceEvents": {
										"type": "boolean"
									},
									"IsMultiRegionTrail": {
										"type": "boolean"
									},
									"HomeRegion": {},
									"TrailARN": {},
									"LogFileValidationEnabled": {
										"type": "boolean"
									},
									"CloudWatchLogsLogGroupArn": {},
									"CloudWatchLogsRoleArn": {},
									"KmsKeyId": {}
								}
							}
						}
					}
				},
				"idempotent": true
			},
			"GetTrailStatus": {
				"input": {
					"type": "structure",
					"required": [
						"Name"
					],
					"members": {
						"Name": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"IsLogging": {
							"type": "boolean"
						},
						"LatestDeliveryError": {},
						"LatestNotificationError": {},
						"LatestDeliveryTime": {
							"type": "timestamp"
						},
						"LatestNotificationTime": {
							"type": "timestamp"
						},
						"StartLoggingTime": {
							"type": "timestamp"
						},
						"StopLoggingTime": {
							"type": "timestamp"
						},
						"LatestCloudWatchLogsDeliveryError": {},
						"LatestCloudWatchLogsDeliveryTime": {
							"type": "timestamp"
						},
						"LatestDigestDeliveryTime": {
							"type": "timestamp"
						},
						"LatestDigestDeliveryError": {},
						"LatestDeliveryAttemptTime": {},
						"LatestNotificationAttemptTime": {},
						"LatestNotificationAttemptSucceeded": {},
						"LatestDeliveryAttemptSucceeded": {},
						"TimeLoggingStarted": {},
						"TimeLoggingStopped": {}
					}
				},
				"idempotent": true
			},
			"ListPublicKeys": {
				"input": {
					"type": "structure",
					"members": {
						"StartTime": {
							"type": "timestamp"
						},
						"EndTime": {
							"type": "timestamp"
						},
						"NextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"PublicKeyList": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"Value": {
										"type": "blob"
									},
									"ValidityStartTime": {
										"type": "timestamp"
									},
									"ValidityEndTime": {
										"type": "timestamp"
									},
									"Fingerprint": {}
								}
							}
						},
						"NextToken": {}
					}
				},
				"idempotent": true
			},
			"ListTags": {
				"input": {
					"type": "structure",
					"required": [
						"ResourceIdList"
					],
					"members": {
						"ResourceIdList": {
							"type": "list",
							"member": {}
						},
						"NextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ResourceTagList": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"ResourceId": {},
									"TagsList": {
										"shape": "S3"
									}
								}
							}
						},
						"NextToken": {}
					}
				},
				"idempotent": true
			},
			"LookupEvents": {
				"input": {
					"type": "structure",
					"members": {
						"LookupAttributes": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"AttributeKey",
									"AttributeValue"
								],
								"members": {
									"AttributeKey": {},
									"AttributeValue": {}
								}
							}
						},
						"StartTime": {
							"type": "timestamp"
						},
						"EndTime": {
							"type": "timestamp"
						},
						"MaxResults": {
							"type": "integer"
						},
						"NextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Events": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"EventId": {},
									"EventName": {},
									"EventTime": {
										"type": "timestamp"
									},
									"Username": {},
									"Resources": {
										"type": "list",
										"member": {
											"type": "structure",
											"members": {
												"ResourceType": {},
												"ResourceName": {}
											}
										}
									},
									"CloudTrailEvent": {}
								}
							}
						},
						"NextToken": {}
					}
				},
				"idempotent": true
			},
			"RemoveTags": {
				"input": {
					"type": "structure",
					"required": [
						"ResourceId"
					],
					"members": {
						"ResourceId": {},
						"TagsList": {
							"shape": "S3"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				},
				"idempotent": true
			},
			"StartLogging": {
				"input": {
					"type": "structure",
					"required": [
						"Name"
					],
					"members": {
						"Name": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				},
				"idempotent": true
			},
			"StopLogging": {
				"input": {
					"type": "structure",
					"required": [
						"Name"
					],
					"members": {
						"Name": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				},
				"idempotent": true
			},
			"UpdateTrail": {
				"input": {
					"type": "structure",
					"required": [
						"Name"
					],
					"members": {
						"Name": {},
						"S3BucketName": {},
						"S3KeyPrefix": {},
						"SnsTopicName": {},
						"IncludeGlobalServiceEvents": {
							"type": "boolean"
						},
						"IsMultiRegionTrail": {
							"type": "boolean"
						},
						"EnableLogFileValidation": {
							"type": "boolean"
						},
						"CloudWatchLogsLogGroupArn": {},
						"CloudWatchLogsRoleArn": {},
						"KmsKeyId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Name": {},
						"S3BucketName": {},
						"S3KeyPrefix": {},
						"SnsTopicName": {
							"deprecated": true
						},
						"SnsTopicARN": {},
						"IncludeGlobalServiceEvents": {
							"type": "boolean"
						},
						"IsMultiRegionTrail": {
							"type": "boolean"
						},
						"TrailARN": {},
						"LogFileValidationEnabled": {
							"type": "boolean"
						},
						"CloudWatchLogsLogGroupArn": {},
						"CloudWatchLogsRoleArn": {},
						"KmsKeyId": {}
					}
				},
				"idempotent": true
			}
		},
		"shapes": {
			"S3": {
				"type": "list",
				"member": {
					"type": "structure",
					"required": [
						"Key"
					],
					"members": {
						"Key": {},
						"Value": {}
					}
				}
			}
		}
	};

/***/ },
/* 271 */
/***/ function(module, exports) {

	module.exports = {
		"pagination": {
			"DescribeTrails": {
				"result_key": "trailList"
			}
		}
	};

/***/ },
/* 272 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['cloudwatch'] = {};
	AWS.CloudWatch = Service.defineService('cloudwatch', ['2010-08-01']);
	Object.defineProperty(apiLoader.services['cloudwatch'], '2010-08-01', {
	  get: function get() {
	    var model = __webpack_require__(273);
	    model.paginators = __webpack_require__(274).pagination;
	    model.waiters = __webpack_require__(275).waiters;
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.CloudWatch;


/***/ },
/* 273 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2010-08-01",
			"endpointPrefix": "monitoring",
			"protocol": "query",
			"serviceAbbreviation": "CloudWatch",
			"serviceFullName": "Amazon CloudWatch",
			"signatureVersion": "v4",
			"xmlNamespace": "http://monitoring.amazonaws.com/doc/2010-08-01/"
		},
		"operations": {
			"DeleteAlarms": {
				"input": {
					"type": "structure",
					"required": [
						"AlarmNames"
					],
					"members": {
						"AlarmNames": {
							"shape": "S2"
						}
					}
				}
			},
			"DescribeAlarmHistory": {
				"input": {
					"type": "structure",
					"members": {
						"AlarmName": {},
						"HistoryItemType": {},
						"StartDate": {
							"type": "timestamp"
						},
						"EndDate": {
							"type": "timestamp"
						},
						"MaxRecords": {
							"type": "integer"
						},
						"NextToken": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeAlarmHistoryResult",
					"type": "structure",
					"members": {
						"AlarmHistoryItems": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"AlarmName": {},
									"Timestamp": {
										"type": "timestamp"
									},
									"HistoryItemType": {},
									"HistorySummary": {},
									"HistoryData": {}
								}
							}
						},
						"NextToken": {}
					}
				}
			},
			"DescribeAlarms": {
				"input": {
					"type": "structure",
					"members": {
						"AlarmNames": {
							"shape": "S2"
						},
						"AlarmNamePrefix": {},
						"StateValue": {},
						"ActionPrefix": {},
						"MaxRecords": {
							"type": "integer"
						},
						"NextToken": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeAlarmsResult",
					"type": "structure",
					"members": {
						"MetricAlarms": {
							"shape": "Sj"
						},
						"NextToken": {}
					}
				}
			},
			"DescribeAlarmsForMetric": {
				"input": {
					"type": "structure",
					"required": [
						"MetricName",
						"Namespace"
					],
					"members": {
						"MetricName": {},
						"Namespace": {},
						"Statistic": {},
						"Dimensions": {
							"shape": "Sv"
						},
						"Period": {
							"type": "integer"
						},
						"Unit": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeAlarmsForMetricResult",
					"type": "structure",
					"members": {
						"MetricAlarms": {
							"shape": "Sj"
						}
					}
				}
			},
			"DisableAlarmActions": {
				"input": {
					"type": "structure",
					"required": [
						"AlarmNames"
					],
					"members": {
						"AlarmNames": {
							"shape": "S2"
						}
					}
				}
			},
			"EnableAlarmActions": {
				"input": {
					"type": "structure",
					"required": [
						"AlarmNames"
					],
					"members": {
						"AlarmNames": {
							"shape": "S2"
						}
					}
				}
			},
			"GetMetricStatistics": {
				"input": {
					"type": "structure",
					"required": [
						"Namespace",
						"MetricName",
						"StartTime",
						"EndTime",
						"Period",
						"Statistics"
					],
					"members": {
						"Namespace": {},
						"MetricName": {},
						"Dimensions": {
							"shape": "Sv"
						},
						"StartTime": {
							"type": "timestamp"
						},
						"EndTime": {
							"type": "timestamp"
						},
						"Period": {
							"type": "integer"
						},
						"Statistics": {
							"type": "list",
							"member": {}
						},
						"Unit": {}
					}
				},
				"output": {
					"resultWrapper": "GetMetricStatisticsResult",
					"type": "structure",
					"members": {
						"Label": {},
						"Datapoints": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"Timestamp": {
										"type": "timestamp"
									},
									"SampleCount": {
										"type": "double"
									},
									"Average": {
										"type": "double"
									},
									"Sum": {
										"type": "double"
									},
									"Minimum": {
										"type": "double"
									},
									"Maximum": {
										"type": "double"
									},
									"Unit": {}
								},
								"xmlOrder": [
									"Timestamp",
									"SampleCount",
									"Average",
									"Sum",
									"Minimum",
									"Maximum",
									"Unit"
								]
							}
						}
					}
				}
			},
			"ListMetrics": {
				"input": {
					"type": "structure",
					"members": {
						"Namespace": {},
						"MetricName": {},
						"Dimensions": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"Name"
								],
								"members": {
									"Name": {},
									"Value": {}
								}
							}
						},
						"NextToken": {}
					}
				},
				"output": {
					"resultWrapper": "ListMetricsResult",
					"type": "structure",
					"members": {
						"Metrics": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"Namespace": {},
									"MetricName": {},
									"Dimensions": {
										"shape": "Sv"
									}
								},
								"xmlOrder": [
									"Namespace",
									"MetricName",
									"Dimensions"
								]
							}
						},
						"NextToken": {}
					},
					"xmlOrder": [
						"Metrics",
						"NextToken"
					]
				}
			},
			"PutMetricAlarm": {
				"input": {
					"type": "structure",
					"required": [
						"AlarmName",
						"MetricName",
						"Namespace",
						"Statistic",
						"Period",
						"EvaluationPeriods",
						"Threshold",
						"ComparisonOperator"
					],
					"members": {
						"AlarmName": {},
						"AlarmDescription": {},
						"ActionsEnabled": {
							"type": "boolean"
						},
						"OKActions": {
							"shape": "So"
						},
						"AlarmActions": {
							"shape": "So"
						},
						"InsufficientDataActions": {
							"shape": "So"
						},
						"MetricName": {},
						"Namespace": {},
						"Statistic": {},
						"Dimensions": {
							"shape": "Sv"
						},
						"Period": {
							"type": "integer"
						},
						"Unit": {},
						"EvaluationPeriods": {
							"type": "integer"
						},
						"Threshold": {
							"type": "double"
						},
						"ComparisonOperator": {}
					}
				}
			},
			"PutMetricData": {
				"input": {
					"type": "structure",
					"required": [
						"Namespace",
						"MetricData"
					],
					"members": {
						"Namespace": {},
						"MetricData": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"MetricName"
								],
								"members": {
									"MetricName": {},
									"Dimensions": {
										"shape": "Sv"
									},
									"Timestamp": {
										"type": "timestamp"
									},
									"Value": {
										"type": "double"
									},
									"StatisticValues": {
										"type": "structure",
										"required": [
											"SampleCount",
											"Sum",
											"Minimum",
											"Maximum"
										],
										"members": {
											"SampleCount": {
												"type": "double"
											},
											"Sum": {
												"type": "double"
											},
											"Minimum": {
												"type": "double"
											},
											"Maximum": {
												"type": "double"
											}
										}
									},
									"Unit": {}
								}
							}
						}
					}
				}
			},
			"SetAlarmState": {
				"input": {
					"type": "structure",
					"required": [
						"AlarmName",
						"StateValue",
						"StateReason"
					],
					"members": {
						"AlarmName": {},
						"StateValue": {},
						"StateReason": {},
						"StateReasonData": {}
					}
				}
			}
		},
		"shapes": {
			"S2": {
				"type": "list",
				"member": {}
			},
			"Sj": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"AlarmName": {},
						"AlarmArn": {},
						"AlarmDescription": {},
						"AlarmConfigurationUpdatedTimestamp": {
							"type": "timestamp"
						},
						"ActionsEnabled": {
							"type": "boolean"
						},
						"OKActions": {
							"shape": "So"
						},
						"AlarmActions": {
							"shape": "So"
						},
						"InsufficientDataActions": {
							"shape": "So"
						},
						"StateValue": {},
						"StateReason": {},
						"StateReasonData": {},
						"StateUpdatedTimestamp": {
							"type": "timestamp"
						},
						"MetricName": {},
						"Namespace": {},
						"Statistic": {},
						"Dimensions": {
							"shape": "Sv"
						},
						"Period": {
							"type": "integer"
						},
						"Unit": {},
						"EvaluationPeriods": {
							"type": "integer"
						},
						"Threshold": {
							"type": "double"
						},
						"ComparisonOperator": {}
					},
					"xmlOrder": [
						"AlarmName",
						"AlarmArn",
						"AlarmDescription",
						"AlarmConfigurationUpdatedTimestamp",
						"ActionsEnabled",
						"OKActions",
						"AlarmActions",
						"InsufficientDataActions",
						"StateValue",
						"StateReason",
						"StateReasonData",
						"StateUpdatedTimestamp",
						"MetricName",
						"Namespace",
						"Statistic",
						"Dimensions",
						"Period",
						"Unit",
						"EvaluationPeriods",
						"Threshold",
						"ComparisonOperator"
					]
				}
			},
			"So": {
				"type": "list",
				"member": {}
			},
			"Sv": {
				"type": "list",
				"member": {
					"type": "structure",
					"required": [
						"Name",
						"Value"
					],
					"members": {
						"Name": {},
						"Value": {}
					},
					"xmlOrder": [
						"Name",
						"Value"
					]
				}
			}
		}
	};

/***/ },
/* 274 */
/***/ function(module, exports) {

	module.exports = {
		"pagination": {
			"DescribeAlarmHistory": {
				"input_token": "NextToken",
				"output_token": "NextToken",
				"limit_key": "MaxRecords",
				"result_key": "AlarmHistoryItems"
			},
			"DescribeAlarms": {
				"input_token": "NextToken",
				"output_token": "NextToken",
				"limit_key": "MaxRecords",
				"result_key": "MetricAlarms"
			},
			"DescribeAlarmsForMetric": {
				"result_key": "MetricAlarms"
			},
			"ListMetrics": {
				"input_token": "NextToken",
				"output_token": "NextToken",
				"result_key": "Metrics"
			}
		}
	};

/***/ },
/* 275 */
/***/ function(module, exports) {

	module.exports = {
		"version": 2,
		"waiters": {
			"AlarmExists": {
				"delay": 5,
				"maxAttempts": 40,
				"operation": "DescribeAlarms",
				"acceptors": [
					{
						"matcher": "path",
						"expected": true,
						"argument": "length(MetricAlarms[]) > `0`",
						"state": "success"
					}
				]
			}
		}
	};

/***/ },
/* 276 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['cloudwatchevents'] = {};
	AWS.CloudWatchEvents = Service.defineService('cloudwatchevents', ['2014-02-03*', '2015-10-07']);
	Object.defineProperty(apiLoader.services['cloudwatchevents'], '2015-10-07', {
	  get: function get() {
	    var model = __webpack_require__(277);
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.CloudWatchEvents;


/***/ },
/* 277 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2015-10-07",
			"endpointPrefix": "events",
			"jsonVersion": "1.1",
			"serviceFullName": "Amazon CloudWatch Events",
			"signatureVersion": "v4",
			"targetPrefix": "AWSEvents",
			"protocol": "json"
		},
		"operations": {
			"DeleteRule": {
				"input": {
					"type": "structure",
					"required": [
						"Name"
					],
					"members": {
						"Name": {}
					}
				}
			},
			"DescribeRule": {
				"input": {
					"type": "structure",
					"required": [
						"Name"
					],
					"members": {
						"Name": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Name": {},
						"Arn": {},
						"EventPattern": {},
						"ScheduleExpression": {},
						"State": {},
						"Description": {},
						"RoleArn": {}
					}
				}
			},
			"DisableRule": {
				"input": {
					"type": "structure",
					"required": [
						"Name"
					],
					"members": {
						"Name": {}
					}
				}
			},
			"EnableRule": {
				"input": {
					"type": "structure",
					"required": [
						"Name"
					],
					"members": {
						"Name": {}
					}
				}
			},
			"ListRuleNamesByTarget": {
				"input": {
					"type": "structure",
					"required": [
						"TargetArn"
					],
					"members": {
						"TargetArn": {},
						"NextToken": {},
						"Limit": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"RuleNames": {
							"type": "list",
							"member": {}
						},
						"NextToken": {}
					}
				}
			},
			"ListRules": {
				"input": {
					"type": "structure",
					"members": {
						"NamePrefix": {},
						"NextToken": {},
						"Limit": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Rules": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"Name": {},
									"Arn": {},
									"EventPattern": {},
									"State": {},
									"Description": {},
									"ScheduleExpression": {},
									"RoleArn": {}
								}
							}
						},
						"NextToken": {}
					}
				}
			},
			"ListTargetsByRule": {
				"input": {
					"type": "structure",
					"required": [
						"Rule"
					],
					"members": {
						"Rule": {},
						"NextToken": {},
						"Limit": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Targets": {
							"shape": "Sp"
						},
						"NextToken": {}
					}
				}
			},
			"PutEvents": {
				"input": {
					"type": "structure",
					"required": [
						"Entries"
					],
					"members": {
						"Entries": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"Time": {
										"type": "timestamp"
									},
									"Source": {},
									"Resources": {
										"type": "list",
										"member": {}
									},
									"DetailType": {},
									"Detail": {}
								}
							}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"FailedEntryCount": {
							"type": "integer"
						},
						"Entries": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"EventId": {},
									"ErrorCode": {},
									"ErrorMessage": {}
								}
							}
						}
					}
				}
			},
			"PutRule": {
				"input": {
					"type": "structure",
					"required": [
						"Name"
					],
					"members": {
						"Name": {},
						"ScheduleExpression": {},
						"EventPattern": {},
						"State": {},
						"Description": {},
						"RoleArn": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"RuleArn": {}
					}
				}
			},
			"PutTargets": {
				"input": {
					"type": "structure",
					"required": [
						"Rule",
						"Targets"
					],
					"members": {
						"Rule": {},
						"Targets": {
							"shape": "Sp"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"FailedEntryCount": {
							"type": "integer"
						},
						"FailedEntries": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"TargetId": {},
									"ErrorCode": {},
									"ErrorMessage": {}
								}
							}
						}
					}
				}
			},
			"RemoveTargets": {
				"input": {
					"type": "structure",
					"required": [
						"Rule",
						"Ids"
					],
					"members": {
						"Rule": {},
						"Ids": {
							"type": "list",
							"member": {}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"FailedEntryCount": {
							"type": "integer"
						},
						"FailedEntries": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"TargetId": {},
									"ErrorCode": {},
									"ErrorMessage": {}
								}
							}
						}
					}
				}
			},
			"TestEventPattern": {
				"input": {
					"type": "structure",
					"required": [
						"EventPattern",
						"Event"
					],
					"members": {
						"EventPattern": {},
						"Event": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Result": {
							"type": "boolean"
						}
					}
				}
			}
		},
		"shapes": {
			"Sp": {
				"type": "list",
				"member": {
					"type": "structure",
					"required": [
						"Id",
						"Arn"
					],
					"members": {
						"Id": {},
						"Arn": {},
						"Input": {},
						"InputPath": {}
					}
				}
			}
		},
		"examples": {}
	};

/***/ },
/* 278 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['cloudwatchlogs'] = {};
	AWS.CloudWatchLogs = Service.defineService('cloudwatchlogs', ['2014-03-28']);
	Object.defineProperty(apiLoader.services['cloudwatchlogs'], '2014-03-28', {
	  get: function get() {
	    var model = __webpack_require__(279);
	    model.paginators = __webpack_require__(280).pagination;
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.CloudWatchLogs;


/***/ },
/* 279 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2014-03-28",
			"endpointPrefix": "logs",
			"jsonVersion": "1.1",
			"protocol": "json",
			"serviceFullName": "Amazon CloudWatch Logs",
			"signatureVersion": "v4",
			"targetPrefix": "Logs_20140328"
		},
		"operations": {
			"CancelExportTask": {
				"input": {
					"type": "structure",
					"required": [
						"taskId"
					],
					"members": {
						"taskId": {}
					}
				}
			},
			"CreateExportTask": {
				"input": {
					"type": "structure",
					"required": [
						"logGroupName",
						"from",
						"to",
						"destination"
					],
					"members": {
						"taskName": {},
						"logGroupName": {},
						"logStreamNamePrefix": {},
						"from": {
							"type": "long"
						},
						"to": {
							"type": "long"
						},
						"destination": {},
						"destinationPrefix": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"taskId": {}
					}
				}
			},
			"CreateLogGroup": {
				"input": {
					"type": "structure",
					"required": [
						"logGroupName"
					],
					"members": {
						"logGroupName": {}
					}
				}
			},
			"CreateLogStream": {
				"input": {
					"type": "structure",
					"required": [
						"logGroupName",
						"logStreamName"
					],
					"members": {
						"logGroupName": {},
						"logStreamName": {}
					}
				}
			},
			"DeleteDestination": {
				"input": {
					"type": "structure",
					"required": [
						"destinationName"
					],
					"members": {
						"destinationName": {}
					}
				}
			},
			"DeleteLogGroup": {
				"input": {
					"type": "structure",
					"required": [
						"logGroupName"
					],
					"members": {
						"logGroupName": {}
					}
				}
			},
			"DeleteLogStream": {
				"input": {
					"type": "structure",
					"required": [
						"logGroupName",
						"logStreamName"
					],
					"members": {
						"logGroupName": {},
						"logStreamName": {}
					}
				}
			},
			"DeleteMetricFilter": {
				"input": {
					"type": "structure",
					"required": [
						"logGroupName",
						"filterName"
					],
					"members": {
						"logGroupName": {},
						"filterName": {}
					}
				}
			},
			"DeleteRetentionPolicy": {
				"input": {
					"type": "structure",
					"required": [
						"logGroupName"
					],
					"members": {
						"logGroupName": {}
					}
				}
			},
			"DeleteSubscriptionFilter": {
				"input": {
					"type": "structure",
					"required": [
						"logGroupName",
						"filterName"
					],
					"members": {
						"logGroupName": {},
						"filterName": {}
					}
				}
			},
			"DescribeDestinations": {
				"input": {
					"type": "structure",
					"members": {
						"DestinationNamePrefix": {},
						"nextToken": {},
						"limit": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"destinations": {
							"type": "list",
							"member": {
								"shape": "Sq"
							}
						},
						"nextToken": {}
					}
				}
			},
			"DescribeExportTasks": {
				"input": {
					"type": "structure",
					"members": {
						"taskId": {},
						"statusCode": {},
						"nextToken": {},
						"limit": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"exportTasks": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"taskId": {},
									"taskName": {},
									"logGroupName": {},
									"from": {
										"type": "long"
									},
									"to": {
										"type": "long"
									},
									"destination": {},
									"destinationPrefix": {},
									"status": {
										"type": "structure",
										"members": {
											"code": {},
											"message": {}
										}
									},
									"executionInfo": {
										"type": "structure",
										"members": {
											"creationTime": {
												"type": "long"
											},
											"completionTime": {
												"type": "long"
											}
										}
									}
								}
							}
						},
						"nextToken": {}
					}
				}
			},
			"DescribeLogGroups": {
				"input": {
					"type": "structure",
					"members": {
						"logGroupNamePrefix": {},
						"nextToken": {},
						"limit": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"logGroups": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"logGroupName": {},
									"creationTime": {
										"type": "long"
									},
									"retentionInDays": {
										"type": "integer"
									},
									"metricFilterCount": {
										"type": "integer"
									},
									"arn": {},
									"storedBytes": {
										"type": "long"
									}
								}
							}
						},
						"nextToken": {}
					}
				}
			},
			"DescribeLogStreams": {
				"input": {
					"type": "structure",
					"required": [
						"logGroupName"
					],
					"members": {
						"logGroupName": {},
						"logStreamNamePrefix": {},
						"orderBy": {},
						"descending": {
							"type": "boolean"
						},
						"nextToken": {},
						"limit": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"logStreams": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"logStreamName": {},
									"creationTime": {
										"type": "long"
									},
									"firstEventTimestamp": {
										"type": "long"
									},
									"lastEventTimestamp": {
										"type": "long"
									},
									"lastIngestionTime": {
										"type": "long"
									},
									"uploadSequenceToken": {},
									"arn": {},
									"storedBytes": {
										"type": "long"
									}
								}
							}
						},
						"nextToken": {}
					}
				}
			},
			"DescribeMetricFilters": {
				"input": {
					"type": "structure",
					"required": [
						"logGroupName"
					],
					"members": {
						"logGroupName": {},
						"filterNamePrefix": {},
						"nextToken": {},
						"limit": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"metricFilters": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"filterName": {},
									"filterPattern": {},
									"metricTransformations": {
										"shape": "S1m"
									},
									"creationTime": {
										"type": "long"
									}
								}
							}
						},
						"nextToken": {}
					}
				}
			},
			"DescribeSubscriptionFilters": {
				"input": {
					"type": "structure",
					"required": [
						"logGroupName"
					],
					"members": {
						"logGroupName": {},
						"filterNamePrefix": {},
						"nextToken": {},
						"limit": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"subscriptionFilters": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"filterName": {},
									"logGroupName": {},
									"filterPattern": {},
									"destinationArn": {},
									"roleArn": {},
									"creationTime": {
										"type": "long"
									}
								}
							}
						},
						"nextToken": {}
					}
				}
			},
			"FilterLogEvents": {
				"input": {
					"type": "structure",
					"required": [
						"logGroupName"
					],
					"members": {
						"logGroupName": {},
						"logStreamNames": {
							"type": "list",
							"member": {}
						},
						"startTime": {
							"type": "long"
						},
						"endTime": {
							"type": "long"
						},
						"filterPattern": {},
						"nextToken": {},
						"limit": {
							"type": "integer"
						},
						"interleaved": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"events": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"logStreamName": {},
									"timestamp": {
										"type": "long"
									},
									"message": {},
									"ingestionTime": {
										"type": "long"
									},
									"eventId": {}
								}
							}
						},
						"searchedLogStreams": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"logStreamName": {},
									"searchedCompletely": {
										"type": "boolean"
									}
								}
							}
						},
						"nextToken": {}
					}
				}
			},
			"GetLogEvents": {
				"input": {
					"type": "structure",
					"required": [
						"logGroupName",
						"logStreamName"
					],
					"members": {
						"logGroupName": {},
						"logStreamName": {},
						"startTime": {
							"type": "long"
						},
						"endTime": {
							"type": "long"
						},
						"nextToken": {},
						"limit": {
							"type": "integer"
						},
						"startFromHead": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"events": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"timestamp": {
										"type": "long"
									},
									"message": {},
									"ingestionTime": {
										"type": "long"
									}
								}
							}
						},
						"nextForwardToken": {},
						"nextBackwardToken": {}
					}
				}
			},
			"PutDestination": {
				"input": {
					"type": "structure",
					"required": [
						"destinationName",
						"targetArn",
						"roleArn"
					],
					"members": {
						"destinationName": {},
						"targetArn": {},
						"roleArn": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"destination": {
							"shape": "Sq"
						}
					}
				}
			},
			"PutDestinationPolicy": {
				"input": {
					"type": "structure",
					"required": [
						"destinationName",
						"accessPolicy"
					],
					"members": {
						"destinationName": {},
						"accessPolicy": {}
					}
				}
			},
			"PutLogEvents": {
				"input": {
					"type": "structure",
					"required": [
						"logGroupName",
						"logStreamName",
						"logEvents"
					],
					"members": {
						"logGroupName": {},
						"logStreamName": {},
						"logEvents": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"timestamp",
									"message"
								],
								"members": {
									"timestamp": {
										"type": "long"
									},
									"message": {}
								}
							}
						},
						"sequenceToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"nextSequenceToken": {},
						"rejectedLogEventsInfo": {
							"type": "structure",
							"members": {
								"tooNewLogEventStartIndex": {
									"type": "integer"
								},
								"tooOldLogEventEndIndex": {
									"type": "integer"
								},
								"expiredLogEventEndIndex": {
									"type": "integer"
								}
							}
						}
					}
				}
			},
			"PutMetricFilter": {
				"input": {
					"type": "structure",
					"required": [
						"logGroupName",
						"filterName",
						"filterPattern",
						"metricTransformations"
					],
					"members": {
						"logGroupName": {},
						"filterName": {},
						"filterPattern": {},
						"metricTransformations": {
							"shape": "S1m"
						}
					}
				}
			},
			"PutRetentionPolicy": {
				"input": {
					"type": "structure",
					"required": [
						"logGroupName",
						"retentionInDays"
					],
					"members": {
						"logGroupName": {},
						"retentionInDays": {
							"type": "integer"
						}
					}
				}
			},
			"PutSubscriptionFilter": {
				"input": {
					"type": "structure",
					"required": [
						"logGroupName",
						"filterName",
						"filterPattern",
						"destinationArn"
					],
					"members": {
						"logGroupName": {},
						"filterName": {},
						"filterPattern": {},
						"destinationArn": {},
						"roleArn": {}
					}
				}
			},
			"TestMetricFilter": {
				"input": {
					"type": "structure",
					"required": [
						"filterPattern",
						"logEventMessages"
					],
					"members": {
						"filterPattern": {},
						"logEventMessages": {
							"type": "list",
							"member": {}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"matches": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"eventNumber": {
										"type": "long"
									},
									"eventMessage": {},
									"extractedValues": {
										"type": "map",
										"key": {},
										"value": {}
									}
								}
							}
						}
					}
				}
			}
		},
		"shapes": {
			"Sq": {
				"type": "structure",
				"members": {
					"destinationName": {},
					"targetArn": {},
					"roleArn": {},
					"accessPolicy": {},
					"arn": {},
					"creationTime": {
						"type": "long"
					}
				}
			},
			"S1m": {
				"type": "list",
				"member": {
					"type": "structure",
					"required": [
						"metricName",
						"metricNamespace",
						"metricValue"
					],
					"members": {
						"metricName": {},
						"metricNamespace": {},
						"metricValue": {},
						"defaultValue": {
							"type": "double"
						}
					}
				}
			}
		}
	};

/***/ },
/* 280 */
/***/ function(module, exports) {

	module.exports = {
		"pagination": {
			"DescribeDestinations": {
				"input_token": "nextToken",
				"output_token": "nextToken",
				"limit_key": "limit",
				"result_key": "destinations"
			},
			"DescribeLogGroups": {
				"input_token": "nextToken",
				"output_token": "nextToken",
				"limit_key": "limit",
				"result_key": "logGroups"
			},
			"DescribeLogStreams": {
				"input_token": "nextToken",
				"output_token": "nextToken",
				"limit_key": "limit",
				"result_key": "logStreams"
			},
			"DescribeMetricFilters": {
				"input_token": "nextToken",
				"output_token": "nextToken",
				"limit_key": "limit",
				"result_key": "metricFilters"
			},
			"DescribeSubscriptionFilters": {
				"input_token": "nextToken",
				"output_token": "nextToken",
				"limit_key": "limit",
				"result_key": "subscriptionFilters"
			},
			"FilterLogEvents": {
				"input_token": "nextToken",
				"output_token": "nextToken",
				"limit_key": "limit",
				"result_key": [
					"events",
					"searchedLogStreams"
				]
			},
			"GetLogEvents": {
				"input_token": "nextToken",
				"output_token": "nextForwardToken",
				"limit_key": "limit",
				"result_key": "events"
			}
		}
	};

/***/ },
/* 281 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['codecommit'] = {};
	AWS.CodeCommit = Service.defineService('codecommit', ['2015-04-13']);
	Object.defineProperty(apiLoader.services['codecommit'], '2015-04-13', {
	  get: function get() {
	    var model = __webpack_require__(282);
	    model.paginators = __webpack_require__(283).pagination;
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.CodeCommit;


/***/ },
/* 282 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2015-04-13",
			"endpointPrefix": "codecommit",
			"jsonVersion": "1.1",
			"protocol": "json",
			"serviceAbbreviation": "CodeCommit",
			"serviceFullName": "AWS CodeCommit",
			"signatureVersion": "v4",
			"targetPrefix": "CodeCommit_20150413"
		},
		"operations": {
			"BatchGetRepositories": {
				"input": {
					"type": "structure",
					"required": [
						"repositoryNames"
					],
					"members": {
						"repositoryNames": {
							"type": "list",
							"member": {}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"repositories": {
							"type": "list",
							"member": {
								"shape": "S6"
							}
						},
						"repositoriesNotFound": {
							"type": "list",
							"member": {}
						}
					}
				}
			},
			"CreateBranch": {
				"input": {
					"type": "structure",
					"required": [
						"repositoryName",
						"branchName",
						"commitId"
					],
					"members": {
						"repositoryName": {},
						"branchName": {},
						"commitId": {}
					}
				}
			},
			"CreateRepository": {
				"input": {
					"type": "structure",
					"required": [
						"repositoryName"
					],
					"members": {
						"repositoryName": {},
						"repositoryDescription": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"repositoryMetadata": {
							"shape": "S6"
						}
					}
				}
			},
			"DeleteRepository": {
				"input": {
					"type": "structure",
					"required": [
						"repositoryName"
					],
					"members": {
						"repositoryName": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"repositoryId": {}
					}
				}
			},
			"GetBranch": {
				"input": {
					"type": "structure",
					"members": {
						"repositoryName": {},
						"branchName": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"branch": {
							"type": "structure",
							"members": {
								"branchName": {},
								"commitId": {}
							}
						}
					}
				}
			},
			"GetCommit": {
				"input": {
					"type": "structure",
					"required": [
						"repositoryName",
						"commitId"
					],
					"members": {
						"repositoryName": {},
						"commitId": {}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"commit"
					],
					"members": {
						"commit": {
							"type": "structure",
							"members": {
								"treeId": {},
								"parents": {
									"type": "list",
									"member": {}
								},
								"message": {},
								"author": {
									"shape": "Sw"
								},
								"committer": {
									"shape": "Sw"
								},
								"additionalData": {}
							}
						}
					}
				}
			},
			"GetRepository": {
				"input": {
					"type": "structure",
					"required": [
						"repositoryName"
					],
					"members": {
						"repositoryName": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"repositoryMetadata": {
							"shape": "S6"
						}
					}
				}
			},
			"GetRepositoryTriggers": {
				"input": {
					"type": "structure",
					"members": {
						"repositoryName": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"configurationId": {},
						"triggers": {
							"shape": "S16"
						}
					}
				}
			},
			"ListBranches": {
				"input": {
					"type": "structure",
					"required": [
						"repositoryName"
					],
					"members": {
						"repositoryName": {},
						"nextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"branches": {
							"shape": "S1a"
						},
						"nextToken": {}
					}
				}
			},
			"ListRepositories": {
				"input": {
					"type": "structure",
					"members": {
						"nextToken": {},
						"sortBy": {},
						"order": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"repositories": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"repositoryName": {},
									"repositoryId": {}
								}
							}
						},
						"nextToken": {}
					}
				}
			},
			"PutRepositoryTriggers": {
				"input": {
					"type": "structure",
					"members": {
						"repositoryName": {},
						"triggers": {
							"shape": "S16"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"configurationId": {}
					}
				}
			},
			"TestRepositoryTriggers": {
				"input": {
					"type": "structure",
					"members": {
						"repositoryName": {},
						"triggers": {
							"shape": "S16"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"successfulExecutions": {
							"type": "list",
							"member": {}
						},
						"failedExecutions": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"trigger": {},
									"failureMessage": {}
								}
							}
						}
					}
				}
			},
			"UpdateDefaultBranch": {
				"input": {
					"type": "structure",
					"required": [
						"repositoryName",
						"defaultBranchName"
					],
					"members": {
						"repositoryName": {},
						"defaultBranchName": {}
					}
				}
			},
			"UpdateRepositoryDescription": {
				"input": {
					"type": "structure",
					"required": [
						"repositoryName"
					],
					"members": {
						"repositoryName": {},
						"repositoryDescription": {}
					}
				}
			},
			"UpdateRepositoryName": {
				"input": {
					"type": "structure",
					"required": [
						"oldName",
						"newName"
					],
					"members": {
						"oldName": {},
						"newName": {}
					}
				}
			}
		},
		"shapes": {
			"S6": {
				"type": "structure",
				"members": {
					"accountId": {},
					"repositoryId": {},
					"repositoryName": {},
					"repositoryDescription": {},
					"defaultBranch": {},
					"lastModifiedDate": {
						"type": "timestamp"
					},
					"creationDate": {
						"type": "timestamp"
					},
					"cloneUrlHttp": {},
					"cloneUrlSsh": {},
					"Arn": {}
				}
			},
			"Sw": {
				"type": "structure",
				"members": {
					"name": {},
					"email": {},
					"date": {}
				}
			},
			"S16": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"name": {},
						"destinationArn": {},
						"customData": {},
						"branches": {
							"shape": "S1a"
						},
						"events": {
							"type": "list",
							"member": {}
						}
					}
				}
			},
			"S1a": {
				"type": "list",
				"member": {}
			}
		}
	};

/***/ },
/* 283 */
/***/ function(module, exports) {

	module.exports = {
		"pagination": {
			"ListBranches": {
				"input_token": "nextToken",
				"output_token": "nextToken",
				"result_key": "branches"
			},
			"ListRepositories": {
				"input_token": "nextToken",
				"output_token": "nextToken",
				"result_key": "repositories"
			}
		}
	};

/***/ },
/* 284 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['codedeploy'] = {};
	AWS.CodeDeploy = Service.defineService('codedeploy', ['2014-10-06']);
	Object.defineProperty(apiLoader.services['codedeploy'], '2014-10-06', {
	  get: function get() {
	    var model = __webpack_require__(285);
	    model.paginators = __webpack_require__(286).pagination;
	    model.waiters = __webpack_require__(287).waiters;
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.CodeDeploy;


/***/ },
/* 285 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2014-10-06",
			"endpointPrefix": "codedeploy",
			"jsonVersion": "1.1",
			"protocol": "json",
			"serviceAbbreviation": "CodeDeploy",
			"serviceFullName": "AWS CodeDeploy",
			"signatureVersion": "v4",
			"targetPrefix": "CodeDeploy_20141006",
			"timestampFormat": "unixTimestamp"
		},
		"operations": {
			"AddTagsToOnPremisesInstances": {
				"input": {
					"type": "structure",
					"required": [
						"tags",
						"instanceNames"
					],
					"members": {
						"tags": {
							"shape": "S2"
						},
						"instanceNames": {
							"shape": "S6"
						}
					}
				}
			},
			"BatchGetApplicationRevisions": {
				"input": {
					"type": "structure",
					"required": [
						"applicationName",
						"revisions"
					],
					"members": {
						"applicationName": {},
						"revisions": {
							"shape": "Sa"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"applicationName": {},
						"errorMessage": {},
						"revisions": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"revisionLocation": {
										"shape": "Sb"
									},
									"genericRevisionInfo": {
										"shape": "Sq"
									}
								}
							}
						}
					}
				}
			},
			"BatchGetApplications": {
				"input": {
					"type": "structure",
					"members": {
						"applicationNames": {
							"shape": "Sw"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"applicationsInfo": {
							"type": "list",
							"member": {
								"shape": "Sz"
							}
						}
					}
				}
			},
			"BatchGetDeploymentGroups": {
				"input": {
					"type": "structure",
					"required": [
						"applicationName",
						"deploymentGroupNames"
					],
					"members": {
						"applicationName": {},
						"deploymentGroupNames": {
							"shape": "Ss"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"deploymentGroupsInfo": {
							"type": "list",
							"member": {
								"shape": "S15"
							}
						},
						"errorMessage": {}
					}
				}
			},
			"BatchGetDeploymentInstances": {
				"input": {
					"type": "structure",
					"required": [
						"deploymentId",
						"instanceIds"
					],
					"members": {
						"deploymentId": {},
						"instanceIds": {
							"shape": "S1y"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"instancesSummary": {
							"type": "list",
							"member": {
								"shape": "S22"
							}
						},
						"errorMessage": {}
					}
				}
			},
			"BatchGetDeployments": {
				"input": {
					"type": "structure",
					"members": {
						"deploymentIds": {
							"shape": "S2e"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"deploymentsInfo": {
							"type": "list",
							"member": {
								"shape": "S2h"
							}
						}
					}
				}
			},
			"BatchGetOnPremisesInstances": {
				"input": {
					"type": "structure",
					"members": {
						"instanceNames": {
							"shape": "S6"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"instanceInfos": {
							"type": "list",
							"member": {
								"shape": "S2s"
							}
						}
					}
				}
			},
			"CreateApplication": {
				"input": {
					"type": "structure",
					"required": [
						"applicationName"
					],
					"members": {
						"applicationName": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"applicationId": {}
					}
				}
			},
			"CreateDeployment": {
				"input": {
					"type": "structure",
					"required": [
						"applicationName"
					],
					"members": {
						"applicationName": {},
						"deploymentGroupName": {},
						"revision": {
							"shape": "Sb"
						},
						"deploymentConfigName": {},
						"description": {},
						"ignoreApplicationStopFailures": {
							"type": "boolean"
						},
						"autoRollbackConfiguration": {
							"shape": "S1t"
						},
						"updateOutdatedInstancesOnly": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"deploymentId": {}
					}
				}
			},
			"CreateDeploymentConfig": {
				"input": {
					"type": "structure",
					"required": [
						"deploymentConfigName"
					],
					"members": {
						"deploymentConfigName": {},
						"minimumHealthyHosts": {
							"shape": "S30"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"deploymentConfigId": {}
					}
				}
			},
			"CreateDeploymentGroup": {
				"input": {
					"type": "structure",
					"required": [
						"applicationName",
						"deploymentGroupName",
						"serviceRoleArn"
					],
					"members": {
						"applicationName": {},
						"deploymentGroupName": {},
						"deploymentConfigName": {},
						"ec2TagFilters": {
							"shape": "S18"
						},
						"onPremisesInstanceTagFilters": {
							"shape": "S1b"
						},
						"autoScalingGroups": {
							"shape": "S36"
						},
						"serviceRoleArn": {},
						"triggerConfigurations": {
							"shape": "S1j"
						},
						"alarmConfiguration": {
							"shape": "S1p"
						},
						"autoRollbackConfiguration": {
							"shape": "S1t"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"deploymentGroupId": {}
					}
				}
			},
			"DeleteApplication": {
				"input": {
					"type": "structure",
					"required": [
						"applicationName"
					],
					"members": {
						"applicationName": {}
					}
				}
			},
			"DeleteDeploymentConfig": {
				"input": {
					"type": "structure",
					"required": [
						"deploymentConfigName"
					],
					"members": {
						"deploymentConfigName": {}
					}
				}
			},
			"DeleteDeploymentGroup": {
				"input": {
					"type": "structure",
					"required": [
						"applicationName",
						"deploymentGroupName"
					],
					"members": {
						"applicationName": {},
						"deploymentGroupName": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"hooksNotCleanedUp": {
							"shape": "S1e"
						}
					}
				}
			},
			"DeregisterOnPremisesInstance": {
				"input": {
					"type": "structure",
					"required": [
						"instanceName"
					],
					"members": {
						"instanceName": {}
					}
				}
			},
			"GetApplication": {
				"input": {
					"type": "structure",
					"required": [
						"applicationName"
					],
					"members": {
						"applicationName": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"application": {
							"shape": "Sz"
						}
					}
				}
			},
			"GetApplicationRevision": {
				"input": {
					"type": "structure",
					"required": [
						"applicationName",
						"revision"
					],
					"members": {
						"applicationName": {},
						"revision": {
							"shape": "Sb"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"applicationName": {},
						"revision": {
							"shape": "Sb"
						},
						"revisionInfo": {
							"shape": "Sq"
						}
					}
				}
			},
			"GetDeployment": {
				"input": {
					"type": "structure",
					"required": [
						"deploymentId"
					],
					"members": {
						"deploymentId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"deploymentInfo": {
							"shape": "S2h"
						}
					}
				}
			},
			"GetDeploymentConfig": {
				"input": {
					"type": "structure",
					"required": [
						"deploymentConfigName"
					],
					"members": {
						"deploymentConfigName": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"deploymentConfigInfo": {
							"type": "structure",
							"members": {
								"deploymentConfigId": {},
								"deploymentConfigName": {},
								"minimumHealthyHosts": {
									"shape": "S30"
								},
								"createTime": {
									"type": "timestamp"
								}
							}
						}
					}
				}
			},
			"GetDeploymentGroup": {
				"input": {
					"type": "structure",
					"required": [
						"applicationName",
						"deploymentGroupName"
					],
					"members": {
						"applicationName": {},
						"deploymentGroupName": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"deploymentGroupInfo": {
							"shape": "S15"
						}
					}
				}
			},
			"GetDeploymentInstance": {
				"input": {
					"type": "structure",
					"required": [
						"deploymentId",
						"instanceId"
					],
					"members": {
						"deploymentId": {},
						"instanceId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"instanceSummary": {
							"shape": "S22"
						}
					}
				}
			},
			"GetOnPremisesInstance": {
				"input": {
					"type": "structure",
					"required": [
						"instanceName"
					],
					"members": {
						"instanceName": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"instanceInfo": {
							"shape": "S2s"
						}
					}
				}
			},
			"ListApplicationRevisions": {
				"input": {
					"type": "structure",
					"required": [
						"applicationName"
					],
					"members": {
						"applicationName": {},
						"sortBy": {},
						"sortOrder": {},
						"s3Bucket": {},
						"s3KeyPrefix": {},
						"deployed": {},
						"nextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"revisions": {
							"shape": "Sa"
						},
						"nextToken": {}
					}
				}
			},
			"ListApplications": {
				"input": {
					"type": "structure",
					"members": {
						"nextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"applications": {
							"shape": "Sw"
						},
						"nextToken": {}
					}
				}
			},
			"ListDeploymentConfigs": {
				"input": {
					"type": "structure",
					"members": {
						"nextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"deploymentConfigsList": {
							"type": "list",
							"member": {}
						},
						"nextToken": {}
					}
				}
			},
			"ListDeploymentGroups": {
				"input": {
					"type": "structure",
					"required": [
						"applicationName"
					],
					"members": {
						"applicationName": {},
						"nextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"applicationName": {},
						"deploymentGroups": {
							"shape": "Ss"
						},
						"nextToken": {}
					}
				}
			},
			"ListDeploymentInstances": {
				"input": {
					"type": "structure",
					"required": [
						"deploymentId"
					],
					"members": {
						"deploymentId": {},
						"nextToken": {},
						"instanceStatusFilter": {
							"type": "list",
							"member": {}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"instancesList": {
							"shape": "S1y"
						},
						"nextToken": {}
					}
				}
			},
			"ListDeployments": {
				"input": {
					"type": "structure",
					"members": {
						"applicationName": {},
						"deploymentGroupName": {},
						"includeOnlyStatuses": {
							"type": "list",
							"member": {}
						},
						"createTimeRange": {
							"type": "structure",
							"members": {
								"start": {
									"type": "timestamp"
								},
								"end": {
									"type": "timestamp"
								}
							}
						},
						"nextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"deployments": {
							"shape": "S2e"
						},
						"nextToken": {}
					}
				}
			},
			"ListOnPremisesInstances": {
				"input": {
					"type": "structure",
					"members": {
						"registrationStatus": {},
						"tagFilters": {
							"shape": "S1b"
						},
						"nextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"instanceNames": {
							"shape": "S6"
						},
						"nextToken": {}
					}
				}
			},
			"RegisterApplicationRevision": {
				"input": {
					"type": "structure",
					"required": [
						"applicationName",
						"revision"
					],
					"members": {
						"applicationName": {},
						"description": {},
						"revision": {
							"shape": "Sb"
						}
					}
				}
			},
			"RegisterOnPremisesInstance": {
				"input": {
					"type": "structure",
					"required": [
						"instanceName",
						"iamUserArn"
					],
					"members": {
						"instanceName": {},
						"iamUserArn": {}
					}
				}
			},
			"RemoveTagsFromOnPremisesInstances": {
				"input": {
					"type": "structure",
					"required": [
						"tags",
						"instanceNames"
					],
					"members": {
						"tags": {
							"shape": "S2"
						},
						"instanceNames": {
							"shape": "S6"
						}
					}
				}
			},
			"StopDeployment": {
				"input": {
					"type": "structure",
					"required": [
						"deploymentId"
					],
					"members": {
						"deploymentId": {},
						"autoRollbackEnabled": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"status": {},
						"statusMessage": {}
					}
				}
			},
			"UpdateApplication": {
				"input": {
					"type": "structure",
					"members": {
						"applicationName": {},
						"newApplicationName": {}
					}
				}
			},
			"UpdateDeploymentGroup": {
				"input": {
					"type": "structure",
					"required": [
						"applicationName",
						"currentDeploymentGroupName"
					],
					"members": {
						"applicationName": {},
						"currentDeploymentGroupName": {},
						"newDeploymentGroupName": {},
						"deploymentConfigName": {},
						"ec2TagFilters": {
							"shape": "S18"
						},
						"onPremisesInstanceTagFilters": {
							"shape": "S1b"
						},
						"autoScalingGroups": {
							"shape": "S36"
						},
						"serviceRoleArn": {},
						"triggerConfigurations": {
							"shape": "S1j"
						},
						"alarmConfiguration": {
							"shape": "S1p"
						},
						"autoRollbackConfiguration": {
							"shape": "S1t"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"hooksNotCleanedUp": {
							"shape": "S1e"
						}
					}
				}
			}
		},
		"shapes": {
			"S2": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"Key": {},
						"Value": {}
					}
				}
			},
			"S6": {
				"type": "list",
				"member": {}
			},
			"Sa": {
				"type": "list",
				"member": {
					"shape": "Sb"
				}
			},
			"Sb": {
				"type": "structure",
				"members": {
					"revisionType": {},
					"s3Location": {
						"type": "structure",
						"members": {
							"bucket": {},
							"key": {},
							"bundleType": {},
							"version": {},
							"eTag": {}
						}
					},
					"gitHubLocation": {
						"type": "structure",
						"members": {
							"repository": {},
							"commitId": {}
						}
					}
				}
			},
			"Sq": {
				"type": "structure",
				"members": {
					"description": {},
					"deploymentGroups": {
						"shape": "Ss"
					},
					"firstUsedTime": {
						"type": "timestamp"
					},
					"lastUsedTime": {
						"type": "timestamp"
					},
					"registerTime": {
						"type": "timestamp"
					}
				}
			},
			"Ss": {
				"type": "list",
				"member": {}
			},
			"Sw": {
				"type": "list",
				"member": {}
			},
			"Sz": {
				"type": "structure",
				"members": {
					"applicationId": {},
					"applicationName": {},
					"createTime": {
						"type": "timestamp"
					},
					"linkedToGitHub": {
						"type": "boolean"
					}
				}
			},
			"S15": {
				"type": "structure",
				"members": {
					"applicationName": {},
					"deploymentGroupId": {},
					"deploymentGroupName": {},
					"deploymentConfigName": {},
					"ec2TagFilters": {
						"shape": "S18"
					},
					"onPremisesInstanceTagFilters": {
						"shape": "S1b"
					},
					"autoScalingGroups": {
						"shape": "S1e"
					},
					"serviceRoleArn": {},
					"targetRevision": {
						"shape": "Sb"
					},
					"triggerConfigurations": {
						"shape": "S1j"
					},
					"alarmConfiguration": {
						"shape": "S1p"
					},
					"autoRollbackConfiguration": {
						"shape": "S1t"
					}
				}
			},
			"S18": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"Key": {},
						"Value": {},
						"Type": {}
					}
				}
			},
			"S1b": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"Key": {},
						"Value": {},
						"Type": {}
					}
				}
			},
			"S1e": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"name": {},
						"hook": {}
					}
				}
			},
			"S1j": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"triggerName": {},
						"triggerTargetArn": {},
						"triggerEvents": {
							"type": "list",
							"member": {}
						}
					}
				}
			},
			"S1p": {
				"type": "structure",
				"members": {
					"enabled": {
						"type": "boolean"
					},
					"ignorePollAlarmFailure": {
						"type": "boolean"
					},
					"alarms": {
						"type": "list",
						"member": {
							"type": "structure",
							"members": {
								"name": {}
							}
						}
					}
				}
			},
			"S1t": {
				"type": "structure",
				"members": {
					"enabled": {
						"type": "boolean"
					},
					"events": {
						"type": "list",
						"member": {}
					}
				}
			},
			"S1y": {
				"type": "list",
				"member": {}
			},
			"S22": {
				"type": "structure",
				"members": {
					"deploymentId": {},
					"instanceId": {},
					"status": {},
					"lastUpdatedAt": {
						"type": "timestamp"
					},
					"lifecycleEvents": {
						"type": "list",
						"member": {
							"type": "structure",
							"members": {
								"lifecycleEventName": {},
								"diagnostics": {
									"type": "structure",
									"members": {
										"errorCode": {},
										"scriptName": {},
										"message": {},
										"logTail": {}
									}
								},
								"startTime": {
									"type": "timestamp"
								},
								"endTime": {
									"type": "timestamp"
								},
								"status": {}
							}
						}
					}
				}
			},
			"S2e": {
				"type": "list",
				"member": {}
			},
			"S2h": {
				"type": "structure",
				"members": {
					"applicationName": {},
					"deploymentGroupName": {},
					"deploymentConfigName": {},
					"deploymentId": {},
					"revision": {
						"shape": "Sb"
					},
					"status": {},
					"errorInformation": {
						"type": "structure",
						"members": {
							"code": {},
							"message": {}
						}
					},
					"createTime": {
						"type": "timestamp"
					},
					"startTime": {
						"type": "timestamp"
					},
					"completeTime": {
						"type": "timestamp"
					},
					"deploymentOverview": {
						"type": "structure",
						"members": {
							"Pending": {
								"type": "long"
							},
							"InProgress": {
								"type": "long"
							},
							"Succeeded": {
								"type": "long"
							},
							"Failed": {
								"type": "long"
							},
							"Skipped": {
								"type": "long"
							}
						}
					},
					"description": {},
					"creator": {},
					"ignoreApplicationStopFailures": {
						"type": "boolean"
					},
					"autoRollbackConfiguration": {
						"shape": "S1t"
					},
					"updateOutdatedInstancesOnly": {
						"type": "boolean"
					},
					"rollbackInfo": {
						"type": "structure",
						"members": {
							"rollbackDeploymentId": {},
							"rollbackTriggeringDeploymentId": {},
							"rollbackMessage": {}
						}
					}
				}
			},
			"S2s": {
				"type": "structure",
				"members": {
					"instanceName": {},
					"iamUserArn": {},
					"instanceArn": {},
					"registerTime": {
						"type": "timestamp"
					},
					"deregisterTime": {
						"type": "timestamp"
					},
					"tags": {
						"shape": "S2"
					}
				}
			},
			"S30": {
				"type": "structure",
				"members": {
					"value": {
						"type": "integer"
					},
					"type": {}
				}
			},
			"S36": {
				"type": "list",
				"member": {}
			}
		}
	};

/***/ },
/* 286 */
/***/ function(module, exports) {

	module.exports = {
		"pagination": {
			"ListApplicationRevisions": {
				"input_token": "nextToken",
				"output_token": "nextToken",
				"result_key": "revisions"
			},
			"ListApplications": {
				"input_token": "nextToken",
				"output_token": "nextToken",
				"result_key": "applications"
			},
			"ListDeploymentConfigs": {
				"input_token": "nextToken",
				"output_token": "nextToken",
				"result_key": "deploymentConfigsList"
			},
			"ListDeploymentGroups": {
				"input_token": "nextToken",
				"output_token": "nextToken",
				"result_key": "deploymentGroups"
			},
			"ListDeploymentInstances": {
				"input_token": "nextToken",
				"output_token": "nextToken",
				"result_key": "instancesList"
			},
			"ListDeployments": {
				"input_token": "nextToken",
				"output_token": "nextToken",
				"result_key": "deployments"
			}
		}
	};

/***/ },
/* 287 */
/***/ function(module, exports) {

	module.exports = {
		"version": 2,
		"waiters": {
			"DeploymentSuccessful": {
				"delay": 15,
				"operation": "GetDeployment",
				"maxAttempts": 120,
				"acceptors": [
					{
						"expected": "Succeeded",
						"matcher": "path",
						"state": "success",
						"argument": "deploymentInfo.status"
					},
					{
						"expected": "Failed",
						"matcher": "path",
						"state": "failure",
						"argument": "deploymentInfo.status"
					},
					{
						"expected": "Stopped",
						"matcher": "path",
						"state": "failure",
						"argument": "deploymentInfo.status"
					}
				]
			}
		}
	};

/***/ },
/* 288 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['codepipeline'] = {};
	AWS.CodePipeline = Service.defineService('codepipeline', ['2015-07-09']);
	Object.defineProperty(apiLoader.services['codepipeline'], '2015-07-09', {
	  get: function get() {
	    var model = __webpack_require__(289);
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.CodePipeline;


/***/ },
/* 289 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2015-07-09",
			"endpointPrefix": "codepipeline",
			"jsonVersion": "1.1",
			"protocol": "json",
			"serviceAbbreviation": "CodePipeline",
			"serviceFullName": "AWS CodePipeline",
			"signatureVersion": "v4",
			"targetPrefix": "CodePipeline_20150709"
		},
		"operations": {
			"AcknowledgeJob": {
				"input": {
					"type": "structure",
					"required": [
						"jobId",
						"nonce"
					],
					"members": {
						"jobId": {},
						"nonce": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"status": {}
					}
				}
			},
			"AcknowledgeThirdPartyJob": {
				"input": {
					"type": "structure",
					"required": [
						"jobId",
						"nonce",
						"clientToken"
					],
					"members": {
						"jobId": {},
						"nonce": {},
						"clientToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"status": {}
					}
				}
			},
			"CreateCustomActionType": {
				"input": {
					"type": "structure",
					"required": [
						"category",
						"provider",
						"version",
						"inputArtifactDetails",
						"outputArtifactDetails"
					],
					"members": {
						"category": {},
						"provider": {},
						"version": {},
						"settings": {
							"shape": "Se"
						},
						"configurationProperties": {
							"shape": "Sh"
						},
						"inputArtifactDetails": {
							"shape": "Sn"
						},
						"outputArtifactDetails": {
							"shape": "Sn"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"actionType"
					],
					"members": {
						"actionType": {
							"shape": "Sr"
						}
					}
				}
			},
			"CreatePipeline": {
				"input": {
					"type": "structure",
					"required": [
						"pipeline"
					],
					"members": {
						"pipeline": {
							"shape": "Sv"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"pipeline": {
							"shape": "Sv"
						}
					}
				}
			},
			"DeleteCustomActionType": {
				"input": {
					"type": "structure",
					"required": [
						"category",
						"provider",
						"version"
					],
					"members": {
						"category": {},
						"provider": {},
						"version": {}
					}
				}
			},
			"DeletePipeline": {
				"input": {
					"type": "structure",
					"required": [
						"name"
					],
					"members": {
						"name": {}
					}
				}
			},
			"DisableStageTransition": {
				"input": {
					"type": "structure",
					"required": [
						"pipelineName",
						"stageName",
						"transitionType",
						"reason"
					],
					"members": {
						"pipelineName": {},
						"stageName": {},
						"transitionType": {},
						"reason": {}
					}
				}
			},
			"EnableStageTransition": {
				"input": {
					"type": "structure",
					"required": [
						"pipelineName",
						"stageName",
						"transitionType"
					],
					"members": {
						"pipelineName": {},
						"stageName": {},
						"transitionType": {}
					}
				}
			},
			"GetJobDetails": {
				"input": {
					"type": "structure",
					"required": [
						"jobId"
					],
					"members": {
						"jobId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"jobDetails": {
							"type": "structure",
							"members": {
								"id": {},
								"data": {
									"shape": "S1x"
								},
								"accountId": {}
							}
						}
					}
				}
			},
			"GetPipeline": {
				"input": {
					"type": "structure",
					"required": [
						"name"
					],
					"members": {
						"name": {},
						"version": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"pipeline": {
							"shape": "Sv"
						}
					}
				}
			},
			"GetPipelineExecution": {
				"input": {
					"type": "structure",
					"required": [
						"pipelineName",
						"pipelineExecutionId"
					],
					"members": {
						"pipelineName": {},
						"pipelineExecutionId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"pipelineExecution": {
							"type": "structure",
							"members": {
								"pipelineName": {},
								"pipelineVersion": {
									"type": "integer"
								},
								"pipelineExecutionId": {},
								"status": {},
								"artifactRevisions": {
									"type": "list",
									"member": {
										"type": "structure",
										"members": {
											"name": {},
											"revisionId": {},
											"revisionChangeIdentifier": {},
											"revisionSummary": {},
											"created": {
												"type": "timestamp"
											},
											"revisionUrl": {}
										}
									}
								}
							}
						}
					}
				}
			},
			"GetPipelineState": {
				"input": {
					"type": "structure",
					"required": [
						"name"
					],
					"members": {
						"name": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"pipelineName": {},
						"pipelineVersion": {
							"type": "integer"
						},
						"stageStates": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"stageName": {},
									"inboundTransitionState": {
										"type": "structure",
										"members": {
											"enabled": {
												"type": "boolean"
											},
											"lastChangedBy": {},
											"lastChangedAt": {
												"type": "timestamp"
											},
											"disabledReason": {}
										}
									},
									"actionStates": {
										"type": "list",
										"member": {
											"type": "structure",
											"members": {
												"actionName": {},
												"currentRevision": {
													"shape": "S32"
												},
												"latestExecution": {
													"type": "structure",
													"members": {
														"status": {},
														"summary": {},
														"lastStatusChange": {
															"type": "timestamp"
														},
														"token": {},
														"lastUpdatedBy": {},
														"externalExecutionId": {},
														"externalExecutionUrl": {},
														"percentComplete": {
															"type": "integer"
														},
														"errorDetails": {
															"type": "structure",
															"members": {
																"code": {},
																"message": {}
															}
														}
													}
												},
												"entityUrl": {},
												"revisionUrl": {}
											}
										}
									},
									"latestExecution": {
										"type": "structure",
										"required": [
											"pipelineExecutionId",
											"status"
										],
										"members": {
											"pipelineExecutionId": {},
											"status": {}
										}
									}
								}
							}
						},
						"created": {
							"type": "timestamp"
						},
						"updated": {
							"type": "timestamp"
						}
					}
				}
			},
			"GetThirdPartyJobDetails": {
				"input": {
					"type": "structure",
					"required": [
						"jobId",
						"clientToken"
					],
					"members": {
						"jobId": {},
						"clientToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"jobDetails": {
							"type": "structure",
							"members": {
								"id": {},
								"data": {
									"type": "structure",
									"members": {
										"actionTypeId": {
											"shape": "Ss"
										},
										"actionConfiguration": {
											"shape": "S1y"
										},
										"pipelineContext": {
											"shape": "S1z"
										},
										"inputArtifacts": {
											"shape": "S22"
										},
										"outputArtifacts": {
											"shape": "S22"
										},
										"artifactCredentials": {
											"shape": "S2a"
										},
										"continuationToken": {},
										"encryptionKey": {
											"shape": "S11"
										}
									}
								},
								"nonce": {}
							}
						}
					}
				}
			},
			"ListActionTypes": {
				"input": {
					"type": "structure",
					"members": {
						"actionOwnerFilter": {},
						"nextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"actionTypes"
					],
					"members": {
						"actionTypes": {
							"type": "list",
							"member": {
								"shape": "Sr"
							}
						},
						"nextToken": {}
					}
				}
			},
			"ListPipelines": {
				"input": {
					"type": "structure",
					"members": {
						"nextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"pipelines": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"name": {},
									"version": {
										"type": "integer"
									},
									"created": {
										"type": "timestamp"
									},
									"updated": {
										"type": "timestamp"
									}
								}
							}
						},
						"nextToken": {}
					}
				}
			},
			"PollForJobs": {
				"input": {
					"type": "structure",
					"required": [
						"actionTypeId"
					],
					"members": {
						"actionTypeId": {
							"shape": "Ss"
						},
						"maxBatchSize": {
							"type": "integer"
						},
						"queryParam": {
							"type": "map",
							"key": {},
							"value": {}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"jobs": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"id": {},
									"data": {
										"shape": "S1x"
									},
									"nonce": {},
									"accountId": {}
								}
							}
						}
					}
				}
			},
			"PollForThirdPartyJobs": {
				"input": {
					"type": "structure",
					"required": [
						"actionTypeId"
					],
					"members": {
						"actionTypeId": {
							"shape": "Ss"
						},
						"maxBatchSize": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"jobs": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"clientId": {},
									"jobId": {}
								}
							}
						}
					}
				}
			},
			"PutActionRevision": {
				"input": {
					"type": "structure",
					"required": [
						"pipelineName",
						"stageName",
						"actionName",
						"actionRevision"
					],
					"members": {
						"pipelineName": {},
						"stageName": {},
						"actionName": {},
						"actionRevision": {
							"shape": "S32"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"newRevision": {
							"type": "boolean"
						},
						"pipelineExecutionId": {}
					}
				}
			},
			"PutApprovalResult": {
				"input": {
					"type": "structure",
					"required": [
						"pipelineName",
						"stageName",
						"actionName",
						"result",
						"token"
					],
					"members": {
						"pipelineName": {},
						"stageName": {},
						"actionName": {},
						"result": {
							"type": "structure",
							"required": [
								"summary",
								"status"
							],
							"members": {
								"summary": {},
								"status": {}
							}
						},
						"token": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"approvedAt": {
							"type": "timestamp"
						}
					}
				}
			},
			"PutJobFailureResult": {
				"input": {
					"type": "structure",
					"required": [
						"jobId",
						"failureDetails"
					],
					"members": {
						"jobId": {},
						"failureDetails": {
							"shape": "S4c"
						}
					}
				}
			},
			"PutJobSuccessResult": {
				"input": {
					"type": "structure",
					"required": [
						"jobId"
					],
					"members": {
						"jobId": {},
						"currentRevision": {
							"shape": "S4f"
						},
						"continuationToken": {},
						"executionDetails": {
							"shape": "S4h"
						}
					}
				}
			},
			"PutThirdPartyJobFailureResult": {
				"input": {
					"type": "structure",
					"required": [
						"jobId",
						"clientToken",
						"failureDetails"
					],
					"members": {
						"jobId": {},
						"clientToken": {},
						"failureDetails": {
							"shape": "S4c"
						}
					}
				}
			},
			"PutThirdPartyJobSuccessResult": {
				"input": {
					"type": "structure",
					"required": [
						"jobId",
						"clientToken"
					],
					"members": {
						"jobId": {},
						"clientToken": {},
						"currentRevision": {
							"shape": "S4f"
						},
						"continuationToken": {},
						"executionDetails": {
							"shape": "S4h"
						}
					}
				}
			},
			"RetryStageExecution": {
				"input": {
					"type": "structure",
					"required": [
						"pipelineName",
						"stageName",
						"pipelineExecutionId",
						"retryMode"
					],
					"members": {
						"pipelineName": {},
						"stageName": {},
						"pipelineExecutionId": {},
						"retryMode": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"pipelineExecutionId": {}
					}
				}
			},
			"StartPipelineExecution": {
				"input": {
					"type": "structure",
					"required": [
						"name"
					],
					"members": {
						"name": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"pipelineExecutionId": {}
					}
				}
			},
			"UpdatePipeline": {
				"input": {
					"type": "structure",
					"required": [
						"pipeline"
					],
					"members": {
						"pipeline": {
							"shape": "Sv"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"pipeline": {
							"shape": "Sv"
						}
					}
				}
			}
		},
		"shapes": {
			"Se": {
				"type": "structure",
				"members": {
					"thirdPartyConfigurationUrl": {},
					"entityUrlTemplate": {},
					"executionUrlTemplate": {},
					"revisionUrlTemplate": {}
				}
			},
			"Sh": {
				"type": "list",
				"member": {
					"type": "structure",
					"required": [
						"name",
						"required",
						"key",
						"secret"
					],
					"members": {
						"name": {},
						"required": {
							"type": "boolean"
						},
						"key": {
							"type": "boolean"
						},
						"secret": {
							"type": "boolean"
						},
						"queryable": {
							"type": "boolean"
						},
						"description": {},
						"type": {}
					}
				}
			},
			"Sn": {
				"type": "structure",
				"required": [
					"minimumCount",
					"maximumCount"
				],
				"members": {
					"minimumCount": {
						"type": "integer"
					},
					"maximumCount": {
						"type": "integer"
					}
				}
			},
			"Sr": {
				"type": "structure",
				"required": [
					"id",
					"inputArtifactDetails",
					"outputArtifactDetails"
				],
				"members": {
					"id": {
						"shape": "Ss"
					},
					"settings": {
						"shape": "Se"
					},
					"actionConfigurationProperties": {
						"shape": "Sh"
					},
					"inputArtifactDetails": {
						"shape": "Sn"
					},
					"outputArtifactDetails": {
						"shape": "Sn"
					}
				}
			},
			"Ss": {
				"type": "structure",
				"required": [
					"category",
					"owner",
					"provider",
					"version"
				],
				"members": {
					"category": {},
					"owner": {},
					"provider": {},
					"version": {}
				}
			},
			"Sv": {
				"type": "structure",
				"required": [
					"name",
					"roleArn",
					"artifactStore",
					"stages"
				],
				"members": {
					"name": {},
					"roleArn": {},
					"artifactStore": {
						"type": "structure",
						"required": [
							"type",
							"location"
						],
						"members": {
							"type": {},
							"location": {},
							"encryptionKey": {
								"shape": "S11"
							}
						}
					},
					"stages": {
						"type": "list",
						"member": {
							"type": "structure",
							"required": [
								"name",
								"actions"
							],
							"members": {
								"name": {},
								"blockers": {
									"type": "list",
									"member": {
										"type": "structure",
										"required": [
											"name",
											"type"
										],
										"members": {
											"name": {},
											"type": {}
										}
									}
								},
								"actions": {
									"type": "list",
									"member": {
										"type": "structure",
										"required": [
											"name",
											"actionTypeId"
										],
										"members": {
											"name": {},
											"actionTypeId": {
												"shape": "Ss"
											},
											"runOrder": {
												"type": "integer"
											},
											"configuration": {
												"shape": "S1f"
											},
											"outputArtifacts": {
												"type": "list",
												"member": {
													"type": "structure",
													"required": [
														"name"
													],
													"members": {
														"name": {}
													}
												}
											},
											"inputArtifacts": {
												"type": "list",
												"member": {
													"type": "structure",
													"required": [
														"name"
													],
													"members": {
														"name": {}
													}
												}
											},
											"roleArn": {}
										}
									}
								}
							}
						}
					},
					"version": {
						"type": "integer"
					}
				}
			},
			"S11": {
				"type": "structure",
				"required": [
					"id",
					"type"
				],
				"members": {
					"id": {},
					"type": {}
				}
			},
			"S1f": {
				"type": "map",
				"key": {},
				"value": {}
			},
			"S1x": {
				"type": "structure",
				"members": {
					"actionTypeId": {
						"shape": "Ss"
					},
					"actionConfiguration": {
						"shape": "S1y"
					},
					"pipelineContext": {
						"shape": "S1z"
					},
					"inputArtifacts": {
						"shape": "S22"
					},
					"outputArtifacts": {
						"shape": "S22"
					},
					"artifactCredentials": {
						"shape": "S2a"
					},
					"continuationToken": {},
					"encryptionKey": {
						"shape": "S11"
					}
				}
			},
			"S1y": {
				"type": "structure",
				"members": {
					"configuration": {
						"shape": "S1f"
					}
				}
			},
			"S1z": {
				"type": "structure",
				"members": {
					"pipelineName": {},
					"stage": {
						"type": "structure",
						"members": {
							"name": {}
						}
					},
					"action": {
						"type": "structure",
						"members": {
							"name": {}
						}
					}
				}
			},
			"S22": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"name": {},
						"revision": {},
						"location": {
							"type": "structure",
							"members": {
								"type": {},
								"s3Location": {
									"type": "structure",
									"required": [
										"bucketName",
										"objectKey"
									],
									"members": {
										"bucketName": {},
										"objectKey": {}
									}
								}
							}
						}
					}
				}
			},
			"S2a": {
				"type": "structure",
				"required": [
					"accessKeyId",
					"secretAccessKey",
					"sessionToken"
				],
				"members": {
					"accessKeyId": {},
					"secretAccessKey": {},
					"sessionToken": {}
				},
				"sensitive": true
			},
			"S32": {
				"type": "structure",
				"required": [
					"revisionId",
					"revisionChangeId",
					"created"
				],
				"members": {
					"revisionId": {},
					"revisionChangeId": {},
					"created": {
						"type": "timestamp"
					}
				}
			},
			"S4c": {
				"type": "structure",
				"required": [
					"type",
					"message"
				],
				"members": {
					"type": {},
					"message": {},
					"externalExecutionId": {}
				}
			},
			"S4f": {
				"type": "structure",
				"required": [
					"revision",
					"changeIdentifier"
				],
				"members": {
					"revision": {},
					"changeIdentifier": {},
					"created": {
						"type": "timestamp"
					},
					"revisionSummary": {}
				}
			},
			"S4h": {
				"type": "structure",
				"members": {
					"summary": {},
					"externalExecutionId": {},
					"percentComplete": {
						"type": "integer"
					}
				}
			}
		}
	};

/***/ },
/* 290 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['cognitoidentityserviceprovider'] = {};
	AWS.CognitoIdentityServiceProvider = Service.defineService('cognitoidentityserviceprovider', ['2016-04-18']);
	Object.defineProperty(apiLoader.services['cognitoidentityserviceprovider'], '2016-04-18', {
	  get: function get() {
	    var model = __webpack_require__(291);
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.CognitoIdentityServiceProvider;


/***/ },
/* 291 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2016-04-18",
			"endpointPrefix": "cognito-idp",
			"jsonVersion": "1.1",
			"protocol": "json",
			"serviceFullName": "Amazon Cognito Identity Provider",
			"signatureVersion": "v4",
			"targetPrefix": "AWSCognitoIdentityProviderService"
		},
		"operations": {
			"AddCustomAttributes": {
				"input": {
					"type": "structure",
					"required": [
						"UserPoolId",
						"CustomAttributes"
					],
					"members": {
						"UserPoolId": {},
						"CustomAttributes": {
							"type": "list",
							"member": {
								"shape": "S4"
							}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"AdminConfirmSignUp": {
				"input": {
					"type": "structure",
					"required": [
						"UserPoolId",
						"Username"
					],
					"members": {
						"UserPoolId": {},
						"Username": {
							"shape": "Sd"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"AdminCreateUser": {
				"input": {
					"type": "structure",
					"required": [
						"UserPoolId",
						"Username"
					],
					"members": {
						"UserPoolId": {},
						"Username": {
							"shape": "Sd"
						},
						"UserAttributes": {
							"shape": "Sg"
						},
						"ValidationData": {
							"shape": "Sg"
						},
						"TemporaryPassword": {
							"shape": "Sk"
						},
						"ForceAliasCreation": {
							"type": "boolean"
						},
						"MessageAction": {},
						"DesiredDeliveryMediums": {
							"type": "list",
							"member": {}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"User": {
							"shape": "Sq"
						}
					}
				}
			},
			"AdminDeleteUser": {
				"input": {
					"type": "structure",
					"required": [
						"UserPoolId",
						"Username"
					],
					"members": {
						"UserPoolId": {},
						"Username": {
							"shape": "Sd"
						}
					}
				}
			},
			"AdminDeleteUserAttributes": {
				"input": {
					"type": "structure",
					"required": [
						"UserPoolId",
						"Username",
						"UserAttributeNames"
					],
					"members": {
						"UserPoolId": {},
						"Username": {
							"shape": "Sd"
						},
						"UserAttributeNames": {
							"shape": "Sx"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"AdminDisableUser": {
				"input": {
					"type": "structure",
					"required": [
						"UserPoolId",
						"Username"
					],
					"members": {
						"UserPoolId": {},
						"Username": {
							"shape": "Sd"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"AdminEnableUser": {
				"input": {
					"type": "structure",
					"required": [
						"UserPoolId",
						"Username"
					],
					"members": {
						"UserPoolId": {},
						"Username": {
							"shape": "Sd"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"AdminForgetDevice": {
				"input": {
					"type": "structure",
					"required": [
						"UserPoolId",
						"Username",
						"DeviceKey"
					],
					"members": {
						"UserPoolId": {},
						"Username": {
							"shape": "Sd"
						},
						"DeviceKey": {}
					}
				}
			},
			"AdminGetDevice": {
				"input": {
					"type": "structure",
					"required": [
						"DeviceKey",
						"UserPoolId",
						"Username"
					],
					"members": {
						"DeviceKey": {},
						"UserPoolId": {},
						"Username": {
							"shape": "Sd"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"Device"
					],
					"members": {
						"Device": {
							"shape": "S17"
						}
					}
				}
			},
			"AdminGetUser": {
				"input": {
					"type": "structure",
					"required": [
						"UserPoolId",
						"Username"
					],
					"members": {
						"UserPoolId": {},
						"Username": {
							"shape": "Sd"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"Username"
					],
					"members": {
						"Username": {
							"shape": "Sd"
						},
						"UserAttributes": {
							"shape": "Sg"
						},
						"UserCreateDate": {
							"type": "timestamp"
						},
						"UserLastModifiedDate": {
							"type": "timestamp"
						},
						"Enabled": {
							"type": "boolean"
						},
						"UserStatus": {},
						"MFAOptions": {
							"shape": "St"
						}
					}
				}
			},
			"AdminInitiateAuth": {
				"input": {
					"type": "structure",
					"required": [
						"UserPoolId",
						"ClientId",
						"AuthFlow"
					],
					"members": {
						"UserPoolId": {},
						"ClientId": {
							"shape": "S1b"
						},
						"AuthFlow": {},
						"AuthParameters": {
							"shape": "S1d"
						},
						"ClientMetadata": {
							"shape": "S1e"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ChallengeName": {},
						"Session": {},
						"ChallengeParameters": {
							"shape": "S1i"
						},
						"AuthenticationResult": {
							"shape": "S1j"
						}
					}
				}
			},
			"AdminListDevices": {
				"input": {
					"type": "structure",
					"required": [
						"UserPoolId",
						"Username"
					],
					"members": {
						"UserPoolId": {},
						"Username": {
							"shape": "Sd"
						},
						"Limit": {
							"type": "integer"
						},
						"PaginationToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Devices": {
							"shape": "S1r"
						},
						"PaginationToken": {}
					}
				}
			},
			"AdminResetUserPassword": {
				"input": {
					"type": "structure",
					"required": [
						"UserPoolId",
						"Username"
					],
					"members": {
						"UserPoolId": {},
						"Username": {
							"shape": "Sd"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"AdminRespondToAuthChallenge": {
				"input": {
					"type": "structure",
					"required": [
						"UserPoolId",
						"ClientId",
						"ChallengeName"
					],
					"members": {
						"UserPoolId": {},
						"ClientId": {
							"shape": "S1b"
						},
						"ChallengeName": {},
						"ChallengeResponses": {
							"shape": "S1v"
						},
						"Session": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ChallengeName": {},
						"Session": {},
						"ChallengeParameters": {
							"shape": "S1i"
						},
						"AuthenticationResult": {
							"shape": "S1j"
						}
					}
				}
			},
			"AdminSetUserSettings": {
				"input": {
					"type": "structure",
					"required": [
						"UserPoolId",
						"Username",
						"MFAOptions"
					],
					"members": {
						"UserPoolId": {},
						"Username": {
							"shape": "Sd"
						},
						"MFAOptions": {
							"shape": "St"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"AdminUpdateDeviceStatus": {
				"input": {
					"type": "structure",
					"required": [
						"UserPoolId",
						"Username",
						"DeviceKey"
					],
					"members": {
						"UserPoolId": {},
						"Username": {
							"shape": "Sd"
						},
						"DeviceKey": {},
						"DeviceRememberedStatus": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"AdminUpdateUserAttributes": {
				"input": {
					"type": "structure",
					"required": [
						"UserPoolId",
						"Username",
						"UserAttributes"
					],
					"members": {
						"UserPoolId": {},
						"Username": {
							"shape": "Sd"
						},
						"UserAttributes": {
							"shape": "Sg"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"AdminUserGlobalSignOut": {
				"input": {
					"type": "structure",
					"required": [
						"UserPoolId",
						"Username"
					],
					"members": {
						"UserPoolId": {},
						"Username": {
							"shape": "Sd"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"ChangePassword": {
				"input": {
					"type": "structure",
					"required": [
						"PreviousPassword",
						"ProposedPassword"
					],
					"members": {
						"PreviousPassword": {
							"shape": "Sk"
						},
						"ProposedPassword": {
							"shape": "Sk"
						},
						"AccessToken": {
							"shape": "S1k"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				},
				"authtype": "none"
			},
			"ConfirmDevice": {
				"input": {
					"type": "structure",
					"required": [
						"AccessToken",
						"DeviceKey"
					],
					"members": {
						"AccessToken": {
							"shape": "S1k"
						},
						"DeviceKey": {},
						"DeviceSecretVerifierConfig": {
							"type": "structure",
							"members": {
								"PasswordVerifier": {},
								"Salt": {}
							}
						},
						"DeviceName": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"UserConfirmationNecessary": {
							"type": "boolean"
						}
					}
				}
			},
			"ConfirmForgotPassword": {
				"input": {
					"type": "structure",
					"required": [
						"ClientId",
						"Username",
						"ConfirmationCode",
						"Password"
					],
					"members": {
						"ClientId": {
							"shape": "S1b"
						},
						"SecretHash": {
							"shape": "S2d"
						},
						"Username": {
							"shape": "Sd"
						},
						"ConfirmationCode": {},
						"Password": {
							"shape": "Sk"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				},
				"authtype": "none"
			},
			"ConfirmSignUp": {
				"input": {
					"type": "structure",
					"required": [
						"ClientId",
						"Username",
						"ConfirmationCode"
					],
					"members": {
						"ClientId": {
							"shape": "S1b"
						},
						"SecretHash": {
							"shape": "S2d"
						},
						"Username": {
							"shape": "Sd"
						},
						"ConfirmationCode": {},
						"ForceAliasCreation": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				},
				"authtype": "none"
			},
			"CreateUserImportJob": {
				"input": {
					"type": "structure",
					"required": [
						"JobName",
						"UserPoolId",
						"CloudWatchLogsRoleArn"
					],
					"members": {
						"JobName": {},
						"UserPoolId": {},
						"CloudWatchLogsRoleArn": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"UserImportJob": {
							"shape": "S2m"
						}
					}
				}
			},
			"CreateUserPool": {
				"input": {
					"type": "structure",
					"required": [
						"PoolName"
					],
					"members": {
						"PoolName": {},
						"Policies": {
							"shape": "S2u"
						},
						"LambdaConfig": {
							"shape": "S2x"
						},
						"AutoVerifiedAttributes": {
							"shape": "S2y"
						},
						"AliasAttributes": {
							"shape": "S30"
						},
						"SmsVerificationMessage": {},
						"EmailVerificationMessage": {},
						"EmailVerificationSubject": {},
						"SmsAuthenticationMessage": {},
						"MfaConfiguration": {},
						"DeviceConfiguration": {
							"shape": "S36"
						},
						"EmailConfiguration": {
							"shape": "S37"
						},
						"SmsConfiguration": {
							"shape": "S39"
						},
						"AdminCreateUserConfig": {
							"shape": "S3a"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"UserPool": {
							"shape": "S3e"
						}
					}
				}
			},
			"CreateUserPoolClient": {
				"input": {
					"type": "structure",
					"required": [
						"UserPoolId",
						"ClientName"
					],
					"members": {
						"UserPoolId": {},
						"ClientName": {},
						"GenerateSecret": {
							"type": "boolean"
						},
						"RefreshTokenValidity": {
							"type": "integer"
						},
						"ReadAttributes": {
							"shape": "S3l"
						},
						"WriteAttributes": {
							"shape": "S3l"
						},
						"ExplicitAuthFlows": {
							"shape": "S3n"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"UserPoolClient": {
							"shape": "S3q"
						}
					}
				}
			},
			"DeleteUser": {
				"input": {
					"type": "structure",
					"members": {
						"AccessToken": {
							"shape": "S1k"
						}
					}
				},
				"authtype": "none"
			},
			"DeleteUserAttributes": {
				"input": {
					"type": "structure",
					"required": [
						"UserAttributeNames"
					],
					"members": {
						"UserAttributeNames": {
							"shape": "Sx"
						},
						"AccessToken": {
							"shape": "S1k"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				},
				"authtype": "none"
			},
			"DeleteUserPool": {
				"input": {
					"type": "structure",
					"required": [
						"UserPoolId"
					],
					"members": {
						"UserPoolId": {}
					}
				}
			},
			"DeleteUserPoolClient": {
				"input": {
					"type": "structure",
					"required": [
						"UserPoolId",
						"ClientId"
					],
					"members": {
						"UserPoolId": {},
						"ClientId": {
							"shape": "S1b"
						}
					}
				}
			},
			"DescribeUserImportJob": {
				"input": {
					"type": "structure",
					"required": [
						"UserPoolId",
						"JobId"
					],
					"members": {
						"UserPoolId": {},
						"JobId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"UserImportJob": {
							"shape": "S2m"
						}
					}
				}
			},
			"DescribeUserPool": {
				"input": {
					"type": "structure",
					"required": [
						"UserPoolId"
					],
					"members": {
						"UserPoolId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"UserPool": {
							"shape": "S3e"
						}
					}
				}
			},
			"DescribeUserPoolClient": {
				"input": {
					"type": "structure",
					"required": [
						"UserPoolId",
						"ClientId"
					],
					"members": {
						"UserPoolId": {},
						"ClientId": {
							"shape": "S1b"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"UserPoolClient": {
							"shape": "S3q"
						}
					}
				}
			},
			"ForgetDevice": {
				"input": {
					"type": "structure",
					"required": [
						"DeviceKey"
					],
					"members": {
						"AccessToken": {
							"shape": "S1k"
						},
						"DeviceKey": {}
					}
				}
			},
			"ForgotPassword": {
				"input": {
					"type": "structure",
					"required": [
						"ClientId",
						"Username"
					],
					"members": {
						"ClientId": {
							"shape": "S1b"
						},
						"SecretHash": {
							"shape": "S2d"
						},
						"Username": {
							"shape": "Sd"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"CodeDeliveryDetails": {
							"shape": "S46"
						}
					}
				},
				"authtype": "none"
			},
			"GetCSVHeader": {
				"input": {
					"type": "structure",
					"required": [
						"UserPoolId"
					],
					"members": {
						"UserPoolId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"UserPoolId": {},
						"CSVHeader": {
							"type": "list",
							"member": {}
						}
					}
				}
			},
			"GetDevice": {
				"input": {
					"type": "structure",
					"required": [
						"DeviceKey"
					],
					"members": {
						"DeviceKey": {},
						"AccessToken": {
							"shape": "S1k"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"Device"
					],
					"members": {
						"Device": {
							"shape": "S17"
						}
					}
				}
			},
			"GetUser": {
				"input": {
					"type": "structure",
					"members": {
						"AccessToken": {
							"shape": "S1k"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"Username",
						"UserAttributes"
					],
					"members": {
						"Username": {
							"shape": "Sd"
						},
						"UserAttributes": {
							"shape": "Sg"
						},
						"MFAOptions": {
							"shape": "St"
						}
					}
				},
				"authtype": "none"
			},
			"GetUserAttributeVerificationCode": {
				"input": {
					"type": "structure",
					"required": [
						"AttributeName"
					],
					"members": {
						"AccessToken": {
							"shape": "S1k"
						},
						"AttributeName": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"CodeDeliveryDetails": {
							"shape": "S46"
						}
					}
				},
				"authtype": "none"
			},
			"GlobalSignOut": {
				"input": {
					"type": "structure",
					"members": {
						"AccessToken": {
							"shape": "S1k"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"InitiateAuth": {
				"input": {
					"type": "structure",
					"required": [
						"AuthFlow",
						"ClientId"
					],
					"members": {
						"AuthFlow": {},
						"AuthParameters": {
							"shape": "S1d"
						},
						"ClientMetadata": {
							"shape": "S1e"
						},
						"ClientId": {
							"shape": "S1b"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ChallengeName": {},
						"Session": {},
						"ChallengeParameters": {
							"shape": "S1i"
						},
						"AuthenticationResult": {
							"shape": "S1j"
						}
					}
				}
			},
			"ListDevices": {
				"input": {
					"type": "structure",
					"required": [
						"AccessToken"
					],
					"members": {
						"AccessToken": {
							"shape": "S1k"
						},
						"Limit": {
							"type": "integer"
						},
						"PaginationToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Devices": {
							"shape": "S1r"
						},
						"PaginationToken": {}
					}
				}
			},
			"ListUserImportJobs": {
				"input": {
					"type": "structure",
					"required": [
						"UserPoolId",
						"MaxResults"
					],
					"members": {
						"UserPoolId": {},
						"MaxResults": {
							"type": "integer"
						},
						"PaginationToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"UserImportJobs": {
							"type": "list",
							"member": {
								"shape": "S2m"
							}
						},
						"PaginationToken": {}
					}
				}
			},
			"ListUserPoolClients": {
				"input": {
					"type": "structure",
					"required": [
						"UserPoolId"
					],
					"members": {
						"UserPoolId": {},
						"MaxResults": {
							"type": "integer"
						},
						"NextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"UserPoolClients": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"ClientId": {
										"shape": "S1b"
									},
									"UserPoolId": {},
									"ClientName": {}
								}
							}
						},
						"NextToken": {}
					}
				}
			},
			"ListUserPools": {
				"input": {
					"type": "structure",
					"required": [
						"MaxResults"
					],
					"members": {
						"NextToken": {},
						"MaxResults": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"UserPools": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"Id": {},
									"Name": {},
									"LambdaConfig": {
										"shape": "S2x"
									},
									"Status": {},
									"LastModifiedDate": {
										"type": "timestamp"
									},
									"CreationDate": {
										"type": "timestamp"
									}
								}
							}
						},
						"NextToken": {}
					}
				}
			},
			"ListUsers": {
				"input": {
					"type": "structure",
					"required": [
						"UserPoolId"
					],
					"members": {
						"UserPoolId": {},
						"AttributesToGet": {
							"type": "list",
							"member": {}
						},
						"Limit": {
							"type": "integer"
						},
						"PaginationToken": {},
						"Filter": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Users": {
							"type": "list",
							"member": {
								"shape": "Sq"
							}
						},
						"PaginationToken": {}
					}
				}
			},
			"ResendConfirmationCode": {
				"input": {
					"type": "structure",
					"required": [
						"ClientId",
						"Username"
					],
					"members": {
						"ClientId": {
							"shape": "S1b"
						},
						"SecretHash": {
							"shape": "S2d"
						},
						"Username": {
							"shape": "Sd"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"CodeDeliveryDetails": {
							"shape": "S46"
						}
					}
				},
				"authtype": "none"
			},
			"RespondToAuthChallenge": {
				"input": {
					"type": "structure",
					"required": [
						"ClientId",
						"ChallengeName"
					],
					"members": {
						"ClientId": {
							"shape": "S1b"
						},
						"ChallengeName": {},
						"Session": {},
						"ChallengeResponses": {
							"shape": "S1v"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ChallengeName": {},
						"Session": {},
						"ChallengeParameters": {
							"shape": "S1i"
						},
						"AuthenticationResult": {
							"shape": "S1j"
						}
					}
				}
			},
			"SetUserSettings": {
				"input": {
					"type": "structure",
					"required": [
						"AccessToken",
						"MFAOptions"
					],
					"members": {
						"AccessToken": {
							"shape": "S1k"
						},
						"MFAOptions": {
							"shape": "St"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				},
				"authtype": "none"
			},
			"SignUp": {
				"input": {
					"type": "structure",
					"required": [
						"ClientId",
						"Username",
						"Password"
					],
					"members": {
						"ClientId": {
							"shape": "S1b"
						},
						"SecretHash": {
							"shape": "S2d"
						},
						"Username": {
							"shape": "Sd"
						},
						"Password": {
							"shape": "Sk"
						},
						"UserAttributes": {
							"shape": "Sg"
						},
						"ValidationData": {
							"shape": "Sg"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"UserConfirmed": {
							"type": "boolean"
						},
						"CodeDeliveryDetails": {
							"shape": "S46"
						}
					}
				},
				"authtype": "none"
			},
			"StartUserImportJob": {
				"input": {
					"type": "structure",
					"required": [
						"UserPoolId",
						"JobId"
					],
					"members": {
						"UserPoolId": {},
						"JobId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"UserImportJob": {
							"shape": "S2m"
						}
					}
				}
			},
			"StopUserImportJob": {
				"input": {
					"type": "structure",
					"required": [
						"UserPoolId",
						"JobId"
					],
					"members": {
						"UserPoolId": {},
						"JobId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"UserImportJob": {
							"shape": "S2m"
						}
					}
				}
			},
			"UpdateDeviceStatus": {
				"input": {
					"type": "structure",
					"required": [
						"AccessToken",
						"DeviceKey"
					],
					"members": {
						"AccessToken": {
							"shape": "S1k"
						},
						"DeviceKey": {},
						"DeviceRememberedStatus": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"UpdateUserAttributes": {
				"input": {
					"type": "structure",
					"required": [
						"UserAttributes"
					],
					"members": {
						"UserAttributes": {
							"shape": "Sg"
						},
						"AccessToken": {
							"shape": "S1k"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"CodeDeliveryDetailsList": {
							"type": "list",
							"member": {
								"shape": "S46"
							}
						}
					}
				},
				"authtype": "none"
			},
			"UpdateUserPool": {
				"input": {
					"type": "structure",
					"required": [
						"UserPoolId"
					],
					"members": {
						"UserPoolId": {},
						"Policies": {
							"shape": "S2u"
						},
						"LambdaConfig": {
							"shape": "S2x"
						},
						"AutoVerifiedAttributes": {
							"shape": "S2y"
						},
						"SmsVerificationMessage": {},
						"EmailVerificationMessage": {},
						"EmailVerificationSubject": {},
						"SmsAuthenticationMessage": {},
						"MfaConfiguration": {},
						"DeviceConfiguration": {
							"shape": "S36"
						},
						"EmailConfiguration": {
							"shape": "S37"
						},
						"SmsConfiguration": {
							"shape": "S39"
						},
						"AdminCreateUserConfig": {
							"shape": "S3a"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"UpdateUserPoolClient": {
				"input": {
					"type": "structure",
					"required": [
						"UserPoolId",
						"ClientId"
					],
					"members": {
						"UserPoolId": {},
						"ClientId": {
							"shape": "S1b"
						},
						"ClientName": {},
						"RefreshTokenValidity": {
							"type": "integer"
						},
						"ReadAttributes": {
							"shape": "S3l"
						},
						"WriteAttributes": {
							"shape": "S3l"
						},
						"ExplicitAuthFlows": {
							"shape": "S3n"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"UserPoolClient": {
							"shape": "S3q"
						}
					}
				}
			},
			"VerifyUserAttribute": {
				"input": {
					"type": "structure",
					"required": [
						"AttributeName",
						"Code"
					],
					"members": {
						"AccessToken": {
							"shape": "S1k"
						},
						"AttributeName": {},
						"Code": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				},
				"authtype": "none"
			}
		},
		"shapes": {
			"S4": {
				"type": "structure",
				"members": {
					"Name": {},
					"AttributeDataType": {},
					"DeveloperOnlyAttribute": {
						"type": "boolean"
					},
					"Mutable": {
						"type": "boolean"
					},
					"Required": {
						"type": "boolean"
					},
					"NumberAttributeConstraints": {
						"type": "structure",
						"members": {
							"MinValue": {},
							"MaxValue": {}
						}
					},
					"StringAttributeConstraints": {
						"type": "structure",
						"members": {
							"MinLength": {},
							"MaxLength": {}
						}
					}
				}
			},
			"Sd": {
				"type": "string",
				"sensitive": true
			},
			"Sg": {
				"type": "list",
				"member": {
					"type": "structure",
					"required": [
						"Name"
					],
					"members": {
						"Name": {},
						"Value": {
							"type": "string",
							"sensitive": true
						}
					}
				}
			},
			"Sk": {
				"type": "string",
				"sensitive": true
			},
			"Sq": {
				"type": "structure",
				"members": {
					"Username": {
						"shape": "Sd"
					},
					"Attributes": {
						"shape": "Sg"
					},
					"UserCreateDate": {
						"type": "timestamp"
					},
					"UserLastModifiedDate": {
						"type": "timestamp"
					},
					"Enabled": {
						"type": "boolean"
					},
					"UserStatus": {},
					"MFAOptions": {
						"shape": "St"
					}
				}
			},
			"St": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"DeliveryMedium": {},
						"AttributeName": {}
					}
				}
			},
			"Sx": {
				"type": "list",
				"member": {}
			},
			"S17": {
				"type": "structure",
				"members": {
					"DeviceKey": {},
					"DeviceAttributes": {
						"shape": "Sg"
					},
					"DeviceCreateDate": {
						"type": "timestamp"
					},
					"DeviceLastModifiedDate": {
						"type": "timestamp"
					},
					"DeviceLastAuthenticatedDate": {
						"type": "timestamp"
					}
				}
			},
			"S1b": {
				"type": "string",
				"sensitive": true
			},
			"S1d": {
				"type": "map",
				"key": {},
				"value": {}
			},
			"S1e": {
				"type": "map",
				"key": {},
				"value": {}
			},
			"S1i": {
				"type": "map",
				"key": {},
				"value": {}
			},
			"S1j": {
				"type": "structure",
				"members": {
					"AccessToken": {
						"shape": "S1k"
					},
					"ExpiresIn": {
						"type": "integer"
					},
					"TokenType": {},
					"RefreshToken": {
						"shape": "S1k"
					},
					"IdToken": {
						"shape": "S1k"
					},
					"NewDeviceMetadata": {
						"type": "structure",
						"members": {
							"DeviceKey": {},
							"DeviceGroupKey": {}
						}
					}
				}
			},
			"S1k": {
				"type": "string",
				"sensitive": true
			},
			"S1r": {
				"type": "list",
				"member": {
					"shape": "S17"
				}
			},
			"S1v": {
				"type": "map",
				"key": {},
				"value": {}
			},
			"S2d": {
				"type": "string",
				"sensitive": true
			},
			"S2m": {
				"type": "structure",
				"members": {
					"JobName": {},
					"JobId": {},
					"UserPoolId": {},
					"PreSignedUrl": {},
					"CreationDate": {
						"type": "timestamp"
					},
					"StartDate": {
						"type": "timestamp"
					},
					"CompletionDate": {
						"type": "timestamp"
					},
					"Status": {},
					"CloudWatchLogsRoleArn": {},
					"ImportedUsers": {
						"type": "long"
					},
					"SkippedUsers": {
						"type": "long"
					},
					"FailedUsers": {
						"type": "long"
					},
					"CompletionMessage": {}
				}
			},
			"S2u": {
				"type": "structure",
				"members": {
					"PasswordPolicy": {
						"type": "structure",
						"members": {
							"MinimumLength": {
								"type": "integer"
							},
							"RequireUppercase": {
								"type": "boolean"
							},
							"RequireLowercase": {
								"type": "boolean"
							},
							"RequireNumbers": {
								"type": "boolean"
							},
							"RequireSymbols": {
								"type": "boolean"
							}
						}
					}
				}
			},
			"S2x": {
				"type": "structure",
				"members": {
					"PreSignUp": {},
					"CustomMessage": {},
					"PostConfirmation": {},
					"PreAuthentication": {},
					"PostAuthentication": {},
					"DefineAuthChallenge": {},
					"CreateAuthChallenge": {},
					"VerifyAuthChallengeResponse": {}
				}
			},
			"S2y": {
				"type": "list",
				"member": {}
			},
			"S30": {
				"type": "list",
				"member": {}
			},
			"S36": {
				"type": "structure",
				"members": {
					"ChallengeRequiredOnNewDevice": {
						"type": "boolean"
					},
					"DeviceOnlyRememberedOnUserPrompt": {
						"type": "boolean"
					}
				}
			},
			"S37": {
				"type": "structure",
				"members": {
					"SourceArn": {},
					"ReplyToEmailAddress": {}
				}
			},
			"S39": {
				"type": "structure",
				"members": {
					"SnsCallerArn": {},
					"ExternalId": {}
				}
			},
			"S3a": {
				"type": "structure",
				"members": {
					"AllowAdminCreateUserOnly": {
						"type": "boolean"
					},
					"UnusedAccountValidityDays": {
						"type": "integer"
					},
					"InviteMessageTemplate": {
						"type": "structure",
						"members": {
							"SMSMessage": {},
							"EmailMessage": {},
							"EmailSubject": {}
						}
					}
				}
			},
			"S3e": {
				"type": "structure",
				"members": {
					"Id": {},
					"Name": {},
					"Policies": {
						"shape": "S2u"
					},
					"LambdaConfig": {
						"shape": "S2x"
					},
					"Status": {},
					"LastModifiedDate": {
						"type": "timestamp"
					},
					"CreationDate": {
						"type": "timestamp"
					},
					"SchemaAttributes": {
						"type": "list",
						"member": {
							"shape": "S4"
						}
					},
					"AutoVerifiedAttributes": {
						"shape": "S2y"
					},
					"AliasAttributes": {
						"shape": "S30"
					},
					"SmsVerificationMessage": {},
					"EmailVerificationMessage": {},
					"EmailVerificationSubject": {},
					"SmsAuthenticationMessage": {},
					"MfaConfiguration": {},
					"DeviceConfiguration": {
						"shape": "S36"
					},
					"EstimatedNumberOfUsers": {
						"type": "integer"
					},
					"EmailConfiguration": {
						"shape": "S37"
					},
					"SmsConfiguration": {
						"shape": "S39"
					},
					"SmsConfigurationFailure": {},
					"EmailConfigurationFailure": {},
					"AdminCreateUserConfig": {
						"shape": "S3a"
					}
				}
			},
			"S3l": {
				"type": "list",
				"member": {}
			},
			"S3n": {
				"type": "list",
				"member": {}
			},
			"S3q": {
				"type": "structure",
				"members": {
					"UserPoolId": {},
					"ClientName": {},
					"ClientId": {
						"shape": "S1b"
					},
					"ClientSecret": {
						"type": "string",
						"sensitive": true
					},
					"LastModifiedDate": {
						"type": "timestamp"
					},
					"CreationDate": {
						"type": "timestamp"
					},
					"RefreshTokenValidity": {
						"type": "integer"
					},
					"ReadAttributes": {
						"shape": "S3l"
					},
					"WriteAttributes": {
						"shape": "S3l"
					},
					"ExplicitAuthFlows": {
						"shape": "S3n"
					}
				}
			},
			"S46": {
				"type": "structure",
				"members": {
					"Destination": {},
					"DeliveryMedium": {},
					"AttributeName": {}
				}
			}
		}
	};

/***/ },
/* 292 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['cognitosync'] = {};
	AWS.CognitoSync = Service.defineService('cognitosync', ['2014-06-30']);
	Object.defineProperty(apiLoader.services['cognitosync'], '2014-06-30', {
	  get: function get() {
	    var model = __webpack_require__(293);
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.CognitoSync;


/***/ },
/* 293 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2014-06-30",
			"endpointPrefix": "cognito-sync",
			"jsonVersion": "1.1",
			"serviceFullName": "Amazon Cognito Sync",
			"signatureVersion": "v4",
			"protocol": "rest-json"
		},
		"operations": {
			"BulkPublish": {
				"http": {
					"requestUri": "/identitypools/{IdentityPoolId}/bulkpublish",
					"responseCode": 200
				},
				"input": {
					"type": "structure",
					"required": [
						"IdentityPoolId"
					],
					"members": {
						"IdentityPoolId": {
							"location": "uri",
							"locationName": "IdentityPoolId"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"IdentityPoolId": {}
					}
				}
			},
			"DeleteDataset": {
				"http": {
					"method": "DELETE",
					"requestUri": "/identitypools/{IdentityPoolId}/identities/{IdentityId}/datasets/{DatasetName}",
					"responseCode": 200
				},
				"input": {
					"type": "structure",
					"required": [
						"IdentityPoolId",
						"IdentityId",
						"DatasetName"
					],
					"members": {
						"IdentityPoolId": {
							"location": "uri",
							"locationName": "IdentityPoolId"
						},
						"IdentityId": {
							"location": "uri",
							"locationName": "IdentityId"
						},
						"DatasetName": {
							"location": "uri",
							"locationName": "DatasetName"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Dataset": {
							"shape": "S8"
						}
					}
				}
			},
			"DescribeDataset": {
				"http": {
					"method": "GET",
					"requestUri": "/identitypools/{IdentityPoolId}/identities/{IdentityId}/datasets/{DatasetName}",
					"responseCode": 200
				},
				"input": {
					"type": "structure",
					"required": [
						"IdentityPoolId",
						"IdentityId",
						"DatasetName"
					],
					"members": {
						"IdentityPoolId": {
							"location": "uri",
							"locationName": "IdentityPoolId"
						},
						"IdentityId": {
							"location": "uri",
							"locationName": "IdentityId"
						},
						"DatasetName": {
							"location": "uri",
							"locationName": "DatasetName"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Dataset": {
							"shape": "S8"
						}
					}
				}
			},
			"DescribeIdentityPoolUsage": {
				"http": {
					"method": "GET",
					"requestUri": "/identitypools/{IdentityPoolId}",
					"responseCode": 200
				},
				"input": {
					"type": "structure",
					"required": [
						"IdentityPoolId"
					],
					"members": {
						"IdentityPoolId": {
							"location": "uri",
							"locationName": "IdentityPoolId"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"IdentityPoolUsage": {
							"shape": "Sg"
						}
					}
				}
			},
			"DescribeIdentityUsage": {
				"http": {
					"method": "GET",
					"requestUri": "/identitypools/{IdentityPoolId}/identities/{IdentityId}",
					"responseCode": 200
				},
				"input": {
					"type": "structure",
					"required": [
						"IdentityPoolId",
						"IdentityId"
					],
					"members": {
						"IdentityPoolId": {
							"location": "uri",
							"locationName": "IdentityPoolId"
						},
						"IdentityId": {
							"location": "uri",
							"locationName": "IdentityId"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"IdentityUsage": {
							"type": "structure",
							"members": {
								"IdentityId": {},
								"IdentityPoolId": {},
								"LastModifiedDate": {
									"type": "timestamp"
								},
								"DatasetCount": {
									"type": "integer"
								},
								"DataStorage": {
									"type": "long"
								}
							}
						}
					}
				}
			},
			"GetBulkPublishDetails": {
				"http": {
					"requestUri": "/identitypools/{IdentityPoolId}/getBulkPublishDetails",
					"responseCode": 200
				},
				"input": {
					"type": "structure",
					"required": [
						"IdentityPoolId"
					],
					"members": {
						"IdentityPoolId": {
							"location": "uri",
							"locationName": "IdentityPoolId"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"IdentityPoolId": {},
						"BulkPublishStartTime": {
							"type": "timestamp"
						},
						"BulkPublishCompleteTime": {
							"type": "timestamp"
						},
						"BulkPublishStatus": {},
						"FailureMessage": {}
					}
				}
			},
			"GetCognitoEvents": {
				"http": {
					"method": "GET",
					"requestUri": "/identitypools/{IdentityPoolId}/events",
					"responseCode": 200
				},
				"input": {
					"type": "structure",
					"required": [
						"IdentityPoolId"
					],
					"members": {
						"IdentityPoolId": {
							"location": "uri",
							"locationName": "IdentityPoolId"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Events": {
							"shape": "Sq"
						}
					}
				}
			},
			"GetIdentityPoolConfiguration": {
				"http": {
					"method": "GET",
					"requestUri": "/identitypools/{IdentityPoolId}/configuration",
					"responseCode": 200
				},
				"input": {
					"type": "structure",
					"required": [
						"IdentityPoolId"
					],
					"members": {
						"IdentityPoolId": {
							"location": "uri",
							"locationName": "IdentityPoolId"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"IdentityPoolId": {},
						"PushSync": {
							"shape": "Sv"
						},
						"CognitoStreams": {
							"shape": "Sz"
						}
					}
				}
			},
			"ListDatasets": {
				"http": {
					"method": "GET",
					"requestUri": "/identitypools/{IdentityPoolId}/identities/{IdentityId}/datasets",
					"responseCode": 200
				},
				"input": {
					"type": "structure",
					"required": [
						"IdentityId",
						"IdentityPoolId"
					],
					"members": {
						"IdentityPoolId": {
							"location": "uri",
							"locationName": "IdentityPoolId"
						},
						"IdentityId": {
							"location": "uri",
							"locationName": "IdentityId"
						},
						"NextToken": {
							"location": "querystring",
							"locationName": "nextToken"
						},
						"MaxResults": {
							"location": "querystring",
							"locationName": "maxResults",
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Datasets": {
							"type": "list",
							"member": {
								"shape": "S8"
							}
						},
						"Count": {
							"type": "integer"
						},
						"NextToken": {}
					}
				}
			},
			"ListIdentityPoolUsage": {
				"http": {
					"method": "GET",
					"requestUri": "/identitypools",
					"responseCode": 200
				},
				"input": {
					"type": "structure",
					"members": {
						"NextToken": {
							"location": "querystring",
							"locationName": "nextToken"
						},
						"MaxResults": {
							"location": "querystring",
							"locationName": "maxResults",
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"IdentityPoolUsages": {
							"type": "list",
							"member": {
								"shape": "Sg"
							}
						},
						"MaxResults": {
							"type": "integer"
						},
						"Count": {
							"type": "integer"
						},
						"NextToken": {}
					}
				}
			},
			"ListRecords": {
				"http": {
					"method": "GET",
					"requestUri": "/identitypools/{IdentityPoolId}/identities/{IdentityId}/datasets/{DatasetName}/records",
					"responseCode": 200
				},
				"input": {
					"type": "structure",
					"required": [
						"IdentityPoolId",
						"IdentityId",
						"DatasetName"
					],
					"members": {
						"IdentityPoolId": {
							"location": "uri",
							"locationName": "IdentityPoolId"
						},
						"IdentityId": {
							"location": "uri",
							"locationName": "IdentityId"
						},
						"DatasetName": {
							"location": "uri",
							"locationName": "DatasetName"
						},
						"LastSyncCount": {
							"location": "querystring",
							"locationName": "lastSyncCount",
							"type": "long"
						},
						"NextToken": {
							"location": "querystring",
							"locationName": "nextToken"
						},
						"MaxResults": {
							"location": "querystring",
							"locationName": "maxResults",
							"type": "integer"
						},
						"SyncSessionToken": {
							"location": "querystring",
							"locationName": "syncSessionToken"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Records": {
							"shape": "S1c"
						},
						"NextToken": {},
						"Count": {
							"type": "integer"
						},
						"DatasetSyncCount": {
							"type": "long"
						},
						"LastModifiedBy": {},
						"MergedDatasetNames": {
							"type": "list",
							"member": {}
						},
						"DatasetExists": {
							"type": "boolean"
						},
						"DatasetDeletedAfterRequestedSyncCount": {
							"type": "boolean"
						},
						"SyncSessionToken": {}
					}
				}
			},
			"RegisterDevice": {
				"http": {
					"requestUri": "/identitypools/{IdentityPoolId}/identity/{IdentityId}/device",
					"responseCode": 200
				},
				"input": {
					"type": "structure",
					"required": [
						"IdentityPoolId",
						"IdentityId",
						"Platform",
						"Token"
					],
					"members": {
						"IdentityPoolId": {
							"location": "uri",
							"locationName": "IdentityPoolId"
						},
						"IdentityId": {
							"location": "uri",
							"locationName": "IdentityId"
						},
						"Platform": {},
						"Token": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"DeviceId": {}
					}
				}
			},
			"SetCognitoEvents": {
				"http": {
					"requestUri": "/identitypools/{IdentityPoolId}/events",
					"responseCode": 200
				},
				"input": {
					"type": "structure",
					"required": [
						"IdentityPoolId",
						"Events"
					],
					"members": {
						"IdentityPoolId": {
							"location": "uri",
							"locationName": "IdentityPoolId"
						},
						"Events": {
							"shape": "Sq"
						}
					}
				}
			},
			"SetIdentityPoolConfiguration": {
				"http": {
					"requestUri": "/identitypools/{IdentityPoolId}/configuration",
					"responseCode": 200
				},
				"input": {
					"type": "structure",
					"required": [
						"IdentityPoolId"
					],
					"members": {
						"IdentityPoolId": {
							"location": "uri",
							"locationName": "IdentityPoolId"
						},
						"PushSync": {
							"shape": "Sv"
						},
						"CognitoStreams": {
							"shape": "Sz"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"IdentityPoolId": {},
						"PushSync": {
							"shape": "Sv"
						},
						"CognitoStreams": {
							"shape": "Sz"
						}
					}
				}
			},
			"SubscribeToDataset": {
				"http": {
					"requestUri": "/identitypools/{IdentityPoolId}/identities/{IdentityId}/datasets/{DatasetName}/subscriptions/{DeviceId}",
					"responseCode": 200
				},
				"input": {
					"type": "structure",
					"required": [
						"IdentityPoolId",
						"IdentityId",
						"DatasetName",
						"DeviceId"
					],
					"members": {
						"IdentityPoolId": {
							"location": "uri",
							"locationName": "IdentityPoolId"
						},
						"IdentityId": {
							"location": "uri",
							"locationName": "IdentityId"
						},
						"DatasetName": {
							"location": "uri",
							"locationName": "DatasetName"
						},
						"DeviceId": {
							"location": "uri",
							"locationName": "DeviceId"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"UnsubscribeFromDataset": {
				"http": {
					"method": "DELETE",
					"requestUri": "/identitypools/{IdentityPoolId}/identities/{IdentityId}/datasets/{DatasetName}/subscriptions/{DeviceId}",
					"responseCode": 200
				},
				"input": {
					"type": "structure",
					"required": [
						"IdentityPoolId",
						"IdentityId",
						"DatasetName",
						"DeviceId"
					],
					"members": {
						"IdentityPoolId": {
							"location": "uri",
							"locationName": "IdentityPoolId"
						},
						"IdentityId": {
							"location": "uri",
							"locationName": "IdentityId"
						},
						"DatasetName": {
							"location": "uri",
							"locationName": "DatasetName"
						},
						"DeviceId": {
							"location": "uri",
							"locationName": "DeviceId"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"UpdateRecords": {
				"http": {
					"requestUri": "/identitypools/{IdentityPoolId}/identities/{IdentityId}/datasets/{DatasetName}",
					"responseCode": 200
				},
				"input": {
					"type": "structure",
					"required": [
						"IdentityPoolId",
						"IdentityId",
						"DatasetName",
						"SyncSessionToken"
					],
					"members": {
						"IdentityPoolId": {
							"location": "uri",
							"locationName": "IdentityPoolId"
						},
						"IdentityId": {
							"location": "uri",
							"locationName": "IdentityId"
						},
						"DatasetName": {
							"location": "uri",
							"locationName": "DatasetName"
						},
						"DeviceId": {},
						"RecordPatches": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"Op",
									"Key",
									"SyncCount"
								],
								"members": {
									"Op": {},
									"Key": {},
									"Value": {},
									"SyncCount": {
										"type": "long"
									},
									"DeviceLastModifiedDate": {
										"type": "timestamp"
									}
								}
							}
						},
						"SyncSessionToken": {},
						"ClientContext": {
							"location": "header",
							"locationName": "x-amz-Client-Context"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Records": {
							"shape": "S1c"
						}
					}
				}
			}
		},
		"shapes": {
			"S8": {
				"type": "structure",
				"members": {
					"IdentityId": {},
					"DatasetName": {},
					"CreationDate": {
						"type": "timestamp"
					},
					"LastModifiedDate": {
						"type": "timestamp"
					},
					"LastModifiedBy": {},
					"DataStorage": {
						"type": "long"
					},
					"NumRecords": {
						"type": "long"
					}
				}
			},
			"Sg": {
				"type": "structure",
				"members": {
					"IdentityPoolId": {},
					"SyncSessionsCount": {
						"type": "long"
					},
					"DataStorage": {
						"type": "long"
					},
					"LastModifiedDate": {
						"type": "timestamp"
					}
				}
			},
			"Sq": {
				"type": "map",
				"key": {},
				"value": {}
			},
			"Sv": {
				"type": "structure",
				"members": {
					"ApplicationArns": {
						"type": "list",
						"member": {}
					},
					"RoleArn": {}
				}
			},
			"Sz": {
				"type": "structure",
				"members": {
					"StreamName": {},
					"RoleArn": {},
					"StreamingStatus": {}
				}
			},
			"S1c": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"Key": {},
						"Value": {},
						"SyncCount": {
							"type": "long"
						},
						"LastModifiedDate": {
							"type": "timestamp"
						},
						"LastModifiedBy": {},
						"DeviceLastModifiedDate": {
							"type": "timestamp"
						}
					}
				}
			}
		},
		"examples": {}
	};

/***/ },
/* 294 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['configservice'] = {};
	AWS.ConfigService = Service.defineService('configservice', ['2014-11-12']);
	Object.defineProperty(apiLoader.services['configservice'], '2014-11-12', {
	  get: function get() {
	    var model = __webpack_require__(295);
	    model.paginators = __webpack_require__(296).pagination;
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.ConfigService;


/***/ },
/* 295 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2014-11-12",
			"endpointPrefix": "config",
			"jsonVersion": "1.1",
			"protocol": "json",
			"serviceAbbreviation": "Config Service",
			"serviceFullName": "AWS Config",
			"signatureVersion": "v4",
			"targetPrefix": "StarlingDoveService"
		},
		"operations": {
			"DeleteConfigRule": {
				"input": {
					"type": "structure",
					"required": [
						"ConfigRuleName"
					],
					"members": {
						"ConfigRuleName": {}
					}
				}
			},
			"DeleteConfigurationRecorder": {
				"input": {
					"type": "structure",
					"required": [
						"ConfigurationRecorderName"
					],
					"members": {
						"ConfigurationRecorderName": {}
					}
				}
			},
			"DeleteDeliveryChannel": {
				"input": {
					"type": "structure",
					"required": [
						"DeliveryChannelName"
					],
					"members": {
						"DeliveryChannelName": {}
					}
				}
			},
			"DeleteEvaluationResults": {
				"input": {
					"type": "structure",
					"required": [
						"ConfigRuleName"
					],
					"members": {
						"ConfigRuleName": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"DeliverConfigSnapshot": {
				"input": {
					"type": "structure",
					"required": [
						"deliveryChannelName"
					],
					"members": {
						"deliveryChannelName": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"configSnapshotId": {}
					}
				}
			},
			"DescribeComplianceByConfigRule": {
				"input": {
					"type": "structure",
					"members": {
						"ConfigRuleNames": {
							"shape": "Sd"
						},
						"ComplianceTypes": {
							"shape": "Se"
						},
						"NextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ComplianceByConfigRules": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"ConfigRuleName": {},
									"Compliance": {
										"shape": "Sj"
									}
								}
							}
						},
						"NextToken": {}
					}
				}
			},
			"DescribeComplianceByResource": {
				"input": {
					"type": "structure",
					"members": {
						"ResourceType": {},
						"ResourceId": {},
						"ComplianceTypes": {
							"shape": "Se"
						},
						"Limit": {
							"type": "integer"
						},
						"NextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ComplianceByResources": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"ResourceType": {},
									"ResourceId": {},
									"Compliance": {
										"shape": "Sj"
									}
								}
							}
						},
						"NextToken": {}
					}
				}
			},
			"DescribeConfigRuleEvaluationStatus": {
				"input": {
					"type": "structure",
					"members": {
						"ConfigRuleNames": {
							"shape": "Sd"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ConfigRulesEvaluationStatus": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"ConfigRuleName": {},
									"ConfigRuleArn": {},
									"ConfigRuleId": {},
									"LastSuccessfulInvocationTime": {
										"type": "timestamp"
									},
									"LastFailedInvocationTime": {
										"type": "timestamp"
									},
									"LastSuccessfulEvaluationTime": {
										"type": "timestamp"
									},
									"LastFailedEvaluationTime": {
										"type": "timestamp"
									},
									"FirstActivatedTime": {
										"type": "timestamp"
									},
									"LastErrorCode": {},
									"LastErrorMessage": {},
									"FirstEvaluationStarted": {
										"type": "boolean"
									}
								}
							}
						}
					}
				}
			},
			"DescribeConfigRules": {
				"input": {
					"type": "structure",
					"members": {
						"ConfigRuleNames": {
							"shape": "Sd"
						},
						"NextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ConfigRules": {
							"type": "list",
							"member": {
								"shape": "S12"
							}
						},
						"NextToken": {}
					}
				}
			},
			"DescribeConfigurationRecorderStatus": {
				"input": {
					"type": "structure",
					"members": {
						"ConfigurationRecorderNames": {
							"shape": "S1g"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ConfigurationRecordersStatus": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"name": {},
									"lastStartTime": {
										"type": "timestamp"
									},
									"lastStopTime": {
										"type": "timestamp"
									},
									"recording": {
										"type": "boolean"
									},
									"lastStatus": {},
									"lastErrorCode": {},
									"lastErrorMessage": {},
									"lastStatusChangeTime": {
										"type": "timestamp"
									}
								}
							}
						}
					}
				}
			},
			"DescribeConfigurationRecorders": {
				"input": {
					"type": "structure",
					"members": {
						"ConfigurationRecorderNames": {
							"shape": "S1g"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ConfigurationRecorders": {
							"type": "list",
							"member": {
								"shape": "S1o"
							}
						}
					}
				}
			},
			"DescribeDeliveryChannelStatus": {
				"input": {
					"type": "structure",
					"members": {
						"DeliveryChannelNames": {
							"shape": "S1v"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"DeliveryChannelsStatus": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"name": {},
									"configSnapshotDeliveryInfo": {
										"shape": "S1z"
									},
									"configHistoryDeliveryInfo": {
										"shape": "S1z"
									},
									"configStreamDeliveryInfo": {
										"type": "structure",
										"members": {
											"lastStatus": {},
											"lastErrorCode": {},
											"lastErrorMessage": {},
											"lastStatusChangeTime": {
												"type": "timestamp"
											}
										}
									}
								}
							}
						}
					}
				}
			},
			"DescribeDeliveryChannels": {
				"input": {
					"type": "structure",
					"members": {
						"DeliveryChannelNames": {
							"shape": "S1v"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"DeliveryChannels": {
							"type": "list",
							"member": {
								"shape": "S25"
							}
						}
					}
				}
			},
			"GetComplianceDetailsByConfigRule": {
				"input": {
					"type": "structure",
					"required": [
						"ConfigRuleName"
					],
					"members": {
						"ConfigRuleName": {},
						"ComplianceTypes": {
							"shape": "Se"
						},
						"Limit": {
							"type": "integer"
						},
						"NextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"EvaluationResults": {
							"shape": "S29"
						},
						"NextToken": {}
					}
				}
			},
			"GetComplianceDetailsByResource": {
				"input": {
					"type": "structure",
					"required": [
						"ResourceType",
						"ResourceId"
					],
					"members": {
						"ResourceType": {},
						"ResourceId": {},
						"ComplianceTypes": {
							"shape": "Se"
						},
						"NextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"EvaluationResults": {
							"shape": "S29"
						},
						"NextToken": {}
					}
				}
			},
			"GetComplianceSummaryByConfigRule": {
				"output": {
					"type": "structure",
					"members": {
						"ComplianceSummary": {
							"shape": "S2g"
						}
					}
				}
			},
			"GetComplianceSummaryByResourceType": {
				"input": {
					"type": "structure",
					"members": {
						"ResourceTypes": {
							"type": "list",
							"member": {}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ComplianceSummariesByResourceType": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"ResourceType": {},
									"ComplianceSummary": {
										"shape": "S2g"
									}
								}
							}
						}
					}
				}
			},
			"GetResourceConfigHistory": {
				"input": {
					"type": "structure",
					"required": [
						"resourceType",
						"resourceId"
					],
					"members": {
						"resourceType": {},
						"resourceId": {},
						"laterTime": {
							"type": "timestamp"
						},
						"earlierTime": {
							"type": "timestamp"
						},
						"chronologicalOrder": {},
						"limit": {
							"type": "integer"
						},
						"nextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"configurationItems": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"version": {},
									"accountId": {},
									"configurationItemCaptureTime": {
										"type": "timestamp"
									},
									"configurationItemStatus": {},
									"configurationStateId": {},
									"configurationItemMD5Hash": {},
									"arn": {},
									"resourceType": {},
									"resourceId": {},
									"resourceName": {},
									"awsRegion": {},
									"availabilityZone": {},
									"resourceCreationTime": {
										"type": "timestamp"
									},
									"tags": {
										"type": "map",
										"key": {},
										"value": {}
									},
									"relatedEvents": {
										"type": "list",
										"member": {}
									},
									"relationships": {
										"type": "list",
										"member": {
											"type": "structure",
											"members": {
												"resourceType": {},
												"resourceId": {},
												"resourceName": {},
												"relationshipName": {}
											}
										}
									},
									"configuration": {},
									"supplementaryConfiguration": {
										"type": "map",
										"key": {},
										"value": {}
									}
								}
							}
						},
						"nextToken": {}
					}
				}
			},
			"ListDiscoveredResources": {
				"input": {
					"type": "structure",
					"required": [
						"resourceType"
					],
					"members": {
						"resourceType": {},
						"resourceIds": {
							"type": "list",
							"member": {}
						},
						"resourceName": {},
						"limit": {
							"type": "integer"
						},
						"includeDeletedResources": {
							"type": "boolean"
						},
						"nextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"resourceIdentifiers": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"resourceType": {},
									"resourceId": {},
									"resourceName": {},
									"resourceDeletionTime": {
										"type": "timestamp"
									}
								}
							}
						},
						"nextToken": {}
					}
				}
			},
			"PutConfigRule": {
				"input": {
					"type": "structure",
					"required": [
						"ConfigRule"
					],
					"members": {
						"ConfigRule": {
							"shape": "S12"
						}
					}
				}
			},
			"PutConfigurationRecorder": {
				"input": {
					"type": "structure",
					"required": [
						"ConfigurationRecorder"
					],
					"members": {
						"ConfigurationRecorder": {
							"shape": "S1o"
						}
					}
				}
			},
			"PutDeliveryChannel": {
				"input": {
					"type": "structure",
					"required": [
						"DeliveryChannel"
					],
					"members": {
						"DeliveryChannel": {
							"shape": "S25"
						}
					}
				}
			},
			"PutEvaluations": {
				"input": {
					"type": "structure",
					"required": [
						"ResultToken"
					],
					"members": {
						"Evaluations": {
							"shape": "S3r"
						},
						"ResultToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"FailedEvaluations": {
							"shape": "S3r"
						}
					}
				}
			},
			"StartConfigRulesEvaluation": {
				"input": {
					"type": "structure",
					"members": {
						"ConfigRuleNames": {
							"type": "list",
							"member": {}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"StartConfigurationRecorder": {
				"input": {
					"type": "structure",
					"required": [
						"ConfigurationRecorderName"
					],
					"members": {
						"ConfigurationRecorderName": {}
					}
				}
			},
			"StopConfigurationRecorder": {
				"input": {
					"type": "structure",
					"required": [
						"ConfigurationRecorderName"
					],
					"members": {
						"ConfigurationRecorderName": {}
					}
				}
			}
		},
		"shapes": {
			"Sd": {
				"type": "list",
				"member": {}
			},
			"Se": {
				"type": "list",
				"member": {}
			},
			"Sj": {
				"type": "structure",
				"members": {
					"ComplianceType": {},
					"ComplianceContributorCount": {
						"shape": "Sk"
					}
				}
			},
			"Sk": {
				"type": "structure",
				"members": {
					"CappedCount": {
						"type": "integer"
					},
					"CapExceeded": {
						"type": "boolean"
					}
				}
			},
			"S12": {
				"type": "structure",
				"required": [
					"Source"
				],
				"members": {
					"ConfigRuleName": {},
					"ConfigRuleArn": {},
					"ConfigRuleId": {},
					"Description": {},
					"Scope": {
						"type": "structure",
						"members": {
							"ComplianceResourceTypes": {
								"type": "list",
								"member": {}
							},
							"TagKey": {},
							"TagValue": {},
							"ComplianceResourceId": {}
						}
					},
					"Source": {
						"type": "structure",
						"members": {
							"Owner": {},
							"SourceIdentifier": {},
							"SourceDetails": {
								"type": "list",
								"member": {
									"type": "structure",
									"members": {
										"EventSource": {},
										"MessageType": {},
										"MaximumExecutionFrequency": {}
									}
								}
							}
						}
					},
					"InputParameters": {},
					"MaximumExecutionFrequency": {},
					"ConfigRuleState": {}
				}
			},
			"S1g": {
				"type": "list",
				"member": {}
			},
			"S1o": {
				"type": "structure",
				"members": {
					"name": {},
					"roleARN": {},
					"recordingGroup": {
						"type": "structure",
						"members": {
							"allSupported": {
								"type": "boolean"
							},
							"includeGlobalResourceTypes": {
								"type": "boolean"
							},
							"resourceTypes": {
								"type": "list",
								"member": {}
							}
						}
					}
				}
			},
			"S1v": {
				"type": "list",
				"member": {}
			},
			"S1z": {
				"type": "structure",
				"members": {
					"lastStatus": {},
					"lastErrorCode": {},
					"lastErrorMessage": {},
					"lastAttemptTime": {
						"type": "timestamp"
					},
					"lastSuccessfulTime": {
						"type": "timestamp"
					},
					"nextDeliveryTime": {
						"type": "timestamp"
					}
				}
			},
			"S25": {
				"type": "structure",
				"members": {
					"name": {},
					"s3BucketName": {},
					"s3KeyPrefix": {},
					"snsTopicARN": {},
					"configSnapshotDeliveryProperties": {
						"type": "structure",
						"members": {
							"deliveryFrequency": {}
						}
					}
				}
			},
			"S29": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"EvaluationResultIdentifier": {
							"type": "structure",
							"members": {
								"EvaluationResultQualifier": {
									"type": "structure",
									"members": {
										"ConfigRuleName": {},
										"ResourceType": {},
										"ResourceId": {}
									}
								},
								"OrderingTimestamp": {
									"type": "timestamp"
								}
							}
						},
						"ComplianceType": {},
						"ResultRecordedTime": {
							"type": "timestamp"
						},
						"ConfigRuleInvokedTime": {
							"type": "timestamp"
						},
						"Annotation": {},
						"ResultToken": {}
					}
				}
			},
			"S2g": {
				"type": "structure",
				"members": {
					"CompliantResourceCount": {
						"shape": "Sk"
					},
					"NonCompliantResourceCount": {
						"shape": "Sk"
					},
					"ComplianceSummaryTimestamp": {
						"type": "timestamp"
					}
				}
			},
			"S3r": {
				"type": "list",
				"member": {
					"type": "structure",
					"required": [
						"ComplianceResourceType",
						"ComplianceResourceId",
						"ComplianceType",
						"OrderingTimestamp"
					],
					"members": {
						"ComplianceResourceType": {},
						"ComplianceResourceId": {},
						"ComplianceType": {},
						"Annotation": {},
						"OrderingTimestamp": {
							"type": "timestamp"
						}
					}
				}
			}
		}
	};

/***/ },
/* 296 */
/***/ function(module, exports) {

	module.exports = {
		"pagination": {
			"GetResourceConfigHistory": {
				"input_token": "nextToken",
				"output_token": "nextToken",
				"limit_key": "limit",
				"result_key": "configurationItems"
			}
		}
	};

/***/ },
/* 297 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['datapipeline'] = {};
	AWS.DataPipeline = Service.defineService('datapipeline', ['2012-10-29']);
	Object.defineProperty(apiLoader.services['datapipeline'], '2012-10-29', {
	  get: function get() {
	    var model = __webpack_require__(298);
	    model.paginators = __webpack_require__(299).pagination;
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.DataPipeline;


/***/ },
/* 298 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2012-10-29",
			"endpointPrefix": "datapipeline",
			"jsonVersion": "1.1",
			"serviceFullName": "AWS Data Pipeline",
			"signatureVersion": "v4",
			"targetPrefix": "DataPipeline",
			"protocol": "json"
		},
		"operations": {
			"ActivatePipeline": {
				"input": {
					"type": "structure",
					"required": [
						"pipelineId"
					],
					"members": {
						"pipelineId": {},
						"parameterValues": {
							"shape": "S3"
						},
						"startTimestamp": {
							"type": "timestamp"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"AddTags": {
				"input": {
					"type": "structure",
					"required": [
						"pipelineId",
						"tags"
					],
					"members": {
						"pipelineId": {},
						"tags": {
							"shape": "Sa"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"CreatePipeline": {
				"input": {
					"type": "structure",
					"required": [
						"name",
						"uniqueId"
					],
					"members": {
						"name": {},
						"uniqueId": {},
						"description": {},
						"tags": {
							"shape": "Sa"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"pipelineId"
					],
					"members": {
						"pipelineId": {}
					}
				}
			},
			"DeactivatePipeline": {
				"input": {
					"type": "structure",
					"required": [
						"pipelineId"
					],
					"members": {
						"pipelineId": {},
						"cancelActive": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"DeletePipeline": {
				"input": {
					"type": "structure",
					"required": [
						"pipelineId"
					],
					"members": {
						"pipelineId": {}
					}
				}
			},
			"DescribeObjects": {
				"input": {
					"type": "structure",
					"required": [
						"pipelineId",
						"objectIds"
					],
					"members": {
						"pipelineId": {},
						"objectIds": {
							"shape": "Sn"
						},
						"evaluateExpressions": {
							"type": "boolean"
						},
						"marker": {}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"pipelineObjects"
					],
					"members": {
						"pipelineObjects": {
							"shape": "Sq"
						},
						"marker": {},
						"hasMoreResults": {
							"type": "boolean"
						}
					}
				}
			},
			"DescribePipelines": {
				"input": {
					"type": "structure",
					"required": [
						"pipelineIds"
					],
					"members": {
						"pipelineIds": {
							"shape": "Sn"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"pipelineDescriptionList"
					],
					"members": {
						"pipelineDescriptionList": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"pipelineId",
									"name",
									"fields"
								],
								"members": {
									"pipelineId": {},
									"name": {},
									"fields": {
										"shape": "Ss"
									},
									"description": {},
									"tags": {
										"shape": "Sa"
									}
								}
							}
						}
					}
				}
			},
			"EvaluateExpression": {
				"input": {
					"type": "structure",
					"required": [
						"pipelineId",
						"objectId",
						"expression"
					],
					"members": {
						"pipelineId": {},
						"objectId": {},
						"expression": {}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"evaluatedExpression"
					],
					"members": {
						"evaluatedExpression": {}
					}
				}
			},
			"GetPipelineDefinition": {
				"input": {
					"type": "structure",
					"required": [
						"pipelineId"
					],
					"members": {
						"pipelineId": {},
						"version": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"pipelineObjects": {
							"shape": "Sq"
						},
						"parameterObjects": {
							"shape": "S13"
						},
						"parameterValues": {
							"shape": "S3"
						}
					}
				}
			},
			"ListPipelines": {
				"input": {
					"type": "structure",
					"members": {
						"marker": {}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"pipelineIdList"
					],
					"members": {
						"pipelineIdList": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"id": {},
									"name": {}
								}
							}
						},
						"marker": {},
						"hasMoreResults": {
							"type": "boolean"
						}
					}
				}
			},
			"PollForTask": {
				"input": {
					"type": "structure",
					"required": [
						"workerGroup"
					],
					"members": {
						"workerGroup": {},
						"hostname": {},
						"instanceIdentity": {
							"type": "structure",
							"members": {
								"document": {},
								"signature": {}
							}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"taskObject": {
							"type": "structure",
							"members": {
								"taskId": {},
								"pipelineId": {},
								"attemptId": {},
								"objects": {
									"type": "map",
									"key": {},
									"value": {
										"shape": "Sr"
									}
								}
							}
						}
					}
				}
			},
			"PutPipelineDefinition": {
				"input": {
					"type": "structure",
					"required": [
						"pipelineId",
						"pipelineObjects"
					],
					"members": {
						"pipelineId": {},
						"pipelineObjects": {
							"shape": "Sq"
						},
						"parameterObjects": {
							"shape": "S13"
						},
						"parameterValues": {
							"shape": "S3"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"errored"
					],
					"members": {
						"validationErrors": {
							"shape": "S1l"
						},
						"validationWarnings": {
							"shape": "S1p"
						},
						"errored": {
							"type": "boolean"
						}
					}
				}
			},
			"QueryObjects": {
				"input": {
					"type": "structure",
					"required": [
						"pipelineId",
						"sphere"
					],
					"members": {
						"pipelineId": {},
						"query": {
							"type": "structure",
							"members": {
								"selectors": {
									"type": "list",
									"member": {
										"type": "structure",
										"members": {
											"fieldName": {},
											"operator": {
												"type": "structure",
												"members": {
													"type": {},
													"values": {
														"shape": "S1x"
													}
												}
											}
										}
									}
								}
							}
						},
						"sphere": {},
						"marker": {},
						"limit": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ids": {
							"shape": "Sn"
						},
						"marker": {},
						"hasMoreResults": {
							"type": "boolean"
						}
					}
				}
			},
			"RemoveTags": {
				"input": {
					"type": "structure",
					"required": [
						"pipelineId",
						"tagKeys"
					],
					"members": {
						"pipelineId": {},
						"tagKeys": {
							"shape": "S1x"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"ReportTaskProgress": {
				"input": {
					"type": "structure",
					"required": [
						"taskId"
					],
					"members": {
						"taskId": {},
						"fields": {
							"shape": "Ss"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"canceled"
					],
					"members": {
						"canceled": {
							"type": "boolean"
						}
					}
				}
			},
			"ReportTaskRunnerHeartbeat": {
				"input": {
					"type": "structure",
					"required": [
						"taskrunnerId"
					],
					"members": {
						"taskrunnerId": {},
						"workerGroup": {},
						"hostname": {}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"terminate"
					],
					"members": {
						"terminate": {
							"type": "boolean"
						}
					}
				}
			},
			"SetStatus": {
				"input": {
					"type": "structure",
					"required": [
						"pipelineId",
						"objectIds",
						"status"
					],
					"members": {
						"pipelineId": {},
						"objectIds": {
							"shape": "Sn"
						},
						"status": {}
					}
				}
			},
			"SetTaskStatus": {
				"input": {
					"type": "structure",
					"required": [
						"taskId",
						"taskStatus"
					],
					"members": {
						"taskId": {},
						"taskStatus": {},
						"errorId": {},
						"errorMessage": {},
						"errorStackTrace": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"ValidatePipelineDefinition": {
				"input": {
					"type": "structure",
					"required": [
						"pipelineId",
						"pipelineObjects"
					],
					"members": {
						"pipelineId": {},
						"pipelineObjects": {
							"shape": "Sq"
						},
						"parameterObjects": {
							"shape": "S13"
						},
						"parameterValues": {
							"shape": "S3"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"errored"
					],
					"members": {
						"validationErrors": {
							"shape": "S1l"
						},
						"validationWarnings": {
							"shape": "S1p"
						},
						"errored": {
							"type": "boolean"
						}
					}
				}
			}
		},
		"shapes": {
			"S3": {
				"type": "list",
				"member": {
					"type": "structure",
					"required": [
						"id",
						"stringValue"
					],
					"members": {
						"id": {},
						"stringValue": {}
					}
				}
			},
			"Sa": {
				"type": "list",
				"member": {
					"type": "structure",
					"required": [
						"key",
						"value"
					],
					"members": {
						"key": {},
						"value": {}
					}
				}
			},
			"Sn": {
				"type": "list",
				"member": {}
			},
			"Sq": {
				"type": "list",
				"member": {
					"shape": "Sr"
				}
			},
			"Sr": {
				"type": "structure",
				"required": [
					"id",
					"name",
					"fields"
				],
				"members": {
					"id": {},
					"name": {},
					"fields": {
						"shape": "Ss"
					}
				}
			},
			"Ss": {
				"type": "list",
				"member": {
					"type": "structure",
					"required": [
						"key"
					],
					"members": {
						"key": {},
						"stringValue": {},
						"refValue": {}
					}
				}
			},
			"S13": {
				"type": "list",
				"member": {
					"type": "structure",
					"required": [
						"id",
						"attributes"
					],
					"members": {
						"id": {},
						"attributes": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"key",
									"stringValue"
								],
								"members": {
									"key": {},
									"stringValue": {}
								}
							}
						}
					}
				}
			},
			"S1l": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"id": {},
						"errors": {
							"shape": "S1n"
						}
					}
				}
			},
			"S1n": {
				"type": "list",
				"member": {}
			},
			"S1p": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"id": {},
						"warnings": {
							"shape": "S1n"
						}
					}
				}
			},
			"S1x": {
				"type": "list",
				"member": {}
			}
		}
	};

/***/ },
/* 299 */
/***/ function(module, exports) {

	module.exports = {
		"pagination": {
			"ListPipelines": {
				"input_token": "marker",
				"output_token": "marker",
				"more_results": "hasMoreResults",
				"result_key": "pipelineIdList"
			},
			"DescribeObjects": {
				"input_token": "marker",
				"output_token": "marker",
				"more_results": "hasMoreResults",
				"result_key": "pipelineObjects"
			},
			"DescribePipelines": {
				"result_key": "pipelineDescriptionList"
			},
			"QueryObjects": {
				"input_token": "marker",
				"output_token": "marker",
				"more_results": "hasMoreResults",
				"limit_key": "limit",
				"result_key": "ids"
			}
		}
	};

/***/ },
/* 300 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['devicefarm'] = {};
	AWS.DeviceFarm = Service.defineService('devicefarm', ['2015-06-23']);
	Object.defineProperty(apiLoader.services['devicefarm'], '2015-06-23', {
	  get: function get() {
	    var model = __webpack_require__(301);
	    model.paginators = __webpack_require__(302).pagination;
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.DeviceFarm;


/***/ },
/* 301 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2015-06-23",
			"endpointPrefix": "devicefarm",
			"jsonVersion": "1.1",
			"protocol": "json",
			"serviceFullName": "AWS Device Farm",
			"signatureVersion": "v4",
			"targetPrefix": "DeviceFarm_20150623"
		},
		"operations": {
			"CreateDevicePool": {
				"input": {
					"type": "structure",
					"required": [
						"projectArn",
						"name",
						"rules"
					],
					"members": {
						"projectArn": {},
						"name": {},
						"description": {},
						"rules": {
							"shape": "S5"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"devicePool": {
							"shape": "Sb"
						}
					}
				}
			},
			"CreateProject": {
				"input": {
					"type": "structure",
					"required": [
						"name"
					],
					"members": {
						"name": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"project": {
							"shape": "Sf"
						}
					}
				}
			},
			"CreateRemoteAccessSession": {
				"input": {
					"type": "structure",
					"required": [
						"projectArn",
						"deviceArn"
					],
					"members": {
						"projectArn": {},
						"deviceArn": {},
						"name": {},
						"configuration": {
							"type": "structure",
							"members": {
								"billingMethod": {}
							}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"remoteAccessSession": {
							"shape": "Sl"
						}
					}
				}
			},
			"CreateUpload": {
				"input": {
					"type": "structure",
					"required": [
						"projectArn",
						"name",
						"type"
					],
					"members": {
						"projectArn": {},
						"name": {},
						"type": {},
						"contentType": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"upload": {
							"shape": "S12"
						}
					}
				}
			},
			"DeleteDevicePool": {
				"input": {
					"type": "structure",
					"required": [
						"arn"
					],
					"members": {
						"arn": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"DeleteProject": {
				"input": {
					"type": "structure",
					"required": [
						"arn"
					],
					"members": {
						"arn": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"DeleteRemoteAccessSession": {
				"input": {
					"type": "structure",
					"required": [
						"arn"
					],
					"members": {
						"arn": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"DeleteRun": {
				"input": {
					"type": "structure",
					"required": [
						"arn"
					],
					"members": {
						"arn": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"DeleteUpload": {
				"input": {
					"type": "structure",
					"required": [
						"arn"
					],
					"members": {
						"arn": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"GetAccountSettings": {
				"input": {
					"type": "structure",
					"members": {}
				},
				"output": {
					"type": "structure",
					"members": {
						"accountSettings": {
							"type": "structure",
							"members": {
								"awsAccountNumber": {},
								"unmeteredDevices": {
									"shape": "S1k"
								},
								"unmeteredRemoteAccessDevices": {
									"shape": "S1k"
								}
							}
						}
					}
				}
			},
			"GetDevice": {
				"input": {
					"type": "structure",
					"required": [
						"arn"
					],
					"members": {
						"arn": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"device": {
							"shape": "So"
						}
					}
				}
			},
			"GetDevicePool": {
				"input": {
					"type": "structure",
					"required": [
						"arn"
					],
					"members": {
						"arn": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"devicePool": {
							"shape": "Sb"
						}
					}
				}
			},
			"GetDevicePoolCompatibility": {
				"input": {
					"type": "structure",
					"required": [
						"devicePoolArn"
					],
					"members": {
						"devicePoolArn": {},
						"appArn": {},
						"testType": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"compatibleDevices": {
							"shape": "S1s"
						},
						"incompatibleDevices": {
							"shape": "S1s"
						}
					}
				}
			},
			"GetJob": {
				"input": {
					"type": "structure",
					"required": [
						"arn"
					],
					"members": {
						"arn": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"job": {
							"shape": "S1y"
						}
					}
				}
			},
			"GetOfferingStatus": {
				"input": {
					"type": "structure",
					"members": {
						"nextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"current": {
							"shape": "S23"
						},
						"nextPeriod": {
							"shape": "S23"
						},
						"nextToken": {}
					}
				}
			},
			"GetProject": {
				"input": {
					"type": "structure",
					"required": [
						"arn"
					],
					"members": {
						"arn": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"project": {
							"shape": "Sf"
						}
					}
				}
			},
			"GetRemoteAccessSession": {
				"input": {
					"type": "structure",
					"required": [
						"arn"
					],
					"members": {
						"arn": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"remoteAccessSession": {
							"shape": "Sl"
						}
					}
				}
			},
			"GetRun": {
				"input": {
					"type": "structure",
					"required": [
						"arn"
					],
					"members": {
						"arn": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"run": {
							"shape": "S2k"
						}
					}
				}
			},
			"GetSuite": {
				"input": {
					"type": "structure",
					"required": [
						"arn"
					],
					"members": {
						"arn": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"suite": {
							"shape": "S2n"
						}
					}
				}
			},
			"GetTest": {
				"input": {
					"type": "structure",
					"required": [
						"arn"
					],
					"members": {
						"arn": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"test": {
							"shape": "S2q"
						}
					}
				}
			},
			"GetUpload": {
				"input": {
					"type": "structure",
					"required": [
						"arn"
					],
					"members": {
						"arn": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"upload": {
							"shape": "S12"
						}
					}
				}
			},
			"InstallToRemoteAccessSession": {
				"input": {
					"type": "structure",
					"required": [
						"remoteAccessSessionArn",
						"appArn"
					],
					"members": {
						"remoteAccessSessionArn": {},
						"appArn": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"appUpload": {
							"shape": "S12"
						}
					}
				}
			},
			"ListArtifacts": {
				"input": {
					"type": "structure",
					"required": [
						"arn",
						"type"
					],
					"members": {
						"arn": {},
						"type": {},
						"nextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"artifacts": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"arn": {},
									"name": {},
									"type": {},
									"extension": {},
									"url": {}
								}
							}
						},
						"nextToken": {}
					}
				}
			},
			"ListDevicePools": {
				"input": {
					"type": "structure",
					"required": [
						"arn"
					],
					"members": {
						"arn": {},
						"type": {},
						"nextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"devicePools": {
							"type": "list",
							"member": {
								"shape": "Sb"
							}
						},
						"nextToken": {}
					}
				}
			},
			"ListDevices": {
				"input": {
					"type": "structure",
					"members": {
						"arn": {},
						"nextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"devices": {
							"type": "list",
							"member": {
								"shape": "So"
							}
						},
						"nextToken": {}
					}
				}
			},
			"ListJobs": {
				"input": {
					"type": "structure",
					"required": [
						"arn"
					],
					"members": {
						"arn": {},
						"nextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"jobs": {
							"type": "list",
							"member": {
								"shape": "S1y"
							}
						},
						"nextToken": {}
					}
				}
			},
			"ListOfferingTransactions": {
				"input": {
					"type": "structure",
					"members": {
						"nextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"offeringTransactions": {
							"type": "list",
							"member": {
								"shape": "S3d"
							}
						},
						"nextToken": {}
					}
				}
			},
			"ListOfferings": {
				"input": {
					"type": "structure",
					"members": {
						"nextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"offerings": {
							"type": "list",
							"member": {
								"shape": "S27"
							}
						},
						"nextToken": {}
					}
				}
			},
			"ListProjects": {
				"input": {
					"type": "structure",
					"members": {
						"arn": {},
						"nextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"projects": {
							"type": "list",
							"member": {
								"shape": "Sf"
							}
						},
						"nextToken": {}
					}
				}
			},
			"ListRemoteAccessSessions": {
				"input": {
					"type": "structure",
					"required": [
						"arn"
					],
					"members": {
						"arn": {},
						"nextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"remoteAccessSessions": {
							"type": "list",
							"member": {
								"shape": "Sl"
							}
						},
						"nextToken": {}
					}
				}
			},
			"ListRuns": {
				"input": {
					"type": "structure",
					"required": [
						"arn"
					],
					"members": {
						"arn": {},
						"nextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"runs": {
							"type": "list",
							"member": {
								"shape": "S2k"
							}
						},
						"nextToken": {}
					}
				}
			},
			"ListSamples": {
				"input": {
					"type": "structure",
					"required": [
						"arn"
					],
					"members": {
						"arn": {},
						"nextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"samples": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"arn": {},
									"type": {},
									"url": {}
								}
							}
						},
						"nextToken": {}
					}
				}
			},
			"ListSuites": {
				"input": {
					"type": "structure",
					"required": [
						"arn"
					],
					"members": {
						"arn": {},
						"nextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"suites": {
							"type": "list",
							"member": {
								"shape": "S2n"
							}
						},
						"nextToken": {}
					}
				}
			},
			"ListTests": {
				"input": {
					"type": "structure",
					"required": [
						"arn"
					],
					"members": {
						"arn": {},
						"nextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"tests": {
							"type": "list",
							"member": {
								"shape": "S2q"
							}
						},
						"nextToken": {}
					}
				}
			},
			"ListUniqueProblems": {
				"input": {
					"type": "structure",
					"required": [
						"arn"
					],
					"members": {
						"arn": {},
						"nextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"uniqueProblems": {
							"type": "map",
							"key": {},
							"value": {
								"type": "list",
								"member": {
									"type": "structure",
									"members": {
										"message": {},
										"problems": {
											"type": "list",
											"member": {
												"type": "structure",
												"members": {
													"run": {
														"shape": "S49"
													},
													"job": {
														"shape": "S49"
													},
													"suite": {
														"shape": "S49"
													},
													"test": {
														"shape": "S49"
													},
													"device": {
														"shape": "So"
													},
													"result": {},
													"message": {}
												}
											}
										}
									}
								}
							}
						},
						"nextToken": {}
					}
				}
			},
			"ListUploads": {
				"input": {
					"type": "structure",
					"required": [
						"arn"
					],
					"members": {
						"arn": {},
						"nextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"uploads": {
							"type": "list",
							"member": {
								"shape": "S12"
							}
						},
						"nextToken": {}
					}
				}
			},
			"PurchaseOffering": {
				"input": {
					"type": "structure",
					"members": {
						"offeringId": {},
						"quantity": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"offeringTransaction": {
							"shape": "S3d"
						}
					}
				}
			},
			"RenewOffering": {
				"input": {
					"type": "structure",
					"members": {
						"offeringId": {},
						"quantity": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"offeringTransaction": {
							"shape": "S3d"
						}
					}
				}
			},
			"ScheduleRun": {
				"input": {
					"type": "structure",
					"required": [
						"projectArn",
						"devicePoolArn",
						"test"
					],
					"members": {
						"projectArn": {},
						"appArn": {},
						"devicePoolArn": {},
						"name": {},
						"test": {
							"type": "structure",
							"required": [
								"type"
							],
							"members": {
								"type": {},
								"testPackageArn": {},
								"filter": {},
								"parameters": {
									"type": "map",
									"key": {},
									"value": {}
								}
							}
						},
						"configuration": {
							"type": "structure",
							"members": {
								"extraDataPackageArn": {},
								"networkProfileArn": {},
								"locale": {},
								"location": {
									"type": "structure",
									"required": [
										"latitude",
										"longitude"
									],
									"members": {
										"latitude": {
											"type": "double"
										},
										"longitude": {
											"type": "double"
										}
									}
								},
								"radios": {
									"type": "structure",
									"members": {
										"wifi": {
											"type": "boolean"
										},
										"bluetooth": {
											"type": "boolean"
										},
										"nfc": {
											"type": "boolean"
										},
										"gps": {
											"type": "boolean"
										}
									}
								},
								"auxiliaryApps": {
									"type": "list",
									"member": {}
								},
								"billingMethod": {}
							}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"run": {
							"shape": "S2k"
						}
					}
				}
			},
			"StopRemoteAccessSession": {
				"input": {
					"type": "structure",
					"required": [
						"arn"
					],
					"members": {
						"arn": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"remoteAccessSession": {
							"shape": "Sl"
						}
					}
				}
			},
			"StopRun": {
				"input": {
					"type": "structure",
					"required": [
						"arn"
					],
					"members": {
						"arn": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"run": {
							"shape": "S2k"
						}
					}
				}
			},
			"UpdateDevicePool": {
				"input": {
					"type": "structure",
					"required": [
						"arn"
					],
					"members": {
						"arn": {},
						"name": {},
						"description": {},
						"rules": {
							"shape": "S5"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"devicePool": {
							"shape": "Sb"
						}
					}
				}
			},
			"UpdateProject": {
				"input": {
					"type": "structure",
					"required": [
						"arn"
					],
					"members": {
						"arn": {},
						"name": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"project": {
							"shape": "Sf"
						}
					}
				}
			}
		},
		"shapes": {
			"S5": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"attribute": {},
						"operator": {},
						"value": {}
					}
				}
			},
			"Sb": {
				"type": "structure",
				"members": {
					"arn": {},
					"name": {},
					"description": {},
					"type": {},
					"rules": {
						"shape": "S5"
					}
				}
			},
			"Sf": {
				"type": "structure",
				"members": {
					"arn": {},
					"name": {},
					"created": {
						"type": "timestamp"
					}
				}
			},
			"Sl": {
				"type": "structure",
				"members": {
					"arn": {},
					"name": {},
					"created": {
						"type": "timestamp"
					},
					"status": {},
					"result": {},
					"message": {},
					"started": {
						"type": "timestamp"
					},
					"stopped": {
						"type": "timestamp"
					},
					"device": {
						"shape": "So"
					},
					"billingMethod": {},
					"deviceMinutes": {
						"shape": "Sx"
					},
					"endpoint": {}
				}
			},
			"So": {
				"type": "structure",
				"members": {
					"arn": {},
					"name": {},
					"manufacturer": {},
					"model": {},
					"formFactor": {},
					"platform": {},
					"os": {},
					"cpu": {
						"type": "structure",
						"members": {
							"frequency": {},
							"architecture": {},
							"clock": {
								"type": "double"
							}
						}
					},
					"resolution": {
						"type": "structure",
						"members": {
							"width": {
								"type": "integer"
							},
							"height": {
								"type": "integer"
							}
						}
					},
					"heapSize": {
						"type": "long"
					},
					"memory": {
						"type": "long"
					},
					"image": {},
					"carrier": {},
					"radio": {},
					"remoteAccessEnabled": {
						"type": "boolean"
					},
					"fleetType": {},
					"fleetName": {}
				}
			},
			"Sx": {
				"type": "structure",
				"members": {
					"total": {
						"type": "double"
					},
					"metered": {
						"type": "double"
					},
					"unmetered": {
						"type": "double"
					}
				}
			},
			"S12": {
				"type": "structure",
				"members": {
					"arn": {},
					"name": {},
					"created": {
						"type": "timestamp"
					},
					"type": {},
					"status": {},
					"url": {},
					"metadata": {},
					"contentType": {},
					"message": {}
				}
			},
			"S1k": {
				"type": "map",
				"key": {},
				"value": {
					"type": "integer"
				}
			},
			"S1s": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"device": {
							"shape": "So"
						},
						"compatible": {
							"type": "boolean"
						},
						"incompatibilityMessages": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"message": {},
									"type": {}
								}
							}
						}
					}
				}
			},
			"S1y": {
				"type": "structure",
				"members": {
					"arn": {},
					"name": {},
					"type": {},
					"created": {
						"type": "timestamp"
					},
					"status": {},
					"result": {},
					"started": {
						"type": "timestamp"
					},
					"stopped": {
						"type": "timestamp"
					},
					"counters": {
						"shape": "S1z"
					},
					"message": {},
					"device": {
						"shape": "So"
					},
					"deviceMinutes": {
						"shape": "Sx"
					}
				}
			},
			"S1z": {
				"type": "structure",
				"members": {
					"total": {
						"type": "integer"
					},
					"passed": {
						"type": "integer"
					},
					"failed": {
						"type": "integer"
					},
					"warned": {
						"type": "integer"
					},
					"errored": {
						"type": "integer"
					},
					"stopped": {
						"type": "integer"
					},
					"skipped": {
						"type": "integer"
					}
				}
			},
			"S23": {
				"type": "map",
				"key": {},
				"value": {
					"shape": "S25"
				}
			},
			"S25": {
				"type": "structure",
				"members": {
					"type": {},
					"offering": {
						"shape": "S27"
					},
					"quantity": {
						"type": "integer"
					},
					"effectiveOn": {
						"type": "timestamp"
					}
				}
			},
			"S27": {
				"type": "structure",
				"members": {
					"id": {},
					"description": {},
					"type": {},
					"platform": {},
					"recurringCharges": {
						"type": "list",
						"member": {
							"type": "structure",
							"members": {
								"cost": {
									"shape": "S2b"
								},
								"frequency": {}
							}
						}
					}
				}
			},
			"S2b": {
				"type": "structure",
				"members": {
					"amount": {
						"type": "double"
					},
					"currencyCode": {}
				}
			},
			"S2k": {
				"type": "structure",
				"members": {
					"arn": {},
					"name": {},
					"type": {},
					"platform": {},
					"created": {
						"type": "timestamp"
					},
					"status": {},
					"result": {},
					"started": {
						"type": "timestamp"
					},
					"stopped": {
						"type": "timestamp"
					},
					"counters": {
						"shape": "S1z"
					},
					"message": {},
					"totalJobs": {
						"type": "integer"
					},
					"completedJobs": {
						"type": "integer"
					},
					"billingMethod": {},
					"deviceMinutes": {
						"shape": "Sx"
					}
				}
			},
			"S2n": {
				"type": "structure",
				"members": {
					"arn": {},
					"name": {},
					"type": {},
					"created": {
						"type": "timestamp"
					},
					"status": {},
					"result": {},
					"started": {
						"type": "timestamp"
					},
					"stopped": {
						"type": "timestamp"
					},
					"counters": {
						"shape": "S1z"
					},
					"message": {},
					"deviceMinutes": {
						"shape": "Sx"
					}
				}
			},
			"S2q": {
				"type": "structure",
				"members": {
					"arn": {},
					"name": {},
					"type": {},
					"created": {
						"type": "timestamp"
					},
					"status": {},
					"result": {},
					"started": {
						"type": "timestamp"
					},
					"stopped": {
						"type": "timestamp"
					},
					"counters": {
						"shape": "S1z"
					},
					"message": {},
					"deviceMinutes": {
						"shape": "Sx"
					}
				}
			},
			"S3d": {
				"type": "structure",
				"members": {
					"offeringStatus": {
						"shape": "S25"
					},
					"transactionId": {},
					"createdOn": {
						"type": "timestamp"
					},
					"cost": {
						"shape": "S2b"
					}
				}
			},
			"S49": {
				"type": "structure",
				"members": {
					"arn": {},
					"name": {}
				}
			}
		}
	};

/***/ },
/* 302 */
/***/ function(module, exports) {

	module.exports = {
		"pagination": {
			"GetOfferingStatus": {
				"input_token": "nextToken",
				"output_token": "nextToken",
				"result_key": [
					"current",
					"nextPeriod"
				]
			},
			"ListArtifacts": {
				"input_token": "nextToken",
				"output_token": "nextToken",
				"result_key": "artifacts"
			},
			"ListDevicePools": {
				"input_token": "nextToken",
				"output_token": "nextToken",
				"result_key": "devicePools"
			},
			"ListDevices": {
				"input_token": "nextToken",
				"output_token": "nextToken",
				"result_key": "devices"
			},
			"ListJobs": {
				"input_token": "nextToken",
				"output_token": "nextToken",
				"result_key": "jobs"
			},
			"ListOfferingTransactions": {
				"input_token": "nextToken",
				"output_token": "nextToken",
				"result_key": "offeringTransactions"
			},
			"ListOfferings": {
				"input_token": "nextToken",
				"output_token": "nextToken",
				"result_key": "offerings"
			},
			"ListProjects": {
				"input_token": "nextToken",
				"output_token": "nextToken",
				"result_key": "projects"
			},
			"ListRuns": {
				"input_token": "nextToken",
				"output_token": "nextToken",
				"result_key": "runs"
			},
			"ListSamples": {
				"input_token": "nextToken",
				"output_token": "nextToken",
				"result_key": "samples"
			},
			"ListSuites": {
				"input_token": "nextToken",
				"output_token": "nextToken",
				"result_key": "suites"
			},
			"ListTests": {
				"input_token": "nextToken",
				"output_token": "nextToken",
				"result_key": "tests"
			},
			"ListUniqueProblems": {
				"input_token": "nextToken",
				"output_token": "nextToken",
				"result_key": "uniqueProblems"
			},
			"ListUploads": {
				"input_token": "nextToken",
				"output_token": "nextToken",
				"result_key": "uploads"
			}
		}
	};

/***/ },
/* 303 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['directconnect'] = {};
	AWS.DirectConnect = Service.defineService('directconnect', ['2012-10-25']);
	Object.defineProperty(apiLoader.services['directconnect'], '2012-10-25', {
	  get: function get() {
	    var model = __webpack_require__(304);
	    model.paginators = __webpack_require__(305).pagination;
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.DirectConnect;


/***/ },
/* 304 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2012-10-25",
			"endpointPrefix": "directconnect",
			"jsonVersion": "1.1",
			"protocol": "json",
			"serviceFullName": "AWS Direct Connect",
			"signatureVersion": "v4",
			"targetPrefix": "OvertureService"
		},
		"operations": {
			"AllocateConnectionOnInterconnect": {
				"input": {
					"type": "structure",
					"required": [
						"bandwidth",
						"connectionName",
						"ownerAccount",
						"interconnectId",
						"vlan"
					],
					"members": {
						"bandwidth": {},
						"connectionName": {},
						"ownerAccount": {},
						"interconnectId": {},
						"vlan": {
							"type": "integer"
						}
					}
				},
				"output": {
					"shape": "S7"
				}
			},
			"AllocatePrivateVirtualInterface": {
				"input": {
					"type": "structure",
					"required": [
						"connectionId",
						"ownerAccount",
						"newPrivateVirtualInterfaceAllocation"
					],
					"members": {
						"connectionId": {},
						"ownerAccount": {},
						"newPrivateVirtualInterfaceAllocation": {
							"type": "structure",
							"required": [
								"virtualInterfaceName",
								"vlan",
								"asn"
							],
							"members": {
								"virtualInterfaceName": {},
								"vlan": {
									"type": "integer"
								},
								"asn": {
									"type": "integer"
								},
								"authKey": {},
								"amazonAddress": {},
								"customerAddress": {}
							}
						}
					}
				},
				"output": {
					"shape": "Sl"
				}
			},
			"AllocatePublicVirtualInterface": {
				"input": {
					"type": "structure",
					"required": [
						"connectionId",
						"ownerAccount",
						"newPublicVirtualInterfaceAllocation"
					],
					"members": {
						"connectionId": {},
						"ownerAccount": {},
						"newPublicVirtualInterfaceAllocation": {
							"type": "structure",
							"required": [
								"virtualInterfaceName",
								"vlan",
								"asn",
								"amazonAddress",
								"customerAddress",
								"routeFilterPrefixes"
							],
							"members": {
								"virtualInterfaceName": {},
								"vlan": {
									"type": "integer"
								},
								"asn": {
									"type": "integer"
								},
								"authKey": {},
								"amazonAddress": {},
								"customerAddress": {},
								"routeFilterPrefixes": {
									"shape": "Sr"
								}
							}
						}
					}
				},
				"output": {
					"shape": "Sl"
				}
			},
			"ConfirmConnection": {
				"input": {
					"type": "structure",
					"required": [
						"connectionId"
					],
					"members": {
						"connectionId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"connectionState": {}
					}
				}
			},
			"ConfirmPrivateVirtualInterface": {
				"input": {
					"type": "structure",
					"required": [
						"virtualInterfaceId",
						"virtualGatewayId"
					],
					"members": {
						"virtualInterfaceId": {},
						"virtualGatewayId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"virtualInterfaceState": {}
					}
				}
			},
			"ConfirmPublicVirtualInterface": {
				"input": {
					"type": "structure",
					"required": [
						"virtualInterfaceId"
					],
					"members": {
						"virtualInterfaceId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"virtualInterfaceState": {}
					}
				}
			},
			"CreateConnection": {
				"input": {
					"type": "structure",
					"required": [
						"location",
						"bandwidth",
						"connectionName"
					],
					"members": {
						"location": {},
						"bandwidth": {},
						"connectionName": {}
					}
				},
				"output": {
					"shape": "S7"
				}
			},
			"CreateInterconnect": {
				"input": {
					"type": "structure",
					"required": [
						"interconnectName",
						"bandwidth",
						"location"
					],
					"members": {
						"interconnectName": {},
						"bandwidth": {},
						"location": {}
					}
				},
				"output": {
					"shape": "S15"
				}
			},
			"CreatePrivateVirtualInterface": {
				"input": {
					"type": "structure",
					"required": [
						"connectionId",
						"newPrivateVirtualInterface"
					],
					"members": {
						"connectionId": {},
						"newPrivateVirtualInterface": {
							"type": "structure",
							"required": [
								"virtualInterfaceName",
								"vlan",
								"asn",
								"virtualGatewayId"
							],
							"members": {
								"virtualInterfaceName": {},
								"vlan": {
									"type": "integer"
								},
								"asn": {
									"type": "integer"
								},
								"authKey": {},
								"amazonAddress": {},
								"customerAddress": {},
								"virtualGatewayId": {}
							}
						}
					}
				},
				"output": {
					"shape": "Sl"
				}
			},
			"CreatePublicVirtualInterface": {
				"input": {
					"type": "structure",
					"required": [
						"connectionId",
						"newPublicVirtualInterface"
					],
					"members": {
						"connectionId": {},
						"newPublicVirtualInterface": {
							"type": "structure",
							"required": [
								"virtualInterfaceName",
								"vlan",
								"asn",
								"amazonAddress",
								"customerAddress",
								"routeFilterPrefixes"
							],
							"members": {
								"virtualInterfaceName": {},
								"vlan": {
									"type": "integer"
								},
								"asn": {
									"type": "integer"
								},
								"authKey": {},
								"amazonAddress": {},
								"customerAddress": {},
								"routeFilterPrefixes": {
									"shape": "Sr"
								}
							}
						}
					}
				},
				"output": {
					"shape": "Sl"
				}
			},
			"DeleteConnection": {
				"input": {
					"type": "structure",
					"required": [
						"connectionId"
					],
					"members": {
						"connectionId": {}
					}
				},
				"output": {
					"shape": "S7"
				}
			},
			"DeleteInterconnect": {
				"input": {
					"type": "structure",
					"required": [
						"interconnectId"
					],
					"members": {
						"interconnectId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"interconnectState": {}
					}
				}
			},
			"DeleteVirtualInterface": {
				"input": {
					"type": "structure",
					"required": [
						"virtualInterfaceId"
					],
					"members": {
						"virtualInterfaceId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"virtualInterfaceState": {}
					}
				}
			},
			"DescribeConnectionLoa": {
				"input": {
					"type": "structure",
					"required": [
						"connectionId"
					],
					"members": {
						"connectionId": {},
						"providerName": {},
						"loaContentType": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"loa": {
							"shape": "S1k"
						}
					}
				}
			},
			"DescribeConnections": {
				"input": {
					"type": "structure",
					"members": {
						"connectionId": {}
					}
				},
				"output": {
					"shape": "S1n"
				}
			},
			"DescribeConnectionsOnInterconnect": {
				"input": {
					"type": "structure",
					"required": [
						"interconnectId"
					],
					"members": {
						"interconnectId": {}
					}
				},
				"output": {
					"shape": "S1n"
				}
			},
			"DescribeInterconnectLoa": {
				"input": {
					"type": "structure",
					"required": [
						"interconnectId"
					],
					"members": {
						"interconnectId": {},
						"providerName": {},
						"loaContentType": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"loa": {
							"shape": "S1k"
						}
					}
				}
			},
			"DescribeInterconnects": {
				"input": {
					"type": "structure",
					"members": {
						"interconnectId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"interconnects": {
							"type": "list",
							"member": {
								"shape": "S15"
							}
						}
					}
				}
			},
			"DescribeLocations": {
				"output": {
					"type": "structure",
					"members": {
						"locations": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"locationCode": {},
									"locationName": {}
								}
							}
						}
					}
				}
			},
			"DescribeTags": {
				"input": {
					"type": "structure",
					"required": [
						"resourceArns"
					],
					"members": {
						"resourceArns": {
							"type": "list",
							"member": {}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"resourceTags": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"resourceArn": {},
									"tags": {
										"shape": "S25"
									}
								}
							}
						}
					}
				}
			},
			"DescribeVirtualGateways": {
				"output": {
					"type": "structure",
					"members": {
						"virtualGateways": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"virtualGatewayId": {},
									"virtualGatewayState": {}
								}
							}
						}
					}
				}
			},
			"DescribeVirtualInterfaces": {
				"input": {
					"type": "structure",
					"members": {
						"connectionId": {},
						"virtualInterfaceId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"virtualInterfaces": {
							"type": "list",
							"member": {
								"shape": "Sl"
							}
						}
					}
				}
			},
			"TagResource": {
				"input": {
					"type": "structure",
					"required": [
						"resourceArn",
						"tags"
					],
					"members": {
						"resourceArn": {},
						"tags": {
							"shape": "S25"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"UntagResource": {
				"input": {
					"type": "structure",
					"required": [
						"resourceArn",
						"tagKeys"
					],
					"members": {
						"resourceArn": {},
						"tagKeys": {
							"type": "list",
							"member": {}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			}
		},
		"shapes": {
			"S7": {
				"type": "structure",
				"members": {
					"ownerAccount": {},
					"connectionId": {},
					"connectionName": {},
					"connectionState": {},
					"region": {},
					"location": {},
					"bandwidth": {},
					"vlan": {
						"type": "integer"
					},
					"partnerName": {},
					"loaIssueTime": {
						"type": "timestamp"
					}
				}
			},
			"Sl": {
				"type": "structure",
				"members": {
					"ownerAccount": {},
					"virtualInterfaceId": {},
					"location": {},
					"connectionId": {},
					"virtualInterfaceType": {},
					"virtualInterfaceName": {},
					"vlan": {
						"type": "integer"
					},
					"asn": {
						"type": "integer"
					},
					"authKey": {},
					"amazonAddress": {},
					"customerAddress": {},
					"virtualInterfaceState": {},
					"customerRouterConfig": {},
					"virtualGatewayId": {},
					"routeFilterPrefixes": {
						"shape": "Sr"
					}
				}
			},
			"Sr": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"cidr": {}
					}
				}
			},
			"S15": {
				"type": "structure",
				"members": {
					"interconnectId": {},
					"interconnectName": {},
					"interconnectState": {},
					"region": {},
					"location": {},
					"bandwidth": {},
					"loaIssueTime": {
						"type": "timestamp"
					}
				}
			},
			"S1k": {
				"type": "structure",
				"members": {
					"loaContent": {
						"type": "blob"
					},
					"loaContentType": {}
				}
			},
			"S1n": {
				"type": "structure",
				"members": {
					"connections": {
						"type": "list",
						"member": {
							"shape": "S7"
						}
					}
				}
			},
			"S25": {
				"type": "list",
				"member": {
					"type": "structure",
					"required": [
						"key"
					],
					"members": {
						"key": {},
						"value": {}
					}
				}
			}
		}
	};

/***/ },
/* 305 */
/***/ function(module, exports) {

	module.exports = {
		"pagination": {
			"DescribeConnections": {
				"result_key": "connections"
			},
			"DescribeConnectionsOnInterconnect": {
				"result_key": "connections"
			},
			"DescribeInterconnects": {
				"result_key": "interconnects"
			},
			"DescribeLocations": {
				"result_key": "locations"
			},
			"DescribeVirtualGateways": {
				"result_key": "virtualGateways"
			},
			"DescribeVirtualInterfaces": {
				"result_key": "virtualInterfaces"
			}
		}
	};

/***/ },
/* 306 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['directoryservice'] = {};
	AWS.DirectoryService = Service.defineService('directoryservice', ['2015-04-16']);
	Object.defineProperty(apiLoader.services['directoryservice'], '2015-04-16', {
	  get: function get() {
	    var model = __webpack_require__(307);
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.DirectoryService;


/***/ },
/* 307 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2015-04-16",
			"endpointPrefix": "ds",
			"jsonVersion": "1.1",
			"protocol": "json",
			"serviceAbbreviation": "Directory Service",
			"serviceFullName": "AWS Directory Service",
			"signatureVersion": "v4",
			"targetPrefix": "DirectoryService_20150416"
		},
		"operations": {
			"AddIpRoutes": {
				"input": {
					"type": "structure",
					"required": [
						"DirectoryId",
						"IpRoutes"
					],
					"members": {
						"DirectoryId": {},
						"IpRoutes": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"CidrIp": {},
									"Description": {}
								}
							}
						},
						"UpdateSecurityGroupForDirectoryControllers": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"AddTagsToResource": {
				"input": {
					"type": "structure",
					"required": [
						"ResourceId",
						"Tags"
					],
					"members": {
						"ResourceId": {},
						"Tags": {
							"shape": "Sb"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"ConnectDirectory": {
				"input": {
					"type": "structure",
					"required": [
						"Name",
						"Password",
						"Size",
						"ConnectSettings"
					],
					"members": {
						"Name": {},
						"ShortName": {},
						"Password": {
							"shape": "Sj"
						},
						"Description": {},
						"Size": {},
						"ConnectSettings": {
							"type": "structure",
							"required": [
								"VpcId",
								"SubnetIds",
								"CustomerDnsIps",
								"CustomerUserName"
							],
							"members": {
								"VpcId": {},
								"SubnetIds": {
									"shape": "Sn"
								},
								"CustomerDnsIps": {
									"shape": "Sp"
								},
								"CustomerUserName": {}
							}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"DirectoryId": {}
					}
				}
			},
			"CreateAlias": {
				"input": {
					"type": "structure",
					"required": [
						"DirectoryId",
						"Alias"
					],
					"members": {
						"DirectoryId": {},
						"Alias": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"DirectoryId": {},
						"Alias": {}
					}
				}
			},
			"CreateComputer": {
				"input": {
					"type": "structure",
					"required": [
						"DirectoryId",
						"ComputerName",
						"Password"
					],
					"members": {
						"DirectoryId": {},
						"ComputerName": {},
						"Password": {
							"type": "string",
							"sensitive": true
						},
						"OrganizationalUnitDistinguishedName": {},
						"ComputerAttributes": {
							"shape": "S10"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Computer": {
							"type": "structure",
							"members": {
								"ComputerId": {},
								"ComputerName": {},
								"ComputerAttributes": {
									"shape": "S10"
								}
							}
						}
					}
				}
			},
			"CreateConditionalForwarder": {
				"input": {
					"type": "structure",
					"required": [
						"DirectoryId",
						"RemoteDomainName",
						"DnsIpAddrs"
					],
					"members": {
						"DirectoryId": {},
						"RemoteDomainName": {},
						"DnsIpAddrs": {
							"shape": "Sp"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"CreateDirectory": {
				"input": {
					"type": "structure",
					"required": [
						"Name",
						"Password",
						"Size"
					],
					"members": {
						"Name": {},
						"ShortName": {},
						"Password": {
							"shape": "S1b"
						},
						"Description": {},
						"Size": {},
						"VpcSettings": {
							"shape": "S1c"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"DirectoryId": {}
					}
				}
			},
			"CreateMicrosoftAD": {
				"input": {
					"type": "structure",
					"required": [
						"Name",
						"Password",
						"VpcSettings"
					],
					"members": {
						"Name": {},
						"ShortName": {},
						"Password": {
							"shape": "S1b"
						},
						"Description": {},
						"VpcSettings": {
							"shape": "S1c"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"DirectoryId": {}
					}
				}
			},
			"CreateSnapshot": {
				"input": {
					"type": "structure",
					"required": [
						"DirectoryId"
					],
					"members": {
						"DirectoryId": {},
						"Name": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"SnapshotId": {}
					}
				}
			},
			"CreateTrust": {
				"input": {
					"type": "structure",
					"required": [
						"DirectoryId",
						"RemoteDomainName",
						"TrustPassword",
						"TrustDirection"
					],
					"members": {
						"DirectoryId": {},
						"RemoteDomainName": {},
						"TrustPassword": {
							"type": "string",
							"sensitive": true
						},
						"TrustDirection": {},
						"TrustType": {},
						"ConditionalForwarderIpAddrs": {
							"shape": "Sp"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"TrustId": {}
					}
				}
			},
			"DeleteConditionalForwarder": {
				"input": {
					"type": "structure",
					"required": [
						"DirectoryId",
						"RemoteDomainName"
					],
					"members": {
						"DirectoryId": {},
						"RemoteDomainName": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"DeleteDirectory": {
				"input": {
					"type": "structure",
					"required": [
						"DirectoryId"
					],
					"members": {
						"DirectoryId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"DirectoryId": {}
					}
				}
			},
			"DeleteSnapshot": {
				"input": {
					"type": "structure",
					"required": [
						"SnapshotId"
					],
					"members": {
						"SnapshotId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"SnapshotId": {}
					}
				}
			},
			"DeleteTrust": {
				"input": {
					"type": "structure",
					"required": [
						"TrustId"
					],
					"members": {
						"TrustId": {},
						"DeleteAssociatedConditionalForwarder": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"TrustId": {}
					}
				}
			},
			"DeregisterEventTopic": {
				"input": {
					"type": "structure",
					"required": [
						"DirectoryId",
						"TopicName"
					],
					"members": {
						"DirectoryId": {},
						"TopicName": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"DescribeConditionalForwarders": {
				"input": {
					"type": "structure",
					"required": [
						"DirectoryId"
					],
					"members": {
						"DirectoryId": {},
						"RemoteDomainNames": {
							"type": "list",
							"member": {}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ConditionalForwarders": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"RemoteDomainName": {},
									"DnsIpAddrs": {
										"shape": "Sp"
									},
									"ReplicationScope": {}
								}
							}
						}
					}
				}
			},
			"DescribeDirectories": {
				"input": {
					"type": "structure",
					"members": {
						"DirectoryIds": {
							"type": "list",
							"member": {}
						},
						"NextToken": {},
						"Limit": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"DirectoryDescriptions": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"DirectoryId": {},
									"Name": {},
									"ShortName": {},
									"Size": {},
									"Alias": {},
									"AccessUrl": {},
									"Description": {},
									"DnsIpAddrs": {
										"shape": "Sp"
									},
									"Stage": {},
									"LaunchTime": {
										"type": "timestamp"
									},
									"StageLastUpdatedDateTime": {
										"type": "timestamp"
									},
									"Type": {},
									"VpcSettings": {
										"type": "structure",
										"members": {
											"VpcId": {},
											"SubnetIds": {
												"shape": "Sn"
											},
											"SecurityGroupId": {},
											"AvailabilityZones": {
												"shape": "S2m"
											}
										}
									},
									"ConnectSettings": {
										"type": "structure",
										"members": {
											"VpcId": {},
											"SubnetIds": {
												"shape": "Sn"
											},
											"CustomerUserName": {},
											"SecurityGroupId": {},
											"AvailabilityZones": {
												"shape": "S2m"
											},
											"ConnectIps": {
												"type": "list",
												"member": {}
											}
										}
									},
									"RadiusSettings": {
										"shape": "S2q"
									},
									"RadiusStatus": {},
									"StageReason": {},
									"SsoEnabled": {
										"type": "boolean"
									}
								}
							}
						},
						"NextToken": {}
					}
				}
			},
			"DescribeEventTopics": {
				"input": {
					"type": "structure",
					"members": {
						"DirectoryId": {},
						"TopicNames": {
							"type": "list",
							"member": {}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"EventTopics": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"DirectoryId": {},
									"TopicName": {},
									"TopicArn": {},
									"CreatedDateTime": {
										"type": "timestamp"
									},
									"Status": {}
								}
							}
						}
					}
				}
			},
			"DescribeSnapshots": {
				"input": {
					"type": "structure",
					"members": {
						"DirectoryId": {},
						"SnapshotIds": {
							"type": "list",
							"member": {}
						},
						"NextToken": {},
						"Limit": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Snapshots": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"DirectoryId": {},
									"SnapshotId": {},
									"Type": {},
									"Name": {},
									"Status": {},
									"StartTime": {
										"type": "timestamp"
									}
								}
							}
						},
						"NextToken": {}
					}
				}
			},
			"DescribeTrusts": {
				"input": {
					"type": "structure",
					"members": {
						"DirectoryId": {},
						"TrustIds": {
							"type": "list",
							"member": {}
						},
						"NextToken": {},
						"Limit": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Trusts": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"DirectoryId": {},
									"TrustId": {},
									"RemoteDomainName": {},
									"TrustType": {},
									"TrustDirection": {},
									"TrustState": {},
									"CreatedDateTime": {
										"type": "timestamp"
									},
									"LastUpdatedDateTime": {
										"type": "timestamp"
									},
									"StateLastUpdatedDateTime": {
										"type": "timestamp"
									},
									"TrustStateReason": {}
								}
							}
						},
						"NextToken": {}
					}
				}
			},
			"DisableRadius": {
				"input": {
					"type": "structure",
					"required": [
						"DirectoryId"
					],
					"members": {
						"DirectoryId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"DisableSso": {
				"input": {
					"type": "structure",
					"required": [
						"DirectoryId"
					],
					"members": {
						"DirectoryId": {},
						"UserName": {},
						"Password": {
							"shape": "Sj"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"EnableRadius": {
				"input": {
					"type": "structure",
					"required": [
						"DirectoryId",
						"RadiusSettings"
					],
					"members": {
						"DirectoryId": {},
						"RadiusSettings": {
							"shape": "S2q"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"EnableSso": {
				"input": {
					"type": "structure",
					"required": [
						"DirectoryId"
					],
					"members": {
						"DirectoryId": {},
						"UserName": {},
						"Password": {
							"shape": "Sj"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"GetDirectoryLimits": {
				"input": {
					"type": "structure",
					"members": {}
				},
				"output": {
					"type": "structure",
					"members": {
						"DirectoryLimits": {
							"type": "structure",
							"members": {
								"CloudOnlyDirectoriesLimit": {
									"type": "integer"
								},
								"CloudOnlyDirectoriesCurrentCount": {
									"type": "integer"
								},
								"CloudOnlyDirectoriesLimitReached": {
									"type": "boolean"
								},
								"CloudOnlyMicrosoftADLimit": {
									"type": "integer"
								},
								"CloudOnlyMicrosoftADCurrentCount": {
									"type": "integer"
								},
								"CloudOnlyMicrosoftADLimitReached": {
									"type": "boolean"
								},
								"ConnectedDirectoriesLimit": {
									"type": "integer"
								},
								"ConnectedDirectoriesCurrentCount": {
									"type": "integer"
								},
								"ConnectedDirectoriesLimitReached": {
									"type": "boolean"
								}
							}
						}
					}
				}
			},
			"GetSnapshotLimits": {
				"input": {
					"type": "structure",
					"required": [
						"DirectoryId"
					],
					"members": {
						"DirectoryId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"SnapshotLimits": {
							"type": "structure",
							"members": {
								"ManualSnapshotsLimit": {
									"type": "integer"
								},
								"ManualSnapshotsCurrentCount": {
									"type": "integer"
								},
								"ManualSnapshotsLimitReached": {
									"type": "boolean"
								}
							}
						}
					}
				}
			},
			"ListIpRoutes": {
				"input": {
					"type": "structure",
					"required": [
						"DirectoryId"
					],
					"members": {
						"DirectoryId": {},
						"NextToken": {},
						"Limit": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"IpRoutesInfo": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"DirectoryId": {},
									"CidrIp": {},
									"IpRouteStatusMsg": {},
									"AddedDateTime": {
										"type": "timestamp"
									},
									"IpRouteStatusReason": {},
									"Description": {}
								}
							}
						},
						"NextToken": {}
					}
				}
			},
			"ListTagsForResource": {
				"input": {
					"type": "structure",
					"required": [
						"ResourceId"
					],
					"members": {
						"ResourceId": {},
						"NextToken": {},
						"Limit": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Tags": {
							"shape": "Sb"
						},
						"NextToken": {}
					}
				}
			},
			"RegisterEventTopic": {
				"input": {
					"type": "structure",
					"required": [
						"DirectoryId",
						"TopicName"
					],
					"members": {
						"DirectoryId": {},
						"TopicName": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"RemoveIpRoutes": {
				"input": {
					"type": "structure",
					"required": [
						"DirectoryId",
						"CidrIps"
					],
					"members": {
						"DirectoryId": {},
						"CidrIps": {
							"type": "list",
							"member": {}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"RemoveTagsFromResource": {
				"input": {
					"type": "structure",
					"required": [
						"ResourceId",
						"TagKeys"
					],
					"members": {
						"ResourceId": {},
						"TagKeys": {
							"type": "list",
							"member": {}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"RestoreFromSnapshot": {
				"input": {
					"type": "structure",
					"required": [
						"SnapshotId"
					],
					"members": {
						"SnapshotId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"UpdateConditionalForwarder": {
				"input": {
					"type": "structure",
					"required": [
						"DirectoryId",
						"RemoteDomainName",
						"DnsIpAddrs"
					],
					"members": {
						"DirectoryId": {},
						"RemoteDomainName": {},
						"DnsIpAddrs": {
							"shape": "Sp"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"UpdateRadius": {
				"input": {
					"type": "structure",
					"required": [
						"DirectoryId",
						"RadiusSettings"
					],
					"members": {
						"DirectoryId": {},
						"RadiusSettings": {
							"shape": "S2q"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"VerifyTrust": {
				"input": {
					"type": "structure",
					"required": [
						"TrustId"
					],
					"members": {
						"TrustId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"TrustId": {}
					}
				}
			}
		},
		"shapes": {
			"Sb": {
				"type": "list",
				"member": {
					"type": "structure",
					"required": [
						"Key",
						"Value"
					],
					"members": {
						"Key": {},
						"Value": {}
					}
				}
			},
			"Sj": {
				"type": "string",
				"sensitive": true
			},
			"Sn": {
				"type": "list",
				"member": {}
			},
			"Sp": {
				"type": "list",
				"member": {}
			},
			"S10": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"Name": {},
						"Value": {}
					}
				}
			},
			"S1b": {
				"type": "string",
				"sensitive": true
			},
			"S1c": {
				"type": "structure",
				"required": [
					"VpcId",
					"SubnetIds"
				],
				"members": {
					"VpcId": {},
					"SubnetIds": {
						"shape": "Sn"
					}
				}
			},
			"S2m": {
				"type": "list",
				"member": {}
			},
			"S2q": {
				"type": "structure",
				"members": {
					"RadiusServers": {
						"type": "list",
						"member": {}
					},
					"RadiusPort": {
						"type": "integer"
					},
					"RadiusTimeout": {
						"type": "integer"
					},
					"RadiusRetries": {
						"type": "integer"
					},
					"SharedSecret": {
						"type": "string",
						"sensitive": true
					},
					"AuthenticationProtocol": {},
					"DisplayLabel": {},
					"UseSameUsername": {
						"type": "boolean"
					}
				}
			}
		}
	};

/***/ },
/* 308 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['discovery'] = {};
	AWS.Discovery = Service.defineService('discovery', ['2015-11-01']);
	Object.defineProperty(apiLoader.services['discovery'], '2015-11-01', {
	  get: function get() {
	    var model = __webpack_require__(309);
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.Discovery;


/***/ },
/* 309 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2015-11-01",
			"endpointPrefix": "discovery",
			"jsonVersion": "1.1",
			"protocol": "json",
			"serviceFullName": "AWS Application Discovery Service",
			"signatureVersion": "v4",
			"targetPrefix": "AWSPoseidonService_V2015_11_01"
		},
		"operations": {
			"CreateTags": {
				"input": {
					"type": "structure",
					"required": [
						"configurationIds",
						"tags"
					],
					"members": {
						"configurationIds": {
							"shape": "S2"
						},
						"tags": {
							"shape": "S4"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"DeleteTags": {
				"input": {
					"type": "structure",
					"required": [
						"configurationIds"
					],
					"members": {
						"configurationIds": {
							"shape": "S2"
						},
						"tags": {
							"shape": "S4"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"DescribeAgents": {
				"input": {
					"type": "structure",
					"members": {
						"agentIds": {
							"shape": "Sc"
						},
						"maxResults": {
							"type": "integer"
						},
						"nextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"agentsInfo": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"agentId": {},
									"hostName": {},
									"agentNetworkInfoList": {
										"type": "list",
										"member": {
											"type": "structure",
											"members": {
												"ipAddress": {},
												"macAddress": {}
											}
										}
									},
									"connectorId": {},
									"version": {},
									"health": {}
								}
							}
						},
						"nextToken": {}
					}
				}
			},
			"DescribeConfigurations": {
				"input": {
					"type": "structure",
					"required": [
						"configurationIds"
					],
					"members": {
						"configurationIds": {
							"shape": "S2"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"configurations": {
							"type": "list",
							"member": {
								"type": "map",
								"key": {},
								"value": {}
							}
						}
					}
				}
			},
			"DescribeExportConfigurations": {
				"input": {
					"type": "structure",
					"members": {
						"exportIds": {
							"type": "list",
							"member": {}
						},
						"maxResults": {
							"type": "integer"
						},
						"nextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"exportsInfo": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"exportId",
									"exportStatus",
									"statusMessage",
									"exportRequestTime"
								],
								"members": {
									"exportId": {},
									"exportStatus": {},
									"statusMessage": {},
									"configurationsDownloadUrl": {},
									"exportRequestTime": {
										"type": "timestamp"
									}
								}
							}
						},
						"nextToken": {}
					}
				}
			},
			"DescribeTags": {
				"input": {
					"type": "structure",
					"members": {
						"filters": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"name",
									"values"
								],
								"members": {
									"name": {},
									"values": {
										"shape": "S15"
									}
								}
							}
						},
						"maxResults": {
							"type": "integer"
						},
						"nextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"tags": {
							"type": "list",
							"member": {
								"locationName": "item",
								"type": "structure",
								"members": {
									"configurationType": {},
									"configurationId": {},
									"key": {},
									"value": {},
									"timeOfCreation": {
										"type": "timestamp"
									}
								}
							}
						},
						"nextToken": {}
					}
				}
			},
			"ExportConfigurations": {
				"output": {
					"type": "structure",
					"members": {
						"exportId": {}
					}
				}
			},
			"ListConfigurations": {
				"input": {
					"type": "structure",
					"required": [
						"configurationType"
					],
					"members": {
						"configurationType": {},
						"filters": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"name",
									"values",
									"condition"
								],
								"members": {
									"name": {},
									"values": {
										"shape": "S15"
									},
									"condition": {}
								}
							}
						},
						"maxResults": {
							"type": "integer"
						},
						"nextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"configurations": {
							"type": "list",
							"member": {
								"type": "map",
								"key": {},
								"value": {}
							}
						},
						"nextToken": {}
					}
				}
			},
			"StartDataCollectionByAgentIds": {
				"input": {
					"type": "structure",
					"required": [
						"agentIds"
					],
					"members": {
						"agentIds": {
							"shape": "Sc"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"agentsConfigurationStatus": {
							"shape": "S1m"
						}
					}
				}
			},
			"StopDataCollectionByAgentIds": {
				"input": {
					"type": "structure",
					"required": [
						"agentIds"
					],
					"members": {
						"agentIds": {
							"shape": "Sc"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"agentsConfigurationStatus": {
							"shape": "S1m"
						}
					}
				}
			}
		},
		"shapes": {
			"S2": {
				"type": "list",
				"member": {}
			},
			"S4": {
				"type": "list",
				"member": {
					"locationName": "item",
					"type": "structure",
					"required": [
						"key",
						"value"
					],
					"members": {
						"key": {},
						"value": {}
					}
				}
			},
			"Sc": {
				"type": "list",
				"member": {}
			},
			"S15": {
				"type": "list",
				"member": {
					"locationName": "item"
				}
			},
			"S1m": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"agentId": {},
						"operationSucceeded": {
							"type": "boolean"
						},
						"description": {}
					}
				}
			}
		}
	};

/***/ },
/* 310 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['dms'] = {};
	AWS.DMS = Service.defineService('dms', ['2016-01-01']);
	Object.defineProperty(apiLoader.services['dms'], '2016-01-01', {
	  get: function get() {
	    var model = __webpack_require__(311);
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.DMS;


/***/ },
/* 311 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2016-01-01",
			"endpointPrefix": "dms",
			"jsonVersion": "1.1",
			"protocol": "json",
			"serviceFullName": "AWS Database Migration Service",
			"signatureVersion": "v4",
			"targetPrefix": "AmazonDMSv20160101"
		},
		"operations": {
			"AddTagsToResource": {
				"input": {
					"type": "structure",
					"required": [
						"ResourceArn",
						"Tags"
					],
					"members": {
						"ResourceArn": {},
						"Tags": {
							"shape": "S3"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"CreateEndpoint": {
				"input": {
					"type": "structure",
					"required": [
						"EndpointIdentifier",
						"EndpointType",
						"EngineName",
						"Username",
						"Password",
						"ServerName",
						"Port"
					],
					"members": {
						"EndpointIdentifier": {},
						"EndpointType": {},
						"EngineName": {},
						"Username": {},
						"Password": {
							"shape": "S8"
						},
						"ServerName": {},
						"Port": {
							"type": "integer"
						},
						"DatabaseName": {},
						"ExtraConnectionAttributes": {},
						"KmsKeyId": {},
						"Tags": {
							"shape": "S3"
						},
						"CertificateArn": {},
						"SslMode": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Endpoint": {
							"shape": "Sc"
						}
					}
				}
			},
			"CreateReplicationInstance": {
				"input": {
					"type": "structure",
					"required": [
						"ReplicationInstanceIdentifier",
						"ReplicationInstanceClass"
					],
					"members": {
						"ReplicationInstanceIdentifier": {},
						"AllocatedStorage": {
							"type": "integer"
						},
						"ReplicationInstanceClass": {},
						"VpcSecurityGroupIds": {
							"shape": "Se"
						},
						"AvailabilityZone": {},
						"ReplicationSubnetGroupIdentifier": {},
						"PreferredMaintenanceWindow": {},
						"MultiAZ": {
							"type": "boolean"
						},
						"EngineVersion": {},
						"AutoMinorVersionUpgrade": {
							"type": "boolean"
						},
						"Tags": {
							"shape": "S3"
						},
						"KmsKeyId": {},
						"PubliclyAccessible": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ReplicationInstance": {
							"shape": "Sh"
						}
					}
				}
			},
			"CreateReplicationSubnetGroup": {
				"input": {
					"type": "structure",
					"required": [
						"ReplicationSubnetGroupIdentifier",
						"ReplicationSubnetGroupDescription",
						"SubnetIds"
					],
					"members": {
						"ReplicationSubnetGroupIdentifier": {},
						"ReplicationSubnetGroupDescription": {},
						"SubnetIds": {
							"shape": "Sv"
						},
						"Tags": {
							"shape": "S3"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ReplicationSubnetGroup": {
							"shape": "Sm"
						}
					}
				}
			},
			"CreateReplicationTask": {
				"input": {
					"type": "structure",
					"required": [
						"ReplicationTaskIdentifier",
						"SourceEndpointArn",
						"TargetEndpointArn",
						"ReplicationInstanceArn",
						"MigrationType",
						"TableMappings"
					],
					"members": {
						"ReplicationTaskIdentifier": {},
						"SourceEndpointArn": {},
						"TargetEndpointArn": {},
						"ReplicationInstanceArn": {},
						"MigrationType": {},
						"TableMappings": {},
						"ReplicationTaskSettings": {},
						"CdcStartTime": {
							"type": "timestamp"
						},
						"Tags": {
							"shape": "S3"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ReplicationTask": {
							"shape": "S10"
						}
					}
				}
			},
			"DeleteCertificate": {
				"input": {
					"type": "structure",
					"required": [
						"CertificateArn"
					],
					"members": {
						"CertificateArn": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Certificate": {
							"shape": "S15"
						}
					}
				}
			},
			"DeleteEndpoint": {
				"input": {
					"type": "structure",
					"required": [
						"EndpointArn"
					],
					"members": {
						"EndpointArn": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Endpoint": {
							"shape": "Sc"
						}
					}
				}
			},
			"DeleteReplicationInstance": {
				"input": {
					"type": "structure",
					"required": [
						"ReplicationInstanceArn"
					],
					"members": {
						"ReplicationInstanceArn": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ReplicationInstance": {
							"shape": "Sh"
						}
					}
				}
			},
			"DeleteReplicationSubnetGroup": {
				"input": {
					"type": "structure",
					"required": [
						"ReplicationSubnetGroupIdentifier"
					],
					"members": {
						"ReplicationSubnetGroupIdentifier": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"DeleteReplicationTask": {
				"input": {
					"type": "structure",
					"required": [
						"ReplicationTaskArn"
					],
					"members": {
						"ReplicationTaskArn": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ReplicationTask": {
							"shape": "S10"
						}
					}
				}
			},
			"DescribeAccountAttributes": {
				"input": {
					"type": "structure",
					"members": {}
				},
				"output": {
					"type": "structure",
					"members": {
						"AccountQuotas": {
							"type": "list",
							"member": {
								"locationName": "AccountQuota",
								"type": "structure",
								"members": {
									"AccountQuotaName": {},
									"Used": {
										"type": "long"
									},
									"Max": {
										"type": "long"
									}
								}
							}
						}
					}
				}
			},
			"DescribeCertificates": {
				"input": {
					"type": "structure",
					"members": {
						"Filters": {
							"shape": "S1j"
						},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Marker": {},
						"Certificates": {
							"type": "list",
							"member": {
								"shape": "S15",
								"locationName": "Certificate"
							}
						}
					}
				}
			},
			"DescribeConnections": {
				"input": {
					"type": "structure",
					"members": {
						"Filters": {
							"shape": "S1j"
						},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Marker": {},
						"Connections": {
							"type": "list",
							"member": {
								"shape": "S1r",
								"locationName": "Connection"
							}
						}
					}
				}
			},
			"DescribeEndpointTypes": {
				"input": {
					"type": "structure",
					"members": {
						"Filters": {
							"shape": "S1j"
						},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Marker": {},
						"SupportedEndpointTypes": {
							"type": "list",
							"member": {
								"locationName": "SupportedEndpointType",
								"type": "structure",
								"members": {
									"EngineName": {},
									"SupportsCDC": {
										"type": "boolean"
									},
									"EndpointType": {}
								}
							}
						}
					}
				}
			},
			"DescribeEndpoints": {
				"input": {
					"type": "structure",
					"members": {
						"Filters": {
							"shape": "S1j"
						},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Marker": {},
						"Endpoints": {
							"type": "list",
							"member": {
								"shape": "Sc",
								"locationName": "Endpoint"
							}
						}
					}
				}
			},
			"DescribeOrderableReplicationInstances": {
				"input": {
					"type": "structure",
					"members": {
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"OrderableReplicationInstances": {
							"type": "list",
							"member": {
								"locationName": "OrderableReplicationInstance",
								"type": "structure",
								"members": {
									"EngineVersion": {},
									"ReplicationInstanceClass": {},
									"StorageType": {},
									"MinAllocatedStorage": {
										"type": "integer"
									},
									"MaxAllocatedStorage": {
										"type": "integer"
									},
									"DefaultAllocatedStorage": {
										"type": "integer"
									},
									"IncludedAllocatedStorage": {
										"type": "integer"
									}
								}
							}
						},
						"Marker": {}
					}
				}
			},
			"DescribeRefreshSchemasStatus": {
				"input": {
					"type": "structure",
					"required": [
						"EndpointArn"
					],
					"members": {
						"EndpointArn": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"RefreshSchemasStatus": {
							"shape": "S25"
						}
					}
				}
			},
			"DescribeReplicationInstances": {
				"input": {
					"type": "structure",
					"members": {
						"Filters": {
							"shape": "S1j"
						},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Marker": {},
						"ReplicationInstances": {
							"type": "list",
							"member": {
								"shape": "Sh",
								"locationName": "ReplicationInstance"
							}
						}
					}
				}
			},
			"DescribeReplicationSubnetGroups": {
				"input": {
					"type": "structure",
					"members": {
						"Filters": {
							"shape": "S1j"
						},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Marker": {},
						"ReplicationSubnetGroups": {
							"type": "list",
							"member": {
								"shape": "Sm",
								"locationName": "ReplicationSubnetGroup"
							}
						}
					}
				}
			},
			"DescribeReplicationTasks": {
				"input": {
					"type": "structure",
					"members": {
						"Filters": {
							"shape": "S1j"
						},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Marker": {},
						"ReplicationTasks": {
							"type": "list",
							"member": {
								"shape": "S10",
								"locationName": "ReplicationTask"
							}
						}
					}
				}
			},
			"DescribeSchemas": {
				"input": {
					"type": "structure",
					"required": [
						"EndpointArn"
					],
					"members": {
						"EndpointArn": {},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Marker": {},
						"Schemas": {
							"type": "list",
							"member": {}
						}
					}
				}
			},
			"DescribeTableStatistics": {
				"input": {
					"type": "structure",
					"required": [
						"ReplicationTaskArn"
					],
					"members": {
						"ReplicationTaskArn": {},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ReplicationTaskArn": {},
						"TableStatistics": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"SchemaName": {},
									"TableName": {},
									"Inserts": {
										"type": "long"
									},
									"Deletes": {
										"type": "long"
									},
									"Updates": {
										"type": "long"
									},
									"Ddls": {
										"type": "long"
									},
									"FullLoadRows": {
										"type": "long"
									},
									"LastUpdateTime": {
										"type": "timestamp"
									},
									"TableState": {}
								}
							}
						},
						"Marker": {}
					}
				}
			},
			"ImportCertificate": {
				"input": {
					"type": "structure",
					"required": [
						"CertificateIdentifier"
					],
					"members": {
						"CertificateIdentifier": {},
						"CertificatePem": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Certificate": {
							"shape": "S15"
						}
					}
				}
			},
			"ListTagsForResource": {
				"input": {
					"type": "structure",
					"required": [
						"ResourceArn"
					],
					"members": {
						"ResourceArn": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"TagList": {
							"shape": "S3"
						}
					}
				}
			},
			"ModifyEndpoint": {
				"input": {
					"type": "structure",
					"required": [
						"EndpointArn"
					],
					"members": {
						"EndpointArn": {},
						"EndpointIdentifier": {},
						"EndpointType": {},
						"EngineName": {},
						"Username": {},
						"Password": {
							"shape": "S8"
						},
						"ServerName": {},
						"Port": {
							"type": "integer"
						},
						"DatabaseName": {},
						"ExtraConnectionAttributes": {},
						"CertificateArn": {},
						"SslMode": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Endpoint": {
							"shape": "Sc"
						}
					}
				}
			},
			"ModifyReplicationInstance": {
				"input": {
					"type": "structure",
					"required": [
						"ReplicationInstanceArn"
					],
					"members": {
						"ReplicationInstanceArn": {},
						"AllocatedStorage": {
							"type": "integer"
						},
						"ApplyImmediately": {
							"type": "boolean"
						},
						"ReplicationInstanceClass": {},
						"VpcSecurityGroupIds": {
							"shape": "Se"
						},
						"PreferredMaintenanceWindow": {},
						"MultiAZ": {
							"type": "boolean"
						},
						"EngineVersion": {},
						"AllowMajorVersionUpgrade": {
							"type": "boolean"
						},
						"AutoMinorVersionUpgrade": {
							"type": "boolean"
						},
						"ReplicationInstanceIdentifier": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ReplicationInstance": {
							"shape": "Sh"
						}
					}
				}
			},
			"ModifyReplicationSubnetGroup": {
				"input": {
					"type": "structure",
					"required": [
						"ReplicationSubnetGroupIdentifier",
						"SubnetIds"
					],
					"members": {
						"ReplicationSubnetGroupIdentifier": {},
						"ReplicationSubnetGroupDescription": {},
						"SubnetIds": {
							"shape": "Sv"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ReplicationSubnetGroup": {
							"shape": "Sm"
						}
					}
				}
			},
			"RefreshSchemas": {
				"input": {
					"type": "structure",
					"required": [
						"EndpointArn",
						"ReplicationInstanceArn"
					],
					"members": {
						"EndpointArn": {},
						"ReplicationInstanceArn": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"RefreshSchemasStatus": {
							"shape": "S25"
						}
					}
				}
			},
			"RemoveTagsFromResource": {
				"input": {
					"type": "structure",
					"required": [
						"ResourceArn",
						"TagKeys"
					],
					"members": {
						"ResourceArn": {},
						"TagKeys": {
							"type": "list",
							"member": {}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"StartReplicationTask": {
				"input": {
					"type": "structure",
					"required": [
						"ReplicationTaskArn",
						"StartReplicationTaskType"
					],
					"members": {
						"ReplicationTaskArn": {},
						"StartReplicationTaskType": {},
						"CdcStartTime": {
							"type": "timestamp"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ReplicationTask": {
							"shape": "S10"
						}
					}
				}
			},
			"StopReplicationTask": {
				"input": {
					"type": "structure",
					"required": [
						"ReplicationTaskArn"
					],
					"members": {
						"ReplicationTaskArn": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ReplicationTask": {
							"shape": "S10"
						}
					}
				}
			},
			"TestConnection": {
				"input": {
					"type": "structure",
					"required": [
						"ReplicationInstanceArn",
						"EndpointArn"
					],
					"members": {
						"ReplicationInstanceArn": {},
						"EndpointArn": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Connection": {
							"shape": "S1r"
						}
					}
				}
			}
		},
		"shapes": {
			"S3": {
				"type": "list",
				"member": {
					"locationName": "Tag",
					"type": "structure",
					"members": {
						"Key": {},
						"Value": {}
					}
				}
			},
			"S8": {
				"type": "string",
				"sensitive": true
			},
			"Sc": {
				"type": "structure",
				"members": {
					"EndpointIdentifier": {},
					"EndpointType": {},
					"EngineName": {},
					"Username": {},
					"ServerName": {},
					"Port": {
						"type": "integer"
					},
					"DatabaseName": {},
					"ExtraConnectionAttributes": {},
					"Status": {},
					"KmsKeyId": {},
					"EndpointArn": {},
					"CertificateArn": {},
					"SslMode": {}
				}
			},
			"Se": {
				"type": "list",
				"member": {
					"locationName": "VpcSecurityGroupId"
				}
			},
			"Sh": {
				"type": "structure",
				"members": {
					"ReplicationInstanceIdentifier": {},
					"ReplicationInstanceClass": {},
					"ReplicationInstanceStatus": {},
					"AllocatedStorage": {
						"type": "integer"
					},
					"InstanceCreateTime": {
						"type": "timestamp"
					},
					"VpcSecurityGroups": {
						"type": "list",
						"member": {
							"locationName": "VpcSecurityGroupMembership",
							"type": "structure",
							"members": {
								"VpcSecurityGroupId": {},
								"Status": {}
							}
						}
					},
					"AvailabilityZone": {},
					"ReplicationSubnetGroup": {
						"shape": "Sm"
					},
					"PreferredMaintenanceWindow": {},
					"PendingModifiedValues": {
						"type": "structure",
						"members": {
							"ReplicationInstanceClass": {},
							"AllocatedStorage": {
								"type": "integer"
							},
							"MultiAZ": {
								"type": "boolean"
							},
							"EngineVersion": {}
						}
					},
					"MultiAZ": {
						"type": "boolean"
					},
					"EngineVersion": {},
					"AutoMinorVersionUpgrade": {
						"type": "boolean"
					},
					"KmsKeyId": {},
					"ReplicationInstanceArn": {},
					"ReplicationInstancePublicIpAddress": {
						"deprecated": true
					},
					"ReplicationInstancePrivateIpAddress": {
						"deprecated": true
					},
					"ReplicationInstancePublicIpAddresses": {
						"type": "list",
						"member": {}
					},
					"ReplicationInstancePrivateIpAddresses": {
						"type": "list",
						"member": {}
					},
					"PubliclyAccessible": {
						"type": "boolean"
					}
				}
			},
			"Sm": {
				"type": "structure",
				"members": {
					"ReplicationSubnetGroupIdentifier": {},
					"ReplicationSubnetGroupDescription": {},
					"VpcId": {},
					"SubnetGroupStatus": {},
					"Subnets": {
						"type": "list",
						"member": {
							"locationName": "Subnet",
							"type": "structure",
							"members": {
								"SubnetIdentifier": {},
								"SubnetAvailabilityZone": {
									"type": "structure",
									"members": {
										"Name": {}
									}
								},
								"SubnetStatus": {}
							}
						}
					}
				}
			},
			"Sv": {
				"type": "list",
				"member": {
					"locationName": "SubnetIdentifier"
				}
			},
			"S10": {
				"type": "structure",
				"members": {
					"ReplicationTaskIdentifier": {},
					"SourceEndpointArn": {},
					"TargetEndpointArn": {},
					"ReplicationInstanceArn": {},
					"MigrationType": {},
					"TableMappings": {},
					"ReplicationTaskSettings": {},
					"Status": {},
					"LastFailureMessage": {},
					"ReplicationTaskCreationDate": {
						"type": "timestamp"
					},
					"ReplicationTaskStartDate": {
						"type": "timestamp"
					},
					"ReplicationTaskArn": {},
					"ReplicationTaskStats": {
						"type": "structure",
						"members": {
							"FullLoadProgressPercent": {
								"type": "integer"
							},
							"ElapsedTimeMillis": {
								"type": "long"
							},
							"TablesLoaded": {
								"type": "integer"
							},
							"TablesLoading": {
								"type": "integer"
							},
							"TablesQueued": {
								"type": "integer"
							},
							"TablesErrored": {
								"type": "integer"
							}
						}
					}
				}
			},
			"S15": {
				"type": "structure",
				"members": {
					"CertificateIdentifier": {},
					"CertificateCreationDate": {
						"type": "timestamp"
					},
					"CertificatePem": {},
					"CertificateArn": {},
					"CertificateOwner": {},
					"ValidFromDate": {
						"type": "timestamp"
					},
					"ValidToDate": {
						"type": "timestamp"
					},
					"SigningAlgorithm": {},
					"KeyLength": {
						"type": "integer"
					}
				}
			},
			"S1j": {
				"type": "list",
				"member": {
					"locationName": "Filter",
					"type": "structure",
					"required": [
						"Name",
						"Values"
					],
					"members": {
						"Name": {},
						"Values": {
							"type": "list",
							"member": {
								"locationName": "Value"
							}
						}
					}
				}
			},
			"S1r": {
				"type": "structure",
				"members": {
					"ReplicationInstanceArn": {},
					"EndpointArn": {},
					"Status": {},
					"LastFailureMessage": {},
					"EndpointIdentifier": {},
					"ReplicationInstanceIdentifier": {}
				}
			},
			"S25": {
				"type": "structure",
				"members": {
					"EndpointArn": {},
					"ReplicationInstanceArn": {},
					"Status": {},
					"LastRefreshDate": {
						"type": "timestamp"
					},
					"LastFailureMessage": {}
				}
			}
		}
	};

/***/ },
/* 312 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['dynamodb'] = {};
	AWS.DynamoDB = Service.defineService('dynamodb', ['2011-12-05', '2012-08-10']);
	__webpack_require__(313);
	Object.defineProperty(apiLoader.services['dynamodb'], '2011-12-05', {
	  get: function get() {
	    var model = __webpack_require__(319);
	    model.paginators = __webpack_require__(320).pagination;
	    model.waiters = __webpack_require__(321).waiters;
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});
	Object.defineProperty(apiLoader.services['dynamodb'], '2012-08-10', {
	  get: function get() {
	    var model = __webpack_require__(322);
	    model.paginators = __webpack_require__(323).pagination;
	    model.waiters = __webpack_require__(324).waiters;
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.DynamoDB;


/***/ },
/* 313 */
/***/ function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(93);
	__webpack_require__(314);

	AWS.util.update(AWS.DynamoDB.prototype, {
	  /**
	   * @api private
	   */
	  setupRequestListeners: function setupRequestListeners(request) {
	    if (request.service.config.dynamoDbCrc32) {
	      request.removeListener('extractData', AWS.EventListeners.Json.EXTRACT_DATA);
	      request.addListener('extractData', this.checkCrc32);
	      request.addListener('extractData', AWS.EventListeners.Json.EXTRACT_DATA);
	    }
	  },

	  /**
	   * @api private
	   */
	  checkCrc32: function checkCrc32(resp) {
	    if (!resp.httpResponse.streaming && !resp.request.service.crc32IsValid(resp)) {
	      resp.data = null;
	      resp.error = AWS.util.error(new Error(), {
	        code: 'CRC32CheckFailed',
	        message: 'CRC32 integrity check failed',
	        retryable: true
	      });
	      resp.request.haltHandlersOnError();
	      throw (resp.error);
	    }
	  },

	  /**
	   * @api private
	   */
	  crc32IsValid: function crc32IsValid(resp) {
	    var crc = resp.httpResponse.headers['x-amz-crc32'];
	    if (!crc) return true; // no (valid) CRC32 header
	    return parseInt(crc, 10) === AWS.util.crypto.crc32(resp.httpResponse.body);
	  },

	  /**
	   * @api private
	   */
	  defaultRetryCount: 10,

	  /**
	   * @api private
	   */
	  retryDelays: function retryDelays(retryCount) {
	    var delay = retryCount > 0 ? (50 * Math.pow(2, retryCount - 1)) : 0;
	    return delay;
	  }
	});


/***/ },
/* 314 */
/***/ function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(93);
	var Translator = __webpack_require__(315);
	var DynamoDBSet = __webpack_require__(318);

	/**
	 * The document client simplifies working with items in Amazon DynamoDB
	 * by abstracting away the notion of attribute values. This abstraction
	 * annotates native JavaScript types supplied as input parameters, as well
	 * as converts annotated response data to native JavaScript types.
	 *
	 * ## Marshalling Input and Unmarshalling Response Data
	 *
	 * The document client affords developers the use of native JavaScript types
	 * instead of `AttributeValue`s to simplify the JavaScript development
	 * experience with Amazon DynamoDB. JavaScript objects passed in as parameters
	 * are marshalled into `AttributeValue` shapes required by Amazon DynamoDB.
	 * Responses from DynamoDB are unmarshalled into plain JavaScript objects
	 * by the `DocumentClient`. The `DocumentClient`, does not accept
	 * `AttributeValue`s in favor of native JavaScript types.
	 *
	 * |                             JavaScript Type                            | DynamoDB AttributeValue |
	 * |:----------------------------------------------------------------------:|-------------------------|
	 * | String                                                                 | S                       |
	 * | Number                                                                 | N                       |
	 * | Boolean                                                                | BOOL                    |
	 * | null                                                                   | NULL                    |
	 * | Array                                                                  | L                       |
	 * | Object                                                                 | M                       |
	 * | Buffer, File, Blob, ArrayBuffer, DataView, and JavaScript typed arrays | B                       |
	 *
	 * ## Support for Sets
	 *
	 * The `DocumentClient` offers a convenient way to create sets from
	 * JavaScript Arrays. The type of set is inferred from the first element
	 * in the array. DynamoDB supports string, number, and binary sets. To
	 * learn more about supported types see the
	 * [Amazon DynamoDB Data Model Documentation](http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DataModel.html)
	 * For more information see {AWS.DynamoDB.DocumentClient.createSet}
	 *
	 */
	AWS.DynamoDB.DocumentClient = AWS.util.inherit({

	  /**
	   * @api private
	   */
	  operations: {
	    batchGetItem: 'batchGet',
	    batchWriteItem: 'batchWrite',
	    putItem: 'put',
	    getItem: 'get',
	    deleteItem: 'delete',
	    updateItem: 'update',
	    scan: 'scan',
	    query: 'query'
	  },

	  /**
	   * Creates a DynamoDB document client with a set of configuration options.
	   *
	   * @option options params [map] An optional map of parameters to bind to every
	   *   request sent by this service object.
	   * @option options service [AWS.DynamoDB] An optional pre-configured instance
	   *  of the AWS.DynamoDB service object to use for requests. The object may
	   *  bound parameters used by the document client.
	   * @see AWS.DynamoDB.constructor
	   *
	   */
	  constructor: function DocumentClient(options) {
	    var self = this;
	    self.options = options || {};
	    self.configure(self.options);
	  },

	  /**
	   * @api private
	   */
	  configure: function configure(options) {
	    var self = this;
	    self.service = options.service;
	    self.bindServiceObject(options);
	    self.attrValue =
	      self.service.api.operations.putItem.input.members.Item.value.shape;
	  },

	  /**
	   * @api private
	   */
	  bindServiceObject: function bindServiceObject(options) {
	    var self = this;
	    options = options || {};

	    if (!self.service) {
	      self.service = new AWS.DynamoDB(options);
	    } else {
	      var config = AWS.util.copy(self.service.config);
	      self.service = new self.service.constructor.__super__(config);
	      self.service.config.params =
	        AWS.util.merge(self.service.config.params || {}, options.params);
	    }
	  },

	  /**
	   * Returns the attributes of one or more items from one or more tables
	   * by delegating to `AWS.DynamoDB.batchGetItem()`.
	   *
	   * Supply the same parameters as {AWS.DynamoDB.batchGetItem} with
	   * `AttributeValue`s substituted by native JavaScript types.
	   *
	   * @see AWS.DynamoDB.batchGetItem
	   * @example Get items from multiple tables
	   *  var params = {
	   *    RequestItems: {
	   *      'Table-1': {
	   *        Keys: [
	   *          {
	   *             HashKey: 'haskey',
	   *             NumberRangeKey: 1
	   *          }
	   *        ]
	   *      },
	   *      'Table-2': {
	   *        Keys: [
	   *          { foo: 'bar' },
	   *        ]
	   *      }
	   *    }
	   *  };
	   *
	   *  var docClient = new AWS.DynamoDB.DocumentClient();
	   *
	   *  docClient.batchGet(params, function(err, data) {
	   *    if (err) console.log(err);
	   *    else console.log(data);
	   *  });
	   *
	   */
	  batchGet: function(params, callback) {
	    var self = this;
	    var request = self.service.batchGetItem(params);
	    self.setupRequest(request);
	    self.setupResponse(request);
	    if (typeof callback === 'function') {
	      request.send(callback);
	    }
	    return request;
	  },

	  /**
	   * Puts or deletes multiple items in one or more tables by delegating
	   * to `AWS.DynamoDB.batchWriteItem()`.
	   *
	   * Supply the same parameters as {AWS.DynamoDB.batchWriteItem} with
	   * `AttributeValue`s substituted by native JavaScript types.
	   *
	   * @see AWS.DynamoDB.batchWriteItem
	   * @example Write to and delete from a table
	   *  var params = {
	   *    RequestItems: {
	   *      'Table-1': [
	   *        {
	   *          DeleteRequest: {
	   *            Key: { HashKey: 'someKey' }
	   *          }
	   *        },
	   *        {
	   *          PutRequest: {
	   *            Item: {
	   *              HashKey: 'anotherKey',
	   *              NumAttribute: 1,
	   *              BoolAttribute: true,
	   *              ListAttribute: [1, 'two', false],
	   *              MapAttribute: { foo: 'bar' }
	   *            }
	   *          }
	   *        }
	   *      ]
	   *    }
	   *  };
	   *
	   *  var docClient = new AWS.DynamoDB.DocumentClient();
	   *
	   *  docClient.batchWrite(params, function(err, data) {
	   *    if (err) console.log(err);
	   *    else console.log(data);
	   *  });
	   *
	   */
	  batchWrite: function(params, callback) {
	    var self = this;
	    var request = self.service.batchWriteItem(params);
	    self.setupRequest(request);
	    self.setupResponse(request);
	    if (typeof callback === 'function') {
	      request.send(callback);
	    }
	    return request;
	  },

	  /**
	   * Deletes a single item in a table by primary key by delegating to
	   * `AWS.DynamoDB.deleteItem()`
	   *
	   * Supply the same parameters as {AWS.DynamoDB.deleteItem} with
	   * `AttributeValue`s substituted by native JavaScript types.
	   *
	   * @see AWS.DynamoDB.deleteItem
	   * @example Delete an item from a table
	   *  var params = {
	   *    TableName : 'Table',
	   *    Key: {
	   *      HashKey: 'hashkey',
	   *      NumberRangeKey: 1
	   *    }
	   *  };
	   *
	   *  var docClient = new AWS.DynamoDB.DocumentClient();
	   *
	   *  docClient.delete(params, function(err, data) {
	   *    if (err) console.log(err);
	   *    else console.log(data);
	   *  });
	   *
	   */
	  delete: function(params, callback) {
	    var self = this;
	    var request = self.service.deleteItem(params);
	    self.setupRequest(request);
	    self.setupResponse(request);
	    if (typeof callback === 'function') {
	      request.send(callback);
	    }
	    return request;
	  },

	  /**
	   * Returns a set of attributes for the item with the given primary key
	   * by delegating to `AWS.DynamoDB.getItem()`.
	   *
	   * Supply the same parameters as {AWS.DynamoDB.getItem} with
	   * `AttributeValue`s substituted by native JavaScript types.
	   *
	   * @see AWS.DynamoDB.getItem
	   * @example Get an item from a table
	   *  var params = {
	   *    TableName : 'Table',
	   *    Key: {
	   *      HashKey: 'hashkey'
	   *    }
	   *  };
	   *
	   *  var docClient = new AWS.DynamoDB.DocumentClient();
	   *
	   *  docClient.get(params, function(err, data) {
	   *    if (err) console.log(err);
	   *    else console.log(data);
	   *  });
	   *
	   */
	  get: function(params, callback) {
	    var self = this;
	    var request = self.service.getItem(params);
	    self.setupRequest(request);
	    self.setupResponse(request);
	    if (typeof callback === 'function') {
	      request.send(callback);
	    }
	    return request;
	  },

	  /**
	   * Creates a new item, or replaces an old item with a new item by
	   * delegating to `AWS.DynamoDB.putItem()`.
	   *
	   * Supply the same parameters as {AWS.DynamoDB.putItem} with
	   * `AttributeValue`s substituted by native JavaScript types.
	   *
	   * @see AWS.DynamoDB.putItem
	   * @example Create a new item in a table
	   *  var params = {
	   *    TableName : 'Table',
	   *    Item: {
	   *       HashKey: 'haskey',
	   *       NumAttribute: 1,
	   *       BoolAttribute: true,
	   *       ListAttribute: [1, 'two', false],
	   *       MapAttribute: { foo: 'bar'},
	   *       NullAttribute: null
	   *    }
	   *  };
	   *
	   *  var docClient = new AWS.DynamoDB.DocumentClient();
	   *
	   *  docClient.put(params, function(err, data) {
	   *    if (err) console.log(err);
	   *    else console.log(data);
	   *  });
	   *
	   */
	  put: function put(params, callback) {
	    var self = this;
	    var request = self.service.putItem(params);
	    self.setupRequest(request);
	    self.setupResponse(request);
	    if (typeof callback === 'function') {
	      request.send(callback);
	    }
	    return request;
	  },

	  /**
	   * Edits an existing item's attributes, or adds a new item to the table if
	   * it does not already exist by delegating to `AWS.DynamoDB.updateItem()`.
	   *
	   * Supply the same parameters as {AWS.DynamoDB.updateItem} with
	   * `AttributeValue`s substituted by native JavaScript types.
	   *
	   * @see AWS.DynamoDB.updateItem
	   * @example Update an item with expressions
	   *  var params = {
	   *    TableName: 'Table',
	   *    Key: { HashKey : 'hashkey' },
	   *    UpdateExpression: 'set #a = :x + :y',
	   *    ConditionExpression: '#a < :MAX',
	   *    ExpressionAttributeNames: {'#a' : 'Sum'},
	   *    ExpressionAttributeValues: {
	   *      ':x' : 20,
	   *      ':y' : 45,
	   *      ':MAX' : 100,
	   *    }
	   *  };
	   *
	   *  var docClient = new AWS.DynamoDB.DocumentClient();
	   *
	   *  docClient.update(params, function(err, data) {
	   *     if (err) console.log(err);
	   *     else console.log(data);
	   *  });
	   *
	   */
	  update: function(params, callback) {
	    var self = this;
	    var request = self.service.updateItem(params);
	    self.setupRequest(request);
	    self.setupResponse(request);
	    if (typeof callback === 'function') {
	      request.send(callback);
	    }
	    return request;
	  },

	  /**
	   * Returns one or more items and item attributes by accessing every item
	   * in a table or a secondary index.
	   *
	   * Supply the same parameters as {AWS.DynamoDB.scan} with
	   * `AttributeValue`s substituted by native JavaScript types.
	   *
	   * @see AWS.DynamoDB.scan
	   * @example Scan the table with a filter expression
	   *  var params = {
	   *    TableName : 'Table',
	   *    FilterExpression : 'Year = :this_year',
	   *    ExpressionAttributeValues : {':this_year' : 2015}
	   *  };
	   *
	   *  var docClient = new AWS.DynamoDB.DocumentClient();
	   *
	   *  docClient.scan(params, function(err, data) {
	   *     if (err) console.log(err);
	   *     else console.log(data);
	   *  });
	   *
	   */
	  scan: function(params, callback) {
	    var self = this;
	    var request = self.service.scan(params);
	    self.setupRequest(request);
	    self.setupResponse(request);
	    if (typeof callback === 'function') {
	      request.send(callback);
	    }
	    return request;
	  },

	   /**
	    * Directly access items from a table by primary key or a secondary index.
	    *
	    * Supply the same parameters as {AWS.DynamoDB.query} with
	    * `AttributeValue`s substituted by native JavaScript types.
	    *
	    * @see AWS.DynamoDB.query
	    * @example Query an index
	    *  var params = {
	    *    TableName: 'Table',
	    *    IndexName: 'Index',
	    *    KeyConditionExpression: 'HashKey = :hkey and RangeKey > :rkey',
	    *    ExpressionAttributeValues: {
	    *      ':hkey': 'key',
	    *      ':rkey': 2015
	    *    }
	    *  };
	    *
	    *  var docClient = new AWS.DynamoDB.DocumentClient();
	    *
	    *  docClient.query(params, function(err, data) {
	    *     if (err) console.log(err);
	    *     else console.log(data);
	    *  });
	    *
	    */
	  query: function(params, callback) {
	    var self = this;
	    var request = self.service.query(params);
	    self.setupRequest(request);
	    self.setupResponse(request);
	    if (typeof callback === 'function') {
	      request.send(callback);
	    }
	    return request;
	  },

	  /**
	   * Creates a set of elements inferring the type of set from
	   * the type of the first element. Amazon DynamoDB currently supports
	   * the number sets, string sets, and binary sets. For more information
	   * about DynamoDB data types see the documentation on the
	   * [Amazon DynamoDB Data Model](http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DataModel.html#DataModel.DataTypes).
	   *
	   * @param list [Array] Collection to represent your DynamoDB Set
	   * @param options [map]
	   *  * **validate** [Boolean] set to true if you want to validate the type
	   *    of each element in the set. Defaults to `false`.
	   * @example Creating a number set
	   *  var docClient = new AWS.DynamoDB.DocumentClient();
	   *
	   *  var params = {
	   *    Item: {
	   *      hashkey: 'hashkey'
	   *      numbers: docClient.createSet([1, 2, 3]);
	   *    }
	   *  };
	   *
	   *  docClient.put(params, function(err, data) {
	   *    if (err) console.log(err);
	   *    else console.log(data);
	   *  });
	   *
	   */
	  createSet: function(list, options) {
	    options = options || {};
	    return new DynamoDBSet(list, options);
	  },

	  /**
	   * @api private
	   */
	  getTranslator: function() {
	    return new Translator({attrValue: this.attrValue});
	  },

	  /**
	   * @api private
	   */
	  setupRequest: function setupRequest(request) {
	    var self = this;
	    var translator = self.getTranslator();
	    var operation = request.operation;
	    var inputShape = request.service.api.operations[operation].input;
	    request._events.validate.unshift(function(req) {
	      req.rawParams = AWS.util.copy(req.params);
	      req.params = translator.translateInput(req.rawParams, inputShape);
	    });
	  },

	  /**
	   * @api private
	   */
	  setupResponse: function setupResponse(request) {
	    var self = this;
	    var translator = self.getTranslator();
	    var outputShape = self.service.api.operations[request.operation].output;
	    request.on('extractData', function(response) {
	      response.data = translator.translateOutput(response.data, outputShape);
	    });

	    var response = request.response;
	    response.nextPage = function(cb) {
	      var resp = this;
	      var req = resp.request;
	      var config;
	      var service = req.service;
	      var operation = req.operation;
	      try {
	        config = service.paginationConfig(operation, true);
	      } catch (e) { resp.error = e; }

	      if (!resp.hasNextPage()) {
	        if (cb) cb(resp.error, null);
	        else if (resp.error) throw resp.error;
	        return null;
	      }

	      var params = AWS.util.copy(req.rawParams);
	      if (!resp.nextPageTokens) {
	        return cb ? cb(null, null) : null;
	      } else {
	        var inputTokens = config.inputToken;
	        if (typeof inputTokens === 'string') inputTokens = [inputTokens];
	        for (var i = 0; i < inputTokens.length; i++) {
	          params[inputTokens[i]] = resp.nextPageTokens[i];
	        }
	        return self[operation](params, cb);
	      }
	    };
	  }

	});

	module.exports = AWS.DynamoDB.DocumentClient;


/***/ },
/* 315 */
/***/ function(module, exports, __webpack_require__) {

	var util = __webpack_require__(93).util;
	var convert = __webpack_require__(316);

	var Translator = function(options) {
	  options = options || {};
	  this.attrValue = options.attrValue;
	};

	Translator.prototype.translateInput = function(value, shape) {
	  this.mode = 'input';
	  return this.translate(value, shape);
	};

	Translator.prototype.translateOutput = function(value, shape) {
	  this.mode = 'output';
	  return this.translate(value, shape);
	};

	Translator.prototype.translate = function(value, shape) {
	  var self = this;
	  if (!shape || value === undefined) return undefined;

	  if (shape.shape === self.attrValue) {
	    return convert[self.mode](value);
	  }
	  switch (shape.type) {
	    case 'structure': return self.translateStructure(value, shape);
	    case 'map': return self.translateMap(value, shape);
	    case 'list': return self.translateList(value, shape);
	    default: return self.translateScalar(value, shape);
	  }
	};

	Translator.prototype.translateStructure = function(structure, shape) {
	  var self = this;
	  if (structure == null) return undefined;

	  var struct = {};
	  util.each(structure, function(name, value) {
	    var memberShape = shape.members[name];
	    if (memberShape) {
	      var result = self.translate(value, memberShape);
	      if (result !== undefined) struct[name] = result;
	    }
	  });
	  return struct;
	};

	Translator.prototype.translateList = function(list, shape) {
	  var self = this;
	  if (list == null) return undefined;

	  var out = [];
	  util.arrayEach(list, function(value) {
	    var result = self.translate(value, shape.member);
	    if (result === undefined) out.push(null);
	    else out.push(result);
	  });
	  return out;
	};

	Translator.prototype.translateMap = function(map, shape) {
	  var self = this;
	  if (map == null) return undefined;

	  var out = {};
	  util.each(map, function(key, value) {
	    var result = self.translate(value, shape.value);
	    if (result === undefined) out[key] = null;
	    else out[key] = result;
	  });
	  return out;
	};

	Translator.prototype.translateScalar = function(value, shape) {
	  return shape.toType(value);
	};

	module.exports = Translator;


/***/ },
/* 316 */
/***/ function(module, exports, __webpack_require__) {

	var util = __webpack_require__(93).util;
	var typeOf = __webpack_require__(317).typeOf;
	var DynamoDBSet = __webpack_require__(318);

	function convertInput(data) {
	  if (typeOf(data) === 'Object') {
	    var map = {M: {}};
	    for (var key in data) {
	      map['M'][key] = convertInput(data[key]);
	    }
	    return map;
	  } else if (typeOf(data) === 'Array') {
	    var list = {L: []};
	    for (var i = 0; i < data.length; i++) {
	      list['L'].push(convertInput(data[i]));
	    }
	    return list;
	  } else if (typeOf(data) === 'Set') {
	    return formatSet(data);
	  } else if (typeOf(data) === 'String') {
	    return { 'S': data };
	  } else if (typeOf(data) === 'Number') {
	    return { 'N': data.toString() };
	  } else if (typeOf(data) === 'Binary') {
	    return { 'B': data };
	  } else if (typeOf(data) === 'Boolean') {
	    return {'BOOL': data};
	  } else if (typeOf(data) === 'null') {
	    return {'NULL': true};
	  }
	}

	function formatSet(data) {
	  var map = {};
	  switch (data.type) {
	    case 'String': map['SS'] = data.values; break;
	    case 'Binary': map['BS'] = data.values; break;
	    case 'Number': map['NS'] = data.values.map(function (value) {
	      return value.toString();
	    });
	  }
	  return map;
	}

	function convertOutput(data) {
	  var list, map, i;
	  for (var type in data) {
	    var values = data[type];
	    if (type === 'M') {
	      map = {};
	      for (var key in values) {
	        map[key] = convertOutput(values[key]);
	      }
	      return map;
	    } else if (type === 'L') {
	      list = [];
	      for (i = 0; i < values.length; i++) {
	        list.push(convertOutput(values[i]));
	      }
	      return list;
	    } else if (type === 'SS') {
	      list = [];
	      for (i = 0; i < values.length; i++) {
	        list.push(values[i] + '');
	      }
	      return new DynamoDBSet(list);
	    } else if (type === 'NS') {
	      list = [];
	      for (i = 0; i < values.length; i++) {
	        list.push(Number(values[i]));
	      }
	      return new DynamoDBSet(list);
	    } else if (type === 'BS') {
	      list = [];
	      for (i = 0; i < values.length; i++) {
	        list.push(new util.Buffer(values[i]));
	      }
	      return new DynamoDBSet(list);
	    } else if (type === 'S') {
	      return values + '';
	    } else if (type === 'N') {
	      return Number(values);
	    } else if (type === 'B') {
	      return new util.Buffer(values);
	    } else if (type === 'BOOL') {
	      return (values === 'true' || values === 'TRUE' || values === true);
	    } else if (type === 'NULL') {
	      return null;
	    }
	  }
	}

	module.exports = {
	  input: convertInput,
	  output: convertOutput
	};


/***/ },
/* 317 */
/***/ function(module, exports, __webpack_require__) {

	var util = __webpack_require__(93).util;

	function typeOf(data) {
	  if (data === null && typeof data === 'object') {
	    return 'null';
	  } else if (data !== undefined && isBinary(data)) {
	    return 'Binary';
	  } else if (data !== undefined && data.constructor) {
	    return util.typeName(data.constructor);
	  } else {
	    return 'undefined';
	  }
	}

	function isBinary(data) {
	  var types = [
	    'Buffer', 'File', 'Blob', 'ArrayBuffer', 'DataView',
	    'Int8Array', 'Uint8Array', 'Uint8ClampedArray',
	    'Int16Array', 'Uint16Array', 'Int32Array', 'Uint32Array',
	    'Float32Array', 'Float64Array'
	  ];
	  if (util.isNode()) {
	    var Stream = util.stream.Stream;
	    if (util.Buffer.isBuffer(data) || data instanceof Stream)
	      return true;
	  } else {
	    for (var i = 0; i < types.length; i++) {
	      if (data !== undefined && data.constructor) {
	        if (util.isType(data, types[i])) return true;
	        if (util.typeName(data.constructor) === types[i]) return true;
	      }
	    }
	  }
	  return false;
	}

	module.exports = {
	  typeOf: typeOf,
	  isBinary: isBinary
	};


/***/ },
/* 318 */
/***/ function(module, exports, __webpack_require__) {

	var util = __webpack_require__(93).util;
	var typeOf = __webpack_require__(317).typeOf;

	var DynamoDBSet = util.inherit({

	  constructor: function Set(list, options) {
	    options = options || {};
	    this.initialize(list, options.validate);
	  },

	  initialize: function(list, validate) {
	    var self = this;
	    self.values = [].concat(list);
	    self.detectType();
	    if (validate) {
	      self.validate();
	    }
	  },

	  detectType: function() {
	    var self = this;
	    var value = self.values[0];
	    if (typeOf(value) === 'String') {
	      self.type = 'String';
	    } else if (typeOf(value) === 'Number') {
	      self.type = 'Number';
	    } else if (typeOf(value) === 'Binary') {
	      self.type = 'Binary';
	    } else {
	      throw util.error(new Error(), {
	        code: 'InvalidSetType',
	        message: 'Sets can contain string, number, or binary values'
	      });
	    }
	  },

	  validate: function() {
	    var self = this;
	    var length = self.values.length;
	    var values = self.values;
	    for (var i = 0; i < length; i++) {
	      if (typeOf(values[i]) !== self.type) {
	        throw util.error(new Error(), {
	          code: 'InvalidType',
	          message: self.type + ' Set contains ' + typeOf(values[i]) + ' value'
	        });
	      }
	    }
	  }

	});

	module.exports = DynamoDBSet;


/***/ },
/* 319 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2011-12-05",
			"endpointPrefix": "dynamodb",
			"jsonVersion": "1.0",
			"protocol": "json",
			"serviceAbbreviation": "DynamoDB",
			"serviceFullName": "Amazon DynamoDB",
			"signatureVersion": "v4",
			"targetPrefix": "DynamoDB_20111205"
		},
		"operations": {
			"BatchGetItem": {
				"input": {
					"type": "structure",
					"required": [
						"RequestItems"
					],
					"members": {
						"RequestItems": {
							"shape": "S2"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Responses": {
							"type": "map",
							"key": {},
							"value": {
								"type": "structure",
								"members": {
									"Items": {
										"shape": "Sk"
									},
									"ConsumedCapacityUnits": {
										"type": "double"
									}
								}
							}
						},
						"UnprocessedKeys": {
							"shape": "S2"
						}
					}
				}
			},
			"BatchWriteItem": {
				"input": {
					"type": "structure",
					"required": [
						"RequestItems"
					],
					"members": {
						"RequestItems": {
							"shape": "So"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Responses": {
							"type": "map",
							"key": {},
							"value": {
								"type": "structure",
								"members": {
									"ConsumedCapacityUnits": {
										"type": "double"
									}
								}
							}
						},
						"UnprocessedItems": {
							"shape": "So"
						}
					}
				}
			},
			"CreateTable": {
				"input": {
					"type": "structure",
					"required": [
						"TableName",
						"KeySchema",
						"ProvisionedThroughput"
					],
					"members": {
						"TableName": {},
						"KeySchema": {
							"shape": "Sy"
						},
						"ProvisionedThroughput": {
							"shape": "S12"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"TableDescription": {
							"shape": "S15"
						}
					}
				}
			},
			"DeleteItem": {
				"input": {
					"type": "structure",
					"required": [
						"TableName",
						"Key"
					],
					"members": {
						"TableName": {},
						"Key": {
							"shape": "S6"
						},
						"Expected": {
							"shape": "S1b"
						},
						"ReturnValues": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Attributes": {
							"shape": "Sl"
						},
						"ConsumedCapacityUnits": {
							"type": "double"
						}
					}
				}
			},
			"DeleteTable": {
				"input": {
					"type": "structure",
					"required": [
						"TableName"
					],
					"members": {
						"TableName": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"TableDescription": {
							"shape": "S15"
						}
					}
				}
			},
			"DescribeTable": {
				"input": {
					"type": "structure",
					"required": [
						"TableName"
					],
					"members": {
						"TableName": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Table": {
							"shape": "S15"
						}
					}
				}
			},
			"GetItem": {
				"input": {
					"type": "structure",
					"required": [
						"TableName",
						"Key"
					],
					"members": {
						"TableName": {},
						"Key": {
							"shape": "S6"
						},
						"AttributesToGet": {
							"shape": "Se"
						},
						"ConsistentRead": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Item": {
							"shape": "Sl"
						},
						"ConsumedCapacityUnits": {
							"type": "double"
						}
					}
				}
			},
			"ListTables": {
				"input": {
					"type": "structure",
					"members": {
						"ExclusiveStartTableName": {},
						"Limit": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"TableNames": {
							"type": "list",
							"member": {}
						},
						"LastEvaluatedTableName": {}
					}
				}
			},
			"PutItem": {
				"input": {
					"type": "structure",
					"required": [
						"TableName",
						"Item"
					],
					"members": {
						"TableName": {},
						"Item": {
							"shape": "Ss"
						},
						"Expected": {
							"shape": "S1b"
						},
						"ReturnValues": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Attributes": {
							"shape": "Sl"
						},
						"ConsumedCapacityUnits": {
							"type": "double"
						}
					}
				}
			},
			"Query": {
				"input": {
					"type": "structure",
					"required": [
						"TableName",
						"HashKeyValue"
					],
					"members": {
						"TableName": {},
						"AttributesToGet": {
							"shape": "Se"
						},
						"Limit": {
							"type": "integer"
						},
						"ConsistentRead": {
							"type": "boolean"
						},
						"Count": {
							"type": "boolean"
						},
						"HashKeyValue": {
							"shape": "S7"
						},
						"RangeKeyCondition": {
							"shape": "S1u"
						},
						"ScanIndexForward": {
							"type": "boolean"
						},
						"ExclusiveStartKey": {
							"shape": "S6"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Items": {
							"shape": "Sk"
						},
						"Count": {
							"type": "integer"
						},
						"LastEvaluatedKey": {
							"shape": "S6"
						},
						"ConsumedCapacityUnits": {
							"type": "double"
						}
					}
				}
			},
			"Scan": {
				"input": {
					"type": "structure",
					"required": [
						"TableName"
					],
					"members": {
						"TableName": {},
						"AttributesToGet": {
							"shape": "Se"
						},
						"Limit": {
							"type": "integer"
						},
						"Count": {
							"type": "boolean"
						},
						"ScanFilter": {
							"type": "map",
							"key": {},
							"value": {
								"shape": "S1u"
							}
						},
						"ExclusiveStartKey": {
							"shape": "S6"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Items": {
							"shape": "Sk"
						},
						"Count": {
							"type": "integer"
						},
						"ScannedCount": {
							"type": "integer"
						},
						"LastEvaluatedKey": {
							"shape": "S6"
						},
						"ConsumedCapacityUnits": {
							"type": "double"
						}
					}
				}
			},
			"UpdateItem": {
				"input": {
					"type": "structure",
					"required": [
						"TableName",
						"Key",
						"AttributeUpdates"
					],
					"members": {
						"TableName": {},
						"Key": {
							"shape": "S6"
						},
						"AttributeUpdates": {
							"type": "map",
							"key": {},
							"value": {
								"type": "structure",
								"members": {
									"Value": {
										"shape": "S7"
									},
									"Action": {}
								}
							}
						},
						"Expected": {
							"shape": "S1b"
						},
						"ReturnValues": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Attributes": {
							"shape": "Sl"
						},
						"ConsumedCapacityUnits": {
							"type": "double"
						}
					}
				}
			},
			"UpdateTable": {
				"input": {
					"type": "structure",
					"required": [
						"TableName",
						"ProvisionedThroughput"
					],
					"members": {
						"TableName": {},
						"ProvisionedThroughput": {
							"shape": "S12"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"TableDescription": {
							"shape": "S15"
						}
					}
				}
			}
		},
		"shapes": {
			"S2": {
				"type": "map",
				"key": {},
				"value": {
					"type": "structure",
					"required": [
						"Keys"
					],
					"members": {
						"Keys": {
							"type": "list",
							"member": {
								"shape": "S6"
							}
						},
						"AttributesToGet": {
							"shape": "Se"
						},
						"ConsistentRead": {
							"type": "boolean"
						}
					}
				}
			},
			"S6": {
				"type": "structure",
				"required": [
					"HashKeyElement"
				],
				"members": {
					"HashKeyElement": {
						"shape": "S7"
					},
					"RangeKeyElement": {
						"shape": "S7"
					}
				}
			},
			"S7": {
				"type": "structure",
				"members": {
					"S": {},
					"N": {},
					"B": {
						"type": "blob"
					},
					"SS": {
						"type": "list",
						"member": {}
					},
					"NS": {
						"type": "list",
						"member": {}
					},
					"BS": {
						"type": "list",
						"member": {
							"type": "blob"
						}
					}
				}
			},
			"Se": {
				"type": "list",
				"member": {}
			},
			"Sk": {
				"type": "list",
				"member": {
					"shape": "Sl"
				}
			},
			"Sl": {
				"type": "map",
				"key": {},
				"value": {
					"shape": "S7"
				}
			},
			"So": {
				"type": "map",
				"key": {},
				"value": {
					"type": "list",
					"member": {
						"type": "structure",
						"members": {
							"PutRequest": {
								"type": "structure",
								"required": [
									"Item"
								],
								"members": {
									"Item": {
										"shape": "Ss"
									}
								}
							},
							"DeleteRequest": {
								"type": "structure",
								"required": [
									"Key"
								],
								"members": {
									"Key": {
										"shape": "S6"
									}
								}
							}
						}
					}
				}
			},
			"Ss": {
				"type": "map",
				"key": {},
				"value": {
					"shape": "S7"
				}
			},
			"Sy": {
				"type": "structure",
				"required": [
					"HashKeyElement"
				],
				"members": {
					"HashKeyElement": {
						"shape": "Sz"
					},
					"RangeKeyElement": {
						"shape": "Sz"
					}
				}
			},
			"Sz": {
				"type": "structure",
				"required": [
					"AttributeName",
					"AttributeType"
				],
				"members": {
					"AttributeName": {},
					"AttributeType": {}
				}
			},
			"S12": {
				"type": "structure",
				"required": [
					"ReadCapacityUnits",
					"WriteCapacityUnits"
				],
				"members": {
					"ReadCapacityUnits": {
						"type": "long"
					},
					"WriteCapacityUnits": {
						"type": "long"
					}
				}
			},
			"S15": {
				"type": "structure",
				"members": {
					"TableName": {},
					"KeySchema": {
						"shape": "Sy"
					},
					"TableStatus": {},
					"CreationDateTime": {
						"type": "timestamp"
					},
					"ProvisionedThroughput": {
						"type": "structure",
						"members": {
							"LastIncreaseDateTime": {
								"type": "timestamp"
							},
							"LastDecreaseDateTime": {
								"type": "timestamp"
							},
							"NumberOfDecreasesToday": {
								"type": "long"
							},
							"ReadCapacityUnits": {
								"type": "long"
							},
							"WriteCapacityUnits": {
								"type": "long"
							}
						}
					},
					"TableSizeBytes": {
						"type": "long"
					},
					"ItemCount": {
						"type": "long"
					}
				}
			},
			"S1b": {
				"type": "map",
				"key": {},
				"value": {
					"type": "structure",
					"members": {
						"Value": {
							"shape": "S7"
						},
						"Exists": {
							"type": "boolean"
						}
					}
				}
			},
			"S1u": {
				"type": "structure",
				"required": [
					"ComparisonOperator"
				],
				"members": {
					"AttributeValueList": {
						"type": "list",
						"member": {
							"shape": "S7"
						}
					},
					"ComparisonOperator": {}
				}
			}
		}
	};

/***/ },
/* 320 */
/***/ function(module, exports) {

	module.exports = {
		"pagination": {
			"BatchGetItem": {
				"input_token": "RequestItems",
				"output_token": "UnprocessedKeys"
			},
			"ListTables": {
				"input_token": "ExclusiveStartTableName",
				"output_token": "LastEvaluatedTableName",
				"limit_key": "Limit",
				"result_key": "TableNames"
			},
			"Query": {
				"input_token": "ExclusiveStartKey",
				"output_token": "LastEvaluatedKey",
				"limit_key": "Limit",
				"result_key": "Items"
			},
			"Scan": {
				"input_token": "ExclusiveStartKey",
				"output_token": "LastEvaluatedKey",
				"limit_key": "Limit",
				"result_key": "Items"
			}
		}
	};

/***/ },
/* 321 */
/***/ function(module, exports) {

	module.exports = {
		"version": 2,
		"waiters": {
			"TableExists": {
				"delay": 20,
				"operation": "DescribeTable",
				"maxAttempts": 25,
				"acceptors": [
					{
						"expected": "ACTIVE",
						"matcher": "path",
						"state": "success",
						"argument": "Table.TableStatus"
					},
					{
						"expected": "ResourceNotFoundException",
						"matcher": "error",
						"state": "retry"
					}
				]
			},
			"TableNotExists": {
				"delay": 20,
				"operation": "DescribeTable",
				"maxAttempts": 25,
				"acceptors": [
					{
						"expected": "ResourceNotFoundException",
						"matcher": "error",
						"state": "success"
					}
				]
			}
		}
	};

/***/ },
/* 322 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2012-08-10",
			"endpointPrefix": "dynamodb",
			"jsonVersion": "1.0",
			"protocol": "json",
			"serviceAbbreviation": "DynamoDB",
			"serviceFullName": "Amazon DynamoDB",
			"signatureVersion": "v4",
			"targetPrefix": "DynamoDB_20120810"
		},
		"operations": {
			"BatchGetItem": {
				"input": {
					"type": "structure",
					"required": [
						"RequestItems"
					],
					"members": {
						"RequestItems": {
							"shape": "S2"
						},
						"ReturnConsumedCapacity": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Responses": {
							"type": "map",
							"key": {},
							"value": {
								"shape": "Sr"
							}
						},
						"UnprocessedKeys": {
							"shape": "S2"
						},
						"ConsumedCapacity": {
							"shape": "St"
						}
					}
				}
			},
			"BatchWriteItem": {
				"input": {
					"type": "structure",
					"required": [
						"RequestItems"
					],
					"members": {
						"RequestItems": {
							"shape": "S10"
						},
						"ReturnConsumedCapacity": {},
						"ReturnItemCollectionMetrics": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"UnprocessedItems": {
							"shape": "S10"
						},
						"ItemCollectionMetrics": {
							"type": "map",
							"key": {},
							"value": {
								"type": "list",
								"member": {
									"shape": "S1a"
								}
							}
						},
						"ConsumedCapacity": {
							"shape": "St"
						}
					}
				}
			},
			"CreateTable": {
				"input": {
					"type": "structure",
					"required": [
						"AttributeDefinitions",
						"TableName",
						"KeySchema",
						"ProvisionedThroughput"
					],
					"members": {
						"AttributeDefinitions": {
							"shape": "S1f"
						},
						"TableName": {},
						"KeySchema": {
							"shape": "S1j"
						},
						"LocalSecondaryIndexes": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"IndexName",
									"KeySchema",
									"Projection"
								],
								"members": {
									"IndexName": {},
									"KeySchema": {
										"shape": "S1j"
									},
									"Projection": {
										"shape": "S1o"
									}
								}
							}
						},
						"GlobalSecondaryIndexes": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"IndexName",
									"KeySchema",
									"Projection",
									"ProvisionedThroughput"
								],
								"members": {
									"IndexName": {},
									"KeySchema": {
										"shape": "S1j"
									},
									"Projection": {
										"shape": "S1o"
									},
									"ProvisionedThroughput": {
										"shape": "S1u"
									}
								}
							}
						},
						"ProvisionedThroughput": {
							"shape": "S1u"
						},
						"StreamSpecification": {
							"shape": "S1w"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"TableDescription": {
							"shape": "S20"
						}
					}
				}
			},
			"DeleteItem": {
				"input": {
					"type": "structure",
					"required": [
						"TableName",
						"Key"
					],
					"members": {
						"TableName": {},
						"Key": {
							"shape": "S6"
						},
						"Expected": {
							"shape": "S2e"
						},
						"ConditionalOperator": {},
						"ReturnValues": {},
						"ReturnConsumedCapacity": {},
						"ReturnItemCollectionMetrics": {},
						"ConditionExpression": {},
						"ExpressionAttributeNames": {
							"shape": "Sm"
						},
						"ExpressionAttributeValues": {
							"shape": "S2m"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Attributes": {
							"shape": "Ss"
						},
						"ConsumedCapacity": {
							"shape": "Su"
						},
						"ItemCollectionMetrics": {
							"shape": "S1a"
						}
					}
				}
			},
			"DeleteTable": {
				"input": {
					"type": "structure",
					"required": [
						"TableName"
					],
					"members": {
						"TableName": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"TableDescription": {
							"shape": "S20"
						}
					}
				}
			},
			"DescribeLimits": {
				"input": {
					"type": "structure",
					"members": {}
				},
				"output": {
					"type": "structure",
					"members": {
						"AccountMaxReadCapacityUnits": {
							"type": "long"
						},
						"AccountMaxWriteCapacityUnits": {
							"type": "long"
						},
						"TableMaxReadCapacityUnits": {
							"type": "long"
						},
						"TableMaxWriteCapacityUnits": {
							"type": "long"
						}
					}
				}
			},
			"DescribeTable": {
				"input": {
					"type": "structure",
					"required": [
						"TableName"
					],
					"members": {
						"TableName": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Table": {
							"shape": "S20"
						}
					}
				}
			},
			"GetItem": {
				"input": {
					"type": "structure",
					"required": [
						"TableName",
						"Key"
					],
					"members": {
						"TableName": {},
						"Key": {
							"shape": "S6"
						},
						"AttributesToGet": {
							"shape": "Sj"
						},
						"ConsistentRead": {
							"type": "boolean"
						},
						"ReturnConsumedCapacity": {},
						"ProjectionExpression": {},
						"ExpressionAttributeNames": {
							"shape": "Sm"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Item": {
							"shape": "Ss"
						},
						"ConsumedCapacity": {
							"shape": "Su"
						}
					}
				}
			},
			"ListTables": {
				"input": {
					"type": "structure",
					"members": {
						"ExclusiveStartTableName": {},
						"Limit": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"TableNames": {
							"type": "list",
							"member": {}
						},
						"LastEvaluatedTableName": {}
					}
				}
			},
			"PutItem": {
				"input": {
					"type": "structure",
					"required": [
						"TableName",
						"Item"
					],
					"members": {
						"TableName": {},
						"Item": {
							"shape": "S14"
						},
						"Expected": {
							"shape": "S2e"
						},
						"ReturnValues": {},
						"ReturnConsumedCapacity": {},
						"ReturnItemCollectionMetrics": {},
						"ConditionalOperator": {},
						"ConditionExpression": {},
						"ExpressionAttributeNames": {
							"shape": "Sm"
						},
						"ExpressionAttributeValues": {
							"shape": "S2m"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Attributes": {
							"shape": "Ss"
						},
						"ConsumedCapacity": {
							"shape": "Su"
						},
						"ItemCollectionMetrics": {
							"shape": "S1a"
						}
					}
				}
			},
			"Query": {
				"input": {
					"type": "structure",
					"required": [
						"TableName"
					],
					"members": {
						"TableName": {},
						"IndexName": {},
						"Select": {},
						"AttributesToGet": {
							"shape": "Sj"
						},
						"Limit": {
							"type": "integer"
						},
						"ConsistentRead": {
							"type": "boolean"
						},
						"KeyConditions": {
							"type": "map",
							"key": {},
							"value": {
								"shape": "S37"
							}
						},
						"QueryFilter": {
							"shape": "S38"
						},
						"ConditionalOperator": {},
						"ScanIndexForward": {
							"type": "boolean"
						},
						"ExclusiveStartKey": {
							"shape": "S6"
						},
						"ReturnConsumedCapacity": {},
						"ProjectionExpression": {},
						"FilterExpression": {},
						"KeyConditionExpression": {},
						"ExpressionAttributeNames": {
							"shape": "Sm"
						},
						"ExpressionAttributeValues": {
							"shape": "S2m"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Items": {
							"shape": "Sr"
						},
						"Count": {
							"type": "integer"
						},
						"ScannedCount": {
							"type": "integer"
						},
						"LastEvaluatedKey": {
							"shape": "S6"
						},
						"ConsumedCapacity": {
							"shape": "Su"
						}
					}
				}
			},
			"Scan": {
				"input": {
					"type": "structure",
					"required": [
						"TableName"
					],
					"members": {
						"TableName": {},
						"IndexName": {},
						"AttributesToGet": {
							"shape": "Sj"
						},
						"Limit": {
							"type": "integer"
						},
						"Select": {},
						"ScanFilter": {
							"shape": "S38"
						},
						"ConditionalOperator": {},
						"ExclusiveStartKey": {
							"shape": "S6"
						},
						"ReturnConsumedCapacity": {},
						"TotalSegments": {
							"type": "integer"
						},
						"Segment": {
							"type": "integer"
						},
						"ProjectionExpression": {},
						"FilterExpression": {},
						"ExpressionAttributeNames": {
							"shape": "Sm"
						},
						"ExpressionAttributeValues": {
							"shape": "S2m"
						},
						"ConsistentRead": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Items": {
							"shape": "Sr"
						},
						"Count": {
							"type": "integer"
						},
						"ScannedCount": {
							"type": "integer"
						},
						"LastEvaluatedKey": {
							"shape": "S6"
						},
						"ConsumedCapacity": {
							"shape": "Su"
						}
					}
				}
			},
			"UpdateItem": {
				"input": {
					"type": "structure",
					"required": [
						"TableName",
						"Key"
					],
					"members": {
						"TableName": {},
						"Key": {
							"shape": "S6"
						},
						"AttributeUpdates": {
							"type": "map",
							"key": {},
							"value": {
								"type": "structure",
								"members": {
									"Value": {
										"shape": "S8"
									},
									"Action": {}
								}
							}
						},
						"Expected": {
							"shape": "S2e"
						},
						"ConditionalOperator": {},
						"ReturnValues": {},
						"ReturnConsumedCapacity": {},
						"ReturnItemCollectionMetrics": {},
						"UpdateExpression": {},
						"ConditionExpression": {},
						"ExpressionAttributeNames": {
							"shape": "Sm"
						},
						"ExpressionAttributeValues": {
							"shape": "S2m"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Attributes": {
							"shape": "Ss"
						},
						"ConsumedCapacity": {
							"shape": "Su"
						},
						"ItemCollectionMetrics": {
							"shape": "S1a"
						}
					}
				}
			},
			"UpdateTable": {
				"input": {
					"type": "structure",
					"required": [
						"TableName"
					],
					"members": {
						"AttributeDefinitions": {
							"shape": "S1f"
						},
						"TableName": {},
						"ProvisionedThroughput": {
							"shape": "S1u"
						},
						"GlobalSecondaryIndexUpdates": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"Update": {
										"type": "structure",
										"required": [
											"IndexName",
											"ProvisionedThroughput"
										],
										"members": {
											"IndexName": {},
											"ProvisionedThroughput": {
												"shape": "S1u"
											}
										}
									},
									"Create": {
										"type": "structure",
										"required": [
											"IndexName",
											"KeySchema",
											"Projection",
											"ProvisionedThroughput"
										],
										"members": {
											"IndexName": {},
											"KeySchema": {
												"shape": "S1j"
											},
											"Projection": {
												"shape": "S1o"
											},
											"ProvisionedThroughput": {
												"shape": "S1u"
											}
										}
									},
									"Delete": {
										"type": "structure",
										"required": [
											"IndexName"
										],
										"members": {
											"IndexName": {}
										}
									}
								}
							}
						},
						"StreamSpecification": {
							"shape": "S1w"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"TableDescription": {
							"shape": "S20"
						}
					}
				}
			}
		},
		"shapes": {
			"S2": {
				"type": "map",
				"key": {},
				"value": {
					"type": "structure",
					"required": [
						"Keys"
					],
					"members": {
						"Keys": {
							"type": "list",
							"member": {
								"shape": "S6"
							}
						},
						"AttributesToGet": {
							"shape": "Sj"
						},
						"ConsistentRead": {
							"type": "boolean"
						},
						"ProjectionExpression": {},
						"ExpressionAttributeNames": {
							"shape": "Sm"
						}
					}
				}
			},
			"S6": {
				"type": "map",
				"key": {},
				"value": {
					"shape": "S8"
				}
			},
			"S8": {
				"type": "structure",
				"members": {
					"S": {},
					"N": {},
					"B": {
						"type": "blob"
					},
					"SS": {
						"type": "list",
						"member": {}
					},
					"NS": {
						"type": "list",
						"member": {}
					},
					"BS": {
						"type": "list",
						"member": {
							"type": "blob"
						}
					},
					"M": {
						"type": "map",
						"key": {},
						"value": {
							"shape": "S8"
						}
					},
					"L": {
						"type": "list",
						"member": {
							"shape": "S8"
						}
					},
					"NULL": {
						"type": "boolean"
					},
					"BOOL": {
						"type": "boolean"
					}
				}
			},
			"Sj": {
				"type": "list",
				"member": {}
			},
			"Sm": {
				"type": "map",
				"key": {},
				"value": {}
			},
			"Sr": {
				"type": "list",
				"member": {
					"shape": "Ss"
				}
			},
			"Ss": {
				"type": "map",
				"key": {},
				"value": {
					"shape": "S8"
				}
			},
			"St": {
				"type": "list",
				"member": {
					"shape": "Su"
				}
			},
			"Su": {
				"type": "structure",
				"members": {
					"TableName": {},
					"CapacityUnits": {
						"type": "double"
					},
					"Table": {
						"shape": "Sw"
					},
					"LocalSecondaryIndexes": {
						"shape": "Sx"
					},
					"GlobalSecondaryIndexes": {
						"shape": "Sx"
					}
				}
			},
			"Sw": {
				"type": "structure",
				"members": {
					"CapacityUnits": {
						"type": "double"
					}
				}
			},
			"Sx": {
				"type": "map",
				"key": {},
				"value": {
					"shape": "Sw"
				}
			},
			"S10": {
				"type": "map",
				"key": {},
				"value": {
					"type": "list",
					"member": {
						"type": "structure",
						"members": {
							"PutRequest": {
								"type": "structure",
								"required": [
									"Item"
								],
								"members": {
									"Item": {
										"shape": "S14"
									}
								}
							},
							"DeleteRequest": {
								"type": "structure",
								"required": [
									"Key"
								],
								"members": {
									"Key": {
										"shape": "S6"
									}
								}
							}
						}
					}
				}
			},
			"S14": {
				"type": "map",
				"key": {},
				"value": {
					"shape": "S8"
				}
			},
			"S1a": {
				"type": "structure",
				"members": {
					"ItemCollectionKey": {
						"type": "map",
						"key": {},
						"value": {
							"shape": "S8"
						}
					},
					"SizeEstimateRangeGB": {
						"type": "list",
						"member": {
							"type": "double"
						}
					}
				}
			},
			"S1f": {
				"type": "list",
				"member": {
					"type": "structure",
					"required": [
						"AttributeName",
						"AttributeType"
					],
					"members": {
						"AttributeName": {},
						"AttributeType": {}
					}
				}
			},
			"S1j": {
				"type": "list",
				"member": {
					"type": "structure",
					"required": [
						"AttributeName",
						"KeyType"
					],
					"members": {
						"AttributeName": {},
						"KeyType": {}
					}
				}
			},
			"S1o": {
				"type": "structure",
				"members": {
					"ProjectionType": {},
					"NonKeyAttributes": {
						"type": "list",
						"member": {}
					}
				}
			},
			"S1u": {
				"type": "structure",
				"required": [
					"ReadCapacityUnits",
					"WriteCapacityUnits"
				],
				"members": {
					"ReadCapacityUnits": {
						"type": "long"
					},
					"WriteCapacityUnits": {
						"type": "long"
					}
				}
			},
			"S1w": {
				"type": "structure",
				"members": {
					"StreamEnabled": {
						"type": "boolean"
					},
					"StreamViewType": {}
				}
			},
			"S20": {
				"type": "structure",
				"members": {
					"AttributeDefinitions": {
						"shape": "S1f"
					},
					"TableName": {},
					"KeySchema": {
						"shape": "S1j"
					},
					"TableStatus": {},
					"CreationDateTime": {
						"type": "timestamp"
					},
					"ProvisionedThroughput": {
						"shape": "S23"
					},
					"TableSizeBytes": {
						"type": "long"
					},
					"ItemCount": {
						"type": "long"
					},
					"TableArn": {},
					"LocalSecondaryIndexes": {
						"type": "list",
						"member": {
							"type": "structure",
							"members": {
								"IndexName": {},
								"KeySchema": {
									"shape": "S1j"
								},
								"Projection": {
									"shape": "S1o"
								},
								"IndexSizeBytes": {
									"type": "long"
								},
								"ItemCount": {
									"type": "long"
								},
								"IndexArn": {}
							}
						}
					},
					"GlobalSecondaryIndexes": {
						"type": "list",
						"member": {
							"type": "structure",
							"members": {
								"IndexName": {},
								"KeySchema": {
									"shape": "S1j"
								},
								"Projection": {
									"shape": "S1o"
								},
								"IndexStatus": {},
								"Backfilling": {
									"type": "boolean"
								},
								"ProvisionedThroughput": {
									"shape": "S23"
								},
								"IndexSizeBytes": {
									"type": "long"
								},
								"ItemCount": {
									"type": "long"
								},
								"IndexArn": {}
							}
						}
					},
					"StreamSpecification": {
						"shape": "S1w"
					},
					"LatestStreamLabel": {},
					"LatestStreamArn": {}
				}
			},
			"S23": {
				"type": "structure",
				"members": {
					"LastIncreaseDateTime": {
						"type": "timestamp"
					},
					"LastDecreaseDateTime": {
						"type": "timestamp"
					},
					"NumberOfDecreasesToday": {
						"type": "long"
					},
					"ReadCapacityUnits": {
						"type": "long"
					},
					"WriteCapacityUnits": {
						"type": "long"
					}
				}
			},
			"S2e": {
				"type": "map",
				"key": {},
				"value": {
					"type": "structure",
					"members": {
						"Value": {
							"shape": "S8"
						},
						"Exists": {
							"type": "boolean"
						},
						"ComparisonOperator": {},
						"AttributeValueList": {
							"shape": "S2i"
						}
					}
				}
			},
			"S2i": {
				"type": "list",
				"member": {
					"shape": "S8"
				}
			},
			"S2m": {
				"type": "map",
				"key": {},
				"value": {
					"shape": "S8"
				}
			},
			"S37": {
				"type": "structure",
				"required": [
					"ComparisonOperator"
				],
				"members": {
					"AttributeValueList": {
						"shape": "S2i"
					},
					"ComparisonOperator": {}
				}
			},
			"S38": {
				"type": "map",
				"key": {},
				"value": {
					"shape": "S37"
				}
			}
		}
	};

/***/ },
/* 323 */
/***/ function(module, exports) {

	module.exports = {
		"pagination": {
			"BatchGetItem": {
				"input_token": "RequestItems",
				"output_token": "UnprocessedKeys"
			},
			"ListTables": {
				"input_token": "ExclusiveStartTableName",
				"output_token": "LastEvaluatedTableName",
				"limit_key": "Limit",
				"result_key": "TableNames"
			},
			"Query": {
				"input_token": "ExclusiveStartKey",
				"output_token": "LastEvaluatedKey",
				"limit_key": "Limit",
				"result_key": "Items"
			},
			"Scan": {
				"input_token": "ExclusiveStartKey",
				"output_token": "LastEvaluatedKey",
				"limit_key": "Limit",
				"result_key": "Items"
			}
		}
	};

/***/ },
/* 324 */
/***/ function(module, exports) {

	module.exports = {
		"version": 2,
		"waiters": {
			"TableExists": {
				"delay": 20,
				"operation": "DescribeTable",
				"maxAttempts": 25,
				"acceptors": [
					{
						"expected": "ACTIVE",
						"matcher": "path",
						"state": "success",
						"argument": "Table.TableStatus"
					},
					{
						"expected": "ResourceNotFoundException",
						"matcher": "error",
						"state": "retry"
					}
				]
			},
			"TableNotExists": {
				"delay": 20,
				"operation": "DescribeTable",
				"maxAttempts": 25,
				"acceptors": [
					{
						"expected": "ResourceNotFoundException",
						"matcher": "error",
						"state": "success"
					}
				]
			}
		}
	};

/***/ },
/* 325 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['dynamodbstreams'] = {};
	AWS.DynamoDBStreams = Service.defineService('dynamodbstreams', ['2012-08-10']);
	Object.defineProperty(apiLoader.services['dynamodbstreams'], '2012-08-10', {
	  get: function get() {
	    var model = __webpack_require__(326);
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.DynamoDBStreams;


/***/ },
/* 326 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2012-08-10",
			"endpointPrefix": "streams.dynamodb",
			"jsonVersion": "1.0",
			"protocol": "json",
			"serviceFullName": "Amazon DynamoDB Streams",
			"signatureVersion": "v4",
			"signingName": "dynamodb",
			"targetPrefix": "DynamoDBStreams_20120810"
		},
		"operations": {
			"DescribeStream": {
				"input": {
					"type": "structure",
					"required": [
						"StreamArn"
					],
					"members": {
						"StreamArn": {},
						"Limit": {
							"type": "integer"
						},
						"ExclusiveStartShardId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"StreamDescription": {
							"type": "structure",
							"members": {
								"StreamArn": {},
								"StreamLabel": {},
								"StreamStatus": {},
								"StreamViewType": {},
								"CreationRequestDateTime": {
									"type": "timestamp"
								},
								"TableName": {},
								"KeySchema": {
									"type": "list",
									"member": {
										"type": "structure",
										"required": [
											"AttributeName",
											"KeyType"
										],
										"members": {
											"AttributeName": {},
											"KeyType": {}
										}
									}
								},
								"Shards": {
									"type": "list",
									"member": {
										"type": "structure",
										"members": {
											"ShardId": {},
											"SequenceNumberRange": {
												"type": "structure",
												"members": {
													"StartingSequenceNumber": {},
													"EndingSequenceNumber": {}
												}
											},
											"ParentShardId": {}
										}
									}
								},
								"LastEvaluatedShardId": {}
							}
						}
					}
				}
			},
			"GetRecords": {
				"input": {
					"type": "structure",
					"required": [
						"ShardIterator"
					],
					"members": {
						"ShardIterator": {},
						"Limit": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Records": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"eventID": {},
									"eventName": {},
									"eventVersion": {},
									"eventSource": {},
									"awsRegion": {},
									"dynamodb": {
										"type": "structure",
										"members": {
											"ApproximateCreationDateTime": {
												"type": "timestamp"
											},
											"Keys": {
												"shape": "Sr"
											},
											"NewImage": {
												"shape": "Sr"
											},
											"OldImage": {
												"shape": "Sr"
											},
											"SequenceNumber": {},
											"SizeBytes": {
												"type": "long"
											},
											"StreamViewType": {}
										}
									}
								}
							}
						},
						"NextShardIterator": {}
					}
				}
			},
			"GetShardIterator": {
				"input": {
					"type": "structure",
					"required": [
						"StreamArn",
						"ShardId",
						"ShardIteratorType"
					],
					"members": {
						"StreamArn": {},
						"ShardId": {},
						"ShardIteratorType": {},
						"SequenceNumber": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ShardIterator": {}
					}
				}
			},
			"ListStreams": {
				"input": {
					"type": "structure",
					"members": {
						"TableName": {},
						"Limit": {
							"type": "integer"
						},
						"ExclusiveStartStreamArn": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Streams": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"StreamArn": {},
									"TableName": {},
									"StreamLabel": {}
								}
							}
						},
						"LastEvaluatedStreamArn": {}
					}
				}
			}
		},
		"shapes": {
			"Sr": {
				"type": "map",
				"key": {},
				"value": {
					"shape": "St"
				}
			},
			"St": {
				"type": "structure",
				"members": {
					"S": {},
					"N": {},
					"B": {
						"type": "blob"
					},
					"SS": {
						"type": "list",
						"member": {}
					},
					"NS": {
						"type": "list",
						"member": {}
					},
					"BS": {
						"type": "list",
						"member": {
							"type": "blob"
						}
					},
					"M": {
						"type": "map",
						"key": {},
						"value": {
							"shape": "St"
						}
					},
					"L": {
						"type": "list",
						"member": {
							"shape": "St"
						}
					},
					"NULL": {
						"type": "boolean"
					},
					"BOOL": {
						"type": "boolean"
					}
				}
			}
		}
	};

/***/ },
/* 327 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['ec2'] = {};
	AWS.EC2 = Service.defineService('ec2', ['2013-06-15*', '2013-10-15*', '2014-02-01*', '2014-05-01*', '2014-06-15*', '2014-09-01*', '2014-10-01*', '2015-03-01*', '2015-04-15*', '2015-10-01*', '2016-04-01*', '2016-09-15']);
	__webpack_require__(328);
	Object.defineProperty(apiLoader.services['ec2'], '2016-09-15', {
	  get: function get() {
	    var model = __webpack_require__(329);
	    model.paginators = __webpack_require__(330).pagination;
	    model.waiters = __webpack_require__(331).waiters;
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.EC2;


/***/ },
/* 328 */
/***/ function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(93);

	AWS.util.update(AWS.EC2.prototype, {
	  /**
	   * @api private
	   */
	  setupRequestListeners: function setupRequestListeners(request) {
	    request.removeListener('extractError', AWS.EventListeners.Query.EXTRACT_ERROR);
	    request.addListener('extractError', this.extractError);

	    if (request.operation === 'copySnapshot') {
	      request.onAsync('validate', this.buildCopySnapshotPresignedUrl);
	    }
	  },

	  /**
	   * @api private
	   */
	  buildCopySnapshotPresignedUrl: function buildCopySnapshotPresignedUrl(req, done) {
	    if (req.params.PresignedUrl || req._subRequest) {
	      return done();
	    }

	    req.params = AWS.util.copy(req.params);
	    req.params.DestinationRegion = req.service.config.region;

	    var config = AWS.util.copy(req.service.config);
	    delete config.endpoint;
	    config.region = req.params.SourceRegion;
	    var svc = new req.service.constructor(config);
	    var newReq = svc[req.operation](req.params);
	    newReq._subRequest = true;
	    newReq.presign(function(err, url) {
	      if (err) done(err);
	      else {
	        req.params.PresignedUrl = url;
	        done();
	      }
	    });
	  },

	  /**
	   * @api private
	   */
	  extractError: function extractError(resp) {
	    // EC2 nests the error code and message deeper than other AWS Query services.
	    var httpResponse = resp.httpResponse;
	    var data = new AWS.XML.Parser().parse(httpResponse.body.toString() || '');
	    if (data.Errors) {
	      resp.error = AWS.util.error(new Error(), {
	        code: data.Errors.Error.Code,
	        message: data.Errors.Error.Message
	      });
	    } else {
	      resp.error = AWS.util.error(new Error(), {
	        code: httpResponse.statusCode,
	        message: null
	      });
	    }
	    resp.error.requestId = data.RequestID || null;
	  }
	});


/***/ },
/* 329 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2016-09-15",
			"endpointPrefix": "ec2",
			"protocol": "ec2",
			"serviceAbbreviation": "Amazon EC2",
			"serviceFullName": "Amazon Elastic Compute Cloud",
			"signatureVersion": "v4",
			"xmlNamespace": "http://ec2.amazonaws.com/doc/2016-09-15"
		},
		"operations": {
			"AcceptReservedInstancesExchangeQuote": {
				"input": {
					"type": "structure",
					"required": [
						"ReservedInstanceIds"
					],
					"members": {
						"DryRun": {
							"type": "boolean"
						},
						"ReservedInstanceIds": {
							"shape": "S3",
							"locationName": "ReservedInstanceId"
						},
						"TargetConfigurations": {
							"shape": "S5",
							"locationName": "TargetConfiguration"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ExchangeId": {
							"locationName": "exchangeId"
						}
					}
				}
			},
			"AcceptVpcPeeringConnection": {
				"input": {
					"type": "structure",
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"VpcPeeringConnectionId": {
							"locationName": "vpcPeeringConnectionId"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"VpcPeeringConnection": {
							"shape": "Sb",
							"locationName": "vpcPeeringConnection"
						}
					}
				}
			},
			"AllocateAddress": {
				"input": {
					"type": "structure",
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"Domain": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"PublicIp": {
							"locationName": "publicIp"
						},
						"Domain": {
							"locationName": "domain"
						},
						"AllocationId": {
							"locationName": "allocationId"
						}
					}
				}
			},
			"AllocateHosts": {
				"input": {
					"type": "structure",
					"required": [
						"InstanceType",
						"Quantity",
						"AvailabilityZone"
					],
					"members": {
						"AutoPlacement": {
							"locationName": "autoPlacement"
						},
						"ClientToken": {
							"locationName": "clientToken"
						},
						"InstanceType": {
							"locationName": "instanceType"
						},
						"Quantity": {
							"locationName": "quantity",
							"type": "integer"
						},
						"AvailabilityZone": {
							"locationName": "availabilityZone"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"HostIds": {
							"shape": "Sp",
							"locationName": "hostIdSet"
						}
					}
				}
			},
			"AssignPrivateIpAddresses": {
				"input": {
					"type": "structure",
					"required": [
						"NetworkInterfaceId"
					],
					"members": {
						"NetworkInterfaceId": {
							"locationName": "networkInterfaceId"
						},
						"PrivateIpAddresses": {
							"shape": "Sr",
							"locationName": "privateIpAddress"
						},
						"SecondaryPrivateIpAddressCount": {
							"locationName": "secondaryPrivateIpAddressCount",
							"type": "integer"
						},
						"AllowReassignment": {
							"locationName": "allowReassignment",
							"type": "boolean"
						}
					}
				}
			},
			"AssociateAddress": {
				"input": {
					"type": "structure",
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"InstanceId": {},
						"PublicIp": {},
						"AllocationId": {},
						"NetworkInterfaceId": {
							"locationName": "networkInterfaceId"
						},
						"PrivateIpAddress": {
							"locationName": "privateIpAddress"
						},
						"AllowReassociation": {
							"locationName": "allowReassociation",
							"type": "boolean"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"AssociationId": {
							"locationName": "associationId"
						}
					}
				}
			},
			"AssociateDhcpOptions": {
				"input": {
					"type": "structure",
					"required": [
						"DhcpOptionsId",
						"VpcId"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"DhcpOptionsId": {},
						"VpcId": {}
					}
				}
			},
			"AssociateRouteTable": {
				"input": {
					"type": "structure",
					"required": [
						"SubnetId",
						"RouteTableId"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"SubnetId": {
							"locationName": "subnetId"
						},
						"RouteTableId": {
							"locationName": "routeTableId"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"AssociationId": {
							"locationName": "associationId"
						}
					}
				}
			},
			"AttachClassicLinkVpc": {
				"input": {
					"type": "structure",
					"required": [
						"InstanceId",
						"VpcId",
						"Groups"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"InstanceId": {
							"locationName": "instanceId"
						},
						"VpcId": {
							"locationName": "vpcId"
						},
						"Groups": {
							"shape": "Sy",
							"locationName": "SecurityGroupId"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Return": {
							"locationName": "return",
							"type": "boolean"
						}
					}
				}
			},
			"AttachInternetGateway": {
				"input": {
					"type": "structure",
					"required": [
						"InternetGatewayId",
						"VpcId"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"InternetGatewayId": {
							"locationName": "internetGatewayId"
						},
						"VpcId": {
							"locationName": "vpcId"
						}
					}
				}
			},
			"AttachNetworkInterface": {
				"input": {
					"type": "structure",
					"required": [
						"NetworkInterfaceId",
						"InstanceId",
						"DeviceIndex"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"NetworkInterfaceId": {
							"locationName": "networkInterfaceId"
						},
						"InstanceId": {
							"locationName": "instanceId"
						},
						"DeviceIndex": {
							"locationName": "deviceIndex",
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"AttachmentId": {
							"locationName": "attachmentId"
						}
					}
				}
			},
			"AttachVolume": {
				"input": {
					"type": "structure",
					"required": [
						"VolumeId",
						"InstanceId",
						"Device"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"VolumeId": {},
						"InstanceId": {},
						"Device": {}
					}
				},
				"output": {
					"shape": "S14"
				}
			},
			"AttachVpnGateway": {
				"input": {
					"type": "structure",
					"required": [
						"VpnGatewayId",
						"VpcId"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"VpnGatewayId": {},
						"VpcId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"VpcAttachment": {
							"shape": "S18",
							"locationName": "attachment"
						}
					}
				}
			},
			"AuthorizeSecurityGroupEgress": {
				"input": {
					"type": "structure",
					"required": [
						"GroupId"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"GroupId": {
							"locationName": "groupId"
						},
						"SourceSecurityGroupName": {
							"locationName": "sourceSecurityGroupName"
						},
						"SourceSecurityGroupOwnerId": {
							"locationName": "sourceSecurityGroupOwnerId"
						},
						"IpProtocol": {
							"locationName": "ipProtocol"
						},
						"FromPort": {
							"locationName": "fromPort",
							"type": "integer"
						},
						"ToPort": {
							"locationName": "toPort",
							"type": "integer"
						},
						"CidrIp": {
							"locationName": "cidrIp"
						},
						"IpPermissions": {
							"shape": "S1b",
							"locationName": "ipPermissions"
						}
					}
				}
			},
			"AuthorizeSecurityGroupIngress": {
				"input": {
					"type": "structure",
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"GroupName": {},
						"GroupId": {},
						"SourceSecurityGroupName": {},
						"SourceSecurityGroupOwnerId": {},
						"IpProtocol": {},
						"FromPort": {
							"type": "integer"
						},
						"ToPort": {
							"type": "integer"
						},
						"CidrIp": {},
						"IpPermissions": {
							"shape": "S1b"
						}
					}
				}
			},
			"BundleInstance": {
				"input": {
					"type": "structure",
					"required": [
						"InstanceId",
						"Storage"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"InstanceId": {},
						"Storage": {
							"shape": "S1l"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"BundleTask": {
							"shape": "S1p",
							"locationName": "bundleInstanceTask"
						}
					}
				}
			},
			"CancelBundleTask": {
				"input": {
					"type": "structure",
					"required": [
						"BundleId"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"BundleId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"BundleTask": {
							"shape": "S1p",
							"locationName": "bundleInstanceTask"
						}
					}
				}
			},
			"CancelConversionTask": {
				"input": {
					"type": "structure",
					"required": [
						"ConversionTaskId"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"ConversionTaskId": {
							"locationName": "conversionTaskId"
						},
						"ReasonMessage": {
							"locationName": "reasonMessage"
						}
					}
				}
			},
			"CancelExportTask": {
				"input": {
					"type": "structure",
					"required": [
						"ExportTaskId"
					],
					"members": {
						"ExportTaskId": {
							"locationName": "exportTaskId"
						}
					}
				}
			},
			"CancelImportTask": {
				"input": {
					"type": "structure",
					"members": {
						"DryRun": {
							"type": "boolean"
						},
						"ImportTaskId": {},
						"CancelReason": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ImportTaskId": {
							"locationName": "importTaskId"
						},
						"State": {
							"locationName": "state"
						},
						"PreviousState": {
							"locationName": "previousState"
						}
					}
				}
			},
			"CancelReservedInstancesListing": {
				"input": {
					"type": "structure",
					"required": [
						"ReservedInstancesListingId"
					],
					"members": {
						"ReservedInstancesListingId": {
							"locationName": "reservedInstancesListingId"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ReservedInstancesListings": {
							"shape": "S20",
							"locationName": "reservedInstancesListingsSet"
						}
					}
				}
			},
			"CancelSpotFleetRequests": {
				"input": {
					"type": "structure",
					"required": [
						"SpotFleetRequestIds",
						"TerminateInstances"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"SpotFleetRequestIds": {
							"shape": "S2c",
							"locationName": "spotFleetRequestId"
						},
						"TerminateInstances": {
							"locationName": "terminateInstances",
							"type": "boolean"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"UnsuccessfulFleetRequests": {
							"locationName": "unsuccessfulFleetRequestSet",
							"type": "list",
							"member": {
								"locationName": "item",
								"type": "structure",
								"required": [
									"SpotFleetRequestId",
									"Error"
								],
								"members": {
									"SpotFleetRequestId": {
										"locationName": "spotFleetRequestId"
									},
									"Error": {
										"locationName": "error",
										"type": "structure",
										"required": [
											"Code",
											"Message"
										],
										"members": {
											"Code": {
												"locationName": "code"
											},
											"Message": {
												"locationName": "message"
											}
										}
									}
								}
							}
						},
						"SuccessfulFleetRequests": {
							"locationName": "successfulFleetRequestSet",
							"type": "list",
							"member": {
								"locationName": "item",
								"type": "structure",
								"required": [
									"SpotFleetRequestId",
									"CurrentSpotFleetRequestState",
									"PreviousSpotFleetRequestState"
								],
								"members": {
									"SpotFleetRequestId": {
										"locationName": "spotFleetRequestId"
									},
									"CurrentSpotFleetRequestState": {
										"locationName": "currentSpotFleetRequestState"
									},
									"PreviousSpotFleetRequestState": {
										"locationName": "previousSpotFleetRequestState"
									}
								}
							}
						}
					}
				}
			},
			"CancelSpotInstanceRequests": {
				"input": {
					"type": "structure",
					"required": [
						"SpotInstanceRequestIds"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"SpotInstanceRequestIds": {
							"shape": "S2m",
							"locationName": "SpotInstanceRequestId"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"CancelledSpotInstanceRequests": {
							"locationName": "spotInstanceRequestSet",
							"type": "list",
							"member": {
								"locationName": "item",
								"type": "structure",
								"members": {
									"SpotInstanceRequestId": {
										"locationName": "spotInstanceRequestId"
									},
									"State": {
										"locationName": "state"
									}
								}
							}
						}
					}
				}
			},
			"ConfirmProductInstance": {
				"input": {
					"type": "structure",
					"required": [
						"ProductCode",
						"InstanceId"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"ProductCode": {},
						"InstanceId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"OwnerId": {
							"locationName": "ownerId"
						},
						"Return": {
							"locationName": "return",
							"type": "boolean"
						}
					}
				}
			},
			"CopyImage": {
				"input": {
					"type": "structure",
					"required": [
						"SourceRegion",
						"SourceImageId",
						"Name"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"SourceRegion": {},
						"SourceImageId": {},
						"Name": {},
						"Description": {},
						"ClientToken": {},
						"Encrypted": {
							"locationName": "encrypted",
							"type": "boolean"
						},
						"KmsKeyId": {
							"locationName": "kmsKeyId"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ImageId": {
							"locationName": "imageId"
						}
					}
				}
			},
			"CopySnapshot": {
				"input": {
					"type": "structure",
					"required": [
						"SourceRegion",
						"SourceSnapshotId"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"SourceRegion": {},
						"SourceSnapshotId": {},
						"Description": {},
						"DestinationRegion": {
							"locationName": "destinationRegion"
						},
						"PresignedUrl": {
							"locationName": "presignedUrl"
						},
						"Encrypted": {
							"locationName": "encrypted",
							"type": "boolean"
						},
						"KmsKeyId": {
							"locationName": "kmsKeyId"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"SnapshotId": {
							"locationName": "snapshotId"
						}
					}
				}
			},
			"CreateCustomerGateway": {
				"input": {
					"type": "structure",
					"required": [
						"Type",
						"PublicIp",
						"BgpAsn"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"Type": {},
						"PublicIp": {
							"locationName": "IpAddress"
						},
						"BgpAsn": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"CustomerGateway": {
							"shape": "S30",
							"locationName": "customerGateway"
						}
					}
				}
			},
			"CreateDhcpOptions": {
				"input": {
					"type": "structure",
					"required": [
						"DhcpConfigurations"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"DhcpConfigurations": {
							"locationName": "dhcpConfiguration",
							"type": "list",
							"member": {
								"locationName": "item",
								"type": "structure",
								"members": {
									"Key": {
										"locationName": "key"
									},
									"Values": {
										"shape": "S2c",
										"locationName": "Value"
									}
								}
							}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"DhcpOptions": {
							"shape": "S35",
							"locationName": "dhcpOptions"
						}
					}
				}
			},
			"CreateFlowLogs": {
				"input": {
					"type": "structure",
					"required": [
						"ResourceIds",
						"ResourceType",
						"TrafficType",
						"LogGroupName",
						"DeliverLogsPermissionArn"
					],
					"members": {
						"ResourceIds": {
							"shape": "S2c",
							"locationName": "ResourceId"
						},
						"ResourceType": {},
						"TrafficType": {},
						"LogGroupName": {},
						"DeliverLogsPermissionArn": {},
						"ClientToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"FlowLogIds": {
							"shape": "S2c",
							"locationName": "flowLogIdSet"
						},
						"ClientToken": {
							"locationName": "clientToken"
						},
						"Unsuccessful": {
							"shape": "S3e",
							"locationName": "unsuccessful"
						}
					}
				}
			},
			"CreateImage": {
				"input": {
					"type": "structure",
					"required": [
						"InstanceId",
						"Name"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"InstanceId": {
							"locationName": "instanceId"
						},
						"Name": {
							"locationName": "name"
						},
						"Description": {
							"locationName": "description"
						},
						"NoReboot": {
							"locationName": "noReboot",
							"type": "boolean"
						},
						"BlockDeviceMappings": {
							"shape": "S3i",
							"locationName": "blockDeviceMapping"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ImageId": {
							"locationName": "imageId"
						}
					}
				}
			},
			"CreateInstanceExportTask": {
				"input": {
					"type": "structure",
					"required": [
						"InstanceId"
					],
					"members": {
						"Description": {
							"locationName": "description"
						},
						"InstanceId": {
							"locationName": "instanceId"
						},
						"TargetEnvironment": {
							"locationName": "targetEnvironment"
						},
						"ExportToS3Task": {
							"locationName": "exportToS3",
							"type": "structure",
							"members": {
								"DiskImageFormat": {
									"locationName": "diskImageFormat"
								},
								"ContainerFormat": {
									"locationName": "containerFormat"
								},
								"S3Bucket": {
									"locationName": "s3Bucket"
								},
								"S3Prefix": {
									"locationName": "s3Prefix"
								}
							}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ExportTask": {
							"shape": "S3t",
							"locationName": "exportTask"
						}
					}
				}
			},
			"CreateInternetGateway": {
				"input": {
					"type": "structure",
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"InternetGateway": {
							"shape": "S3z",
							"locationName": "internetGateway"
						}
					}
				}
			},
			"CreateKeyPair": {
				"input": {
					"type": "structure",
					"required": [
						"KeyName"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"KeyName": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"KeyName": {
							"locationName": "keyName"
						},
						"KeyFingerprint": {
							"locationName": "keyFingerprint"
						},
						"KeyMaterial": {
							"locationName": "keyMaterial"
						}
					}
				}
			},
			"CreateNatGateway": {
				"input": {
					"type": "structure",
					"required": [
						"SubnetId",
						"AllocationId"
					],
					"members": {
						"SubnetId": {},
						"AllocationId": {},
						"ClientToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"NatGateway": {
							"shape": "S46",
							"locationName": "natGateway"
						},
						"ClientToken": {
							"locationName": "clientToken"
						}
					}
				}
			},
			"CreateNetworkAcl": {
				"input": {
					"type": "structure",
					"required": [
						"VpcId"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"VpcId": {
							"locationName": "vpcId"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"NetworkAcl": {
							"shape": "S4d",
							"locationName": "networkAcl"
						}
					}
				}
			},
			"CreateNetworkAclEntry": {
				"input": {
					"type": "structure",
					"required": [
						"NetworkAclId",
						"RuleNumber",
						"Protocol",
						"RuleAction",
						"Egress",
						"CidrBlock"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"NetworkAclId": {
							"locationName": "networkAclId"
						},
						"RuleNumber": {
							"locationName": "ruleNumber",
							"type": "integer"
						},
						"Protocol": {
							"locationName": "protocol"
						},
						"RuleAction": {
							"locationName": "ruleAction"
						},
						"Egress": {
							"locationName": "egress",
							"type": "boolean"
						},
						"CidrBlock": {
							"locationName": "cidrBlock"
						},
						"IcmpTypeCode": {
							"shape": "S4h",
							"locationName": "Icmp"
						},
						"PortRange": {
							"shape": "S4i",
							"locationName": "portRange"
						}
					}
				}
			},
			"CreateNetworkInterface": {
				"input": {
					"type": "structure",
					"required": [
						"SubnetId"
					],
					"members": {
						"SubnetId": {
							"locationName": "subnetId"
						},
						"Description": {
							"locationName": "description"
						},
						"PrivateIpAddress": {
							"locationName": "privateIpAddress"
						},
						"Groups": {
							"shape": "S4n",
							"locationName": "SecurityGroupId"
						},
						"PrivateIpAddresses": {
							"shape": "S4o",
							"locationName": "privateIpAddresses"
						},
						"SecondaryPrivateIpAddressCount": {
							"locationName": "secondaryPrivateIpAddressCount",
							"type": "integer"
						},
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"NetworkInterface": {
							"shape": "S4r",
							"locationName": "networkInterface"
						}
					}
				}
			},
			"CreatePlacementGroup": {
				"input": {
					"type": "structure",
					"required": [
						"GroupName",
						"Strategy"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"GroupName": {
							"locationName": "groupName"
						},
						"Strategy": {
							"locationName": "strategy"
						}
					}
				}
			},
			"CreateReservedInstancesListing": {
				"input": {
					"type": "structure",
					"required": [
						"ReservedInstancesId",
						"InstanceCount",
						"PriceSchedules",
						"ClientToken"
					],
					"members": {
						"ReservedInstancesId": {
							"locationName": "reservedInstancesId"
						},
						"InstanceCount": {
							"locationName": "instanceCount",
							"type": "integer"
						},
						"PriceSchedules": {
							"locationName": "priceSchedules",
							"type": "list",
							"member": {
								"locationName": "item",
								"type": "structure",
								"members": {
									"Term": {
										"locationName": "term",
										"type": "long"
									},
									"Price": {
										"locationName": "price",
										"type": "double"
									},
									"CurrencyCode": {
										"locationName": "currencyCode"
									}
								}
							}
						},
						"ClientToken": {
							"locationName": "clientToken"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ReservedInstancesListings": {
							"shape": "S20",
							"locationName": "reservedInstancesListingsSet"
						}
					}
				}
			},
			"CreateRoute": {
				"input": {
					"type": "structure",
					"required": [
						"RouteTableId",
						"DestinationCidrBlock"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"RouteTableId": {
							"locationName": "routeTableId"
						},
						"DestinationCidrBlock": {
							"locationName": "destinationCidrBlock"
						},
						"GatewayId": {
							"locationName": "gatewayId"
						},
						"InstanceId": {
							"locationName": "instanceId"
						},
						"NetworkInterfaceId": {
							"locationName": "networkInterfaceId"
						},
						"VpcPeeringConnectionId": {
							"locationName": "vpcPeeringConnectionId"
						},
						"NatGatewayId": {
							"locationName": "natGatewayId"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Return": {
							"locationName": "return",
							"type": "boolean"
						}
					}
				}
			},
			"CreateRouteTable": {
				"input": {
					"type": "structure",
					"required": [
						"VpcId"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"VpcId": {
							"locationName": "vpcId"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"RouteTable": {
							"shape": "S5a",
							"locationName": "routeTable"
						}
					}
				}
			},
			"CreateSecurityGroup": {
				"input": {
					"type": "structure",
					"required": [
						"GroupName",
						"Description"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"GroupName": {},
						"Description": {
							"locationName": "GroupDescription"
						},
						"VpcId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"GroupId": {
							"locationName": "groupId"
						}
					}
				}
			},
			"CreateSnapshot": {
				"input": {
					"type": "structure",
					"required": [
						"VolumeId"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"VolumeId": {},
						"Description": {}
					}
				},
				"output": {
					"shape": "S5m"
				}
			},
			"CreateSpotDatafeedSubscription": {
				"input": {
					"type": "structure",
					"required": [
						"Bucket"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"Bucket": {
							"locationName": "bucket"
						},
						"Prefix": {
							"locationName": "prefix"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"SpotDatafeedSubscription": {
							"shape": "S5q",
							"locationName": "spotDatafeedSubscription"
						}
					}
				}
			},
			"CreateSubnet": {
				"input": {
					"type": "structure",
					"required": [
						"VpcId",
						"CidrBlock"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"VpcId": {},
						"CidrBlock": {},
						"AvailabilityZone": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Subnet": {
							"shape": "S5v",
							"locationName": "subnet"
						}
					}
				}
			},
			"CreateTags": {
				"input": {
					"type": "structure",
					"required": [
						"Resources",
						"Tags"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"Resources": {
							"shape": "S5y",
							"locationName": "ResourceId"
						},
						"Tags": {
							"shape": "Sh",
							"locationName": "Tag"
						}
					}
				}
			},
			"CreateVolume": {
				"input": {
					"type": "structure",
					"required": [
						"AvailabilityZone"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"Size": {
							"type": "integer"
						},
						"SnapshotId": {},
						"AvailabilityZone": {},
						"VolumeType": {},
						"Iops": {
							"type": "integer"
						},
						"Encrypted": {
							"locationName": "encrypted",
							"type": "boolean"
						},
						"KmsKeyId": {}
					}
				},
				"output": {
					"shape": "S60"
				}
			},
			"CreateVpc": {
				"input": {
					"type": "structure",
					"required": [
						"CidrBlock"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"CidrBlock": {},
						"InstanceTenancy": {
							"locationName": "instanceTenancy"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Vpc": {
							"shape": "S66",
							"locationName": "vpc"
						}
					}
				}
			},
			"CreateVpcEndpoint": {
				"input": {
					"type": "structure",
					"required": [
						"VpcId",
						"ServiceName"
					],
					"members": {
						"DryRun": {
							"type": "boolean"
						},
						"VpcId": {},
						"ServiceName": {},
						"PolicyDocument": {},
						"RouteTableIds": {
							"shape": "S2c",
							"locationName": "RouteTableId"
						},
						"ClientToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"VpcEndpoint": {
							"shape": "S6a",
							"locationName": "vpcEndpoint"
						},
						"ClientToken": {
							"locationName": "clientToken"
						}
					}
				}
			},
			"CreateVpcPeeringConnection": {
				"input": {
					"type": "structure",
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"VpcId": {
							"locationName": "vpcId"
						},
						"PeerVpcId": {
							"locationName": "peerVpcId"
						},
						"PeerOwnerId": {
							"locationName": "peerOwnerId"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"VpcPeeringConnection": {
							"shape": "Sb",
							"locationName": "vpcPeeringConnection"
						}
					}
				}
			},
			"CreateVpnConnection": {
				"input": {
					"type": "structure",
					"required": [
						"Type",
						"CustomerGatewayId",
						"VpnGatewayId"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"Type": {},
						"CustomerGatewayId": {},
						"VpnGatewayId": {},
						"Options": {
							"locationName": "options",
							"type": "structure",
							"members": {
								"StaticRoutesOnly": {
									"locationName": "staticRoutesOnly",
									"type": "boolean"
								}
							}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"VpnConnection": {
							"shape": "S6h",
							"locationName": "vpnConnection"
						}
					}
				}
			},
			"CreateVpnConnectionRoute": {
				"input": {
					"type": "structure",
					"required": [
						"VpnConnectionId",
						"DestinationCidrBlock"
					],
					"members": {
						"VpnConnectionId": {},
						"DestinationCidrBlock": {}
					}
				}
			},
			"CreateVpnGateway": {
				"input": {
					"type": "structure",
					"required": [
						"Type"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"Type": {},
						"AvailabilityZone": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"VpnGateway": {
							"shape": "S6t",
							"locationName": "vpnGateway"
						}
					}
				}
			},
			"DeleteCustomerGateway": {
				"input": {
					"type": "structure",
					"required": [
						"CustomerGatewayId"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"CustomerGatewayId": {}
					}
				}
			},
			"DeleteDhcpOptions": {
				"input": {
					"type": "structure",
					"required": [
						"DhcpOptionsId"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"DhcpOptionsId": {}
					}
				}
			},
			"DeleteFlowLogs": {
				"input": {
					"type": "structure",
					"required": [
						"FlowLogIds"
					],
					"members": {
						"FlowLogIds": {
							"shape": "S2c",
							"locationName": "FlowLogId"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Unsuccessful": {
							"shape": "S3e",
							"locationName": "unsuccessful"
						}
					}
				}
			},
			"DeleteInternetGateway": {
				"input": {
					"type": "structure",
					"required": [
						"InternetGatewayId"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"InternetGatewayId": {
							"locationName": "internetGatewayId"
						}
					}
				}
			},
			"DeleteKeyPair": {
				"input": {
					"type": "structure",
					"required": [
						"KeyName"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"KeyName": {}
					}
				}
			},
			"DeleteNatGateway": {
				"input": {
					"type": "structure",
					"required": [
						"NatGatewayId"
					],
					"members": {
						"NatGatewayId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"NatGatewayId": {
							"locationName": "natGatewayId"
						}
					}
				}
			},
			"DeleteNetworkAcl": {
				"input": {
					"type": "structure",
					"required": [
						"NetworkAclId"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"NetworkAclId": {
							"locationName": "networkAclId"
						}
					}
				}
			},
			"DeleteNetworkAclEntry": {
				"input": {
					"type": "structure",
					"required": [
						"NetworkAclId",
						"RuleNumber",
						"Egress"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"NetworkAclId": {
							"locationName": "networkAclId"
						},
						"RuleNumber": {
							"locationName": "ruleNumber",
							"type": "integer"
						},
						"Egress": {
							"locationName": "egress",
							"type": "boolean"
						}
					}
				}
			},
			"DeleteNetworkInterface": {
				"input": {
					"type": "structure",
					"required": [
						"NetworkInterfaceId"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"NetworkInterfaceId": {
							"locationName": "networkInterfaceId"
						}
					}
				}
			},
			"DeletePlacementGroup": {
				"input": {
					"type": "structure",
					"required": [
						"GroupName"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"GroupName": {
							"locationName": "groupName"
						}
					}
				}
			},
			"DeleteRoute": {
				"input": {
					"type": "structure",
					"required": [
						"RouteTableId",
						"DestinationCidrBlock"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"RouteTableId": {
							"locationName": "routeTableId"
						},
						"DestinationCidrBlock": {
							"locationName": "destinationCidrBlock"
						}
					}
				}
			},
			"DeleteRouteTable": {
				"input": {
					"type": "structure",
					"required": [
						"RouteTableId"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"RouteTableId": {
							"locationName": "routeTableId"
						}
					}
				}
			},
			"DeleteSecurityGroup": {
				"input": {
					"type": "structure",
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"GroupName": {},
						"GroupId": {}
					}
				}
			},
			"DeleteSnapshot": {
				"input": {
					"type": "structure",
					"required": [
						"SnapshotId"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"SnapshotId": {}
					}
				}
			},
			"DeleteSpotDatafeedSubscription": {
				"input": {
					"type": "structure",
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						}
					}
				}
			},
			"DeleteSubnet": {
				"input": {
					"type": "structure",
					"required": [
						"SubnetId"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"SubnetId": {}
					}
				}
			},
			"DeleteTags": {
				"input": {
					"type": "structure",
					"required": [
						"Resources"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"Resources": {
							"shape": "S5y",
							"locationName": "resourceId"
						},
						"Tags": {
							"shape": "Sh",
							"locationName": "tag"
						}
					}
				}
			},
			"DeleteVolume": {
				"input": {
					"type": "structure",
					"required": [
						"VolumeId"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"VolumeId": {}
					}
				}
			},
			"DeleteVpc": {
				"input": {
					"type": "structure",
					"required": [
						"VpcId"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"VpcId": {}
					}
				}
			},
			"DeleteVpcEndpoints": {
				"input": {
					"type": "structure",
					"required": [
						"VpcEndpointIds"
					],
					"members": {
						"DryRun": {
							"type": "boolean"
						},
						"VpcEndpointIds": {
							"shape": "S2c",
							"locationName": "VpcEndpointId"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Unsuccessful": {
							"shape": "S3e",
							"locationName": "unsuccessful"
						}
					}
				}
			},
			"DeleteVpcPeeringConnection": {
				"input": {
					"type": "structure",
					"required": [
						"VpcPeeringConnectionId"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"VpcPeeringConnectionId": {
							"locationName": "vpcPeeringConnectionId"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Return": {
							"locationName": "return",
							"type": "boolean"
						}
					}
				}
			},
			"DeleteVpnConnection": {
				"input": {
					"type": "structure",
					"required": [
						"VpnConnectionId"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"VpnConnectionId": {}
					}
				}
			},
			"DeleteVpnConnectionRoute": {
				"input": {
					"type": "structure",
					"required": [
						"VpnConnectionId",
						"DestinationCidrBlock"
					],
					"members": {
						"VpnConnectionId": {},
						"DestinationCidrBlock": {}
					}
				}
			},
			"DeleteVpnGateway": {
				"input": {
					"type": "structure",
					"required": [
						"VpnGatewayId"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"VpnGatewayId": {}
					}
				}
			},
			"DeregisterImage": {
				"input": {
					"type": "structure",
					"required": [
						"ImageId"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"ImageId": {}
					}
				}
			},
			"DescribeAccountAttributes": {
				"input": {
					"type": "structure",
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"AttributeNames": {
							"locationName": "attributeName",
							"type": "list",
							"member": {
								"locationName": "attributeName"
							}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"AccountAttributes": {
							"locationName": "accountAttributeSet",
							"type": "list",
							"member": {
								"locationName": "item",
								"type": "structure",
								"members": {
									"AttributeName": {
										"locationName": "attributeName"
									},
									"AttributeValues": {
										"locationName": "attributeValueSet",
										"type": "list",
										"member": {
											"locationName": "item",
											"type": "structure",
											"members": {
												"AttributeValue": {
													"locationName": "attributeValue"
												}
											}
										}
									}
								}
							}
						}
					}
				}
			},
			"DescribeAddresses": {
				"input": {
					"type": "structure",
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"PublicIps": {
							"locationName": "PublicIp",
							"type": "list",
							"member": {
								"locationName": "PublicIp"
							}
						},
						"Filters": {
							"shape": "S7y",
							"locationName": "Filter"
						},
						"AllocationIds": {
							"locationName": "AllocationId",
							"type": "list",
							"member": {
								"locationName": "AllocationId"
							}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Addresses": {
							"locationName": "addressesSet",
							"type": "list",
							"member": {
								"locationName": "item",
								"type": "structure",
								"members": {
									"InstanceId": {
										"locationName": "instanceId"
									},
									"PublicIp": {
										"locationName": "publicIp"
									},
									"AllocationId": {
										"locationName": "allocationId"
									},
									"AssociationId": {
										"locationName": "associationId"
									},
									"Domain": {
										"locationName": "domain"
									},
									"NetworkInterfaceId": {
										"locationName": "networkInterfaceId"
									},
									"NetworkInterfaceOwnerId": {
										"locationName": "networkInterfaceOwnerId"
									},
									"PrivateIpAddress": {
										"locationName": "privateIpAddress"
									}
								}
							}
						}
					}
				}
			},
			"DescribeAvailabilityZones": {
				"input": {
					"type": "structure",
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"ZoneNames": {
							"locationName": "ZoneName",
							"type": "list",
							"member": {
								"locationName": "ZoneName"
							}
						},
						"Filters": {
							"shape": "S7y",
							"locationName": "Filter"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"AvailabilityZones": {
							"locationName": "availabilityZoneInfo",
							"type": "list",
							"member": {
								"locationName": "item",
								"type": "structure",
								"members": {
									"ZoneName": {
										"locationName": "zoneName"
									},
									"State": {
										"locationName": "zoneState"
									},
									"RegionName": {
										"locationName": "regionName"
									},
									"Messages": {
										"locationName": "messageSet",
										"type": "list",
										"member": {
											"locationName": "item",
											"type": "structure",
											"members": {
												"Message": {
													"locationName": "message"
												}
											}
										}
									}
								}
							}
						}
					}
				}
			},
			"DescribeBundleTasks": {
				"input": {
					"type": "structure",
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"BundleIds": {
							"locationName": "BundleId",
							"type": "list",
							"member": {
								"locationName": "BundleId"
							}
						},
						"Filters": {
							"shape": "S7y",
							"locationName": "Filter"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"BundleTasks": {
							"locationName": "bundleInstanceTasksSet",
							"type": "list",
							"member": {
								"shape": "S1p",
								"locationName": "item"
							}
						}
					}
				}
			},
			"DescribeClassicLinkInstances": {
				"input": {
					"type": "structure",
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"InstanceIds": {
							"shape": "S8h",
							"locationName": "InstanceId"
						},
						"Filters": {
							"shape": "S7y",
							"locationName": "Filter"
						},
						"NextToken": {
							"locationName": "nextToken"
						},
						"MaxResults": {
							"locationName": "maxResults",
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Instances": {
							"locationName": "instancesSet",
							"type": "list",
							"member": {
								"locationName": "item",
								"type": "structure",
								"members": {
									"InstanceId": {
										"locationName": "instanceId"
									},
									"VpcId": {
										"locationName": "vpcId"
									},
									"Groups": {
										"shape": "S4t",
										"locationName": "groupSet"
									},
									"Tags": {
										"shape": "Sh",
										"locationName": "tagSet"
									}
								}
							}
						},
						"NextToken": {
							"locationName": "nextToken"
						}
					}
				}
			},
			"DescribeConversionTasks": {
				"input": {
					"type": "structure",
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"ConversionTaskIds": {
							"locationName": "conversionTaskId",
							"type": "list",
							"member": {
								"locationName": "item"
							}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ConversionTasks": {
							"locationName": "conversionTasks",
							"type": "list",
							"member": {
								"shape": "S8p",
								"locationName": "item"
							}
						}
					}
				}
			},
			"DescribeCustomerGateways": {
				"input": {
					"type": "structure",
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"CustomerGatewayIds": {
							"locationName": "CustomerGatewayId",
							"type": "list",
							"member": {
								"locationName": "CustomerGatewayId"
							}
						},
						"Filters": {
							"shape": "S7y",
							"locationName": "Filter"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"CustomerGateways": {
							"locationName": "customerGatewaySet",
							"type": "list",
							"member": {
								"shape": "S30",
								"locationName": "item"
							}
						}
					}
				}
			},
			"DescribeDhcpOptions": {
				"input": {
					"type": "structure",
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"DhcpOptionsIds": {
							"locationName": "DhcpOptionsId",
							"type": "list",
							"member": {
								"locationName": "DhcpOptionsId"
							}
						},
						"Filters": {
							"shape": "S7y",
							"locationName": "Filter"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"DhcpOptions": {
							"locationName": "dhcpOptionsSet",
							"type": "list",
							"member": {
								"shape": "S35",
								"locationName": "item"
							}
						}
					}
				}
			},
			"DescribeExportTasks": {
				"input": {
					"type": "structure",
					"members": {
						"ExportTaskIds": {
							"locationName": "exportTaskId",
							"type": "list",
							"member": {
								"locationName": "ExportTaskId"
							}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ExportTasks": {
							"locationName": "exportTaskSet",
							"type": "list",
							"member": {
								"shape": "S3t",
								"locationName": "item"
							}
						}
					}
				}
			},
			"DescribeFlowLogs": {
				"input": {
					"type": "structure",
					"members": {
						"FlowLogIds": {
							"shape": "S2c",
							"locationName": "FlowLogId"
						},
						"Filter": {
							"shape": "S7y"
						},
						"NextToken": {},
						"MaxResults": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"FlowLogs": {
							"locationName": "flowLogSet",
							"type": "list",
							"member": {
								"locationName": "item",
								"type": "structure",
								"members": {
									"CreationTime": {
										"locationName": "creationTime",
										"type": "timestamp"
									},
									"FlowLogId": {
										"locationName": "flowLogId"
									},
									"FlowLogStatus": {
										"locationName": "flowLogStatus"
									},
									"ResourceId": {
										"locationName": "resourceId"
									},
									"TrafficType": {
										"locationName": "trafficType"
									},
									"LogGroupName": {
										"locationName": "logGroupName"
									},
									"DeliverLogsStatus": {
										"locationName": "deliverLogsStatus"
									},
									"DeliverLogsErrorMessage": {
										"locationName": "deliverLogsErrorMessage"
									},
									"DeliverLogsPermissionArn": {
										"locationName": "deliverLogsPermissionArn"
									}
								}
							}
						},
						"NextToken": {
							"locationName": "nextToken"
						}
					}
				}
			},
			"DescribeHostReservationOfferings": {
				"input": {
					"type": "structure",
					"members": {
						"OfferingId": {},
						"MinDuration": {
							"type": "integer"
						},
						"MaxDuration": {
							"type": "integer"
						},
						"Filter": {
							"shape": "S7y"
						},
						"MaxResults": {
							"type": "integer"
						},
						"NextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"OfferingSet": {
							"locationName": "offeringSet",
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"OfferingId": {
										"locationName": "offeringId"
									},
									"InstanceFamily": {
										"locationName": "instanceFamily"
									},
									"PaymentOption": {
										"locationName": "paymentOption"
									},
									"UpfrontPrice": {
										"locationName": "upfrontPrice"
									},
									"HourlyPrice": {
										"locationName": "hourlyPrice"
									},
									"CurrencyCode": {
										"locationName": "currencyCode"
									},
									"Duration": {
										"locationName": "duration",
										"type": "integer"
									}
								}
							}
						},
						"NextToken": {
							"locationName": "nextToken"
						}
					}
				}
			},
			"DescribeHostReservations": {
				"input": {
					"type": "structure",
					"members": {
						"HostReservationIdSet": {
							"type": "list",
							"member": {
								"locationName": "item"
							}
						},
						"Filter": {
							"shape": "S7y"
						},
						"MaxResults": {
							"type": "integer"
						},
						"NextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"HostReservationSet": {
							"locationName": "hostReservationSet",
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"HostReservationId": {
										"locationName": "hostReservationId"
									},
									"HostIdSet": {
										"shape": "S9o",
										"locationName": "hostIdSet"
									},
									"OfferingId": {
										"locationName": "offeringId"
									},
									"InstanceFamily": {
										"locationName": "instanceFamily"
									},
									"PaymentOption": {
										"locationName": "paymentOption"
									},
									"HourlyPrice": {
										"locationName": "hourlyPrice"
									},
									"UpfrontPrice": {
										"locationName": "upfrontPrice"
									},
									"CurrencyCode": {
										"locationName": "currencyCode"
									},
									"Count": {
										"locationName": "count",
										"type": "integer"
									},
									"Duration": {
										"locationName": "duration",
										"type": "integer"
									},
									"End": {
										"locationName": "end",
										"type": "timestamp"
									},
									"Start": {
										"locationName": "start",
										"type": "timestamp"
									},
									"State": {
										"locationName": "state"
									}
								}
							}
						},
						"NextToken": {
							"locationName": "nextToken"
						}
					}
				}
			},
			"DescribeHosts": {
				"input": {
					"type": "structure",
					"members": {
						"HostIds": {
							"shape": "S9r",
							"locationName": "hostId"
						},
						"NextToken": {
							"locationName": "nextToken"
						},
						"MaxResults": {
							"locationName": "maxResults",
							"type": "integer"
						},
						"Filter": {
							"shape": "S7y",
							"locationName": "filter"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Hosts": {
							"locationName": "hostSet",
							"type": "list",
							"member": {
								"locationName": "item",
								"type": "structure",
								"members": {
									"HostId": {
										"locationName": "hostId"
									},
									"AutoPlacement": {
										"locationName": "autoPlacement"
									},
									"HostReservationId": {
										"locationName": "hostReservationId"
									},
									"ClientToken": {
										"locationName": "clientToken"
									},
									"HostProperties": {
										"locationName": "hostProperties",
										"type": "structure",
										"members": {
											"Sockets": {
												"locationName": "sockets",
												"type": "integer"
											},
											"Cores": {
												"locationName": "cores",
												"type": "integer"
											},
											"TotalVCpus": {
												"locationName": "totalVCpus",
												"type": "integer"
											},
											"InstanceType": {
												"locationName": "instanceType"
											}
										}
									},
									"State": {
										"locationName": "state"
									},
									"AvailabilityZone": {
										"locationName": "availabilityZone"
									},
									"Instances": {
										"locationName": "instances",
										"type": "list",
										"member": {
											"locationName": "item",
											"type": "structure",
											"members": {
												"InstanceId": {
													"locationName": "instanceId"
												},
												"InstanceType": {
													"locationName": "instanceType"
												}
											}
										}
									},
									"AvailableCapacity": {
										"locationName": "availableCapacity",
										"type": "structure",
										"members": {
											"AvailableInstanceCapacity": {
												"locationName": "availableInstanceCapacity",
												"type": "list",
												"member": {
													"locationName": "item",
													"type": "structure",
													"members": {
														"InstanceType": {
															"locationName": "instanceType"
														},
														"AvailableCapacity": {
															"locationName": "availableCapacity",
															"type": "integer"
														},
														"TotalCapacity": {
															"locationName": "totalCapacity",
															"type": "integer"
														}
													}
												}
											},
											"AvailableVCpus": {
												"locationName": "availableVCpus",
												"type": "integer"
											}
										}
									}
								}
							}
						},
						"NextToken": {
							"locationName": "nextToken"
						}
					}
				}
			},
			"DescribeIdFormat": {
				"input": {
					"type": "structure",
					"members": {
						"Resource": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Statuses": {
							"shape": "Sa4",
							"locationName": "statusSet"
						}
					}
				}
			},
			"DescribeIdentityIdFormat": {
				"input": {
					"type": "structure",
					"required": [
						"PrincipalArn"
					],
					"members": {
						"Resource": {
							"locationName": "resource"
						},
						"PrincipalArn": {
							"locationName": "principalArn"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Statuses": {
							"shape": "Sa4",
							"locationName": "statusSet"
						}
					}
				}
			},
			"DescribeImageAttribute": {
				"input": {
					"type": "structure",
					"required": [
						"ImageId",
						"Attribute"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"ImageId": {},
						"Attribute": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ImageId": {
							"locationName": "imageId"
						},
						"LaunchPermissions": {
							"shape": "Sab",
							"locationName": "launchPermission"
						},
						"ProductCodes": {
							"shape": "Sae",
							"locationName": "productCodes"
						},
						"KernelId": {
							"shape": "S39",
							"locationName": "kernel"
						},
						"RamdiskId": {
							"shape": "S39",
							"locationName": "ramdisk"
						},
						"Description": {
							"shape": "S39",
							"locationName": "description"
						},
						"SriovNetSupport": {
							"shape": "S39",
							"locationName": "sriovNetSupport"
						},
						"BlockDeviceMappings": {
							"shape": "Sah",
							"locationName": "blockDeviceMapping"
						}
					}
				}
			},
			"DescribeImages": {
				"input": {
					"type": "structure",
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"ImageIds": {
							"locationName": "ImageId",
							"type": "list",
							"member": {
								"locationName": "ImageId"
							}
						},
						"Owners": {
							"shape": "Sak",
							"locationName": "Owner"
						},
						"ExecutableUsers": {
							"locationName": "ExecutableBy",
							"type": "list",
							"member": {
								"locationName": "ExecutableBy"
							}
						},
						"Filters": {
							"shape": "S7y",
							"locationName": "Filter"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Images": {
							"locationName": "imagesSet",
							"type": "list",
							"member": {
								"locationName": "item",
								"type": "structure",
								"members": {
									"ImageId": {
										"locationName": "imageId"
									},
									"ImageLocation": {
										"locationName": "imageLocation"
									},
									"State": {
										"locationName": "imageState"
									},
									"OwnerId": {
										"locationName": "imageOwnerId"
									},
									"CreationDate": {
										"locationName": "creationDate"
									},
									"Public": {
										"locationName": "isPublic",
										"type": "boolean"
									},
									"ProductCodes": {
										"shape": "Sae",
										"locationName": "productCodes"
									},
									"Architecture": {
										"locationName": "architecture"
									},
									"ImageType": {
										"locationName": "imageType"
									},
									"KernelId": {
										"locationName": "kernelId"
									},
									"RamdiskId": {
										"locationName": "ramdiskId"
									},
									"Platform": {
										"locationName": "platform"
									},
									"SriovNetSupport": {
										"locationName": "sriovNetSupport"
									},
									"EnaSupport": {
										"locationName": "enaSupport",
										"type": "boolean"
									},
									"StateReason": {
										"shape": "Sas",
										"locationName": "stateReason"
									},
									"ImageOwnerAlias": {
										"locationName": "imageOwnerAlias"
									},
									"Name": {
										"locationName": "name"
									},
									"Description": {
										"locationName": "description"
									},
									"RootDeviceType": {
										"locationName": "rootDeviceType"
									},
									"RootDeviceName": {
										"locationName": "rootDeviceName"
									},
									"BlockDeviceMappings": {
										"shape": "Sah",
										"locationName": "blockDeviceMapping"
									},
									"VirtualizationType": {
										"locationName": "virtualizationType"
									},
									"Tags": {
										"shape": "Sh",
										"locationName": "tagSet"
									},
									"Hypervisor": {
										"locationName": "hypervisor"
									}
								}
							}
						}
					}
				}
			},
			"DescribeImportImageTasks": {
				"input": {
					"type": "structure",
					"members": {
						"DryRun": {
							"type": "boolean"
						},
						"ImportTaskIds": {
							"shape": "Sax",
							"locationName": "ImportTaskId"
						},
						"NextToken": {},
						"MaxResults": {
							"type": "integer"
						},
						"Filters": {
							"shape": "S7y"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ImportImageTasks": {
							"locationName": "importImageTaskSet",
							"type": "list",
							"member": {
								"locationName": "item",
								"type": "structure",
								"members": {
									"ImportTaskId": {
										"locationName": "importTaskId"
									},
									"Architecture": {
										"locationName": "architecture"
									},
									"LicenseType": {
										"locationName": "licenseType"
									},
									"Platform": {
										"locationName": "platform"
									},
									"Hypervisor": {
										"locationName": "hypervisor"
									},
									"Description": {
										"locationName": "description"
									},
									"SnapshotDetails": {
										"shape": "Sb1",
										"locationName": "snapshotDetailSet"
									},
									"ImageId": {
										"locationName": "imageId"
									},
									"Progress": {
										"locationName": "progress"
									},
									"StatusMessage": {
										"locationName": "statusMessage"
									},
									"Status": {
										"locationName": "status"
									}
								}
							}
						},
						"NextToken": {
							"locationName": "nextToken"
						}
					}
				}
			},
			"DescribeImportSnapshotTasks": {
				"input": {
					"type": "structure",
					"members": {
						"DryRun": {
							"type": "boolean"
						},
						"ImportTaskIds": {
							"shape": "Sax",
							"locationName": "ImportTaskId"
						},
						"NextToken": {},
						"MaxResults": {
							"type": "integer"
						},
						"Filters": {
							"shape": "S7y"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ImportSnapshotTasks": {
							"locationName": "importSnapshotTaskSet",
							"type": "list",
							"member": {
								"locationName": "item",
								"type": "structure",
								"members": {
									"ImportTaskId": {
										"locationName": "importTaskId"
									},
									"SnapshotTaskDetail": {
										"shape": "Sb8",
										"locationName": "snapshotTaskDetail"
									},
									"Description": {
										"locationName": "description"
									}
								}
							}
						},
						"NextToken": {
							"locationName": "nextToken"
						}
					}
				}
			},
			"DescribeInstanceAttribute": {
				"input": {
					"type": "structure",
					"required": [
						"InstanceId",
						"Attribute"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"InstanceId": {
							"locationName": "instanceId"
						},
						"Attribute": {
							"locationName": "attribute"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"InstanceId": {
							"locationName": "instanceId"
						},
						"InstanceType": {
							"shape": "S39",
							"locationName": "instanceType"
						},
						"KernelId": {
							"shape": "S39",
							"locationName": "kernel"
						},
						"RamdiskId": {
							"shape": "S39",
							"locationName": "ramdisk"
						},
						"UserData": {
							"shape": "S39",
							"locationName": "userData"
						},
						"DisableApiTermination": {
							"shape": "Sbc",
							"locationName": "disableApiTermination"
						},
						"InstanceInitiatedShutdownBehavior": {
							"shape": "S39",
							"locationName": "instanceInitiatedShutdownBehavior"
						},
						"RootDeviceName": {
							"shape": "S39",
							"locationName": "rootDeviceName"
						},
						"BlockDeviceMappings": {
							"shape": "Sbd",
							"locationName": "blockDeviceMapping"
						},
						"ProductCodes": {
							"shape": "Sae",
							"locationName": "productCodes"
						},
						"EbsOptimized": {
							"shape": "Sbc",
							"locationName": "ebsOptimized"
						},
						"SriovNetSupport": {
							"shape": "S39",
							"locationName": "sriovNetSupport"
						},
						"EnaSupport": {
							"shape": "Sbc",
							"locationName": "enaSupport"
						},
						"SourceDestCheck": {
							"shape": "Sbc",
							"locationName": "sourceDestCheck"
						},
						"Groups": {
							"shape": "S4t",
							"locationName": "groupSet"
						}
					}
				}
			},
			"DescribeInstanceStatus": {
				"input": {
					"type": "structure",
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"InstanceIds": {
							"shape": "S8h",
							"locationName": "InstanceId"
						},
						"Filters": {
							"shape": "S7y",
							"locationName": "Filter"
						},
						"NextToken": {},
						"MaxResults": {
							"type": "integer"
						},
						"IncludeAllInstances": {
							"locationName": "includeAllInstances",
							"type": "boolean"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"InstanceStatuses": {
							"locationName": "instanceStatusSet",
							"type": "list",
							"member": {
								"locationName": "item",
								"type": "structure",
								"members": {
									"InstanceId": {
										"locationName": "instanceId"
									},
									"AvailabilityZone": {
										"locationName": "availabilityZone"
									},
									"Events": {
										"locationName": "eventsSet",
										"type": "list",
										"member": {
											"locationName": "item",
											"type": "structure",
											"members": {
												"Code": {
													"locationName": "code"
												},
												"Description": {
													"locationName": "description"
												},
												"NotBefore": {
													"locationName": "notBefore",
													"type": "timestamp"
												},
												"NotAfter": {
													"locationName": "notAfter",
													"type": "timestamp"
												}
											}
										}
									},
									"InstanceState": {
										"shape": "Sbn",
										"locationName": "instanceState"
									},
									"SystemStatus": {
										"shape": "Sbp",
										"locationName": "systemStatus"
									},
									"InstanceStatus": {
										"shape": "Sbp",
										"locationName": "instanceStatus"
									}
								}
							}
						},
						"NextToken": {
							"locationName": "nextToken"
						}
					}
				}
			},
			"DescribeInstances": {
				"input": {
					"type": "structure",
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"InstanceIds": {
							"shape": "S8h",
							"locationName": "InstanceId"
						},
						"Filters": {
							"shape": "S7y",
							"locationName": "Filter"
						},
						"NextToken": {
							"locationName": "nextToken"
						},
						"MaxResults": {
							"locationName": "maxResults",
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Reservations": {
							"locationName": "reservationSet",
							"type": "list",
							"member": {
								"shape": "Sby",
								"locationName": "item"
							}
						},
						"NextToken": {
							"locationName": "nextToken"
						}
					}
				}
			},
			"DescribeInternetGateways": {
				"input": {
					"type": "structure",
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"InternetGatewayIds": {
							"shape": "S2c",
							"locationName": "internetGatewayId"
						},
						"Filters": {
							"shape": "S7y",
							"locationName": "Filter"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"InternetGateways": {
							"locationName": "internetGatewaySet",
							"type": "list",
							"member": {
								"shape": "S3z",
								"locationName": "item"
							}
						}
					}
				}
			},
			"DescribeKeyPairs": {
				"input": {
					"type": "structure",
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"KeyNames": {
							"locationName": "KeyName",
							"type": "list",
							"member": {
								"locationName": "KeyName"
							}
						},
						"Filters": {
							"shape": "S7y",
							"locationName": "Filter"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"KeyPairs": {
							"locationName": "keySet",
							"type": "list",
							"member": {
								"locationName": "item",
								"type": "structure",
								"members": {
									"KeyName": {
										"locationName": "keyName"
									},
									"KeyFingerprint": {
										"locationName": "keyFingerprint"
									}
								}
							}
						}
					}
				}
			},
			"DescribeMovingAddresses": {
				"input": {
					"type": "structure",
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"PublicIps": {
							"shape": "S2c",
							"locationName": "publicIp"
						},
						"NextToken": {
							"locationName": "nextToken"
						},
						"Filters": {
							"shape": "S7y",
							"locationName": "filter"
						},
						"MaxResults": {
							"locationName": "maxResults",
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"MovingAddressStatuses": {
							"locationName": "movingAddressStatusSet",
							"type": "list",
							"member": {
								"locationName": "item",
								"type": "structure",
								"members": {
									"PublicIp": {
										"locationName": "publicIp"
									},
									"MoveStatus": {
										"locationName": "moveStatus"
									}
								}
							}
						},
						"NextToken": {
							"locationName": "nextToken"
						}
					}
				}
			},
			"DescribeNatGateways": {
				"input": {
					"type": "structure",
					"members": {
						"NatGatewayIds": {
							"shape": "S2c",
							"locationName": "NatGatewayId"
						},
						"Filter": {
							"shape": "S7y"
						},
						"MaxResults": {
							"type": "integer"
						},
						"NextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"NatGateways": {
							"locationName": "natGatewaySet",
							"type": "list",
							"member": {
								"shape": "S46",
								"locationName": "item"
							}
						},
						"NextToken": {
							"locationName": "nextToken"
						}
					}
				}
			},
			"DescribeNetworkAcls": {
				"input": {
					"type": "structure",
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"NetworkAclIds": {
							"shape": "S2c",
							"locationName": "NetworkAclId"
						},
						"Filters": {
							"shape": "S7y",
							"locationName": "Filter"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"NetworkAcls": {
							"locationName": "networkAclSet",
							"type": "list",
							"member": {
								"shape": "S4d",
								"locationName": "item"
							}
						}
					}
				}
			},
			"DescribeNetworkInterfaceAttribute": {
				"input": {
					"type": "structure",
					"required": [
						"NetworkInterfaceId"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"NetworkInterfaceId": {
							"locationName": "networkInterfaceId"
						},
						"Attribute": {
							"locationName": "attribute"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"NetworkInterfaceId": {
							"locationName": "networkInterfaceId"
						},
						"Description": {
							"shape": "S39",
							"locationName": "description"
						},
						"SourceDestCheck": {
							"shape": "Sbc",
							"locationName": "sourceDestCheck"
						},
						"Groups": {
							"shape": "S4t",
							"locationName": "groupSet"
						},
						"Attachment": {
							"shape": "S4v",
							"locationName": "attachment"
						}
					}
				}
			},
			"DescribeNetworkInterfaces": {
				"input": {
					"type": "structure",
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"NetworkInterfaceIds": {
							"locationName": "NetworkInterfaceId",
							"type": "list",
							"member": {
								"locationName": "item"
							}
						},
						"Filters": {
							"shape": "S7y",
							"locationName": "filter"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"NetworkInterfaces": {
							"locationName": "networkInterfaceSet",
							"type": "list",
							"member": {
								"shape": "S4r",
								"locationName": "item"
							}
						}
					}
				}
			},
			"DescribePlacementGroups": {
				"input": {
					"type": "structure",
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"GroupNames": {
							"locationName": "groupName",
							"type": "list",
							"member": {}
						},
						"Filters": {
							"shape": "S7y",
							"locationName": "Filter"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"PlacementGroups": {
							"locationName": "placementGroupSet",
							"type": "list",
							"member": {
								"locationName": "item",
								"type": "structure",
								"members": {
									"GroupName": {
										"locationName": "groupName"
									},
									"Strategy": {
										"locationName": "strategy"
									},
									"State": {
										"locationName": "state"
									}
								}
							}
						}
					}
				}
			},
			"DescribePrefixLists": {
				"input": {
					"type": "structure",
					"members": {
						"DryRun": {
							"type": "boolean"
						},
						"PrefixListIds": {
							"shape": "S2c",
							"locationName": "PrefixListId"
						},
						"Filters": {
							"shape": "S7y",
							"locationName": "Filter"
						},
						"MaxResults": {
							"type": "integer"
						},
						"NextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"PrefixLists": {
							"locationName": "prefixListSet",
							"type": "list",
							"member": {
								"locationName": "item",
								"type": "structure",
								"members": {
									"PrefixListId": {
										"locationName": "prefixListId"
									},
									"PrefixListName": {
										"locationName": "prefixListName"
									},
									"Cidrs": {
										"shape": "S2c",
										"locationName": "cidrSet"
									}
								}
							}
						},
						"NextToken": {
							"locationName": "nextToken"
						}
					}
				}
			},
			"DescribeRegions": {
				"input": {
					"type": "structure",
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"RegionNames": {
							"locationName": "RegionName",
							"type": "list",
							"member": {
								"locationName": "RegionName"
							}
						},
						"Filters": {
							"shape": "S7y",
							"locationName": "Filter"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Regions": {
							"locationName": "regionInfo",
							"type": "list",
							"member": {
								"locationName": "item",
								"type": "structure",
								"members": {
									"RegionName": {
										"locationName": "regionName"
									},
									"Endpoint": {
										"locationName": "regionEndpoint"
									}
								}
							}
						}
					}
				}
			},
			"DescribeReservedInstances": {
				"input": {
					"type": "structure",
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"ReservedInstancesIds": {
							"shape": "Sdj",
							"locationName": "ReservedInstancesId"
						},
						"Filters": {
							"shape": "S7y",
							"locationName": "Filter"
						},
						"OfferingType": {
							"locationName": "offeringType"
						},
						"OfferingClass": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ReservedInstances": {
							"locationName": "reservedInstancesSet",
							"type": "list",
							"member": {
								"locationName": "item",
								"type": "structure",
								"members": {
									"ReservedInstancesId": {
										"locationName": "reservedInstancesId"
									},
									"InstanceType": {
										"locationName": "instanceType"
									},
									"AvailabilityZone": {
										"locationName": "availabilityZone"
									},
									"Start": {
										"locationName": "start",
										"type": "timestamp"
									},
									"End": {
										"locationName": "end",
										"type": "timestamp"
									},
									"Duration": {
										"locationName": "duration",
										"type": "long"
									},
									"UsagePrice": {
										"locationName": "usagePrice",
										"type": "float"
									},
									"FixedPrice": {
										"locationName": "fixedPrice",
										"type": "float"
									},
									"InstanceCount": {
										"locationName": "instanceCount",
										"type": "integer"
									},
									"ProductDescription": {
										"locationName": "productDescription"
									},
									"State": {
										"locationName": "state"
									},
									"Tags": {
										"shape": "Sh",
										"locationName": "tagSet"
									},
									"InstanceTenancy": {
										"locationName": "instanceTenancy"
									},
									"CurrencyCode": {
										"locationName": "currencyCode"
									},
									"OfferingType": {
										"locationName": "offeringType"
									},
									"RecurringCharges": {
										"shape": "Sds",
										"locationName": "recurringCharges"
									},
									"OfferingClass": {
										"locationName": "offeringClass"
									},
									"Scope": {
										"locationName": "scope"
									}
								}
							}
						}
					}
				}
			},
			"DescribeReservedInstancesListings": {
				"input": {
					"type": "structure",
					"members": {
						"ReservedInstancesId": {
							"locationName": "reservedInstancesId"
						},
						"ReservedInstancesListingId": {
							"locationName": "reservedInstancesListingId"
						},
						"Filters": {
							"shape": "S7y",
							"locationName": "Filter"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ReservedInstancesListings": {
							"shape": "S20",
							"locationName": "reservedInstancesListingsSet"
						}
					}
				}
			},
			"DescribeReservedInstancesModifications": {
				"input": {
					"type": "structure",
					"members": {
						"ReservedInstancesModificationIds": {
							"locationName": "ReservedInstancesModificationId",
							"type": "list",
							"member": {
								"locationName": "ReservedInstancesModificationId"
							}
						},
						"NextToken": {
							"locationName": "nextToken"
						},
						"Filters": {
							"shape": "S7y",
							"locationName": "Filter"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ReservedInstancesModifications": {
							"locationName": "reservedInstancesModificationsSet",
							"type": "list",
							"member": {
								"locationName": "item",
								"type": "structure",
								"members": {
									"ReservedInstancesModificationId": {
										"locationName": "reservedInstancesModificationId"
									},
									"ReservedInstancesIds": {
										"locationName": "reservedInstancesSet",
										"type": "list",
										"member": {
											"locationName": "item",
											"type": "structure",
											"members": {
												"ReservedInstancesId": {
													"locationName": "reservedInstancesId"
												}
											}
										}
									},
									"ModificationResults": {
										"locationName": "modificationResultSet",
										"type": "list",
										"member": {
											"locationName": "item",
											"type": "structure",
											"members": {
												"ReservedInstancesId": {
													"locationName": "reservedInstancesId"
												},
												"TargetConfiguration": {
													"shape": "Se7",
													"locationName": "targetConfiguration"
												}
											}
										}
									},
									"CreateDate": {
										"locationName": "createDate",
										"type": "timestamp"
									},
									"UpdateDate": {
										"locationName": "updateDate",
										"type": "timestamp"
									},
									"EffectiveDate": {
										"locationName": "effectiveDate",
										"type": "timestamp"
									},
									"Status": {
										"locationName": "status"
									},
									"StatusMessage": {
										"locationName": "statusMessage"
									},
									"ClientToken": {
										"locationName": "clientToken"
									}
								}
							}
						},
						"NextToken": {
							"locationName": "nextToken"
						}
					}
				}
			},
			"DescribeReservedInstancesOfferings": {
				"input": {
					"type": "structure",
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"ReservedInstancesOfferingIds": {
							"locationName": "ReservedInstancesOfferingId",
							"type": "list",
							"member": {}
						},
						"InstanceType": {},
						"AvailabilityZone": {},
						"ProductDescription": {},
						"Filters": {
							"shape": "S7y",
							"locationName": "Filter"
						},
						"InstanceTenancy": {
							"locationName": "instanceTenancy"
						},
						"OfferingType": {
							"locationName": "offeringType"
						},
						"NextToken": {
							"locationName": "nextToken"
						},
						"MaxResults": {
							"locationName": "maxResults",
							"type": "integer"
						},
						"IncludeMarketplace": {
							"type": "boolean"
						},
						"MinDuration": {
							"type": "long"
						},
						"MaxDuration": {
							"type": "long"
						},
						"MaxInstanceCount": {
							"type": "integer"
						},
						"OfferingClass": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ReservedInstancesOfferings": {
							"locationName": "reservedInstancesOfferingsSet",
							"type": "list",
							"member": {
								"locationName": "item",
								"type": "structure",
								"members": {
									"ReservedInstancesOfferingId": {
										"locationName": "reservedInstancesOfferingId"
									},
									"InstanceType": {
										"locationName": "instanceType"
									},
									"AvailabilityZone": {
										"locationName": "availabilityZone"
									},
									"Duration": {
										"locationName": "duration",
										"type": "long"
									},
									"UsagePrice": {
										"locationName": "usagePrice",
										"type": "float"
									},
									"FixedPrice": {
										"locationName": "fixedPrice",
										"type": "float"
									},
									"ProductDescription": {
										"locationName": "productDescription"
									},
									"InstanceTenancy": {
										"locationName": "instanceTenancy"
									},
									"CurrencyCode": {
										"locationName": "currencyCode"
									},
									"OfferingType": {
										"locationName": "offeringType"
									},
									"RecurringCharges": {
										"shape": "Sds",
										"locationName": "recurringCharges"
									},
									"Marketplace": {
										"locationName": "marketplace",
										"type": "boolean"
									},
									"PricingDetails": {
										"locationName": "pricingDetailsSet",
										"type": "list",
										"member": {
											"locationName": "item",
											"type": "structure",
											"members": {
												"Price": {
													"locationName": "price",
													"type": "double"
												},
												"Count": {
													"locationName": "count",
													"type": "integer"
												}
											}
										}
									},
									"OfferingClass": {
										"locationName": "offeringClass"
									},
									"Scope": {
										"locationName": "scope"
									}
								}
							}
						},
						"NextToken": {
							"locationName": "nextToken"
						}
					}
				}
			},
			"DescribeRouteTables": {
				"input": {
					"type": "structure",
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"RouteTableIds": {
							"shape": "S2c",
							"locationName": "RouteTableId"
						},
						"Filters": {
							"shape": "S7y",
							"locationName": "Filter"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"RouteTables": {
							"locationName": "routeTableSet",
							"type": "list",
							"member": {
								"shape": "S5a",
								"locationName": "item"
							}
						}
					}
				}
			},
			"DescribeScheduledInstanceAvailability": {
				"input": {
					"type": "structure",
					"required": [
						"Recurrence",
						"FirstSlotStartTimeRange"
					],
					"members": {
						"DryRun": {
							"type": "boolean"
						},
						"Recurrence": {
							"type": "structure",
							"members": {
								"Frequency": {},
								"Interval": {
									"type": "integer"
								},
								"OccurrenceDays": {
									"locationName": "OccurrenceDay",
									"type": "list",
									"member": {
										"locationName": "OccurenceDay",
										"type": "integer"
									}
								},
								"OccurrenceRelativeToEnd": {
									"type": "boolean"
								},
								"OccurrenceUnit": {}
							}
						},
						"FirstSlotStartTimeRange": {
							"type": "structure",
							"required": [
								"EarliestTime",
								"LatestTime"
							],
							"members": {
								"EarliestTime": {
									"type": "timestamp"
								},
								"LatestTime": {
									"type": "timestamp"
								}
							}
						},
						"MinSlotDurationInHours": {
							"type": "integer"
						},
						"MaxSlotDurationInHours": {
							"type": "integer"
						},
						"NextToken": {},
						"MaxResults": {
							"type": "integer"
						},
						"Filters": {
							"shape": "S7y",
							"locationName": "Filter"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"NextToken": {
							"locationName": "nextToken"
						},
						"ScheduledInstanceAvailabilitySet": {
							"locationName": "scheduledInstanceAvailabilitySet",
							"type": "list",
							"member": {
								"locationName": "item",
								"type": "structure",
								"members": {
									"InstanceType": {
										"locationName": "instanceType"
									},
									"Platform": {
										"locationName": "platform"
									},
									"NetworkPlatform": {
										"locationName": "networkPlatform"
									},
									"AvailabilityZone": {
										"locationName": "availabilityZone"
									},
									"PurchaseToken": {
										"locationName": "purchaseToken"
									},
									"SlotDurationInHours": {
										"locationName": "slotDurationInHours",
										"type": "integer"
									},
									"Recurrence": {
										"shape": "Sep",
										"locationName": "recurrence"
									},
									"FirstSlotStartTime": {
										"locationName": "firstSlotStartTime",
										"type": "timestamp"
									},
									"HourlyPrice": {
										"locationName": "hourlyPrice"
									},
									"TotalScheduledInstanceHours": {
										"locationName": "totalScheduledInstanceHours",
										"type": "integer"
									},
									"AvailableInstanceCount": {
										"locationName": "availableInstanceCount",
										"type": "integer"
									},
									"MinTermDurationInDays": {
										"locationName": "minTermDurationInDays",
										"type": "integer"
									},
									"MaxTermDurationInDays": {
										"locationName": "maxTermDurationInDays",
										"type": "integer"
									}
								}
							}
						}
					}
				}
			},
			"DescribeScheduledInstances": {
				"input": {
					"type": "structure",
					"members": {
						"DryRun": {
							"type": "boolean"
						},
						"ScheduledInstanceIds": {
							"locationName": "ScheduledInstanceId",
							"type": "list",
							"member": {
								"locationName": "ScheduledInstanceId"
							}
						},
						"SlotStartTimeRange": {
							"type": "structure",
							"members": {
								"EarliestTime": {
									"type": "timestamp"
								},
								"LatestTime": {
									"type": "timestamp"
								}
							}
						},
						"NextToken": {},
						"MaxResults": {
							"type": "integer"
						},
						"Filters": {
							"shape": "S7y",
							"locationName": "Filter"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"NextToken": {
							"locationName": "nextToken"
						},
						"ScheduledInstanceSet": {
							"locationName": "scheduledInstanceSet",
							"type": "list",
							"member": {
								"shape": "Sew",
								"locationName": "item"
							}
						}
					}
				}
			},
			"DescribeSecurityGroupReferences": {
				"input": {
					"type": "structure",
					"required": [
						"GroupId"
					],
					"members": {
						"DryRun": {
							"type": "boolean"
						},
						"GroupId": {
							"type": "list",
							"member": {
								"locationName": "item"
							}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"SecurityGroupReferenceSet": {
							"locationName": "securityGroupReferenceSet",
							"type": "list",
							"member": {
								"locationName": "item",
								"type": "structure",
								"required": [
									"GroupId",
									"ReferencingVpcId"
								],
								"members": {
									"GroupId": {
										"locationName": "groupId"
									},
									"ReferencingVpcId": {
										"locationName": "referencingVpcId"
									},
									"VpcPeeringConnectionId": {
										"locationName": "vpcPeeringConnectionId"
									}
								}
							}
						}
					}
				}
			},
			"DescribeSecurityGroups": {
				"input": {
					"type": "structure",
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"GroupNames": {
							"shape": "Sf3",
							"locationName": "GroupName"
						},
						"GroupIds": {
							"shape": "Sy",
							"locationName": "GroupId"
						},
						"Filters": {
							"shape": "S7y",
							"locationName": "Filter"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"SecurityGroups": {
							"locationName": "securityGroupInfo",
							"type": "list",
							"member": {
								"locationName": "item",
								"type": "structure",
								"members": {
									"OwnerId": {
										"locationName": "ownerId"
									},
									"GroupName": {
										"locationName": "groupName"
									},
									"GroupId": {
										"locationName": "groupId"
									},
									"Description": {
										"locationName": "groupDescription"
									},
									"IpPermissions": {
										"shape": "S1b",
										"locationName": "ipPermissions"
									},
									"IpPermissionsEgress": {
										"shape": "S1b",
										"locationName": "ipPermissionsEgress"
									},
									"VpcId": {
										"locationName": "vpcId"
									},
									"Tags": {
										"shape": "Sh",
										"locationName": "tagSet"
									}
								}
							}
						}
					}
				}
			},
			"DescribeSnapshotAttribute": {
				"input": {
					"type": "structure",
					"required": [
						"SnapshotId",
						"Attribute"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"SnapshotId": {},
						"Attribute": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"SnapshotId": {
							"locationName": "snapshotId"
						},
						"CreateVolumePermissions": {
							"shape": "Sfa",
							"locationName": "createVolumePermission"
						},
						"ProductCodes": {
							"shape": "Sae",
							"locationName": "productCodes"
						}
					}
				}
			},
			"DescribeSnapshots": {
				"input": {
					"type": "structure",
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"SnapshotIds": {
							"locationName": "SnapshotId",
							"type": "list",
							"member": {
								"locationName": "SnapshotId"
							}
						},
						"OwnerIds": {
							"shape": "Sak",
							"locationName": "Owner"
						},
						"RestorableByUserIds": {
							"locationName": "RestorableBy",
							"type": "list",
							"member": {}
						},
						"Filters": {
							"shape": "S7y",
							"locationName": "Filter"
						},
						"NextToken": {},
						"MaxResults": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Snapshots": {
							"locationName": "snapshotSet",
							"type": "list",
							"member": {
								"shape": "S5m",
								"locationName": "item"
							}
						},
						"NextToken": {
							"locationName": "nextToken"
						}
					}
				}
			},
			"DescribeSpotDatafeedSubscription": {
				"input": {
					"type": "structure",
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"SpotDatafeedSubscription": {
							"shape": "S5q",
							"locationName": "spotDatafeedSubscription"
						}
					}
				}
			},
			"DescribeSpotFleetInstances": {
				"input": {
					"type": "structure",
					"required": [
						"SpotFleetRequestId"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"SpotFleetRequestId": {
							"locationName": "spotFleetRequestId"
						},
						"NextToken": {
							"locationName": "nextToken"
						},
						"MaxResults": {
							"locationName": "maxResults",
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"SpotFleetRequestId",
						"ActiveInstances"
					],
					"members": {
						"SpotFleetRequestId": {
							"locationName": "spotFleetRequestId"
						},
						"ActiveInstances": {
							"locationName": "activeInstanceSet",
							"type": "list",
							"member": {
								"locationName": "item",
								"type": "structure",
								"members": {
									"InstanceType": {
										"locationName": "instanceType"
									},
									"InstanceId": {
										"locationName": "instanceId"
									},
									"SpotInstanceRequestId": {
										"locationName": "spotInstanceRequestId"
									}
								}
							}
						},
						"NextToken": {
							"locationName": "nextToken"
						}
					}
				}
			},
			"DescribeSpotFleetRequestHistory": {
				"input": {
					"type": "structure",
					"required": [
						"SpotFleetRequestId",
						"StartTime"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"SpotFleetRequestId": {
							"locationName": "spotFleetRequestId"
						},
						"EventType": {
							"locationName": "eventType"
						},
						"StartTime": {
							"locationName": "startTime",
							"type": "timestamp"
						},
						"NextToken": {
							"locationName": "nextToken"
						},
						"MaxResults": {
							"locationName": "maxResults",
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"SpotFleetRequestId",
						"StartTime",
						"LastEvaluatedTime",
						"HistoryRecords"
					],
					"members": {
						"SpotFleetRequestId": {
							"locationName": "spotFleetRequestId"
						},
						"StartTime": {
							"locationName": "startTime",
							"type": "timestamp"
						},
						"LastEvaluatedTime": {
							"locationName": "lastEvaluatedTime",
							"type": "timestamp"
						},
						"HistoryRecords": {
							"locationName": "historyRecordSet",
							"type": "list",
							"member": {
								"locationName": "item",
								"type": "structure",
								"required": [
									"Timestamp",
									"EventType",
									"EventInformation"
								],
								"members": {
									"Timestamp": {
										"locationName": "timestamp",
										"type": "timestamp"
									},
									"EventType": {
										"locationName": "eventType"
									},
									"EventInformation": {
										"locationName": "eventInformation",
										"type": "structure",
										"members": {
											"InstanceId": {
												"locationName": "instanceId"
											},
											"EventSubType": {
												"locationName": "eventSubType"
											},
											"EventDescription": {
												"locationName": "eventDescription"
											}
										}
									}
								}
							}
						},
						"NextToken": {
							"locationName": "nextToken"
						}
					}
				}
			},
			"DescribeSpotFleetRequests": {
				"input": {
					"type": "structure",
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"SpotFleetRequestIds": {
							"shape": "S2c",
							"locationName": "spotFleetRequestId"
						},
						"NextToken": {
							"locationName": "nextToken"
						},
						"MaxResults": {
							"locationName": "maxResults",
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"SpotFleetRequestConfigs"
					],
					"members": {
						"SpotFleetRequestConfigs": {
							"locationName": "spotFleetRequestConfigSet",
							"type": "list",
							"member": {
								"locationName": "item",
								"type": "structure",
								"required": [
									"SpotFleetRequestId",
									"SpotFleetRequestState",
									"SpotFleetRequestConfig",
									"CreateTime"
								],
								"members": {
									"SpotFleetRequestId": {
										"locationName": "spotFleetRequestId"
									},
									"SpotFleetRequestState": {
										"locationName": "spotFleetRequestState"
									},
									"SpotFleetRequestConfig": {
										"shape": "Sfx",
										"locationName": "spotFleetRequestConfig"
									},
									"CreateTime": {
										"locationName": "createTime",
										"type": "timestamp"
									},
									"ActivityStatus": {
										"locationName": "activityStatus"
									}
								}
							}
						},
						"NextToken": {
							"locationName": "nextToken"
						}
					}
				}
			},
			"DescribeSpotInstanceRequests": {
				"input": {
					"type": "structure",
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"SpotInstanceRequestIds": {
							"shape": "S2m",
							"locationName": "SpotInstanceRequestId"
						},
						"Filters": {
							"shape": "S7y",
							"locationName": "Filter"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"SpotInstanceRequests": {
							"shape": "Sgb",
							"locationName": "spotInstanceRequestSet"
						}
					}
				}
			},
			"DescribeSpotPriceHistory": {
				"input": {
					"type": "structure",
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"StartTime": {
							"locationName": "startTime",
							"type": "timestamp"
						},
						"EndTime": {
							"locationName": "endTime",
							"type": "timestamp"
						},
						"InstanceTypes": {
							"locationName": "InstanceType",
							"type": "list",
							"member": {}
						},
						"ProductDescriptions": {
							"locationName": "ProductDescription",
							"type": "list",
							"member": {}
						},
						"Filters": {
							"shape": "S7y",
							"locationName": "Filter"
						},
						"AvailabilityZone": {
							"locationName": "availabilityZone"
						},
						"MaxResults": {
							"locationName": "maxResults",
							"type": "integer"
						},
						"NextToken": {
							"locationName": "nextToken"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"SpotPriceHistory": {
							"locationName": "spotPriceHistorySet",
							"type": "list",
							"member": {
								"locationName": "item",
								"type": "structure",
								"members": {
									"InstanceType": {
										"locationName": "instanceType"
									},
									"ProductDescription": {
										"locationName": "productDescription"
									},
									"SpotPrice": {
										"locationName": "spotPrice"
									},
									"Timestamp": {
										"locationName": "timestamp",
										"type": "timestamp"
									},
									"AvailabilityZone": {
										"locationName": "availabilityZone"
									}
								}
							}
						},
						"NextToken": {
							"locationName": "nextToken"
						}
					}
				}
			},
			"DescribeStaleSecurityGroups": {
				"input": {
					"type": "structure",
					"required": [
						"VpcId"
					],
					"members": {
						"DryRun": {
							"type": "boolean"
						},
						"VpcId": {},
						"MaxResults": {
							"type": "integer"
						},
						"NextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"StaleSecurityGroupSet": {
							"locationName": "staleSecurityGroupSet",
							"type": "list",
							"member": {
								"locationName": "item",
								"type": "structure",
								"required": [
									"GroupId"
								],
								"members": {
									"GroupId": {
										"locationName": "groupId"
									},
									"GroupName": {
										"locationName": "groupName"
									},
									"Description": {
										"locationName": "description"
									},
									"VpcId": {
										"locationName": "vpcId"
									},
									"StaleIpPermissions": {
										"shape": "Sgu",
										"locationName": "staleIpPermissions"
									},
									"StaleIpPermissionsEgress": {
										"shape": "Sgu",
										"locationName": "staleIpPermissionsEgress"
									}
								}
							}
						},
						"NextToken": {
							"locationName": "nextToken"
						}
					}
				}
			},
			"DescribeSubnets": {
				"input": {
					"type": "structure",
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"SubnetIds": {
							"locationName": "SubnetId",
							"type": "list",
							"member": {
								"locationName": "SubnetId"
							}
						},
						"Filters": {
							"shape": "S7y",
							"locationName": "Filter"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Subnets": {
							"locationName": "subnetSet",
							"type": "list",
							"member": {
								"shape": "S5v",
								"locationName": "item"
							}
						}
					}
				}
			},
			"DescribeTags": {
				"input": {
					"type": "structure",
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"Filters": {
							"shape": "S7y",
							"locationName": "Filter"
						},
						"MaxResults": {
							"locationName": "maxResults",
							"type": "integer"
						},
						"NextToken": {
							"locationName": "nextToken"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Tags": {
							"locationName": "tagSet",
							"type": "list",
							"member": {
								"locationName": "item",
								"type": "structure",
								"members": {
									"ResourceId": {
										"locationName": "resourceId"
									},
									"ResourceType": {
										"locationName": "resourceType"
									},
									"Key": {
										"locationName": "key"
									},
									"Value": {
										"locationName": "value"
									}
								}
							}
						},
						"NextToken": {
							"locationName": "nextToken"
						}
					}
				}
			},
			"DescribeVolumeAttribute": {
				"input": {
					"type": "structure",
					"required": [
						"VolumeId"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"VolumeId": {},
						"Attribute": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"VolumeId": {
							"locationName": "volumeId"
						},
						"AutoEnableIO": {
							"shape": "Sbc",
							"locationName": "autoEnableIO"
						},
						"ProductCodes": {
							"shape": "Sae",
							"locationName": "productCodes"
						}
					}
				}
			},
			"DescribeVolumeStatus": {
				"input": {
					"type": "structure",
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"VolumeIds": {
							"shape": "Shc",
							"locationName": "VolumeId"
						},
						"Filters": {
							"shape": "S7y",
							"locationName": "Filter"
						},
						"NextToken": {},
						"MaxResults": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"VolumeStatuses": {
							"locationName": "volumeStatusSet",
							"type": "list",
							"member": {
								"locationName": "item",
								"type": "structure",
								"members": {
									"VolumeId": {
										"locationName": "volumeId"
									},
									"AvailabilityZone": {
										"locationName": "availabilityZone"
									},
									"VolumeStatus": {
										"locationName": "volumeStatus",
										"type": "structure",
										"members": {
											"Status": {
												"locationName": "status"
											},
											"Details": {
												"locationName": "details",
												"type": "list",
												"member": {
													"locationName": "item",
													"type": "structure",
													"members": {
														"Name": {
															"locationName": "name"
														},
														"Status": {
															"locationName": "status"
														}
													}
												}
											}
										}
									},
									"Events": {
										"locationName": "eventsSet",
										"type": "list",
										"member": {
											"locationName": "item",
											"type": "structure",
											"members": {
												"EventType": {
													"locationName": "eventType"
												},
												"Description": {
													"locationName": "description"
												},
												"NotBefore": {
													"locationName": "notBefore",
													"type": "timestamp"
												},
												"NotAfter": {
													"locationName": "notAfter",
													"type": "timestamp"
												},
												"EventId": {
													"locationName": "eventId"
												}
											}
										}
									},
									"Actions": {
										"locationName": "actionsSet",
										"type": "list",
										"member": {
											"locationName": "item",
											"type": "structure",
											"members": {
												"Code": {
													"locationName": "code"
												},
												"Description": {
													"locationName": "description"
												},
												"EventType": {
													"locationName": "eventType"
												},
												"EventId": {
													"locationName": "eventId"
												}
											}
										}
									}
								}
							}
						},
						"NextToken": {
							"locationName": "nextToken"
						}
					}
				}
			},
			"DescribeVolumes": {
				"input": {
					"type": "structure",
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"VolumeIds": {
							"shape": "Shc",
							"locationName": "VolumeId"
						},
						"Filters": {
							"shape": "S7y",
							"locationName": "Filter"
						},
						"NextToken": {
							"locationName": "nextToken"
						},
						"MaxResults": {
							"locationName": "maxResults",
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Volumes": {
							"locationName": "volumeSet",
							"type": "list",
							"member": {
								"shape": "S60",
								"locationName": "item"
							}
						},
						"NextToken": {
							"locationName": "nextToken"
						}
					}
				}
			},
			"DescribeVpcAttribute": {
				"input": {
					"type": "structure",
					"required": [
						"VpcId",
						"Attribute"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"VpcId": {},
						"Attribute": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"VpcId": {
							"locationName": "vpcId"
						},
						"EnableDnsSupport": {
							"shape": "Sbc",
							"locationName": "enableDnsSupport"
						},
						"EnableDnsHostnames": {
							"shape": "Sbc",
							"locationName": "enableDnsHostnames"
						}
					}
				}
			},
			"DescribeVpcClassicLink": {
				"input": {
					"type": "structure",
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"VpcIds": {
							"shape": "Shw",
							"locationName": "VpcId"
						},
						"Filters": {
							"shape": "S7y",
							"locationName": "Filter"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Vpcs": {
							"locationName": "vpcSet",
							"type": "list",
							"member": {
								"locationName": "item",
								"type": "structure",
								"members": {
									"VpcId": {
										"locationName": "vpcId"
									},
									"ClassicLinkEnabled": {
										"locationName": "classicLinkEnabled",
										"type": "boolean"
									},
									"Tags": {
										"shape": "Sh",
										"locationName": "tagSet"
									}
								}
							}
						}
					}
				}
			},
			"DescribeVpcClassicLinkDnsSupport": {
				"input": {
					"type": "structure",
					"members": {
						"VpcIds": {
							"shape": "Shw"
						},
						"MaxResults": {
							"locationName": "maxResults",
							"type": "integer"
						},
						"NextToken": {
							"locationName": "nextToken"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Vpcs": {
							"locationName": "vpcs",
							"type": "list",
							"member": {
								"locationName": "item",
								"type": "structure",
								"members": {
									"VpcId": {
										"locationName": "vpcId"
									},
									"ClassicLinkDnsSupported": {
										"locationName": "classicLinkDnsSupported",
										"type": "boolean"
									}
								}
							}
						},
						"NextToken": {
							"locationName": "nextToken"
						}
					}
				}
			},
			"DescribeVpcEndpointServices": {
				"input": {
					"type": "structure",
					"members": {
						"DryRun": {
							"type": "boolean"
						},
						"MaxResults": {
							"type": "integer"
						},
						"NextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ServiceNames": {
							"shape": "S2c",
							"locationName": "serviceNameSet"
						},
						"NextToken": {
							"locationName": "nextToken"
						}
					}
				}
			},
			"DescribeVpcEndpoints": {
				"input": {
					"type": "structure",
					"members": {
						"DryRun": {
							"type": "boolean"
						},
						"VpcEndpointIds": {
							"shape": "S2c",
							"locationName": "VpcEndpointId"
						},
						"Filters": {
							"shape": "S7y",
							"locationName": "Filter"
						},
						"MaxResults": {
							"type": "integer"
						},
						"NextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"VpcEndpoints": {
							"locationName": "vpcEndpointSet",
							"type": "list",
							"member": {
								"shape": "S6a",
								"locationName": "item"
							}
						},
						"NextToken": {
							"locationName": "nextToken"
						}
					}
				}
			},
			"DescribeVpcPeeringConnections": {
				"input": {
					"type": "structure",
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"VpcPeeringConnectionIds": {
							"shape": "S2c",
							"locationName": "VpcPeeringConnectionId"
						},
						"Filters": {
							"shape": "S7y",
							"locationName": "Filter"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"VpcPeeringConnections": {
							"locationName": "vpcPeeringConnectionSet",
							"type": "list",
							"member": {
								"shape": "Sb",
								"locationName": "item"
							}
						}
					}
				}
			},
			"DescribeVpcs": {
				"input": {
					"type": "structure",
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"VpcIds": {
							"locationName": "VpcId",
							"type": "list",
							"member": {
								"locationName": "VpcId"
							}
						},
						"Filters": {
							"shape": "S7y",
							"locationName": "Filter"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Vpcs": {
							"locationName": "vpcSet",
							"type": "list",
							"member": {
								"shape": "S66",
								"locationName": "item"
							}
						}
					}
				}
			},
			"DescribeVpnConnections": {
				"input": {
					"type": "structure",
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"VpnConnectionIds": {
							"locationName": "VpnConnectionId",
							"type": "list",
							"member": {
								"locationName": "VpnConnectionId"
							}
						},
						"Filters": {
							"shape": "S7y",
							"locationName": "Filter"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"VpnConnections": {
							"locationName": "vpnConnectionSet",
							"type": "list",
							"member": {
								"shape": "S6h",
								"locationName": "item"
							}
						}
					}
				}
			},
			"DescribeVpnGateways": {
				"input": {
					"type": "structure",
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"VpnGatewayIds": {
							"locationName": "VpnGatewayId",
							"type": "list",
							"member": {
								"locationName": "VpnGatewayId"
							}
						},
						"Filters": {
							"shape": "S7y",
							"locationName": "Filter"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"VpnGateways": {
							"locationName": "vpnGatewaySet",
							"type": "list",
							"member": {
								"shape": "S6t",
								"locationName": "item"
							}
						}
					}
				}
			},
			"DetachClassicLinkVpc": {
				"input": {
					"type": "structure",
					"required": [
						"InstanceId",
						"VpcId"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"InstanceId": {
							"locationName": "instanceId"
						},
						"VpcId": {
							"locationName": "vpcId"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Return": {
							"locationName": "return",
							"type": "boolean"
						}
					}
				}
			},
			"DetachInternetGateway": {
				"input": {
					"type": "structure",
					"required": [
						"InternetGatewayId",
						"VpcId"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"InternetGatewayId": {
							"locationName": "internetGatewayId"
						},
						"VpcId": {
							"locationName": "vpcId"
						}
					}
				}
			},
			"DetachNetworkInterface": {
				"input": {
					"type": "structure",
					"required": [
						"AttachmentId"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"AttachmentId": {
							"locationName": "attachmentId"
						},
						"Force": {
							"locationName": "force",
							"type": "boolean"
						}
					}
				}
			},
			"DetachVolume": {
				"input": {
					"type": "structure",
					"required": [
						"VolumeId"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"VolumeId": {},
						"InstanceId": {},
						"Device": {},
						"Force": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"shape": "S14"
				}
			},
			"DetachVpnGateway": {
				"input": {
					"type": "structure",
					"required": [
						"VpnGatewayId",
						"VpcId"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"VpnGatewayId": {},
						"VpcId": {}
					}
				}
			},
			"DisableVgwRoutePropagation": {
				"input": {
					"type": "structure",
					"required": [
						"RouteTableId",
						"GatewayId"
					],
					"members": {
						"RouteTableId": {},
						"GatewayId": {}
					}
				}
			},
			"DisableVpcClassicLink": {
				"input": {
					"type": "structure",
					"required": [
						"VpcId"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"VpcId": {
							"locationName": "vpcId"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Return": {
							"locationName": "return",
							"type": "boolean"
						}
					}
				}
			},
			"DisableVpcClassicLinkDnsSupport": {
				"input": {
					"type": "structure",
					"members": {
						"VpcId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Return": {
							"locationName": "return",
							"type": "boolean"
						}
					}
				}
			},
			"DisassociateAddress": {
				"input": {
					"type": "structure",
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"PublicIp": {},
						"AssociationId": {}
					}
				}
			},
			"DisassociateRouteTable": {
				"input": {
					"type": "structure",
					"required": [
						"AssociationId"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"AssociationId": {
							"locationName": "associationId"
						}
					}
				}
			},
			"EnableVgwRoutePropagation": {
				"input": {
					"type": "structure",
					"required": [
						"RouteTableId",
						"GatewayId"
					],
					"members": {
						"RouteTableId": {},
						"GatewayId": {}
					}
				}
			},
			"EnableVolumeIO": {
				"input": {
					"type": "structure",
					"required": [
						"VolumeId"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"VolumeId": {
							"locationName": "volumeId"
						}
					}
				}
			},
			"EnableVpcClassicLink": {
				"input": {
					"type": "structure",
					"required": [
						"VpcId"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"VpcId": {
							"locationName": "vpcId"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Return": {
							"locationName": "return",
							"type": "boolean"
						}
					}
				}
			},
			"EnableVpcClassicLinkDnsSupport": {
				"input": {
					"type": "structure",
					"members": {
						"VpcId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Return": {
							"locationName": "return",
							"type": "boolean"
						}
					}
				}
			},
			"GetConsoleOutput": {
				"input": {
					"type": "structure",
					"required": [
						"InstanceId"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"InstanceId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"InstanceId": {
							"locationName": "instanceId"
						},
						"Timestamp": {
							"locationName": "timestamp",
							"type": "timestamp"
						},
						"Output": {
							"locationName": "output"
						}
					}
				}
			},
			"GetConsoleScreenshot": {
				"input": {
					"type": "structure",
					"required": [
						"InstanceId"
					],
					"members": {
						"DryRun": {
							"type": "boolean"
						},
						"InstanceId": {},
						"WakeUp": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"InstanceId": {
							"locationName": "instanceId"
						},
						"ImageData": {
							"locationName": "imageData"
						}
					}
				}
			},
			"GetHostReservationPurchasePreview": {
				"input": {
					"type": "structure",
					"required": [
						"OfferingId",
						"HostIdSet"
					],
					"members": {
						"OfferingId": {},
						"HostIdSet": {
							"shape": "Sjc"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Purchase": {
							"shape": "Sje",
							"locationName": "purchase"
						},
						"TotalUpfrontPrice": {
							"locationName": "totalUpfrontPrice"
						},
						"TotalHourlyPrice": {
							"locationName": "totalHourlyPrice"
						},
						"CurrencyCode": {
							"locationName": "currencyCode"
						}
					}
				}
			},
			"GetPasswordData": {
				"input": {
					"type": "structure",
					"required": [
						"InstanceId"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"InstanceId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"InstanceId": {
							"locationName": "instanceId"
						},
						"Timestamp": {
							"locationName": "timestamp",
							"type": "timestamp"
						},
						"PasswordData": {
							"locationName": "passwordData"
						}
					}
				}
			},
			"GetReservedInstancesExchangeQuote": {
				"input": {
					"type": "structure",
					"required": [
						"ReservedInstanceIds"
					],
					"members": {
						"DryRun": {
							"type": "boolean"
						},
						"ReservedInstanceIds": {
							"shape": "S3",
							"locationName": "ReservedInstanceId"
						},
						"TargetConfigurations": {
							"shape": "S5",
							"locationName": "TargetConfiguration"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ReservedInstanceValueSet": {
							"locationName": "reservedInstanceValueSet",
							"type": "list",
							"member": {
								"locationName": "item",
								"type": "structure",
								"members": {
									"ReservedInstanceId": {
										"locationName": "reservedInstanceId"
									},
									"ReservationValue": {
										"shape": "Sjm",
										"locationName": "reservationValue"
									}
								}
							}
						},
						"ReservedInstanceValueRollup": {
							"shape": "Sjm",
							"locationName": "reservedInstanceValueRollup"
						},
						"TargetConfigurationValueSet": {
							"locationName": "targetConfigurationValueSet",
							"type": "list",
							"member": {
								"locationName": "item",
								"type": "structure",
								"members": {
									"TargetConfiguration": {
										"locationName": "targetConfiguration",
										"type": "structure",
										"members": {
											"OfferingId": {
												"locationName": "offeringId"
											},
											"InstanceCount": {
												"locationName": "instanceCount",
												"type": "integer"
											}
										}
									},
									"ReservationValue": {
										"shape": "Sjm",
										"locationName": "reservationValue"
									}
								}
							}
						},
						"TargetConfigurationValueRollup": {
							"shape": "Sjm",
							"locationName": "targetConfigurationValueRollup"
						},
						"PaymentDue": {
							"locationName": "paymentDue"
						},
						"CurrencyCode": {
							"locationName": "currencyCode"
						},
						"OutputReservedInstancesWillExpireAt": {
							"locationName": "outputReservedInstancesWillExpireAt",
							"type": "timestamp"
						},
						"IsValidExchange": {
							"locationName": "isValidExchange",
							"type": "boolean"
						},
						"ValidationFailureReason": {
							"locationName": "validationFailureReason"
						}
					}
				}
			},
			"ImportImage": {
				"input": {
					"type": "structure",
					"members": {
						"DryRun": {
							"type": "boolean"
						},
						"Description": {},
						"DiskContainers": {
							"locationName": "DiskContainer",
							"type": "list",
							"member": {
								"locationName": "item",
								"type": "structure",
								"members": {
									"Description": {},
									"Format": {},
									"Url": {},
									"UserBucket": {
										"shape": "Sjt"
									},
									"DeviceName": {},
									"SnapshotId": {}
								}
							}
						},
						"LicenseType": {},
						"Hypervisor": {},
						"Architecture": {},
						"Platform": {},
						"ClientData": {
							"shape": "Sju"
						},
						"ClientToken": {},
						"RoleName": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ImportTaskId": {
							"locationName": "importTaskId"
						},
						"Architecture": {
							"locationName": "architecture"
						},
						"LicenseType": {
							"locationName": "licenseType"
						},
						"Platform": {
							"locationName": "platform"
						},
						"Hypervisor": {
							"locationName": "hypervisor"
						},
						"Description": {
							"locationName": "description"
						},
						"SnapshotDetails": {
							"shape": "Sb1",
							"locationName": "snapshotDetailSet"
						},
						"ImageId": {
							"locationName": "imageId"
						},
						"Progress": {
							"locationName": "progress"
						},
						"StatusMessage": {
							"locationName": "statusMessage"
						},
						"Status": {
							"locationName": "status"
						}
					}
				}
			},
			"ImportInstance": {
				"input": {
					"type": "structure",
					"required": [
						"Platform"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"Description": {
							"locationName": "description"
						},
						"LaunchSpecification": {
							"locationName": "launchSpecification",
							"type": "structure",
							"members": {
								"Architecture": {
									"locationName": "architecture"
								},
								"GroupNames": {
									"shape": "Sjy",
									"locationName": "GroupName"
								},
								"GroupIds": {
									"shape": "S4n",
									"locationName": "GroupId"
								},
								"AdditionalInfo": {
									"locationName": "additionalInfo"
								},
								"UserData": {
									"locationName": "userData",
									"type": "structure",
									"members": {
										"Data": {
											"locationName": "data"
										}
									}
								},
								"InstanceType": {
									"locationName": "instanceType"
								},
								"Placement": {
									"shape": "Sc2",
									"locationName": "placement"
								},
								"Monitoring": {
									"locationName": "monitoring",
									"type": "boolean"
								},
								"SubnetId": {
									"locationName": "subnetId"
								},
								"InstanceInitiatedShutdownBehavior": {
									"locationName": "instanceInitiatedShutdownBehavior"
								},
								"PrivateIpAddress": {
									"locationName": "privateIpAddress"
								}
							}
						},
						"DiskImages": {
							"locationName": "diskImage",
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"Image": {
										"shape": "Sk3"
									},
									"Description": {},
									"Volume": {
										"shape": "Sk4"
									}
								}
							}
						},
						"Platform": {
							"locationName": "platform"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ConversionTask": {
							"shape": "S8p",
							"locationName": "conversionTask"
						}
					}
				}
			},
			"ImportKeyPair": {
				"input": {
					"type": "structure",
					"required": [
						"KeyName",
						"PublicKeyMaterial"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"KeyName": {
							"locationName": "keyName"
						},
						"PublicKeyMaterial": {
							"locationName": "publicKeyMaterial",
							"type": "blob"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"KeyName": {
							"locationName": "keyName"
						},
						"KeyFingerprint": {
							"locationName": "keyFingerprint"
						}
					}
				}
			},
			"ImportSnapshot": {
				"input": {
					"type": "structure",
					"members": {
						"DryRun": {
							"type": "boolean"
						},
						"Description": {},
						"DiskContainer": {
							"type": "structure",
							"members": {
								"Description": {},
								"Format": {},
								"Url": {},
								"UserBucket": {
									"shape": "Sjt"
								}
							}
						},
						"ClientData": {
							"shape": "Sju"
						},
						"ClientToken": {},
						"RoleName": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ImportTaskId": {
							"locationName": "importTaskId"
						},
						"SnapshotTaskDetail": {
							"shape": "Sb8",
							"locationName": "snapshotTaskDetail"
						},
						"Description": {
							"locationName": "description"
						}
					}
				}
			},
			"ImportVolume": {
				"input": {
					"type": "structure",
					"required": [
						"AvailabilityZone",
						"Image",
						"Volume"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"AvailabilityZone": {
							"locationName": "availabilityZone"
						},
						"Image": {
							"shape": "Sk3",
							"locationName": "image"
						},
						"Description": {
							"locationName": "description"
						},
						"Volume": {
							"shape": "Sk4",
							"locationName": "volume"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ConversionTask": {
							"shape": "S8p",
							"locationName": "conversionTask"
						}
					}
				}
			},
			"ModifyHosts": {
				"input": {
					"type": "structure",
					"required": [
						"HostIds",
						"AutoPlacement"
					],
					"members": {
						"HostIds": {
							"shape": "S9r",
							"locationName": "hostId"
						},
						"AutoPlacement": {
							"locationName": "autoPlacement"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Successful": {
							"shape": "Sp",
							"locationName": "successful"
						},
						"Unsuccessful": {
							"shape": "Skf",
							"locationName": "unsuccessful"
						}
					}
				}
			},
			"ModifyIdFormat": {
				"input": {
					"type": "structure",
					"required": [
						"Resource",
						"UseLongIds"
					],
					"members": {
						"Resource": {},
						"UseLongIds": {
							"type": "boolean"
						}
					}
				}
			},
			"ModifyIdentityIdFormat": {
				"input": {
					"type": "structure",
					"required": [
						"Resource",
						"UseLongIds",
						"PrincipalArn"
					],
					"members": {
						"Resource": {
							"locationName": "resource"
						},
						"UseLongIds": {
							"locationName": "useLongIds",
							"type": "boolean"
						},
						"PrincipalArn": {
							"locationName": "principalArn"
						}
					}
				}
			},
			"ModifyImageAttribute": {
				"input": {
					"type": "structure",
					"required": [
						"ImageId"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"ImageId": {},
						"Attribute": {},
						"OperationType": {},
						"UserIds": {
							"shape": "Skk",
							"locationName": "UserId"
						},
						"UserGroups": {
							"locationName": "UserGroup",
							"type": "list",
							"member": {
								"locationName": "UserGroup"
							}
						},
						"ProductCodes": {
							"locationName": "ProductCode",
							"type": "list",
							"member": {
								"locationName": "ProductCode"
							}
						},
						"Value": {},
						"LaunchPermission": {
							"type": "structure",
							"members": {
								"Add": {
									"shape": "Sab"
								},
								"Remove": {
									"shape": "Sab"
								}
							}
						},
						"Description": {
							"shape": "S39"
						}
					}
				}
			},
			"ModifyInstanceAttribute": {
				"input": {
					"type": "structure",
					"required": [
						"InstanceId"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"InstanceId": {
							"locationName": "instanceId"
						},
						"Attribute": {
							"locationName": "attribute"
						},
						"Value": {
							"locationName": "value"
						},
						"BlockDeviceMappings": {
							"locationName": "blockDeviceMapping",
							"type": "list",
							"member": {
								"locationName": "item",
								"type": "structure",
								"members": {
									"DeviceName": {
										"locationName": "deviceName"
									},
									"Ebs": {
										"locationName": "ebs",
										"type": "structure",
										"members": {
											"VolumeId": {
												"locationName": "volumeId"
											},
											"DeleteOnTermination": {
												"locationName": "deleteOnTermination",
												"type": "boolean"
											}
										}
									},
									"VirtualName": {
										"locationName": "virtualName"
									},
									"NoDevice": {
										"locationName": "noDevice"
									}
								}
							}
						},
						"SourceDestCheck": {
							"shape": "Sbc"
						},
						"DisableApiTermination": {
							"shape": "Sbc",
							"locationName": "disableApiTermination"
						},
						"InstanceType": {
							"shape": "S39",
							"locationName": "instanceType"
						},
						"Kernel": {
							"shape": "S39",
							"locationName": "kernel"
						},
						"Ramdisk": {
							"shape": "S39",
							"locationName": "ramdisk"
						},
						"UserData": {
							"locationName": "userData",
							"type": "structure",
							"members": {
								"Value": {
									"locationName": "value",
									"type": "blob"
								}
							}
						},
						"InstanceInitiatedShutdownBehavior": {
							"shape": "S39",
							"locationName": "instanceInitiatedShutdownBehavior"
						},
						"Groups": {
							"shape": "Sy",
							"locationName": "GroupId"
						},
						"EbsOptimized": {
							"shape": "Sbc",
							"locationName": "ebsOptimized"
						},
						"SriovNetSupport": {
							"shape": "S39",
							"locationName": "sriovNetSupport"
						},
						"EnaSupport": {
							"shape": "Sbc",
							"locationName": "enaSupport"
						}
					}
				}
			},
			"ModifyInstancePlacement": {
				"input": {
					"type": "structure",
					"required": [
						"InstanceId"
					],
					"members": {
						"InstanceId": {
							"locationName": "instanceId"
						},
						"Tenancy": {
							"locationName": "tenancy"
						},
						"Affinity": {
							"locationName": "affinity"
						},
						"HostId": {
							"locationName": "hostId"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Return": {
							"locationName": "return",
							"type": "boolean"
						}
					}
				}
			},
			"ModifyNetworkInterfaceAttribute": {
				"input": {
					"type": "structure",
					"required": [
						"NetworkInterfaceId"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"NetworkInterfaceId": {
							"locationName": "networkInterfaceId"
						},
						"Description": {
							"shape": "S39",
							"locationName": "description"
						},
						"SourceDestCheck": {
							"shape": "Sbc",
							"locationName": "sourceDestCheck"
						},
						"Groups": {
							"shape": "S4n",
							"locationName": "SecurityGroupId"
						},
						"Attachment": {
							"locationName": "attachment",
							"type": "structure",
							"members": {
								"AttachmentId": {
									"locationName": "attachmentId"
								},
								"DeleteOnTermination": {
									"locationName": "deleteOnTermination",
									"type": "boolean"
								}
							}
						}
					}
				}
			},
			"ModifyReservedInstances": {
				"input": {
					"type": "structure",
					"required": [
						"ReservedInstancesIds",
						"TargetConfigurations"
					],
					"members": {
						"ClientToken": {
							"locationName": "clientToken"
						},
						"ReservedInstancesIds": {
							"shape": "Sdj",
							"locationName": "ReservedInstancesId"
						},
						"TargetConfigurations": {
							"locationName": "ReservedInstancesConfigurationSetItemType",
							"type": "list",
							"member": {
								"shape": "Se7",
								"locationName": "item"
							}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ReservedInstancesModificationId": {
							"locationName": "reservedInstancesModificationId"
						}
					}
				}
			},
			"ModifySnapshotAttribute": {
				"input": {
					"type": "structure",
					"required": [
						"SnapshotId"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"SnapshotId": {},
						"Attribute": {},
						"OperationType": {},
						"UserIds": {
							"shape": "Skk",
							"locationName": "UserId"
						},
						"GroupNames": {
							"shape": "Sf3",
							"locationName": "UserGroup"
						},
						"CreateVolumePermission": {
							"type": "structure",
							"members": {
								"Add": {
									"shape": "Sfa"
								},
								"Remove": {
									"shape": "Sfa"
								}
							}
						}
					}
				}
			},
			"ModifySpotFleetRequest": {
				"input": {
					"type": "structure",
					"required": [
						"SpotFleetRequestId"
					],
					"members": {
						"SpotFleetRequestId": {
							"locationName": "spotFleetRequestId"
						},
						"TargetCapacity": {
							"locationName": "targetCapacity",
							"type": "integer"
						},
						"ExcessCapacityTerminationPolicy": {
							"locationName": "excessCapacityTerminationPolicy"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Return": {
							"locationName": "return",
							"type": "boolean"
						}
					}
				}
			},
			"ModifySubnetAttribute": {
				"input": {
					"type": "structure",
					"required": [
						"SubnetId"
					],
					"members": {
						"SubnetId": {
							"locationName": "subnetId"
						},
						"MapPublicIpOnLaunch": {
							"shape": "Sbc"
						}
					}
				}
			},
			"ModifyVolumeAttribute": {
				"input": {
					"type": "structure",
					"required": [
						"VolumeId"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"VolumeId": {},
						"AutoEnableIO": {
							"shape": "Sbc"
						}
					}
				}
			},
			"ModifyVpcAttribute": {
				"input": {
					"type": "structure",
					"required": [
						"VpcId"
					],
					"members": {
						"VpcId": {
							"locationName": "vpcId"
						},
						"EnableDnsSupport": {
							"shape": "Sbc"
						},
						"EnableDnsHostnames": {
							"shape": "Sbc"
						}
					}
				}
			},
			"ModifyVpcEndpoint": {
				"input": {
					"type": "structure",
					"required": [
						"VpcEndpointId"
					],
					"members": {
						"DryRun": {
							"type": "boolean"
						},
						"VpcEndpointId": {},
						"ResetPolicy": {
							"type": "boolean"
						},
						"PolicyDocument": {},
						"AddRouteTableIds": {
							"shape": "S2c",
							"locationName": "AddRouteTableId"
						},
						"RemoveRouteTableIds": {
							"shape": "S2c",
							"locationName": "RemoveRouteTableId"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Return": {
							"locationName": "return",
							"type": "boolean"
						}
					}
				}
			},
			"ModifyVpcPeeringConnectionOptions": {
				"input": {
					"type": "structure",
					"required": [
						"VpcPeeringConnectionId"
					],
					"members": {
						"DryRun": {
							"type": "boolean"
						},
						"VpcPeeringConnectionId": {},
						"RequesterPeeringConnectionOptions": {
							"shape": "Slc"
						},
						"AccepterPeeringConnectionOptions": {
							"shape": "Slc"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"RequesterPeeringConnectionOptions": {
							"shape": "Sle",
							"locationName": "requesterPeeringConnectionOptions"
						},
						"AccepterPeeringConnectionOptions": {
							"shape": "Sle",
							"locationName": "accepterPeeringConnectionOptions"
						}
					}
				}
			},
			"MonitorInstances": {
				"input": {
					"type": "structure",
					"required": [
						"InstanceIds"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"InstanceIds": {
							"shape": "S8h",
							"locationName": "InstanceId"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"InstanceMonitorings": {
							"shape": "Slh",
							"locationName": "instancesSet"
						}
					}
				}
			},
			"MoveAddressToVpc": {
				"input": {
					"type": "structure",
					"required": [
						"PublicIp"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"PublicIp": {
							"locationName": "publicIp"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"AllocationId": {
							"locationName": "allocationId"
						},
						"Status": {
							"locationName": "status"
						}
					}
				}
			},
			"PurchaseHostReservation": {
				"input": {
					"type": "structure",
					"required": [
						"OfferingId",
						"HostIdSet"
					],
					"members": {
						"OfferingId": {},
						"HostIdSet": {
							"shape": "Sjc"
						},
						"LimitPrice": {},
						"CurrencyCode": {},
						"ClientToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Purchase": {
							"shape": "Sje",
							"locationName": "purchase"
						},
						"TotalUpfrontPrice": {
							"locationName": "totalUpfrontPrice"
						},
						"TotalHourlyPrice": {
							"locationName": "totalHourlyPrice"
						},
						"CurrencyCode": {
							"locationName": "currencyCode"
						},
						"ClientToken": {
							"locationName": "clientToken"
						}
					}
				}
			},
			"PurchaseReservedInstancesOffering": {
				"input": {
					"type": "structure",
					"required": [
						"ReservedInstancesOfferingId",
						"InstanceCount"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"ReservedInstancesOfferingId": {},
						"InstanceCount": {
							"type": "integer"
						},
						"LimitPrice": {
							"locationName": "limitPrice",
							"type": "structure",
							"members": {
								"Amount": {
									"locationName": "amount",
									"type": "double"
								},
								"CurrencyCode": {
									"locationName": "currencyCode"
								}
							}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ReservedInstancesId": {
							"locationName": "reservedInstancesId"
						}
					}
				}
			},
			"PurchaseScheduledInstances": {
				"input": {
					"type": "structure",
					"required": [
						"PurchaseRequests"
					],
					"members": {
						"DryRun": {
							"type": "boolean"
						},
						"ClientToken": {
							"idempotencyToken": true
						},
						"PurchaseRequests": {
							"locationName": "PurchaseRequest",
							"type": "list",
							"member": {
								"locationName": "PurchaseRequest",
								"type": "structure",
								"required": [
									"PurchaseToken",
									"InstanceCount"
								],
								"members": {
									"PurchaseToken": {},
									"InstanceCount": {
										"type": "integer"
									}
								}
							}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ScheduledInstanceSet": {
							"locationName": "scheduledInstanceSet",
							"type": "list",
							"member": {
								"shape": "Sew",
								"locationName": "item"
							}
						}
					}
				}
			},
			"RebootInstances": {
				"input": {
					"type": "structure",
					"required": [
						"InstanceIds"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"InstanceIds": {
							"shape": "S8h",
							"locationName": "InstanceId"
						}
					}
				}
			},
			"RegisterImage": {
				"input": {
					"type": "structure",
					"required": [
						"Name"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"ImageLocation": {},
						"Name": {
							"locationName": "name"
						},
						"Description": {
							"locationName": "description"
						},
						"Architecture": {
							"locationName": "architecture"
						},
						"KernelId": {
							"locationName": "kernelId"
						},
						"RamdiskId": {
							"locationName": "ramdiskId"
						},
						"RootDeviceName": {
							"locationName": "rootDeviceName"
						},
						"BlockDeviceMappings": {
							"shape": "S3i",
							"locationName": "BlockDeviceMapping"
						},
						"VirtualizationType": {
							"locationName": "virtualizationType"
						},
						"SriovNetSupport": {
							"locationName": "sriovNetSupport"
						},
						"EnaSupport": {
							"locationName": "enaSupport",
							"type": "boolean"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ImageId": {
							"locationName": "imageId"
						}
					}
				}
			},
			"RejectVpcPeeringConnection": {
				"input": {
					"type": "structure",
					"required": [
						"VpcPeeringConnectionId"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"VpcPeeringConnectionId": {
							"locationName": "vpcPeeringConnectionId"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Return": {
							"locationName": "return",
							"type": "boolean"
						}
					}
				}
			},
			"ReleaseAddress": {
				"input": {
					"type": "structure",
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"PublicIp": {},
						"AllocationId": {}
					}
				}
			},
			"ReleaseHosts": {
				"input": {
					"type": "structure",
					"required": [
						"HostIds"
					],
					"members": {
						"HostIds": {
							"shape": "S9r",
							"locationName": "hostId"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Successful": {
							"shape": "Sp",
							"locationName": "successful"
						},
						"Unsuccessful": {
							"shape": "Skf",
							"locationName": "unsuccessful"
						}
					}
				}
			},
			"ReplaceNetworkAclAssociation": {
				"input": {
					"type": "structure",
					"required": [
						"AssociationId",
						"NetworkAclId"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"AssociationId": {
							"locationName": "associationId"
						},
						"NetworkAclId": {
							"locationName": "networkAclId"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"NewAssociationId": {
							"locationName": "newAssociationId"
						}
					}
				}
			},
			"ReplaceNetworkAclEntry": {
				"input": {
					"type": "structure",
					"required": [
						"NetworkAclId",
						"RuleNumber",
						"Protocol",
						"RuleAction",
						"Egress",
						"CidrBlock"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"NetworkAclId": {
							"locationName": "networkAclId"
						},
						"RuleNumber": {
							"locationName": "ruleNumber",
							"type": "integer"
						},
						"Protocol": {
							"locationName": "protocol"
						},
						"RuleAction": {
							"locationName": "ruleAction"
						},
						"Egress": {
							"locationName": "egress",
							"type": "boolean"
						},
						"CidrBlock": {
							"locationName": "cidrBlock"
						},
						"IcmpTypeCode": {
							"shape": "S4h",
							"locationName": "Icmp"
						},
						"PortRange": {
							"shape": "S4i",
							"locationName": "portRange"
						}
					}
				}
			},
			"ReplaceRoute": {
				"input": {
					"type": "structure",
					"required": [
						"RouteTableId",
						"DestinationCidrBlock"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"RouteTableId": {
							"locationName": "routeTableId"
						},
						"DestinationCidrBlock": {
							"locationName": "destinationCidrBlock"
						},
						"GatewayId": {
							"locationName": "gatewayId"
						},
						"InstanceId": {
							"locationName": "instanceId"
						},
						"NetworkInterfaceId": {
							"locationName": "networkInterfaceId"
						},
						"VpcPeeringConnectionId": {
							"locationName": "vpcPeeringConnectionId"
						},
						"NatGatewayId": {
							"locationName": "natGatewayId"
						}
					}
				}
			},
			"ReplaceRouteTableAssociation": {
				"input": {
					"type": "structure",
					"required": [
						"AssociationId",
						"RouteTableId"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"AssociationId": {
							"locationName": "associationId"
						},
						"RouteTableId": {
							"locationName": "routeTableId"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"NewAssociationId": {
							"locationName": "newAssociationId"
						}
					}
				}
			},
			"ReportInstanceStatus": {
				"input": {
					"type": "structure",
					"required": [
						"Instances",
						"Status",
						"ReasonCodes"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"Instances": {
							"shape": "S8h",
							"locationName": "instanceId"
						},
						"Status": {
							"locationName": "status"
						},
						"StartTime": {
							"locationName": "startTime",
							"type": "timestamp"
						},
						"EndTime": {
							"locationName": "endTime",
							"type": "timestamp"
						},
						"ReasonCodes": {
							"locationName": "reasonCode",
							"type": "list",
							"member": {
								"locationName": "item"
							}
						},
						"Description": {
							"locationName": "description"
						}
					}
				}
			},
			"RequestSpotFleet": {
				"input": {
					"type": "structure",
					"required": [
						"SpotFleetRequestConfig"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"SpotFleetRequestConfig": {
							"shape": "Sfx",
							"locationName": "spotFleetRequestConfig"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"SpotFleetRequestId"
					],
					"members": {
						"SpotFleetRequestId": {
							"locationName": "spotFleetRequestId"
						}
					}
				}
			},
			"RequestSpotInstances": {
				"input": {
					"type": "structure",
					"required": [
						"SpotPrice"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"SpotPrice": {
							"locationName": "spotPrice"
						},
						"ClientToken": {
							"locationName": "clientToken"
						},
						"InstanceCount": {
							"locationName": "instanceCount",
							"type": "integer"
						},
						"Type": {
							"locationName": "type"
						},
						"ValidFrom": {
							"locationName": "validFrom",
							"type": "timestamp"
						},
						"ValidUntil": {
							"locationName": "validUntil",
							"type": "timestamp"
						},
						"LaunchGroup": {
							"locationName": "launchGroup"
						},
						"AvailabilityZoneGroup": {
							"locationName": "availabilityZoneGroup"
						},
						"BlockDurationMinutes": {
							"locationName": "blockDurationMinutes",
							"type": "integer"
						},
						"LaunchSpecification": {
							"type": "structure",
							"members": {
								"ImageId": {
									"locationName": "imageId"
								},
								"KeyName": {
									"locationName": "keyName"
								},
								"SecurityGroups": {
									"shape": "S2c",
									"locationName": "SecurityGroup"
								},
								"UserData": {
									"locationName": "userData"
								},
								"AddressingType": {
									"locationName": "addressingType"
								},
								"InstanceType": {
									"locationName": "instanceType"
								},
								"Placement": {
									"shape": "Sg0",
									"locationName": "placement"
								},
								"KernelId": {
									"locationName": "kernelId"
								},
								"RamdiskId": {
									"locationName": "ramdiskId"
								},
								"BlockDeviceMappings": {
									"shape": "Sah",
									"locationName": "blockDeviceMapping"
								},
								"SubnetId": {
									"locationName": "subnetId"
								},
								"NetworkInterfaces": {
									"shape": "Sg2",
									"locationName": "NetworkInterface"
								},
								"IamInstanceProfile": {
									"shape": "Sg4",
									"locationName": "iamInstanceProfile"
								},
								"EbsOptimized": {
									"locationName": "ebsOptimized",
									"type": "boolean"
								},
								"Monitoring": {
									"shape": "Sgh",
									"locationName": "monitoring"
								},
								"SecurityGroupIds": {
									"shape": "S2c",
									"locationName": "SecurityGroupId"
								}
							}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"SpotInstanceRequests": {
							"shape": "Sgb",
							"locationName": "spotInstanceRequestSet"
						}
					}
				}
			},
			"ResetImageAttribute": {
				"input": {
					"type": "structure",
					"required": [
						"ImageId",
						"Attribute"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"ImageId": {},
						"Attribute": {}
					}
				}
			},
			"ResetInstanceAttribute": {
				"input": {
					"type": "structure",
					"required": [
						"InstanceId",
						"Attribute"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"InstanceId": {
							"locationName": "instanceId"
						},
						"Attribute": {
							"locationName": "attribute"
						}
					}
				}
			},
			"ResetNetworkInterfaceAttribute": {
				"input": {
					"type": "structure",
					"required": [
						"NetworkInterfaceId"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"NetworkInterfaceId": {
							"locationName": "networkInterfaceId"
						},
						"SourceDestCheck": {
							"locationName": "sourceDestCheck"
						}
					}
				}
			},
			"ResetSnapshotAttribute": {
				"input": {
					"type": "structure",
					"required": [
						"SnapshotId",
						"Attribute"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"SnapshotId": {},
						"Attribute": {}
					}
				}
			},
			"RestoreAddressToClassic": {
				"input": {
					"type": "structure",
					"required": [
						"PublicIp"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"PublicIp": {
							"locationName": "publicIp"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Status": {
							"locationName": "status"
						},
						"PublicIp": {
							"locationName": "publicIp"
						}
					}
				}
			},
			"RevokeSecurityGroupEgress": {
				"input": {
					"type": "structure",
					"required": [
						"GroupId"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"GroupId": {
							"locationName": "groupId"
						},
						"SourceSecurityGroupName": {
							"locationName": "sourceSecurityGroupName"
						},
						"SourceSecurityGroupOwnerId": {
							"locationName": "sourceSecurityGroupOwnerId"
						},
						"IpProtocol": {
							"locationName": "ipProtocol"
						},
						"FromPort": {
							"locationName": "fromPort",
							"type": "integer"
						},
						"ToPort": {
							"locationName": "toPort",
							"type": "integer"
						},
						"CidrIp": {
							"locationName": "cidrIp"
						},
						"IpPermissions": {
							"shape": "S1b",
							"locationName": "ipPermissions"
						}
					}
				}
			},
			"RevokeSecurityGroupIngress": {
				"input": {
					"type": "structure",
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"GroupName": {},
						"GroupId": {},
						"SourceSecurityGroupName": {},
						"SourceSecurityGroupOwnerId": {},
						"IpProtocol": {},
						"FromPort": {
							"type": "integer"
						},
						"ToPort": {
							"type": "integer"
						},
						"CidrIp": {},
						"IpPermissions": {
							"shape": "S1b"
						}
					}
				}
			},
			"RunInstances": {
				"input": {
					"type": "structure",
					"required": [
						"ImageId",
						"MinCount",
						"MaxCount"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"ImageId": {},
						"MinCount": {
							"type": "integer"
						},
						"MaxCount": {
							"type": "integer"
						},
						"KeyName": {},
						"SecurityGroups": {
							"shape": "Sjy",
							"locationName": "SecurityGroup"
						},
						"SecurityGroupIds": {
							"shape": "S4n",
							"locationName": "SecurityGroupId"
						},
						"UserData": {},
						"InstanceType": {},
						"Placement": {
							"shape": "Sc2"
						},
						"KernelId": {},
						"RamdiskId": {},
						"BlockDeviceMappings": {
							"shape": "S3i",
							"locationName": "BlockDeviceMapping"
						},
						"Monitoring": {
							"shape": "Sgh"
						},
						"SubnetId": {},
						"DisableApiTermination": {
							"locationName": "disableApiTermination",
							"type": "boolean"
						},
						"InstanceInitiatedShutdownBehavior": {
							"locationName": "instanceInitiatedShutdownBehavior"
						},
						"PrivateIpAddress": {
							"locationName": "privateIpAddress"
						},
						"ClientToken": {
							"locationName": "clientToken"
						},
						"AdditionalInfo": {
							"locationName": "additionalInfo"
						},
						"NetworkInterfaces": {
							"shape": "Sg2",
							"locationName": "networkInterface"
						},
						"IamInstanceProfile": {
							"shape": "Sg4",
							"locationName": "iamInstanceProfile"
						},
						"EbsOptimized": {
							"locationName": "ebsOptimized",
							"type": "boolean"
						}
					}
				},
				"output": {
					"shape": "Sby"
				}
			},
			"RunScheduledInstances": {
				"input": {
					"type": "structure",
					"required": [
						"ScheduledInstanceId",
						"LaunchSpecification"
					],
					"members": {
						"DryRun": {
							"type": "boolean"
						},
						"ClientToken": {
							"idempotencyToken": true
						},
						"InstanceCount": {
							"type": "integer"
						},
						"ScheduledInstanceId": {},
						"LaunchSpecification": {
							"type": "structure",
							"required": [
								"ImageId"
							],
							"members": {
								"ImageId": {},
								"KeyName": {},
								"SecurityGroupIds": {
									"shape": "Smv",
									"locationName": "SecurityGroupId"
								},
								"UserData": {},
								"Placement": {
									"type": "structure",
									"members": {
										"AvailabilityZone": {},
										"GroupName": {}
									}
								},
								"KernelId": {},
								"InstanceType": {},
								"RamdiskId": {},
								"BlockDeviceMappings": {
									"locationName": "BlockDeviceMapping",
									"type": "list",
									"member": {
										"locationName": "BlockDeviceMapping",
										"type": "structure",
										"members": {
											"DeviceName": {},
											"NoDevice": {},
											"VirtualName": {},
											"Ebs": {
												"type": "structure",
												"members": {
													"SnapshotId": {},
													"VolumeSize": {
														"type": "integer"
													},
													"DeleteOnTermination": {
														"type": "boolean"
													},
													"VolumeType": {},
													"Iops": {
														"type": "integer"
													},
													"Encrypted": {
														"type": "boolean"
													}
												}
											}
										}
									}
								},
								"Monitoring": {
									"type": "structure",
									"members": {
										"Enabled": {
											"type": "boolean"
										}
									}
								},
								"SubnetId": {},
								"NetworkInterfaces": {
									"locationName": "NetworkInterface",
									"type": "list",
									"member": {
										"locationName": "NetworkInterface",
										"type": "structure",
										"members": {
											"NetworkInterfaceId": {},
											"DeviceIndex": {
												"type": "integer"
											},
											"SubnetId": {},
											"Description": {},
											"PrivateIpAddress": {},
											"PrivateIpAddressConfigs": {
												"locationName": "PrivateIpAddressConfig",
												"type": "list",
												"member": {
													"locationName": "PrivateIpAddressConfigSet",
													"type": "structure",
													"members": {
														"PrivateIpAddress": {},
														"Primary": {
															"type": "boolean"
														}
													}
												}
											},
											"SecondaryPrivateIpAddressCount": {
												"type": "integer"
											},
											"AssociatePublicIpAddress": {
												"type": "boolean"
											},
											"Groups": {
												"shape": "Smv",
												"locationName": "Group"
											},
											"DeleteOnTermination": {
												"type": "boolean"
											}
										}
									}
								},
								"IamInstanceProfile": {
									"type": "structure",
									"members": {
										"Arn": {},
										"Name": {}
									}
								},
								"EbsOptimized": {
									"type": "boolean"
								}
							}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"InstanceIdSet": {
							"locationName": "instanceIdSet",
							"type": "list",
							"member": {
								"locationName": "item"
							}
						}
					}
				}
			},
			"StartInstances": {
				"input": {
					"type": "structure",
					"required": [
						"InstanceIds"
					],
					"members": {
						"InstanceIds": {
							"shape": "S8h",
							"locationName": "InstanceId"
						},
						"AdditionalInfo": {
							"locationName": "additionalInfo"
						},
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"StartingInstances": {
							"shape": "Sna",
							"locationName": "instancesSet"
						}
					}
				}
			},
			"StopInstances": {
				"input": {
					"type": "structure",
					"required": [
						"InstanceIds"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"InstanceIds": {
							"shape": "S8h",
							"locationName": "InstanceId"
						},
						"Force": {
							"locationName": "force",
							"type": "boolean"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"StoppingInstances": {
							"shape": "Sna",
							"locationName": "instancesSet"
						}
					}
				}
			},
			"TerminateInstances": {
				"input": {
					"type": "structure",
					"required": [
						"InstanceIds"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"InstanceIds": {
							"shape": "S8h",
							"locationName": "InstanceId"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"TerminatingInstances": {
							"shape": "Sna",
							"locationName": "instancesSet"
						}
					}
				}
			},
			"UnassignPrivateIpAddresses": {
				"input": {
					"type": "structure",
					"required": [
						"NetworkInterfaceId",
						"PrivateIpAddresses"
					],
					"members": {
						"NetworkInterfaceId": {
							"locationName": "networkInterfaceId"
						},
						"PrivateIpAddresses": {
							"shape": "Sr",
							"locationName": "privateIpAddress"
						}
					}
				}
			},
			"UnmonitorInstances": {
				"input": {
					"type": "structure",
					"required": [
						"InstanceIds"
					],
					"members": {
						"DryRun": {
							"locationName": "dryRun",
							"type": "boolean"
						},
						"InstanceIds": {
							"shape": "S8h",
							"locationName": "InstanceId"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"InstanceMonitorings": {
							"shape": "Slh",
							"locationName": "instancesSet"
						}
					}
				}
			}
		},
		"shapes": {
			"S3": {
				"type": "list",
				"member": {
					"locationName": "ReservedInstanceId"
				}
			},
			"S5": {
				"type": "list",
				"member": {
					"locationName": "TargetConfigurationRequest",
					"type": "structure",
					"required": [
						"OfferingId"
					],
					"members": {
						"OfferingId": {},
						"InstanceCount": {
							"type": "integer"
						}
					}
				}
			},
			"Sb": {
				"type": "structure",
				"members": {
					"AccepterVpcInfo": {
						"shape": "Sc",
						"locationName": "accepterVpcInfo"
					},
					"ExpirationTime": {
						"locationName": "expirationTime",
						"type": "timestamp"
					},
					"RequesterVpcInfo": {
						"shape": "Sc",
						"locationName": "requesterVpcInfo"
					},
					"Status": {
						"locationName": "status",
						"type": "structure",
						"members": {
							"Code": {
								"locationName": "code"
							},
							"Message": {
								"locationName": "message"
							}
						}
					},
					"Tags": {
						"shape": "Sh",
						"locationName": "tagSet"
					},
					"VpcPeeringConnectionId": {
						"locationName": "vpcPeeringConnectionId"
					}
				}
			},
			"Sc": {
				"type": "structure",
				"members": {
					"CidrBlock": {
						"locationName": "cidrBlock"
					},
					"OwnerId": {
						"locationName": "ownerId"
					},
					"VpcId": {
						"locationName": "vpcId"
					},
					"PeeringOptions": {
						"locationName": "peeringOptions",
						"type": "structure",
						"members": {
							"AllowEgressFromLocalClassicLinkToRemoteVpc": {
								"locationName": "allowEgressFromLocalClassicLinkToRemoteVpc",
								"type": "boolean"
							},
							"AllowEgressFromLocalVpcToRemoteClassicLink": {
								"locationName": "allowEgressFromLocalVpcToRemoteClassicLink",
								"type": "boolean"
							},
							"AllowDnsResolutionFromRemoteVpc": {
								"locationName": "allowDnsResolutionFromRemoteVpc",
								"type": "boolean"
							}
						}
					}
				}
			},
			"Sh": {
				"type": "list",
				"member": {
					"locationName": "item",
					"type": "structure",
					"members": {
						"Key": {
							"locationName": "key"
						},
						"Value": {
							"locationName": "value"
						}
					}
				}
			},
			"Sp": {
				"type": "list",
				"member": {
					"locationName": "item"
				}
			},
			"Sr": {
				"type": "list",
				"member": {
					"locationName": "PrivateIpAddress"
				}
			},
			"Sy": {
				"type": "list",
				"member": {
					"locationName": "groupId"
				}
			},
			"S14": {
				"type": "structure",
				"members": {
					"VolumeId": {
						"locationName": "volumeId"
					},
					"InstanceId": {
						"locationName": "instanceId"
					},
					"Device": {
						"locationName": "device"
					},
					"State": {
						"locationName": "status"
					},
					"AttachTime": {
						"locationName": "attachTime",
						"type": "timestamp"
					},
					"DeleteOnTermination": {
						"locationName": "deleteOnTermination",
						"type": "boolean"
					}
				}
			},
			"S18": {
				"type": "structure",
				"members": {
					"VpcId": {
						"locationName": "vpcId"
					},
					"State": {
						"locationName": "state"
					}
				}
			},
			"S1b": {
				"type": "list",
				"member": {
					"locationName": "item",
					"type": "structure",
					"members": {
						"IpProtocol": {
							"locationName": "ipProtocol"
						},
						"FromPort": {
							"locationName": "fromPort",
							"type": "integer"
						},
						"ToPort": {
							"locationName": "toPort",
							"type": "integer"
						},
						"UserIdGroupPairs": {
							"locationName": "groups",
							"type": "list",
							"member": {
								"shape": "S1e",
								"locationName": "item"
							}
						},
						"IpRanges": {
							"locationName": "ipRanges",
							"type": "list",
							"member": {
								"locationName": "item",
								"type": "structure",
								"members": {
									"CidrIp": {
										"locationName": "cidrIp"
									}
								}
							}
						},
						"PrefixListIds": {
							"locationName": "prefixListIds",
							"type": "list",
							"member": {
								"locationName": "item",
								"type": "structure",
								"members": {
									"PrefixListId": {
										"locationName": "prefixListId"
									}
								}
							}
						}
					}
				}
			},
			"S1e": {
				"type": "structure",
				"members": {
					"UserId": {
						"locationName": "userId"
					},
					"GroupName": {
						"locationName": "groupName"
					},
					"GroupId": {
						"locationName": "groupId"
					},
					"VpcId": {
						"locationName": "vpcId"
					},
					"VpcPeeringConnectionId": {
						"locationName": "vpcPeeringConnectionId"
					},
					"PeeringStatus": {
						"locationName": "peeringStatus"
					}
				}
			},
			"S1l": {
				"type": "structure",
				"members": {
					"S3": {
						"type": "structure",
						"members": {
							"Bucket": {
								"locationName": "bucket"
							},
							"Prefix": {
								"locationName": "prefix"
							},
							"AWSAccessKeyId": {},
							"UploadPolicy": {
								"locationName": "uploadPolicy",
								"type": "blob"
							},
							"UploadPolicySignature": {
								"locationName": "uploadPolicySignature"
							}
						}
					}
				}
			},
			"S1p": {
				"type": "structure",
				"members": {
					"InstanceId": {
						"locationName": "instanceId"
					},
					"BundleId": {
						"locationName": "bundleId"
					},
					"State": {
						"locationName": "state"
					},
					"StartTime": {
						"locationName": "startTime",
						"type": "timestamp"
					},
					"UpdateTime": {
						"locationName": "updateTime",
						"type": "timestamp"
					},
					"Storage": {
						"shape": "S1l",
						"locationName": "storage"
					},
					"Progress": {
						"locationName": "progress"
					},
					"BundleTaskError": {
						"locationName": "error",
						"type": "structure",
						"members": {
							"Code": {
								"locationName": "code"
							},
							"Message": {
								"locationName": "message"
							}
						}
					}
				}
			},
			"S20": {
				"type": "list",
				"member": {
					"locationName": "item",
					"type": "structure",
					"members": {
						"ReservedInstancesListingId": {
							"locationName": "reservedInstancesListingId"
						},
						"ReservedInstancesId": {
							"locationName": "reservedInstancesId"
						},
						"CreateDate": {
							"locationName": "createDate",
							"type": "timestamp"
						},
						"UpdateDate": {
							"locationName": "updateDate",
							"type": "timestamp"
						},
						"Status": {
							"locationName": "status"
						},
						"StatusMessage": {
							"locationName": "statusMessage"
						},
						"InstanceCounts": {
							"locationName": "instanceCounts",
							"type": "list",
							"member": {
								"locationName": "item",
								"type": "structure",
								"members": {
									"State": {
										"locationName": "state"
									},
									"InstanceCount": {
										"locationName": "instanceCount",
										"type": "integer"
									}
								}
							}
						},
						"PriceSchedules": {
							"locationName": "priceSchedules",
							"type": "list",
							"member": {
								"locationName": "item",
								"type": "structure",
								"members": {
									"Term": {
										"locationName": "term",
										"type": "long"
									},
									"Price": {
										"locationName": "price",
										"type": "double"
									},
									"CurrencyCode": {
										"locationName": "currencyCode"
									},
									"Active": {
										"locationName": "active",
										"type": "boolean"
									}
								}
							}
						},
						"Tags": {
							"shape": "Sh",
							"locationName": "tagSet"
						},
						"ClientToken": {
							"locationName": "clientToken"
						}
					}
				}
			},
			"S2c": {
				"type": "list",
				"member": {
					"locationName": "item"
				}
			},
			"S2m": {
				"type": "list",
				"member": {
					"locationName": "SpotInstanceRequestId"
				}
			},
			"S30": {
				"type": "structure",
				"members": {
					"CustomerGatewayId": {
						"locationName": "customerGatewayId"
					},
					"State": {
						"locationName": "state"
					},
					"Type": {
						"locationName": "type"
					},
					"IpAddress": {
						"locationName": "ipAddress"
					},
					"BgpAsn": {
						"locationName": "bgpAsn"
					},
					"Tags": {
						"shape": "Sh",
						"locationName": "tagSet"
					}
				}
			},
			"S35": {
				"type": "structure",
				"members": {
					"DhcpOptionsId": {
						"locationName": "dhcpOptionsId"
					},
					"DhcpConfigurations": {
						"locationName": "dhcpConfigurationSet",
						"type": "list",
						"member": {
							"locationName": "item",
							"type": "structure",
							"members": {
								"Key": {
									"locationName": "key"
								},
								"Values": {
									"locationName": "valueSet",
									"type": "list",
									"member": {
										"shape": "S39",
										"locationName": "item"
									}
								}
							}
						}
					},
					"Tags": {
						"shape": "Sh",
						"locationName": "tagSet"
					}
				}
			},
			"S39": {
				"type": "structure",
				"members": {
					"Value": {
						"locationName": "value"
					}
				}
			},
			"S3e": {
				"type": "list",
				"member": {
					"shape": "S3f",
					"locationName": "item"
				}
			},
			"S3f": {
				"type": "structure",
				"required": [
					"Error"
				],
				"members": {
					"Error": {
						"locationName": "error",
						"type": "structure",
						"required": [
							"Code",
							"Message"
						],
						"members": {
							"Code": {
								"locationName": "code"
							},
							"Message": {
								"locationName": "message"
							}
						}
					},
					"ResourceId": {
						"locationName": "resourceId"
					}
				}
			},
			"S3i": {
				"type": "list",
				"member": {
					"shape": "S3j",
					"locationName": "BlockDeviceMapping"
				}
			},
			"S3j": {
				"type": "structure",
				"members": {
					"VirtualName": {
						"locationName": "virtualName"
					},
					"DeviceName": {
						"locationName": "deviceName"
					},
					"Ebs": {
						"locationName": "ebs",
						"type": "structure",
						"members": {
							"SnapshotId": {
								"locationName": "snapshotId"
							},
							"VolumeSize": {
								"locationName": "volumeSize",
								"type": "integer"
							},
							"DeleteOnTermination": {
								"locationName": "deleteOnTermination",
								"type": "boolean"
							},
							"VolumeType": {
								"locationName": "volumeType"
							},
							"Iops": {
								"locationName": "iops",
								"type": "integer"
							},
							"Encrypted": {
								"locationName": "encrypted",
								"type": "boolean"
							}
						}
					},
					"NoDevice": {
						"locationName": "noDevice"
					}
				}
			},
			"S3t": {
				"type": "structure",
				"members": {
					"ExportTaskId": {
						"locationName": "exportTaskId"
					},
					"Description": {
						"locationName": "description"
					},
					"State": {
						"locationName": "state"
					},
					"StatusMessage": {
						"locationName": "statusMessage"
					},
					"InstanceExportDetails": {
						"locationName": "instanceExport",
						"type": "structure",
						"members": {
							"InstanceId": {
								"locationName": "instanceId"
							},
							"TargetEnvironment": {
								"locationName": "targetEnvironment"
							}
						}
					},
					"ExportToS3Task": {
						"locationName": "exportToS3",
						"type": "structure",
						"members": {
							"DiskImageFormat": {
								"locationName": "diskImageFormat"
							},
							"ContainerFormat": {
								"locationName": "containerFormat"
							},
							"S3Bucket": {
								"locationName": "s3Bucket"
							},
							"S3Key": {
								"locationName": "s3Key"
							}
						}
					}
				}
			},
			"S3z": {
				"type": "structure",
				"members": {
					"InternetGatewayId": {
						"locationName": "internetGatewayId"
					},
					"Attachments": {
						"locationName": "attachmentSet",
						"type": "list",
						"member": {
							"locationName": "item",
							"type": "structure",
							"members": {
								"VpcId": {
									"locationName": "vpcId"
								},
								"State": {
									"locationName": "state"
								}
							}
						}
					},
					"Tags": {
						"shape": "Sh",
						"locationName": "tagSet"
					}
				}
			},
			"S46": {
				"type": "structure",
				"members": {
					"VpcId": {
						"locationName": "vpcId"
					},
					"SubnetId": {
						"locationName": "subnetId"
					},
					"NatGatewayId": {
						"locationName": "natGatewayId"
					},
					"CreateTime": {
						"locationName": "createTime",
						"type": "timestamp"
					},
					"DeleteTime": {
						"locationName": "deleteTime",
						"type": "timestamp"
					},
					"NatGatewayAddresses": {
						"locationName": "natGatewayAddressSet",
						"type": "list",
						"member": {
							"locationName": "item",
							"type": "structure",
							"members": {
								"PublicIp": {
									"locationName": "publicIp"
								},
								"AllocationId": {
									"locationName": "allocationId"
								},
								"PrivateIp": {
									"locationName": "privateIp"
								},
								"NetworkInterfaceId": {
									"locationName": "networkInterfaceId"
								}
							}
						}
					},
					"State": {
						"locationName": "state"
					},
					"FailureCode": {
						"locationName": "failureCode"
					},
					"FailureMessage": {
						"locationName": "failureMessage"
					},
					"ProvisionedBandwidth": {
						"locationName": "provisionedBandwidth",
						"type": "structure",
						"members": {
							"Provisioned": {
								"locationName": "provisioned"
							},
							"Requested": {
								"locationName": "requested"
							},
							"RequestTime": {
								"locationName": "requestTime",
								"type": "timestamp"
							},
							"ProvisionTime": {
								"locationName": "provisionTime",
								"type": "timestamp"
							},
							"Status": {
								"locationName": "status"
							}
						}
					}
				}
			},
			"S4d": {
				"type": "structure",
				"members": {
					"NetworkAclId": {
						"locationName": "networkAclId"
					},
					"VpcId": {
						"locationName": "vpcId"
					},
					"IsDefault": {
						"locationName": "default",
						"type": "boolean"
					},
					"Entries": {
						"locationName": "entrySet",
						"type": "list",
						"member": {
							"locationName": "item",
							"type": "structure",
							"members": {
								"RuleNumber": {
									"locationName": "ruleNumber",
									"type": "integer"
								},
								"Protocol": {
									"locationName": "protocol"
								},
								"RuleAction": {
									"locationName": "ruleAction"
								},
								"Egress": {
									"locationName": "egress",
									"type": "boolean"
								},
								"CidrBlock": {
									"locationName": "cidrBlock"
								},
								"IcmpTypeCode": {
									"shape": "S4h",
									"locationName": "icmpTypeCode"
								},
								"PortRange": {
									"shape": "S4i",
									"locationName": "portRange"
								}
							}
						}
					},
					"Associations": {
						"locationName": "associationSet",
						"type": "list",
						"member": {
							"locationName": "item",
							"type": "structure",
							"members": {
								"NetworkAclAssociationId": {
									"locationName": "networkAclAssociationId"
								},
								"NetworkAclId": {
									"locationName": "networkAclId"
								},
								"SubnetId": {
									"locationName": "subnetId"
								}
							}
						}
					},
					"Tags": {
						"shape": "Sh",
						"locationName": "tagSet"
					}
				}
			},
			"S4h": {
				"type": "structure",
				"members": {
					"Type": {
						"locationName": "type",
						"type": "integer"
					},
					"Code": {
						"locationName": "code",
						"type": "integer"
					}
				}
			},
			"S4i": {
				"type": "structure",
				"members": {
					"From": {
						"locationName": "from",
						"type": "integer"
					},
					"To": {
						"locationName": "to",
						"type": "integer"
					}
				}
			},
			"S4n": {
				"type": "list",
				"member": {
					"locationName": "SecurityGroupId"
				}
			},
			"S4o": {
				"type": "list",
				"member": {
					"locationName": "item",
					"type": "structure",
					"required": [
						"PrivateIpAddress"
					],
					"members": {
						"PrivateIpAddress": {
							"locationName": "privateIpAddress"
						},
						"Primary": {
							"locationName": "primary",
							"type": "boolean"
						}
					}
				}
			},
			"S4r": {
				"type": "structure",
				"members": {
					"NetworkInterfaceId": {
						"locationName": "networkInterfaceId"
					},
					"SubnetId": {
						"locationName": "subnetId"
					},
					"VpcId": {
						"locationName": "vpcId"
					},
					"AvailabilityZone": {
						"locationName": "availabilityZone"
					},
					"Description": {
						"locationName": "description"
					},
					"OwnerId": {
						"locationName": "ownerId"
					},
					"RequesterId": {
						"locationName": "requesterId"
					},
					"RequesterManaged": {
						"locationName": "requesterManaged",
						"type": "boolean"
					},
					"Status": {
						"locationName": "status"
					},
					"MacAddress": {
						"locationName": "macAddress"
					},
					"PrivateIpAddress": {
						"locationName": "privateIpAddress"
					},
					"PrivateDnsName": {
						"locationName": "privateDnsName"
					},
					"SourceDestCheck": {
						"locationName": "sourceDestCheck",
						"type": "boolean"
					},
					"Groups": {
						"shape": "S4t",
						"locationName": "groupSet"
					},
					"Attachment": {
						"shape": "S4v",
						"locationName": "attachment"
					},
					"Association": {
						"shape": "S4w",
						"locationName": "association"
					},
					"TagSet": {
						"shape": "Sh",
						"locationName": "tagSet"
					},
					"PrivateIpAddresses": {
						"locationName": "privateIpAddressesSet",
						"type": "list",
						"member": {
							"locationName": "item",
							"type": "structure",
							"members": {
								"PrivateIpAddress": {
									"locationName": "privateIpAddress"
								},
								"PrivateDnsName": {
									"locationName": "privateDnsName"
								},
								"Primary": {
									"locationName": "primary",
									"type": "boolean"
								},
								"Association": {
									"shape": "S4w",
									"locationName": "association"
								}
							}
						}
					},
					"InterfaceType": {
						"locationName": "interfaceType"
					}
				}
			},
			"S4t": {
				"type": "list",
				"member": {
					"locationName": "item",
					"type": "structure",
					"members": {
						"GroupName": {
							"locationName": "groupName"
						},
						"GroupId": {
							"locationName": "groupId"
						}
					}
				}
			},
			"S4v": {
				"type": "structure",
				"members": {
					"AttachmentId": {
						"locationName": "attachmentId"
					},
					"InstanceId": {
						"locationName": "instanceId"
					},
					"InstanceOwnerId": {
						"locationName": "instanceOwnerId"
					},
					"DeviceIndex": {
						"locationName": "deviceIndex",
						"type": "integer"
					},
					"Status": {
						"locationName": "status"
					},
					"AttachTime": {
						"locationName": "attachTime",
						"type": "timestamp"
					},
					"DeleteOnTermination": {
						"locationName": "deleteOnTermination",
						"type": "boolean"
					}
				}
			},
			"S4w": {
				"type": "structure",
				"members": {
					"PublicIp": {
						"locationName": "publicIp"
					},
					"PublicDnsName": {
						"locationName": "publicDnsName"
					},
					"IpOwnerId": {
						"locationName": "ipOwnerId"
					},
					"AllocationId": {
						"locationName": "allocationId"
					},
					"AssociationId": {
						"locationName": "associationId"
					}
				}
			},
			"S5a": {
				"type": "structure",
				"members": {
					"RouteTableId": {
						"locationName": "routeTableId"
					},
					"VpcId": {
						"locationName": "vpcId"
					},
					"Routes": {
						"locationName": "routeSet",
						"type": "list",
						"member": {
							"locationName": "item",
							"type": "structure",
							"members": {
								"DestinationCidrBlock": {
									"locationName": "destinationCidrBlock"
								},
								"DestinationPrefixListId": {
									"locationName": "destinationPrefixListId"
								},
								"GatewayId": {
									"locationName": "gatewayId"
								},
								"InstanceId": {
									"locationName": "instanceId"
								},
								"InstanceOwnerId": {
									"locationName": "instanceOwnerId"
								},
								"NetworkInterfaceId": {
									"locationName": "networkInterfaceId"
								},
								"VpcPeeringConnectionId": {
									"locationName": "vpcPeeringConnectionId"
								},
								"NatGatewayId": {
									"locationName": "natGatewayId"
								},
								"State": {
									"locationName": "state"
								},
								"Origin": {
									"locationName": "origin"
								}
							}
						}
					},
					"Associations": {
						"locationName": "associationSet",
						"type": "list",
						"member": {
							"locationName": "item",
							"type": "structure",
							"members": {
								"RouteTableAssociationId": {
									"locationName": "routeTableAssociationId"
								},
								"RouteTableId": {
									"locationName": "routeTableId"
								},
								"SubnetId": {
									"locationName": "subnetId"
								},
								"Main": {
									"locationName": "main",
									"type": "boolean"
								}
							}
						}
					},
					"Tags": {
						"shape": "Sh",
						"locationName": "tagSet"
					},
					"PropagatingVgws": {
						"locationName": "propagatingVgwSet",
						"type": "list",
						"member": {
							"locationName": "item",
							"type": "structure",
							"members": {
								"GatewayId": {
									"locationName": "gatewayId"
								}
							}
						}
					}
				}
			},
			"S5m": {
				"type": "structure",
				"members": {
					"SnapshotId": {
						"locationName": "snapshotId"
					},
					"VolumeId": {
						"locationName": "volumeId"
					},
					"State": {
						"locationName": "status"
					},
					"StateMessage": {
						"locationName": "statusMessage"
					},
					"StartTime": {
						"locationName": "startTime",
						"type": "timestamp"
					},
					"Progress": {
						"locationName": "progress"
					},
					"OwnerId": {
						"locationName": "ownerId"
					},
					"Description": {
						"locationName": "description"
					},
					"VolumeSize": {
						"locationName": "volumeSize",
						"type": "integer"
					},
					"OwnerAlias": {
						"locationName": "ownerAlias"
					},
					"Tags": {
						"shape": "Sh",
						"locationName": "tagSet"
					},
					"Encrypted": {
						"locationName": "encrypted",
						"type": "boolean"
					},
					"KmsKeyId": {
						"locationName": "kmsKeyId"
					},
					"DataEncryptionKeyId": {
						"locationName": "dataEncryptionKeyId"
					}
				}
			},
			"S5q": {
				"type": "structure",
				"members": {
					"OwnerId": {
						"locationName": "ownerId"
					},
					"Bucket": {
						"locationName": "bucket"
					},
					"Prefix": {
						"locationName": "prefix"
					},
					"State": {
						"locationName": "state"
					},
					"Fault": {
						"shape": "S5s",
						"locationName": "fault"
					}
				}
			},
			"S5s": {
				"type": "structure",
				"members": {
					"Code": {
						"locationName": "code"
					},
					"Message": {
						"locationName": "message"
					}
				}
			},
			"S5v": {
				"type": "structure",
				"members": {
					"SubnetId": {
						"locationName": "subnetId"
					},
					"State": {
						"locationName": "state"
					},
					"VpcId": {
						"locationName": "vpcId"
					},
					"CidrBlock": {
						"locationName": "cidrBlock"
					},
					"AvailableIpAddressCount": {
						"locationName": "availableIpAddressCount",
						"type": "integer"
					},
					"AvailabilityZone": {
						"locationName": "availabilityZone"
					},
					"DefaultForAz": {
						"locationName": "defaultForAz",
						"type": "boolean"
					},
					"MapPublicIpOnLaunch": {
						"locationName": "mapPublicIpOnLaunch",
						"type": "boolean"
					},
					"Tags": {
						"shape": "Sh",
						"locationName": "tagSet"
					}
				}
			},
			"S5y": {
				"type": "list",
				"member": {}
			},
			"S60": {
				"type": "structure",
				"members": {
					"VolumeId": {
						"locationName": "volumeId"
					},
					"Size": {
						"locationName": "size",
						"type": "integer"
					},
					"SnapshotId": {
						"locationName": "snapshotId"
					},
					"AvailabilityZone": {
						"locationName": "availabilityZone"
					},
					"State": {
						"locationName": "status"
					},
					"CreateTime": {
						"locationName": "createTime",
						"type": "timestamp"
					},
					"Attachments": {
						"locationName": "attachmentSet",
						"type": "list",
						"member": {
							"shape": "S14",
							"locationName": "item"
						}
					},
					"Tags": {
						"shape": "Sh",
						"locationName": "tagSet"
					},
					"VolumeType": {
						"locationName": "volumeType"
					},
					"Iops": {
						"locationName": "iops",
						"type": "integer"
					},
					"Encrypted": {
						"locationName": "encrypted",
						"type": "boolean"
					},
					"KmsKeyId": {
						"locationName": "kmsKeyId"
					}
				}
			},
			"S66": {
				"type": "structure",
				"members": {
					"VpcId": {
						"locationName": "vpcId"
					},
					"State": {
						"locationName": "state"
					},
					"CidrBlock": {
						"locationName": "cidrBlock"
					},
					"DhcpOptionsId": {
						"locationName": "dhcpOptionsId"
					},
					"Tags": {
						"shape": "Sh",
						"locationName": "tagSet"
					},
					"InstanceTenancy": {
						"locationName": "instanceTenancy"
					},
					"IsDefault": {
						"locationName": "isDefault",
						"type": "boolean"
					}
				}
			},
			"S6a": {
				"type": "structure",
				"members": {
					"VpcEndpointId": {
						"locationName": "vpcEndpointId"
					},
					"VpcId": {
						"locationName": "vpcId"
					},
					"ServiceName": {
						"locationName": "serviceName"
					},
					"State": {
						"locationName": "state"
					},
					"PolicyDocument": {
						"locationName": "policyDocument"
					},
					"RouteTableIds": {
						"shape": "S2c",
						"locationName": "routeTableIdSet"
					},
					"CreationTimestamp": {
						"locationName": "creationTimestamp",
						"type": "timestamp"
					}
				}
			},
			"S6h": {
				"type": "structure",
				"members": {
					"VpnConnectionId": {
						"locationName": "vpnConnectionId"
					},
					"State": {
						"locationName": "state"
					},
					"CustomerGatewayConfiguration": {
						"locationName": "customerGatewayConfiguration"
					},
					"Type": {
						"locationName": "type"
					},
					"CustomerGatewayId": {
						"locationName": "customerGatewayId"
					},
					"VpnGatewayId": {
						"locationName": "vpnGatewayId"
					},
					"Tags": {
						"shape": "Sh",
						"locationName": "tagSet"
					},
					"VgwTelemetry": {
						"locationName": "vgwTelemetry",
						"type": "list",
						"member": {
							"locationName": "item",
							"type": "structure",
							"members": {
								"OutsideIpAddress": {
									"locationName": "outsideIpAddress"
								},
								"Status": {
									"locationName": "status"
								},
								"LastStatusChange": {
									"locationName": "lastStatusChange",
									"type": "timestamp"
								},
								"StatusMessage": {
									"locationName": "statusMessage"
								},
								"AcceptedRouteCount": {
									"locationName": "acceptedRouteCount",
									"type": "integer"
								}
							}
						}
					},
					"Options": {
						"locationName": "options",
						"type": "structure",
						"members": {
							"StaticRoutesOnly": {
								"locationName": "staticRoutesOnly",
								"type": "boolean"
							}
						}
					},
					"Routes": {
						"locationName": "routes",
						"type": "list",
						"member": {
							"locationName": "item",
							"type": "structure",
							"members": {
								"DestinationCidrBlock": {
									"locationName": "destinationCidrBlock"
								},
								"Source": {
									"locationName": "source"
								},
								"State": {
									"locationName": "state"
								}
							}
						}
					}
				}
			},
			"S6t": {
				"type": "structure",
				"members": {
					"VpnGatewayId": {
						"locationName": "vpnGatewayId"
					},
					"State": {
						"locationName": "state"
					},
					"Type": {
						"locationName": "type"
					},
					"AvailabilityZone": {
						"locationName": "availabilityZone"
					},
					"VpcAttachments": {
						"locationName": "attachments",
						"type": "list",
						"member": {
							"shape": "S18",
							"locationName": "item"
						}
					},
					"Tags": {
						"shape": "Sh",
						"locationName": "tagSet"
					}
				}
			},
			"S7y": {
				"type": "list",
				"member": {
					"locationName": "Filter",
					"type": "structure",
					"members": {
						"Name": {},
						"Values": {
							"shape": "S2c",
							"locationName": "Value"
						}
					}
				}
			},
			"S8h": {
				"type": "list",
				"member": {
					"locationName": "InstanceId"
				}
			},
			"S8p": {
				"type": "structure",
				"required": [
					"ConversionTaskId",
					"State"
				],
				"members": {
					"ConversionTaskId": {
						"locationName": "conversionTaskId"
					},
					"ExpirationTime": {
						"locationName": "expirationTime"
					},
					"ImportInstance": {
						"locationName": "importInstance",
						"type": "structure",
						"required": [
							"Volumes"
						],
						"members": {
							"Volumes": {
								"locationName": "volumes",
								"type": "list",
								"member": {
									"locationName": "item",
									"type": "structure",
									"required": [
										"BytesConverted",
										"AvailabilityZone",
										"Image",
										"Volume",
										"Status"
									],
									"members": {
										"BytesConverted": {
											"locationName": "bytesConverted",
											"type": "long"
										},
										"AvailabilityZone": {
											"locationName": "availabilityZone"
										},
										"Image": {
											"shape": "S8t",
											"locationName": "image"
										},
										"Volume": {
											"shape": "S8u",
											"locationName": "volume"
										},
										"Status": {
											"locationName": "status"
										},
										"StatusMessage": {
											"locationName": "statusMessage"
										},
										"Description": {
											"locationName": "description"
										}
									}
								}
							},
							"InstanceId": {
								"locationName": "instanceId"
							},
							"Platform": {
								"locationName": "platform"
							},
							"Description": {
								"locationName": "description"
							}
						}
					},
					"ImportVolume": {
						"locationName": "importVolume",
						"type": "structure",
						"required": [
							"BytesConverted",
							"AvailabilityZone",
							"Image",
							"Volume"
						],
						"members": {
							"BytesConverted": {
								"locationName": "bytesConverted",
								"type": "long"
							},
							"AvailabilityZone": {
								"locationName": "availabilityZone"
							},
							"Description": {
								"locationName": "description"
							},
							"Image": {
								"shape": "S8t",
								"locationName": "image"
							},
							"Volume": {
								"shape": "S8u",
								"locationName": "volume"
							}
						}
					},
					"State": {
						"locationName": "state"
					},
					"StatusMessage": {
						"locationName": "statusMessage"
					},
					"Tags": {
						"shape": "Sh",
						"locationName": "tagSet"
					}
				}
			},
			"S8t": {
				"type": "structure",
				"required": [
					"Format",
					"Size",
					"ImportManifestUrl"
				],
				"members": {
					"Format": {
						"locationName": "format"
					},
					"Size": {
						"locationName": "size",
						"type": "long"
					},
					"ImportManifestUrl": {
						"locationName": "importManifestUrl"
					},
					"Checksum": {
						"locationName": "checksum"
					}
				}
			},
			"S8u": {
				"type": "structure",
				"required": [
					"Id"
				],
				"members": {
					"Size": {
						"locationName": "size",
						"type": "long"
					},
					"Id": {
						"locationName": "id"
					}
				}
			},
			"S9o": {
				"type": "list",
				"member": {
					"locationName": "item"
				}
			},
			"S9r": {
				"type": "list",
				"member": {
					"locationName": "item"
				}
			},
			"Sa4": {
				"type": "list",
				"member": {
					"locationName": "item",
					"type": "structure",
					"members": {
						"Resource": {
							"locationName": "resource"
						},
						"UseLongIds": {
							"locationName": "useLongIds",
							"type": "boolean"
						},
						"Deadline": {
							"locationName": "deadline",
							"type": "timestamp"
						}
					}
				}
			},
			"Sab": {
				"type": "list",
				"member": {
					"locationName": "item",
					"type": "structure",
					"members": {
						"UserId": {
							"locationName": "userId"
						},
						"Group": {
							"locationName": "group"
						}
					}
				}
			},
			"Sae": {
				"type": "list",
				"member": {
					"locationName": "item",
					"type": "structure",
					"members": {
						"ProductCodeId": {
							"locationName": "productCode"
						},
						"ProductCodeType": {
							"locationName": "type"
						}
					}
				}
			},
			"Sah": {
				"type": "list",
				"member": {
					"shape": "S3j",
					"locationName": "item"
				}
			},
			"Sak": {
				"type": "list",
				"member": {
					"locationName": "Owner"
				}
			},
			"Sas": {
				"type": "structure",
				"members": {
					"Code": {
						"locationName": "code"
					},
					"Message": {
						"locationName": "message"
					}
				}
			},
			"Sax": {
				"type": "list",
				"member": {
					"locationName": "ImportTaskId"
				}
			},
			"Sb1": {
				"type": "list",
				"member": {
					"locationName": "item",
					"type": "structure",
					"members": {
						"DiskImageSize": {
							"locationName": "diskImageSize",
							"type": "double"
						},
						"Description": {
							"locationName": "description"
						},
						"Format": {
							"locationName": "format"
						},
						"Url": {
							"locationName": "url"
						},
						"UserBucket": {
							"shape": "Sb3",
							"locationName": "userBucket"
						},
						"DeviceName": {
							"locationName": "deviceName"
						},
						"SnapshotId": {
							"locationName": "snapshotId"
						},
						"Progress": {
							"locationName": "progress"
						},
						"StatusMessage": {
							"locationName": "statusMessage"
						},
						"Status": {
							"locationName": "status"
						}
					}
				}
			},
			"Sb3": {
				"type": "structure",
				"members": {
					"S3Bucket": {
						"locationName": "s3Bucket"
					},
					"S3Key": {
						"locationName": "s3Key"
					}
				}
			},
			"Sb8": {
				"type": "structure",
				"members": {
					"DiskImageSize": {
						"locationName": "diskImageSize",
						"type": "double"
					},
					"Description": {
						"locationName": "description"
					},
					"Format": {
						"locationName": "format"
					},
					"Url": {
						"locationName": "url"
					},
					"UserBucket": {
						"shape": "Sb3",
						"locationName": "userBucket"
					},
					"SnapshotId": {
						"locationName": "snapshotId"
					},
					"Progress": {
						"locationName": "progress"
					},
					"StatusMessage": {
						"locationName": "statusMessage"
					},
					"Status": {
						"locationName": "status"
					}
				}
			},
			"Sbc": {
				"type": "structure",
				"members": {
					"Value": {
						"locationName": "value",
						"type": "boolean"
					}
				}
			},
			"Sbd": {
				"type": "list",
				"member": {
					"locationName": "item",
					"type": "structure",
					"members": {
						"DeviceName": {
							"locationName": "deviceName"
						},
						"Ebs": {
							"locationName": "ebs",
							"type": "structure",
							"members": {
								"VolumeId": {
									"locationName": "volumeId"
								},
								"Status": {
									"locationName": "status"
								},
								"AttachTime": {
									"locationName": "attachTime",
									"type": "timestamp"
								},
								"DeleteOnTermination": {
									"locationName": "deleteOnTermination",
									"type": "boolean"
								}
							}
						}
					}
				}
			},
			"Sbn": {
				"type": "structure",
				"members": {
					"Code": {
						"locationName": "code",
						"type": "integer"
					},
					"Name": {
						"locationName": "name"
					}
				}
			},
			"Sbp": {
				"type": "structure",
				"members": {
					"Status": {
						"locationName": "status"
					},
					"Details": {
						"locationName": "details",
						"type": "list",
						"member": {
							"locationName": "item",
							"type": "structure",
							"members": {
								"Name": {
									"locationName": "name"
								},
								"Status": {
									"locationName": "status"
								},
								"ImpairedSince": {
									"locationName": "impairedSince",
									"type": "timestamp"
								}
							}
						}
					}
				}
			},
			"Sby": {
				"type": "structure",
				"members": {
					"ReservationId": {
						"locationName": "reservationId"
					},
					"OwnerId": {
						"locationName": "ownerId"
					},
					"RequesterId": {
						"locationName": "requesterId"
					},
					"Groups": {
						"shape": "S4t",
						"locationName": "groupSet"
					},
					"Instances": {
						"locationName": "instancesSet",
						"type": "list",
						"member": {
							"locationName": "item",
							"type": "structure",
							"members": {
								"InstanceId": {
									"locationName": "instanceId"
								},
								"ImageId": {
									"locationName": "imageId"
								},
								"State": {
									"shape": "Sbn",
									"locationName": "instanceState"
								},
								"PrivateDnsName": {
									"locationName": "privateDnsName"
								},
								"PublicDnsName": {
									"locationName": "dnsName"
								},
								"StateTransitionReason": {
									"locationName": "reason"
								},
								"KeyName": {
									"locationName": "keyName"
								},
								"AmiLaunchIndex": {
									"locationName": "amiLaunchIndex",
									"type": "integer"
								},
								"ProductCodes": {
									"shape": "Sae",
									"locationName": "productCodes"
								},
								"InstanceType": {
									"locationName": "instanceType"
								},
								"LaunchTime": {
									"locationName": "launchTime",
									"type": "timestamp"
								},
								"Placement": {
									"shape": "Sc2",
									"locationName": "placement"
								},
								"KernelId": {
									"locationName": "kernelId"
								},
								"RamdiskId": {
									"locationName": "ramdiskId"
								},
								"Platform": {
									"locationName": "platform"
								},
								"Monitoring": {
									"shape": "Sc3",
									"locationName": "monitoring"
								},
								"SubnetId": {
									"locationName": "subnetId"
								},
								"VpcId": {
									"locationName": "vpcId"
								},
								"PrivateIpAddress": {
									"locationName": "privateIpAddress"
								},
								"PublicIpAddress": {
									"locationName": "ipAddress"
								},
								"StateReason": {
									"shape": "Sas",
									"locationName": "stateReason"
								},
								"Architecture": {
									"locationName": "architecture"
								},
								"RootDeviceType": {
									"locationName": "rootDeviceType"
								},
								"RootDeviceName": {
									"locationName": "rootDeviceName"
								},
								"BlockDeviceMappings": {
									"shape": "Sbd",
									"locationName": "blockDeviceMapping"
								},
								"VirtualizationType": {
									"locationName": "virtualizationType"
								},
								"InstanceLifecycle": {
									"locationName": "instanceLifecycle"
								},
								"SpotInstanceRequestId": {
									"locationName": "spotInstanceRequestId"
								},
								"ClientToken": {
									"locationName": "clientToken"
								},
								"Tags": {
									"shape": "Sh",
									"locationName": "tagSet"
								},
								"SecurityGroups": {
									"shape": "S4t",
									"locationName": "groupSet"
								},
								"SourceDestCheck": {
									"locationName": "sourceDestCheck",
									"type": "boolean"
								},
								"Hypervisor": {
									"locationName": "hypervisor"
								},
								"NetworkInterfaces": {
									"locationName": "networkInterfaceSet",
									"type": "list",
									"member": {
										"locationName": "item",
										"type": "structure",
										"members": {
											"NetworkInterfaceId": {
												"locationName": "networkInterfaceId"
											},
											"SubnetId": {
												"locationName": "subnetId"
											},
											"VpcId": {
												"locationName": "vpcId"
											},
											"Description": {
												"locationName": "description"
											},
											"OwnerId": {
												"locationName": "ownerId"
											},
											"Status": {
												"locationName": "status"
											},
											"MacAddress": {
												"locationName": "macAddress"
											},
											"PrivateIpAddress": {
												"locationName": "privateIpAddress"
											},
											"PrivateDnsName": {
												"locationName": "privateDnsName"
											},
											"SourceDestCheck": {
												"locationName": "sourceDestCheck",
												"type": "boolean"
											},
											"Groups": {
												"shape": "S4t",
												"locationName": "groupSet"
											},
											"Attachment": {
												"locationName": "attachment",
												"type": "structure",
												"members": {
													"AttachmentId": {
														"locationName": "attachmentId"
													},
													"DeviceIndex": {
														"locationName": "deviceIndex",
														"type": "integer"
													},
													"Status": {
														"locationName": "status"
													},
													"AttachTime": {
														"locationName": "attachTime",
														"type": "timestamp"
													},
													"DeleteOnTermination": {
														"locationName": "deleteOnTermination",
														"type": "boolean"
													}
												}
											},
											"Association": {
												"shape": "Sc9",
												"locationName": "association"
											},
											"PrivateIpAddresses": {
												"locationName": "privateIpAddressesSet",
												"type": "list",
												"member": {
													"locationName": "item",
													"type": "structure",
													"members": {
														"PrivateIpAddress": {
															"locationName": "privateIpAddress"
														},
														"PrivateDnsName": {
															"locationName": "privateDnsName"
														},
														"Primary": {
															"locationName": "primary",
															"type": "boolean"
														},
														"Association": {
															"shape": "Sc9",
															"locationName": "association"
														}
													}
												}
											}
										}
									}
								},
								"IamInstanceProfile": {
									"locationName": "iamInstanceProfile",
									"type": "structure",
									"members": {
										"Arn": {
											"locationName": "arn"
										},
										"Id": {
											"locationName": "id"
										}
									}
								},
								"EbsOptimized": {
									"locationName": "ebsOptimized",
									"type": "boolean"
								},
								"SriovNetSupport": {
									"locationName": "sriovNetSupport"
								},
								"EnaSupport": {
									"locationName": "enaSupport",
									"type": "boolean"
								}
							}
						}
					}
				}
			},
			"Sc2": {
				"type": "structure",
				"members": {
					"AvailabilityZone": {
						"locationName": "availabilityZone"
					},
					"GroupName": {
						"locationName": "groupName"
					},
					"Tenancy": {
						"locationName": "tenancy"
					},
					"HostId": {
						"locationName": "hostId"
					},
					"Affinity": {
						"locationName": "affinity"
					}
				}
			},
			"Sc3": {
				"type": "structure",
				"members": {
					"State": {
						"locationName": "state"
					}
				}
			},
			"Sc9": {
				"type": "structure",
				"members": {
					"PublicIp": {
						"locationName": "publicIp"
					},
					"PublicDnsName": {
						"locationName": "publicDnsName"
					},
					"IpOwnerId": {
						"locationName": "ipOwnerId"
					}
				}
			},
			"Sdj": {
				"type": "list",
				"member": {
					"locationName": "ReservedInstancesId"
				}
			},
			"Sds": {
				"type": "list",
				"member": {
					"locationName": "item",
					"type": "structure",
					"members": {
						"Frequency": {
							"locationName": "frequency"
						},
						"Amount": {
							"locationName": "amount",
							"type": "double"
						}
					}
				}
			},
			"Se7": {
				"type": "structure",
				"members": {
					"AvailabilityZone": {
						"locationName": "availabilityZone"
					},
					"Platform": {
						"locationName": "platform"
					},
					"InstanceCount": {
						"locationName": "instanceCount",
						"type": "integer"
					},
					"InstanceType": {
						"locationName": "instanceType"
					},
					"Scope": {
						"locationName": "scope"
					}
				}
			},
			"Sep": {
				"type": "structure",
				"members": {
					"Frequency": {
						"locationName": "frequency"
					},
					"Interval": {
						"locationName": "interval",
						"type": "integer"
					},
					"OccurrenceDaySet": {
						"locationName": "occurrenceDaySet",
						"type": "list",
						"member": {
							"locationName": "item",
							"type": "integer"
						}
					},
					"OccurrenceRelativeToEnd": {
						"locationName": "occurrenceRelativeToEnd",
						"type": "boolean"
					},
					"OccurrenceUnit": {
						"locationName": "occurrenceUnit"
					}
				}
			},
			"Sew": {
				"type": "structure",
				"members": {
					"ScheduledInstanceId": {
						"locationName": "scheduledInstanceId"
					},
					"InstanceType": {
						"locationName": "instanceType"
					},
					"Platform": {
						"locationName": "platform"
					},
					"NetworkPlatform": {
						"locationName": "networkPlatform"
					},
					"AvailabilityZone": {
						"locationName": "availabilityZone"
					},
					"SlotDurationInHours": {
						"locationName": "slotDurationInHours",
						"type": "integer"
					},
					"Recurrence": {
						"shape": "Sep",
						"locationName": "recurrence"
					},
					"PreviousSlotEndTime": {
						"locationName": "previousSlotEndTime",
						"type": "timestamp"
					},
					"NextSlotStartTime": {
						"locationName": "nextSlotStartTime",
						"type": "timestamp"
					},
					"HourlyPrice": {
						"locationName": "hourlyPrice"
					},
					"TotalScheduledInstanceHours": {
						"locationName": "totalScheduledInstanceHours",
						"type": "integer"
					},
					"InstanceCount": {
						"locationName": "instanceCount",
						"type": "integer"
					},
					"TermStartDate": {
						"locationName": "termStartDate",
						"type": "timestamp"
					},
					"TermEndDate": {
						"locationName": "termEndDate",
						"type": "timestamp"
					},
					"CreateDate": {
						"locationName": "createDate",
						"type": "timestamp"
					}
				}
			},
			"Sf3": {
				"type": "list",
				"member": {
					"locationName": "GroupName"
				}
			},
			"Sfa": {
				"type": "list",
				"member": {
					"locationName": "item",
					"type": "structure",
					"members": {
						"UserId": {
							"locationName": "userId"
						},
						"Group": {
							"locationName": "group"
						}
					}
				}
			},
			"Sfx": {
				"type": "structure",
				"required": [
					"SpotPrice",
					"TargetCapacity",
					"IamFleetRole",
					"LaunchSpecifications"
				],
				"members": {
					"ClientToken": {
						"locationName": "clientToken"
					},
					"SpotPrice": {
						"locationName": "spotPrice"
					},
					"TargetCapacity": {
						"locationName": "targetCapacity",
						"type": "integer"
					},
					"ValidFrom": {
						"locationName": "validFrom",
						"type": "timestamp"
					},
					"ValidUntil": {
						"locationName": "validUntil",
						"type": "timestamp"
					},
					"TerminateInstancesWithExpiration": {
						"locationName": "terminateInstancesWithExpiration",
						"type": "boolean"
					},
					"IamFleetRole": {
						"locationName": "iamFleetRole"
					},
					"LaunchSpecifications": {
						"locationName": "launchSpecifications",
						"type": "list",
						"member": {
							"locationName": "item",
							"type": "structure",
							"members": {
								"ImageId": {
									"locationName": "imageId"
								},
								"KeyName": {
									"locationName": "keyName"
								},
								"SecurityGroups": {
									"shape": "S4t",
									"locationName": "groupSet"
								},
								"UserData": {
									"locationName": "userData"
								},
								"AddressingType": {
									"locationName": "addressingType"
								},
								"InstanceType": {
									"locationName": "instanceType"
								},
								"Placement": {
									"shape": "Sg0",
									"locationName": "placement"
								},
								"KernelId": {
									"locationName": "kernelId"
								},
								"RamdiskId": {
									"locationName": "ramdiskId"
								},
								"BlockDeviceMappings": {
									"shape": "Sah",
									"locationName": "blockDeviceMapping"
								},
								"Monitoring": {
									"locationName": "monitoring",
									"type": "structure",
									"members": {
										"Enabled": {
											"locationName": "enabled",
											"type": "boolean"
										}
									}
								},
								"SubnetId": {
									"locationName": "subnetId"
								},
								"NetworkInterfaces": {
									"shape": "Sg2",
									"locationName": "networkInterfaceSet"
								},
								"IamInstanceProfile": {
									"shape": "Sg4",
									"locationName": "iamInstanceProfile"
								},
								"EbsOptimized": {
									"locationName": "ebsOptimized",
									"type": "boolean"
								},
								"WeightedCapacity": {
									"locationName": "weightedCapacity",
									"type": "double"
								},
								"SpotPrice": {
									"locationName": "spotPrice"
								}
							}
						}
					},
					"ExcessCapacityTerminationPolicy": {
						"locationName": "excessCapacityTerminationPolicy"
					},
					"AllocationStrategy": {
						"locationName": "allocationStrategy"
					},
					"FulfilledCapacity": {
						"locationName": "fulfilledCapacity",
						"type": "double"
					},
					"Type": {
						"locationName": "type"
					}
				}
			},
			"Sg0": {
				"type": "structure",
				"members": {
					"AvailabilityZone": {
						"locationName": "availabilityZone"
					},
					"GroupName": {
						"locationName": "groupName"
					}
				}
			},
			"Sg2": {
				"type": "list",
				"member": {
					"locationName": "item",
					"type": "structure",
					"members": {
						"NetworkInterfaceId": {
							"locationName": "networkInterfaceId"
						},
						"DeviceIndex": {
							"locationName": "deviceIndex",
							"type": "integer"
						},
						"SubnetId": {
							"locationName": "subnetId"
						},
						"Description": {
							"locationName": "description"
						},
						"PrivateIpAddress": {
							"locationName": "privateIpAddress"
						},
						"Groups": {
							"shape": "S4n",
							"locationName": "SecurityGroupId"
						},
						"DeleteOnTermination": {
							"locationName": "deleteOnTermination",
							"type": "boolean"
						},
						"PrivateIpAddresses": {
							"shape": "S4o",
							"locationName": "privateIpAddressesSet",
							"queryName": "PrivateIpAddresses"
						},
						"SecondaryPrivateIpAddressCount": {
							"locationName": "secondaryPrivateIpAddressCount",
							"type": "integer"
						},
						"AssociatePublicIpAddress": {
							"locationName": "associatePublicIpAddress",
							"type": "boolean"
						}
					}
				}
			},
			"Sg4": {
				"type": "structure",
				"members": {
					"Arn": {
						"locationName": "arn"
					},
					"Name": {
						"locationName": "name"
					}
				}
			},
			"Sgb": {
				"type": "list",
				"member": {
					"locationName": "item",
					"type": "structure",
					"members": {
						"SpotInstanceRequestId": {
							"locationName": "spotInstanceRequestId"
						},
						"SpotPrice": {
							"locationName": "spotPrice"
						},
						"Type": {
							"locationName": "type"
						},
						"State": {
							"locationName": "state"
						},
						"Fault": {
							"shape": "S5s",
							"locationName": "fault"
						},
						"Status": {
							"locationName": "status",
							"type": "structure",
							"members": {
								"Code": {
									"locationName": "code"
								},
								"UpdateTime": {
									"locationName": "updateTime",
									"type": "timestamp"
								},
								"Message": {
									"locationName": "message"
								}
							}
						},
						"ValidFrom": {
							"locationName": "validFrom",
							"type": "timestamp"
						},
						"ValidUntil": {
							"locationName": "validUntil",
							"type": "timestamp"
						},
						"LaunchGroup": {
							"locationName": "launchGroup"
						},
						"AvailabilityZoneGroup": {
							"locationName": "availabilityZoneGroup"
						},
						"LaunchSpecification": {
							"locationName": "launchSpecification",
							"type": "structure",
							"members": {
								"ImageId": {
									"locationName": "imageId"
								},
								"KeyName": {
									"locationName": "keyName"
								},
								"SecurityGroups": {
									"shape": "S4t",
									"locationName": "groupSet"
								},
								"UserData": {
									"locationName": "userData"
								},
								"AddressingType": {
									"locationName": "addressingType"
								},
								"InstanceType": {
									"locationName": "instanceType"
								},
								"Placement": {
									"shape": "Sg0",
									"locationName": "placement"
								},
								"KernelId": {
									"locationName": "kernelId"
								},
								"RamdiskId": {
									"locationName": "ramdiskId"
								},
								"BlockDeviceMappings": {
									"shape": "Sah",
									"locationName": "blockDeviceMapping"
								},
								"SubnetId": {
									"locationName": "subnetId"
								},
								"NetworkInterfaces": {
									"shape": "Sg2",
									"locationName": "networkInterfaceSet"
								},
								"IamInstanceProfile": {
									"shape": "Sg4",
									"locationName": "iamInstanceProfile"
								},
								"EbsOptimized": {
									"locationName": "ebsOptimized",
									"type": "boolean"
								},
								"Monitoring": {
									"shape": "Sgh",
									"locationName": "monitoring"
								}
							}
						},
						"InstanceId": {
							"locationName": "instanceId"
						},
						"CreateTime": {
							"locationName": "createTime",
							"type": "timestamp"
						},
						"ProductDescription": {
							"locationName": "productDescription"
						},
						"BlockDurationMinutes": {
							"locationName": "blockDurationMinutes",
							"type": "integer"
						},
						"ActualBlockHourlyPrice": {
							"locationName": "actualBlockHourlyPrice"
						},
						"Tags": {
							"shape": "Sh",
							"locationName": "tagSet"
						},
						"LaunchedAvailabilityZone": {
							"locationName": "launchedAvailabilityZone"
						}
					}
				}
			},
			"Sgh": {
				"type": "structure",
				"required": [
					"Enabled"
				],
				"members": {
					"Enabled": {
						"locationName": "enabled",
						"type": "boolean"
					}
				}
			},
			"Sgu": {
				"type": "list",
				"member": {
					"locationName": "item",
					"type": "structure",
					"members": {
						"FromPort": {
							"locationName": "fromPort",
							"type": "integer"
						},
						"IpProtocol": {
							"locationName": "ipProtocol"
						},
						"IpRanges": {
							"locationName": "ipRanges",
							"type": "list",
							"member": {
								"locationName": "item"
							}
						},
						"PrefixListIds": {
							"locationName": "prefixListIds",
							"type": "list",
							"member": {
								"locationName": "item"
							}
						},
						"ToPort": {
							"locationName": "toPort",
							"type": "integer"
						},
						"UserIdGroupPairs": {
							"locationName": "groups",
							"type": "list",
							"member": {
								"shape": "S1e",
								"locationName": "item"
							}
						}
					}
				}
			},
			"Shc": {
				"type": "list",
				"member": {
					"locationName": "VolumeId"
				}
			},
			"Shw": {
				"type": "list",
				"member": {
					"locationName": "VpcId"
				}
			},
			"Sjc": {
				"type": "list",
				"member": {
					"locationName": "item"
				}
			},
			"Sje": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"HostReservationId": {
							"locationName": "hostReservationId"
						},
						"HostIdSet": {
							"shape": "S9o",
							"locationName": "hostIdSet"
						},
						"InstanceFamily": {
							"locationName": "instanceFamily"
						},
						"PaymentOption": {
							"locationName": "paymentOption"
						},
						"UpfrontPrice": {
							"locationName": "upfrontPrice"
						},
						"HourlyPrice": {
							"locationName": "hourlyPrice"
						},
						"CurrencyCode": {
							"locationName": "currencyCode"
						},
						"Duration": {
							"locationName": "duration",
							"type": "integer"
						}
					}
				}
			},
			"Sjm": {
				"type": "structure",
				"members": {
					"RemainingTotalValue": {
						"locationName": "remainingTotalValue"
					},
					"RemainingUpfrontValue": {
						"locationName": "remainingUpfrontValue"
					},
					"HourlyPrice": {
						"locationName": "hourlyPrice"
					}
				}
			},
			"Sjt": {
				"type": "structure",
				"members": {
					"S3Bucket": {},
					"S3Key": {}
				}
			},
			"Sju": {
				"type": "structure",
				"members": {
					"UploadStart": {
						"type": "timestamp"
					},
					"UploadEnd": {
						"type": "timestamp"
					},
					"UploadSize": {
						"type": "double"
					},
					"Comment": {}
				}
			},
			"Sjy": {
				"type": "list",
				"member": {
					"locationName": "SecurityGroup"
				}
			},
			"Sk3": {
				"type": "structure",
				"required": [
					"Format",
					"Bytes",
					"ImportManifestUrl"
				],
				"members": {
					"Format": {
						"locationName": "format"
					},
					"Bytes": {
						"locationName": "bytes",
						"type": "long"
					},
					"ImportManifestUrl": {
						"locationName": "importManifestUrl"
					}
				}
			},
			"Sk4": {
				"type": "structure",
				"required": [
					"Size"
				],
				"members": {
					"Size": {
						"locationName": "size",
						"type": "long"
					}
				}
			},
			"Skf": {
				"type": "list",
				"member": {
					"shape": "S3f",
					"locationName": "item"
				}
			},
			"Skk": {
				"type": "list",
				"member": {
					"locationName": "UserId"
				}
			},
			"Slc": {
				"type": "structure",
				"members": {
					"AllowEgressFromLocalClassicLinkToRemoteVpc": {
						"type": "boolean"
					},
					"AllowEgressFromLocalVpcToRemoteClassicLink": {
						"type": "boolean"
					},
					"AllowDnsResolutionFromRemoteVpc": {
						"type": "boolean"
					}
				}
			},
			"Sle": {
				"type": "structure",
				"members": {
					"AllowEgressFromLocalClassicLinkToRemoteVpc": {
						"locationName": "allowEgressFromLocalClassicLinkToRemoteVpc",
						"type": "boolean"
					},
					"AllowEgressFromLocalVpcToRemoteClassicLink": {
						"locationName": "allowEgressFromLocalVpcToRemoteClassicLink",
						"type": "boolean"
					},
					"AllowDnsResolutionFromRemoteVpc": {
						"locationName": "allowDnsResolutionFromRemoteVpc",
						"type": "boolean"
					}
				}
			},
			"Slh": {
				"type": "list",
				"member": {
					"locationName": "item",
					"type": "structure",
					"members": {
						"InstanceId": {
							"locationName": "instanceId"
						},
						"Monitoring": {
							"shape": "Sc3",
							"locationName": "monitoring"
						}
					}
				}
			},
			"Smv": {
				"type": "list",
				"member": {
					"locationName": "SecurityGroupId"
				}
			},
			"Sna": {
				"type": "list",
				"member": {
					"locationName": "item",
					"type": "structure",
					"members": {
						"InstanceId": {
							"locationName": "instanceId"
						},
						"CurrentState": {
							"shape": "Sbn",
							"locationName": "currentState"
						},
						"PreviousState": {
							"shape": "Sbn",
							"locationName": "previousState"
						}
					}
				}
			}
		}
	};

/***/ },
/* 330 */
/***/ function(module, exports) {

	module.exports = {
		"pagination": {
			"DescribeAccountAttributes": {
				"result_key": "AccountAttributes"
			},
			"DescribeAddresses": {
				"result_key": "Addresses"
			},
			"DescribeAvailabilityZones": {
				"result_key": "AvailabilityZones"
			},
			"DescribeBundleTasks": {
				"result_key": "BundleTasks"
			},
			"DescribeConversionTasks": {
				"result_key": "ConversionTasks"
			},
			"DescribeCustomerGateways": {
				"result_key": "CustomerGateways"
			},
			"DescribeDhcpOptions": {
				"result_key": "DhcpOptions"
			},
			"DescribeExportTasks": {
				"result_key": "ExportTasks"
			},
			"DescribeImages": {
				"result_key": "Images"
			},
			"DescribeInstanceStatus": {
				"input_token": "NextToken",
				"output_token": "NextToken",
				"limit_key": "MaxResults",
				"result_key": "InstanceStatuses"
			},
			"DescribeInstances": {
				"input_token": "NextToken",
				"output_token": "NextToken",
				"limit_key": "MaxResults",
				"result_key": "Reservations"
			},
			"DescribeInternetGateways": {
				"result_key": "InternetGateways"
			},
			"DescribeKeyPairs": {
				"result_key": "KeyPairs"
			},
			"DescribeNetworkAcls": {
				"result_key": "NetworkAcls"
			},
			"DescribeNetworkInterfaces": {
				"result_key": "NetworkInterfaces"
			},
			"DescribePlacementGroups": {
				"result_key": "PlacementGroups"
			},
			"DescribeRegions": {
				"result_key": "Regions"
			},
			"DescribeReservedInstances": {
				"result_key": "ReservedInstances"
			},
			"DescribeReservedInstancesListings": {
				"result_key": "ReservedInstancesListings"
			},
			"DescribeReservedInstancesOfferings": {
				"input_token": "NextToken",
				"output_token": "NextToken",
				"limit_key": "MaxResults",
				"result_key": "ReservedInstancesOfferings"
			},
			"DescribeReservedInstancesModifications": {
				"input_token": "NextToken",
				"output_token": "NextToken",
				"result_key": "ReservedInstancesModifications"
			},
			"DescribeRouteTables": {
				"result_key": "RouteTables"
			},
			"DescribeSecurityGroups": {
				"result_key": "SecurityGroups"
			},
			"DescribeSnapshots": {
				"input_token": "NextToken",
				"output_token": "NextToken",
				"limit_key": "MaxResults",
				"result_key": "Snapshots"
			},
			"DescribeSpotInstanceRequests": {
				"result_key": "SpotInstanceRequests"
			},
			"DescribeSpotFleetRequests": {
				"input_token": "NextToken",
				"output_token": "NextToken",
				"limit_key": "MaxResults",
				"result_key": "SpotFleetRequestConfigs"
			},
			"DescribeSpotPriceHistory": {
				"input_token": "NextToken",
				"output_token": "NextToken",
				"limit_key": "MaxResults",
				"result_key": "SpotPriceHistory"
			},
			"DescribeSubnets": {
				"result_key": "Subnets"
			},
			"DescribeTags": {
				"input_token": "NextToken",
				"output_token": "NextToken",
				"limit_key": "MaxResults",
				"result_key": "Tags"
			},
			"DescribeVolumeStatus": {
				"input_token": "NextToken",
				"output_token": "NextToken",
				"limit_key": "MaxResults",
				"result_key": "VolumeStatuses"
			},
			"DescribeVolumes": {
				"input_token": "NextToken",
				"output_token": "NextToken",
				"limit_key": "MaxResults",
				"result_key": "Volumes"
			},
			"DescribeVpcs": {
				"result_key": "Vpcs"
			},
			"DescribeVpcPeeringConnections": {
				"result_key": "VpcPeeringConnections"
			},
			"DescribeVpnConnections": {
				"result_key": "VpnConnections"
			},
			"DescribeVpnGateways": {
				"result_key": "VpnGateways"
			}
		}
	};

/***/ },
/* 331 */
/***/ function(module, exports) {

	module.exports = {
		"version": 2,
		"waiters": {
			"InstanceExists": {
				"delay": 5,
				"maxAttempts": 40,
				"operation": "DescribeInstances",
				"acceptors": [
					{
						"matcher": "path",
						"expected": true,
						"argument": "length(Reservations[]) > `0`",
						"state": "success"
					},
					{
						"matcher": "error",
						"expected": "InvalidInstanceID.NotFound",
						"state": "retry"
					}
				]
			},
			"BundleTaskComplete": {
				"delay": 15,
				"operation": "DescribeBundleTasks",
				"maxAttempts": 40,
				"acceptors": [
					{
						"expected": "complete",
						"matcher": "pathAll",
						"state": "success",
						"argument": "BundleTasks[].State"
					},
					{
						"expected": "failed",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "BundleTasks[].State"
					}
				]
			},
			"ConversionTaskCancelled": {
				"delay": 15,
				"operation": "DescribeConversionTasks",
				"maxAttempts": 40,
				"acceptors": [
					{
						"expected": "cancelled",
						"matcher": "pathAll",
						"state": "success",
						"argument": "ConversionTasks[].State"
					}
				]
			},
			"ConversionTaskCompleted": {
				"delay": 15,
				"operation": "DescribeConversionTasks",
				"maxAttempts": 40,
				"acceptors": [
					{
						"expected": "completed",
						"matcher": "pathAll",
						"state": "success",
						"argument": "ConversionTasks[].State"
					},
					{
						"expected": "cancelled",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "ConversionTasks[].State"
					},
					{
						"expected": "cancelling",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "ConversionTasks[].State"
					}
				]
			},
			"ConversionTaskDeleted": {
				"delay": 15,
				"operation": "DescribeConversionTasks",
				"maxAttempts": 40,
				"acceptors": [
					{
						"expected": "deleted",
						"matcher": "pathAll",
						"state": "success",
						"argument": "ConversionTasks[].State"
					}
				]
			},
			"CustomerGatewayAvailable": {
				"delay": 15,
				"operation": "DescribeCustomerGateways",
				"maxAttempts": 40,
				"acceptors": [
					{
						"expected": "available",
						"matcher": "pathAll",
						"state": "success",
						"argument": "CustomerGateways[].State"
					},
					{
						"expected": "deleted",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "CustomerGateways[].State"
					},
					{
						"expected": "deleting",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "CustomerGateways[].State"
					}
				]
			},
			"ExportTaskCancelled": {
				"delay": 15,
				"operation": "DescribeExportTasks",
				"maxAttempts": 40,
				"acceptors": [
					{
						"expected": "cancelled",
						"matcher": "pathAll",
						"state": "success",
						"argument": "ExportTasks[].State"
					}
				]
			},
			"ExportTaskCompleted": {
				"delay": 15,
				"operation": "DescribeExportTasks",
				"maxAttempts": 40,
				"acceptors": [
					{
						"expected": "completed",
						"matcher": "pathAll",
						"state": "success",
						"argument": "ExportTasks[].State"
					}
				]
			},
			"ImageExists": {
				"operation": "DescribeImages",
				"maxAttempts": 40,
				"delay": 15,
				"acceptors": [
					{
						"matcher": "path",
						"expected": true,
						"argument": "length(Images[]) > `0`",
						"state": "success"
					},
					{
						"matcher": "error",
						"expected": "InvalidAMIID.NotFound",
						"state": "retry"
					}
				]
			},
			"ImageAvailable": {
				"operation": "DescribeImages",
				"maxAttempts": 40,
				"delay": 15,
				"acceptors": [
					{
						"state": "success",
						"matcher": "pathAll",
						"argument": "Images[].State",
						"expected": "available"
					},
					{
						"state": "failure",
						"matcher": "pathAny",
						"argument": "Images[].State",
						"expected": "failed"
					}
				]
			},
			"InstanceRunning": {
				"delay": 15,
				"operation": "DescribeInstances",
				"maxAttempts": 40,
				"acceptors": [
					{
						"expected": "running",
						"matcher": "pathAll",
						"state": "success",
						"argument": "Reservations[].Instances[].State.Name"
					},
					{
						"expected": "shutting-down",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "Reservations[].Instances[].State.Name"
					},
					{
						"expected": "terminated",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "Reservations[].Instances[].State.Name"
					},
					{
						"expected": "stopping",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "Reservations[].Instances[].State.Name"
					},
					{
						"matcher": "error",
						"expected": "InvalidInstanceID.NotFound",
						"state": "retry"
					}
				]
			},
			"InstanceStatusOk": {
				"operation": "DescribeInstanceStatus",
				"maxAttempts": 40,
				"delay": 15,
				"acceptors": [
					{
						"state": "success",
						"matcher": "pathAll",
						"argument": "InstanceStatuses[].InstanceStatus.Status",
						"expected": "ok"
					},
					{
						"matcher": "error",
						"expected": "InvalidInstanceID.NotFound",
						"state": "retry"
					}
				]
			},
			"InstanceStopped": {
				"delay": 15,
				"operation": "DescribeInstances",
				"maxAttempts": 40,
				"acceptors": [
					{
						"expected": "stopped",
						"matcher": "pathAll",
						"state": "success",
						"argument": "Reservations[].Instances[].State.Name"
					},
					{
						"expected": "pending",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "Reservations[].Instances[].State.Name"
					},
					{
						"expected": "terminated",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "Reservations[].Instances[].State.Name"
					}
				]
			},
			"InstanceTerminated": {
				"delay": 15,
				"operation": "DescribeInstances",
				"maxAttempts": 40,
				"acceptors": [
					{
						"expected": "terminated",
						"matcher": "pathAll",
						"state": "success",
						"argument": "Reservations[].Instances[].State.Name"
					},
					{
						"expected": "pending",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "Reservations[].Instances[].State.Name"
					},
					{
						"expected": "stopping",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "Reservations[].Instances[].State.Name"
					}
				]
			},
			"KeyPairExists": {
				"operation": "DescribeKeyPairs",
				"delay": 5,
				"maxAttempts": 6,
				"acceptors": [
					{
						"expected": true,
						"matcher": "pathAll",
						"state": "success",
						"argument": "length(KeyPairs[].KeyName) > `0`"
					},
					{
						"expected": "InvalidKeyPair.NotFound",
						"matcher": "error",
						"state": "retry"
					}
				]
			},
			"NatGatewayAvailable": {
				"operation": "DescribeNatGateways",
				"delay": 15,
				"maxAttempts": 40,
				"acceptors": [
					{
						"state": "success",
						"matcher": "pathAll",
						"argument": "NatGateways[].State",
						"expected": "available"
					},
					{
						"state": "failure",
						"matcher": "pathAny",
						"argument": "NatGateways[].State",
						"expected": "failed"
					},
					{
						"state": "failure",
						"matcher": "pathAny",
						"argument": "NatGateways[].State",
						"expected": "deleting"
					},
					{
						"state": "failure",
						"matcher": "pathAny",
						"argument": "NatGateways[].State",
						"expected": "deleted"
					},
					{
						"state": "retry",
						"matcher": "error",
						"expected": "NatGatewayNotFound"
					}
				]
			},
			"NetworkInterfaceAvailable": {
				"operation": "DescribeNetworkInterfaces",
				"delay": 20,
				"maxAttempts": 10,
				"acceptors": [
					{
						"expected": "available",
						"matcher": "pathAll",
						"state": "success",
						"argument": "NetworkInterfaces[].Status"
					},
					{
						"expected": "InvalidNetworkInterfaceID.NotFound",
						"matcher": "error",
						"state": "failure"
					}
				]
			},
			"PasswordDataAvailable": {
				"operation": "GetPasswordData",
				"maxAttempts": 40,
				"delay": 15,
				"acceptors": [
					{
						"state": "success",
						"matcher": "path",
						"argument": "length(PasswordData) > `0`",
						"expected": true
					}
				]
			},
			"SnapshotCompleted": {
				"delay": 15,
				"operation": "DescribeSnapshots",
				"maxAttempts": 40,
				"acceptors": [
					{
						"expected": "completed",
						"matcher": "pathAll",
						"state": "success",
						"argument": "Snapshots[].State"
					}
				]
			},
			"SpotInstanceRequestFulfilled": {
				"operation": "DescribeSpotInstanceRequests",
				"maxAttempts": 40,
				"delay": 15,
				"acceptors": [
					{
						"state": "success",
						"matcher": "pathAll",
						"argument": "SpotInstanceRequests[].Status.Code",
						"expected": "fulfilled"
					},
					{
						"state": "failure",
						"matcher": "pathAny",
						"argument": "SpotInstanceRequests[].Status.Code",
						"expected": "schedule-expired"
					},
					{
						"state": "failure",
						"matcher": "pathAny",
						"argument": "SpotInstanceRequests[].Status.Code",
						"expected": "canceled-before-fulfillment"
					},
					{
						"state": "failure",
						"matcher": "pathAny",
						"argument": "SpotInstanceRequests[].Status.Code",
						"expected": "bad-parameters"
					},
					{
						"state": "failure",
						"matcher": "pathAny",
						"argument": "SpotInstanceRequests[].Status.Code",
						"expected": "system-error"
					}
				]
			},
			"SubnetAvailable": {
				"delay": 15,
				"operation": "DescribeSubnets",
				"maxAttempts": 40,
				"acceptors": [
					{
						"expected": "available",
						"matcher": "pathAll",
						"state": "success",
						"argument": "Subnets[].State"
					}
				]
			},
			"SystemStatusOk": {
				"operation": "DescribeInstanceStatus",
				"maxAttempts": 40,
				"delay": 15,
				"acceptors": [
					{
						"state": "success",
						"matcher": "pathAll",
						"argument": "InstanceStatuses[].SystemStatus.Status",
						"expected": "ok"
					}
				]
			},
			"VolumeAvailable": {
				"delay": 15,
				"operation": "DescribeVolumes",
				"maxAttempts": 40,
				"acceptors": [
					{
						"expected": "available",
						"matcher": "pathAll",
						"state": "success",
						"argument": "Volumes[].State"
					},
					{
						"expected": "deleted",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "Volumes[].State"
					}
				]
			},
			"VolumeDeleted": {
				"delay": 15,
				"operation": "DescribeVolumes",
				"maxAttempts": 40,
				"acceptors": [
					{
						"expected": "deleted",
						"matcher": "pathAll",
						"state": "success",
						"argument": "Volumes[].State"
					},
					{
						"matcher": "error",
						"expected": "InvalidVolume.NotFound",
						"state": "success"
					}
				]
			},
			"VolumeInUse": {
				"delay": 15,
				"operation": "DescribeVolumes",
				"maxAttempts": 40,
				"acceptors": [
					{
						"expected": "in-use",
						"matcher": "pathAll",
						"state": "success",
						"argument": "Volumes[].State"
					},
					{
						"expected": "deleted",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "Volumes[].State"
					}
				]
			},
			"VpcAvailable": {
				"delay": 15,
				"operation": "DescribeVpcs",
				"maxAttempts": 40,
				"acceptors": [
					{
						"expected": "available",
						"matcher": "pathAll",
						"state": "success",
						"argument": "Vpcs[].State"
					}
				]
			},
			"VpcExists": {
				"operation": "DescribeVpcs",
				"delay": 1,
				"maxAttempts": 5,
				"acceptors": [
					{
						"matcher": "status",
						"expected": 200,
						"state": "success"
					},
					{
						"matcher": "error",
						"expected": "InvalidVpcID.NotFound",
						"state": "retry"
					}
				]
			},
			"VpnConnectionAvailable": {
				"delay": 15,
				"operation": "DescribeVpnConnections",
				"maxAttempts": 40,
				"acceptors": [
					{
						"expected": "available",
						"matcher": "pathAll",
						"state": "success",
						"argument": "VpnConnections[].State"
					},
					{
						"expected": "deleting",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "VpnConnections[].State"
					},
					{
						"expected": "deleted",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "VpnConnections[].State"
					}
				]
			},
			"VpnConnectionDeleted": {
				"delay": 15,
				"operation": "DescribeVpnConnections",
				"maxAttempts": 40,
				"acceptors": [
					{
						"expected": "deleted",
						"matcher": "pathAll",
						"state": "success",
						"argument": "VpnConnections[].State"
					},
					{
						"expected": "pending",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "VpnConnections[].State"
					}
				]
			},
			"VpcPeeringConnectionExists": {
				"delay": 15,
				"operation": "DescribeVpcPeeringConnections",
				"maxAttempts": 40,
				"acceptors": [
					{
						"matcher": "status",
						"expected": 200,
						"state": "success"
					},
					{
						"matcher": "error",
						"expected": "InvalidVpcPeeringConnectionID.NotFound",
						"state": "retry"
					}
				]
			}
		}
	};

/***/ },
/* 332 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['ecr'] = {};
	AWS.ECR = Service.defineService('ecr', ['2015-09-21']);
	Object.defineProperty(apiLoader.services['ecr'], '2015-09-21', {
	  get: function get() {
	    var model = __webpack_require__(333);
	    model.paginators = __webpack_require__(334).pagination;
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.ECR;


/***/ },
/* 333 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2015-09-21",
			"endpointPrefix": "ecr",
			"jsonVersion": "1.1",
			"protocol": "json",
			"serviceAbbreviation": "Amazon ECR",
			"serviceFullName": "Amazon EC2 Container Registry",
			"signatureVersion": "v4",
			"targetPrefix": "AmazonEC2ContainerRegistry_V20150921"
		},
		"operations": {
			"BatchCheckLayerAvailability": {
				"input": {
					"type": "structure",
					"required": [
						"repositoryName",
						"layerDigests"
					],
					"members": {
						"registryId": {},
						"repositoryName": {},
						"layerDigests": {
							"type": "list",
							"member": {}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"layers": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"layerDigest": {},
									"layerAvailability": {},
									"layerSize": {
										"type": "long"
									}
								}
							}
						},
						"failures": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"layerDigest": {},
									"failureCode": {},
									"failureReason": {}
								}
							}
						}
					}
				}
			},
			"BatchDeleteImage": {
				"input": {
					"type": "structure",
					"required": [
						"repositoryName",
						"imageIds"
					],
					"members": {
						"registryId": {},
						"repositoryName": {},
						"imageIds": {
							"shape": "Sh"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"imageIds": {
							"shape": "Sh"
						},
						"failures": {
							"shape": "Sm"
						}
					}
				}
			},
			"BatchGetImage": {
				"input": {
					"type": "structure",
					"required": [
						"repositoryName",
						"imageIds"
					],
					"members": {
						"registryId": {},
						"repositoryName": {},
						"imageIds": {
							"shape": "Sh"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"images": {
							"type": "list",
							"member": {
								"shape": "St"
							}
						},
						"failures": {
							"shape": "Sm"
						}
					}
				}
			},
			"CompleteLayerUpload": {
				"input": {
					"type": "structure",
					"required": [
						"repositoryName",
						"uploadId",
						"layerDigests"
					],
					"members": {
						"registryId": {},
						"repositoryName": {},
						"uploadId": {},
						"layerDigests": {
							"type": "list",
							"member": {}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"registryId": {},
						"repositoryName": {},
						"uploadId": {},
						"layerDigest": {}
					}
				}
			},
			"CreateRepository": {
				"input": {
					"type": "structure",
					"required": [
						"repositoryName"
					],
					"members": {
						"repositoryName": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"repository": {
							"shape": "S11"
						}
					}
				}
			},
			"DeleteRepository": {
				"input": {
					"type": "structure",
					"required": [
						"repositoryName"
					],
					"members": {
						"registryId": {},
						"repositoryName": {},
						"force": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"repository": {
							"shape": "S11"
						}
					}
				}
			},
			"DeleteRepositoryPolicy": {
				"input": {
					"type": "structure",
					"required": [
						"repositoryName"
					],
					"members": {
						"registryId": {},
						"repositoryName": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"registryId": {},
						"repositoryName": {},
						"policyText": {}
					}
				}
			},
			"DescribeImages": {
				"input": {
					"type": "structure",
					"required": [
						"repositoryName"
					],
					"members": {
						"registryId": {},
						"repositoryName": {},
						"imageIds": {
							"shape": "Sh"
						},
						"nextToken": {},
						"maxResults": {
							"type": "integer"
						},
						"filter": {
							"type": "structure",
							"members": {
								"tagStatus": {}
							}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"imageDetails": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"registryId": {},
									"repositoryName": {},
									"imageDigest": {},
									"imageTags": {
										"type": "list",
										"member": {}
									},
									"imageSizeInBytes": {
										"type": "long"
									},
									"imagePushedAt": {
										"type": "timestamp"
									}
								}
							}
						},
						"nextToken": {}
					}
				}
			},
			"DescribeRepositories": {
				"input": {
					"type": "structure",
					"members": {
						"registryId": {},
						"repositoryNames": {
							"type": "list",
							"member": {}
						},
						"nextToken": {},
						"maxResults": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"repositories": {
							"type": "list",
							"member": {
								"shape": "S11"
							}
						},
						"nextToken": {}
					}
				}
			},
			"GetAuthorizationToken": {
				"input": {
					"type": "structure",
					"members": {
						"registryIds": {
							"type": "list",
							"member": {}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"authorizationData": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"authorizationToken": {},
									"expiresAt": {
										"type": "timestamp"
									},
									"proxyEndpoint": {}
								}
							}
						}
					}
				}
			},
			"GetDownloadUrlForLayer": {
				"input": {
					"type": "structure",
					"required": [
						"repositoryName",
						"layerDigest"
					],
					"members": {
						"registryId": {},
						"repositoryName": {},
						"layerDigest": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"downloadUrl": {},
						"layerDigest": {}
					}
				}
			},
			"GetRepositoryPolicy": {
				"input": {
					"type": "structure",
					"required": [
						"repositoryName"
					],
					"members": {
						"registryId": {},
						"repositoryName": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"registryId": {},
						"repositoryName": {},
						"policyText": {}
					}
				}
			},
			"InitiateLayerUpload": {
				"input": {
					"type": "structure",
					"required": [
						"repositoryName"
					],
					"members": {
						"registryId": {},
						"repositoryName": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"uploadId": {},
						"partSize": {
							"type": "long"
						}
					}
				}
			},
			"ListImages": {
				"input": {
					"type": "structure",
					"required": [
						"repositoryName"
					],
					"members": {
						"registryId": {},
						"repositoryName": {},
						"nextToken": {},
						"maxResults": {
							"type": "integer"
						},
						"filter": {
							"type": "structure",
							"members": {
								"tagStatus": {}
							}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"imageIds": {
							"shape": "Sh"
						},
						"nextToken": {}
					}
				}
			},
			"PutImage": {
				"input": {
					"type": "structure",
					"required": [
						"repositoryName",
						"imageManifest"
					],
					"members": {
						"registryId": {},
						"repositoryName": {},
						"imageManifest": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"image": {
							"shape": "St"
						}
					}
				}
			},
			"SetRepositoryPolicy": {
				"input": {
					"type": "structure",
					"required": [
						"repositoryName",
						"policyText"
					],
					"members": {
						"registryId": {},
						"repositoryName": {},
						"policyText": {},
						"force": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"registryId": {},
						"repositoryName": {},
						"policyText": {}
					}
				}
			},
			"UploadLayerPart": {
				"input": {
					"type": "structure",
					"required": [
						"repositoryName",
						"uploadId",
						"partFirstByte",
						"partLastByte",
						"layerPartBlob"
					],
					"members": {
						"registryId": {},
						"repositoryName": {},
						"uploadId": {},
						"partFirstByte": {
							"type": "long"
						},
						"partLastByte": {
							"type": "long"
						},
						"layerPartBlob": {
							"type": "blob"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"registryId": {},
						"repositoryName": {},
						"uploadId": {},
						"lastByteReceived": {
							"type": "long"
						}
					}
				}
			}
		},
		"shapes": {
			"Sh": {
				"type": "list",
				"member": {
					"shape": "Si"
				}
			},
			"Si": {
				"type": "structure",
				"members": {
					"imageDigest": {},
					"imageTag": {}
				}
			},
			"Sm": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"imageId": {
							"shape": "Si"
						},
						"failureCode": {},
						"failureReason": {}
					}
				}
			},
			"St": {
				"type": "structure",
				"members": {
					"registryId": {},
					"repositoryName": {},
					"imageId": {
						"shape": "Si"
					},
					"imageManifest": {}
				}
			},
			"S11": {
				"type": "structure",
				"members": {
					"repositoryArn": {},
					"registryId": {},
					"repositoryName": {},
					"repositoryUri": {},
					"createdAt": {
						"type": "timestamp"
					}
				}
			}
		}
	};

/***/ },
/* 334 */
/***/ function(module, exports) {

	module.exports = {
		"pagination": {
			"ListImages": {
				"input_token": "nextToken",
				"output_token": "nextToken",
				"limit_key": "maxResults",
				"result_key": "imageIds"
			},
			"DescribeImages": {
				"input_token": "nextToken",
				"output_token": "nextToken",
				"limit_key": "maxResults",
				"result_key": "imageDetails"
			},
			"DescribeRepositories": {
				"input_token": "nextToken",
				"output_token": "nextToken",
				"limit_key": "maxResults",
				"result_key": "repositories"
			}
		}
	};

/***/ },
/* 335 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['ecs'] = {};
	AWS.ECS = Service.defineService('ecs', ['2014-11-13']);
	Object.defineProperty(apiLoader.services['ecs'], '2014-11-13', {
	  get: function get() {
	    var model = __webpack_require__(336);
	    model.paginators = __webpack_require__(337).pagination;
	    model.waiters = __webpack_require__(338).waiters;
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.ECS;


/***/ },
/* 336 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2014-11-13",
			"endpointPrefix": "ecs",
			"jsonVersion": "1.1",
			"protocol": "json",
			"serviceAbbreviation": "Amazon ECS",
			"serviceFullName": "Amazon EC2 Container Service",
			"signatureVersion": "v4",
			"targetPrefix": "AmazonEC2ContainerServiceV20141113"
		},
		"operations": {
			"CreateCluster": {
				"input": {
					"type": "structure",
					"members": {
						"clusterName": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"cluster": {
							"shape": "S4"
						}
					}
				}
			},
			"CreateService": {
				"input": {
					"type": "structure",
					"required": [
						"serviceName",
						"taskDefinition",
						"desiredCount"
					],
					"members": {
						"cluster": {},
						"serviceName": {},
						"taskDefinition": {},
						"loadBalancers": {
							"shape": "S7"
						},
						"desiredCount": {
							"type": "integer"
						},
						"clientToken": {},
						"role": {},
						"deploymentConfiguration": {
							"shape": "Sa"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"service": {
							"shape": "Sc"
						}
					}
				}
			},
			"DeleteCluster": {
				"input": {
					"type": "structure",
					"required": [
						"cluster"
					],
					"members": {
						"cluster": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"cluster": {
							"shape": "S4"
						}
					}
				}
			},
			"DeleteService": {
				"input": {
					"type": "structure",
					"required": [
						"service"
					],
					"members": {
						"cluster": {},
						"service": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"service": {
							"shape": "Sc"
						}
					}
				}
			},
			"DeregisterContainerInstance": {
				"input": {
					"type": "structure",
					"required": [
						"containerInstance"
					],
					"members": {
						"cluster": {},
						"containerInstance": {},
						"force": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"containerInstance": {
							"shape": "Sp"
						}
					}
				}
			},
			"DeregisterTaskDefinition": {
				"input": {
					"type": "structure",
					"required": [
						"taskDefinition"
					],
					"members": {
						"taskDefinition": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"taskDefinition": {
							"shape": "S12"
						}
					}
				}
			},
			"DescribeClusters": {
				"input": {
					"type": "structure",
					"members": {
						"clusters": {
							"shape": "Sv"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"clusters": {
							"type": "list",
							"member": {
								"shape": "S4"
							}
						},
						"failures": {
							"shape": "S1w"
						}
					}
				}
			},
			"DescribeContainerInstances": {
				"input": {
					"type": "structure",
					"required": [
						"containerInstances"
					],
					"members": {
						"cluster": {},
						"containerInstances": {
							"shape": "Sv"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"containerInstances": {
							"type": "list",
							"member": {
								"shape": "Sp"
							}
						},
						"failures": {
							"shape": "S1w"
						}
					}
				}
			},
			"DescribeServices": {
				"input": {
					"type": "structure",
					"required": [
						"services"
					],
					"members": {
						"cluster": {},
						"services": {
							"shape": "Sv"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"services": {
							"type": "list",
							"member": {
								"shape": "Sc"
							}
						},
						"failures": {
							"shape": "S1w"
						}
					}
				}
			},
			"DescribeTaskDefinition": {
				"input": {
					"type": "structure",
					"required": [
						"taskDefinition"
					],
					"members": {
						"taskDefinition": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"taskDefinition": {
							"shape": "S12"
						}
					}
				}
			},
			"DescribeTasks": {
				"input": {
					"type": "structure",
					"required": [
						"tasks"
					],
					"members": {
						"cluster": {},
						"tasks": {
							"shape": "Sv"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"tasks": {
							"shape": "S28"
						},
						"failures": {
							"shape": "S1w"
						}
					}
				}
			},
			"DiscoverPollEndpoint": {
				"input": {
					"type": "structure",
					"members": {
						"containerInstance": {},
						"cluster": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"endpoint": {},
						"telemetryEndpoint": {}
					}
				}
			},
			"ListClusters": {
				"input": {
					"type": "structure",
					"members": {
						"nextToken": {},
						"maxResults": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"clusterArns": {
							"shape": "Sv"
						},
						"nextToken": {}
					}
				}
			},
			"ListContainerInstances": {
				"input": {
					"type": "structure",
					"members": {
						"cluster": {},
						"nextToken": {},
						"maxResults": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"containerInstanceArns": {
							"shape": "Sv"
						},
						"nextToken": {}
					}
				}
			},
			"ListServices": {
				"input": {
					"type": "structure",
					"members": {
						"cluster": {},
						"nextToken": {},
						"maxResults": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"serviceArns": {
							"shape": "Sv"
						},
						"nextToken": {}
					}
				}
			},
			"ListTaskDefinitionFamilies": {
				"input": {
					"type": "structure",
					"members": {
						"familyPrefix": {},
						"status": {},
						"nextToken": {},
						"maxResults": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"families": {
							"shape": "Sv"
						},
						"nextToken": {}
					}
				}
			},
			"ListTaskDefinitions": {
				"input": {
					"type": "structure",
					"members": {
						"familyPrefix": {},
						"status": {},
						"sort": {},
						"nextToken": {},
						"maxResults": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"taskDefinitionArns": {
							"shape": "Sv"
						},
						"nextToken": {}
					}
				}
			},
			"ListTasks": {
				"input": {
					"type": "structure",
					"members": {
						"cluster": {},
						"containerInstance": {},
						"family": {},
						"nextToken": {},
						"maxResults": {
							"type": "integer"
						},
						"startedBy": {},
						"serviceName": {},
						"desiredStatus": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"taskArns": {
							"shape": "Sv"
						},
						"nextToken": {}
					}
				}
			},
			"RegisterContainerInstance": {
				"input": {
					"type": "structure",
					"members": {
						"cluster": {},
						"instanceIdentityDocument": {},
						"instanceIdentityDocumentSignature": {},
						"totalResources": {
							"shape": "Sr"
						},
						"versionInfo": {
							"shape": "Sq"
						},
						"containerInstanceArn": {},
						"attributes": {
							"shape": "Sy"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"containerInstance": {
							"shape": "Sp"
						}
					}
				}
			},
			"RegisterTaskDefinition": {
				"input": {
					"type": "structure",
					"required": [
						"family",
						"containerDefinitions"
					],
					"members": {
						"family": {},
						"taskRoleArn": {},
						"networkMode": {},
						"containerDefinitions": {
							"shape": "S13"
						},
						"volumes": {
							"shape": "S1o"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"taskDefinition": {
							"shape": "S12"
						}
					}
				}
			},
			"RunTask": {
				"input": {
					"type": "structure",
					"required": [
						"taskDefinition"
					],
					"members": {
						"cluster": {},
						"taskDefinition": {},
						"overrides": {
							"shape": "S2a"
						},
						"count": {
							"type": "integer"
						},
						"startedBy": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"tasks": {
							"shape": "S28"
						},
						"failures": {
							"shape": "S1w"
						}
					}
				}
			},
			"StartTask": {
				"input": {
					"type": "structure",
					"required": [
						"taskDefinition",
						"containerInstances"
					],
					"members": {
						"cluster": {},
						"taskDefinition": {},
						"overrides": {
							"shape": "S2a"
						},
						"containerInstances": {
							"shape": "Sv"
						},
						"startedBy": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"tasks": {
							"shape": "S28"
						},
						"failures": {
							"shape": "S1w"
						}
					}
				}
			},
			"StopTask": {
				"input": {
					"type": "structure",
					"required": [
						"task"
					],
					"members": {
						"cluster": {},
						"task": {},
						"reason": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"task": {
							"shape": "S29"
						}
					}
				}
			},
			"SubmitContainerStateChange": {
				"input": {
					"type": "structure",
					"members": {
						"cluster": {},
						"task": {},
						"containerName": {},
						"status": {},
						"exitCode": {
							"type": "integer"
						},
						"reason": {},
						"networkBindings": {
							"shape": "S2f"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"acknowledgment": {}
					}
				}
			},
			"SubmitTaskStateChange": {
				"input": {
					"type": "structure",
					"members": {
						"cluster": {},
						"task": {},
						"status": {},
						"reason": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"acknowledgment": {}
					}
				}
			},
			"UpdateContainerAgent": {
				"input": {
					"type": "structure",
					"required": [
						"containerInstance"
					],
					"members": {
						"cluster": {},
						"containerInstance": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"containerInstance": {
							"shape": "Sp"
						}
					}
				}
			},
			"UpdateService": {
				"input": {
					"type": "structure",
					"required": [
						"service"
					],
					"members": {
						"cluster": {},
						"service": {},
						"desiredCount": {
							"type": "integer"
						},
						"taskDefinition": {},
						"deploymentConfiguration": {
							"shape": "Sa"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"service": {
							"shape": "Sc"
						}
					}
				}
			}
		},
		"shapes": {
			"S4": {
				"type": "structure",
				"members": {
					"clusterArn": {},
					"clusterName": {},
					"status": {},
					"registeredContainerInstancesCount": {
						"type": "integer"
					},
					"runningTasksCount": {
						"type": "integer"
					},
					"pendingTasksCount": {
						"type": "integer"
					},
					"activeServicesCount": {
						"type": "integer"
					}
				}
			},
			"S7": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"targetGroupArn": {},
						"loadBalancerName": {},
						"containerName": {},
						"containerPort": {
							"type": "integer"
						}
					}
				}
			},
			"Sa": {
				"type": "structure",
				"members": {
					"maximumPercent": {
						"type": "integer"
					},
					"minimumHealthyPercent": {
						"type": "integer"
					}
				}
			},
			"Sc": {
				"type": "structure",
				"members": {
					"serviceArn": {},
					"serviceName": {},
					"clusterArn": {},
					"loadBalancers": {
						"shape": "S7"
					},
					"status": {},
					"desiredCount": {
						"type": "integer"
					},
					"runningCount": {
						"type": "integer"
					},
					"pendingCount": {
						"type": "integer"
					},
					"taskDefinition": {},
					"deploymentConfiguration": {
						"shape": "Sa"
					},
					"deployments": {
						"type": "list",
						"member": {
							"type": "structure",
							"members": {
								"id": {},
								"status": {},
								"taskDefinition": {},
								"desiredCount": {
									"type": "integer"
								},
								"pendingCount": {
									"type": "integer"
								},
								"runningCount": {
									"type": "integer"
								},
								"createdAt": {
									"type": "timestamp"
								},
								"updatedAt": {
									"type": "timestamp"
								}
							}
						}
					},
					"roleArn": {},
					"events": {
						"type": "list",
						"member": {
							"type": "structure",
							"members": {
								"id": {},
								"createdAt": {
									"type": "timestamp"
								},
								"message": {}
							}
						}
					},
					"createdAt": {
						"type": "timestamp"
					}
				}
			},
			"Sp": {
				"type": "structure",
				"members": {
					"containerInstanceArn": {},
					"ec2InstanceId": {},
					"versionInfo": {
						"shape": "Sq"
					},
					"remainingResources": {
						"shape": "Sr"
					},
					"registeredResources": {
						"shape": "Sr"
					},
					"status": {},
					"agentConnected": {
						"type": "boolean"
					},
					"runningTasksCount": {
						"type": "integer"
					},
					"pendingTasksCount": {
						"type": "integer"
					},
					"agentUpdateStatus": {},
					"attributes": {
						"shape": "Sy"
					}
				}
			},
			"Sq": {
				"type": "structure",
				"members": {
					"agentVersion": {},
					"agentHash": {},
					"dockerVersion": {}
				}
			},
			"Sr": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"name": {},
						"type": {},
						"doubleValue": {
							"type": "double"
						},
						"longValue": {
							"type": "long"
						},
						"integerValue": {
							"type": "integer"
						},
						"stringSetValue": {
							"shape": "Sv"
						}
					}
				}
			},
			"Sv": {
				"type": "list",
				"member": {}
			},
			"Sy": {
				"type": "list",
				"member": {
					"shape": "Sz"
				}
			},
			"Sz": {
				"type": "structure",
				"required": [
					"name"
				],
				"members": {
					"name": {},
					"value": {}
				}
			},
			"S12": {
				"type": "structure",
				"members": {
					"taskDefinitionArn": {},
					"containerDefinitions": {
						"shape": "S13"
					},
					"family": {},
					"taskRoleArn": {},
					"networkMode": {},
					"revision": {
						"type": "integer"
					},
					"volumes": {
						"shape": "S1o"
					},
					"status": {},
					"requiresAttributes": {
						"type": "list",
						"member": {
							"shape": "Sz"
						}
					}
				}
			},
			"S13": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"name": {},
						"image": {},
						"cpu": {
							"type": "integer"
						},
						"memory": {
							"type": "integer"
						},
						"memoryReservation": {
							"type": "integer"
						},
						"links": {
							"shape": "Sv"
						},
						"portMappings": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"containerPort": {
										"type": "integer"
									},
									"hostPort": {
										"type": "integer"
									},
									"protocol": {}
								}
							}
						},
						"essential": {
							"type": "boolean"
						},
						"entryPoint": {
							"shape": "Sv"
						},
						"command": {
							"shape": "Sv"
						},
						"environment": {
							"shape": "S18"
						},
						"mountPoints": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"sourceVolume": {},
									"containerPath": {},
									"readOnly": {
										"type": "boolean"
									}
								}
							}
						},
						"volumesFrom": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"sourceContainer": {},
									"readOnly": {
										"type": "boolean"
									}
								}
							}
						},
						"hostname": {},
						"user": {},
						"workingDirectory": {},
						"disableNetworking": {
							"type": "boolean"
						},
						"privileged": {
							"type": "boolean"
						},
						"readonlyRootFilesystem": {
							"type": "boolean"
						},
						"dnsServers": {
							"shape": "Sv"
						},
						"dnsSearchDomains": {
							"shape": "Sv"
						},
						"extraHosts": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"hostname",
									"ipAddress"
								],
								"members": {
									"hostname": {},
									"ipAddress": {}
								}
							}
						},
						"dockerSecurityOptions": {
							"shape": "Sv"
						},
						"dockerLabels": {
							"type": "map",
							"key": {},
							"value": {}
						},
						"ulimits": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"name",
									"softLimit",
									"hardLimit"
								],
								"members": {
									"name": {},
									"softLimit": {
										"type": "integer"
									},
									"hardLimit": {
										"type": "integer"
									}
								}
							}
						},
						"logConfiguration": {
							"type": "structure",
							"required": [
								"logDriver"
							],
							"members": {
								"logDriver": {},
								"options": {
									"type": "map",
									"key": {},
									"value": {}
								}
							}
						}
					}
				}
			},
			"S18": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"name": {},
						"value": {}
					}
				}
			},
			"S1o": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"name": {},
						"host": {
							"type": "structure",
							"members": {
								"sourcePath": {}
							}
						}
					}
				}
			},
			"S1w": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"arn": {},
						"reason": {}
					}
				}
			},
			"S28": {
				"type": "list",
				"member": {
					"shape": "S29"
				}
			},
			"S29": {
				"type": "structure",
				"members": {
					"taskArn": {},
					"clusterArn": {},
					"taskDefinitionArn": {},
					"containerInstanceArn": {},
					"overrides": {
						"shape": "S2a"
					},
					"lastStatus": {},
					"desiredStatus": {},
					"containers": {
						"type": "list",
						"member": {
							"type": "structure",
							"members": {
								"containerArn": {},
								"taskArn": {},
								"name": {},
								"lastStatus": {},
								"exitCode": {
									"type": "integer"
								},
								"reason": {},
								"networkBindings": {
									"shape": "S2f"
								}
							}
						}
					},
					"startedBy": {},
					"stoppedReason": {},
					"createdAt": {
						"type": "timestamp"
					},
					"startedAt": {
						"type": "timestamp"
					},
					"stoppedAt": {
						"type": "timestamp"
					}
				}
			},
			"S2a": {
				"type": "structure",
				"members": {
					"containerOverrides": {
						"type": "list",
						"member": {
							"type": "structure",
							"members": {
								"name": {},
								"command": {
									"shape": "Sv"
								},
								"environment": {
									"shape": "S18"
								}
							}
						}
					},
					"taskRoleArn": {}
				}
			},
			"S2f": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"bindIP": {},
						"containerPort": {
							"type": "integer"
						},
						"hostPort": {
							"type": "integer"
						},
						"protocol": {}
					}
				}
			}
		}
	};

/***/ },
/* 337 */
/***/ function(module, exports) {

	module.exports = {
		"pagination": {
			"ListClusters": {
				"input_token": "nextToken",
				"output_token": "nextToken",
				"limit_key": "maxResults",
				"result_key": "clusterArns"
			},
			"ListContainerInstances": {
				"input_token": "nextToken",
				"output_token": "nextToken",
				"limit_key": "maxResults",
				"result_key": "containerInstanceArns"
			},
			"ListTaskDefinitions": {
				"input_token": "nextToken",
				"output_token": "nextToken",
				"limit_key": "maxResults",
				"result_key": "taskDefinitionArns"
			},
			"ListTaskDefinitionFamilies": {
				"input_token": "nextToken",
				"output_token": "nextToken",
				"limit_key": "maxResults",
				"result_key": "families"
			},
			"ListTasks": {
				"input_token": "nextToken",
				"output_token": "nextToken",
				"limit_key": "maxResults",
				"result_key": "taskArns"
			},
			"ListServices": {
				"input_token": "nextToken",
				"output_token": "nextToken",
				"limit_key": "maxResults",
				"result_key": "serviceArns"
			}
		}
	};

/***/ },
/* 338 */
/***/ function(module, exports) {

	module.exports = {
		"version": 2,
		"waiters": {
			"TasksRunning": {
				"delay": 6,
				"operation": "DescribeTasks",
				"maxAttempts": 100,
				"acceptors": [
					{
						"expected": "STOPPED",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "tasks[].lastStatus"
					},
					{
						"expected": "MISSING",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "failures[].reason"
					},
					{
						"expected": "RUNNING",
						"matcher": "pathAll",
						"state": "success",
						"argument": "tasks[].lastStatus"
					}
				]
			},
			"TasksStopped": {
				"delay": 6,
				"operation": "DescribeTasks",
				"maxAttempts": 100,
				"acceptors": [
					{
						"expected": "STOPPED",
						"matcher": "pathAll",
						"state": "success",
						"argument": "tasks[].lastStatus"
					}
				]
			},
			"ServicesStable": {
				"delay": 15,
				"operation": "DescribeServices",
				"maxAttempts": 40,
				"acceptors": [
					{
						"expected": "MISSING",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "failures[].reason"
					},
					{
						"expected": "DRAINING",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "services[].status"
					},
					{
						"expected": "INACTIVE",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "services[].status"
					},
					{
						"expected": true,
						"matcher": "path",
						"state": "success",
						"argument": "length(services[?!(length(deployments) == `1` && runningCount == desiredCount)]) == `0`"
					}
				]
			},
			"ServicesInactive": {
				"delay": 15,
				"operation": "DescribeServices",
				"maxAttempts": 40,
				"acceptors": [
					{
						"expected": "MISSING",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "failures[].reason"
					},
					{
						"expected": "INACTIVE",
						"matcher": "pathAny",
						"state": "success",
						"argument": "services[].status"
					}
				]
			}
		}
	};

/***/ },
/* 339 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['efs'] = {};
	AWS.EFS = Service.defineService('efs', ['2015-02-01']);
	Object.defineProperty(apiLoader.services['efs'], '2015-02-01', {
	  get: function get() {
	    var model = __webpack_require__(340);
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.EFS;


/***/ },
/* 340 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2015-02-01",
			"endpointPrefix": "elasticfilesystem",
			"protocol": "rest-json",
			"serviceAbbreviation": "EFS",
			"serviceFullName": "Amazon Elastic File System",
			"signatureVersion": "v4"
		},
		"operations": {
			"CreateFileSystem": {
				"http": {
					"requestUri": "/2015-02-01/file-systems",
					"responseCode": 201
				},
				"input": {
					"type": "structure",
					"required": [
						"CreationToken"
					],
					"members": {
						"CreationToken": {},
						"PerformanceMode": {}
					}
				},
				"output": {
					"shape": "S4"
				}
			},
			"CreateMountTarget": {
				"http": {
					"requestUri": "/2015-02-01/mount-targets",
					"responseCode": 200
				},
				"input": {
					"type": "structure",
					"required": [
						"FileSystemId",
						"SubnetId"
					],
					"members": {
						"FileSystemId": {},
						"SubnetId": {},
						"IpAddress": {},
						"SecurityGroups": {
							"shape": "Sg"
						}
					}
				},
				"output": {
					"shape": "Si"
				}
			},
			"CreateTags": {
				"http": {
					"requestUri": "/2015-02-01/create-tags/{FileSystemId}",
					"responseCode": 204
				},
				"input": {
					"type": "structure",
					"required": [
						"FileSystemId",
						"Tags"
					],
					"members": {
						"FileSystemId": {
							"location": "uri",
							"locationName": "FileSystemId"
						},
						"Tags": {
							"shape": "Sm"
						}
					}
				}
			},
			"DeleteFileSystem": {
				"http": {
					"method": "DELETE",
					"requestUri": "/2015-02-01/file-systems/{FileSystemId}",
					"responseCode": 204
				},
				"input": {
					"type": "structure",
					"required": [
						"FileSystemId"
					],
					"members": {
						"FileSystemId": {
							"location": "uri",
							"locationName": "FileSystemId"
						}
					}
				}
			},
			"DeleteMountTarget": {
				"http": {
					"method": "DELETE",
					"requestUri": "/2015-02-01/mount-targets/{MountTargetId}",
					"responseCode": 204
				},
				"input": {
					"type": "structure",
					"required": [
						"MountTargetId"
					],
					"members": {
						"MountTargetId": {
							"location": "uri",
							"locationName": "MountTargetId"
						}
					}
				}
			},
			"DeleteTags": {
				"http": {
					"requestUri": "/2015-02-01/delete-tags/{FileSystemId}",
					"responseCode": 204
				},
				"input": {
					"type": "structure",
					"required": [
						"FileSystemId",
						"TagKeys"
					],
					"members": {
						"FileSystemId": {
							"location": "uri",
							"locationName": "FileSystemId"
						},
						"TagKeys": {
							"type": "list",
							"member": {}
						}
					}
				}
			},
			"DescribeFileSystems": {
				"http": {
					"method": "GET",
					"requestUri": "/2015-02-01/file-systems",
					"responseCode": 200
				},
				"input": {
					"type": "structure",
					"members": {
						"MaxItems": {
							"location": "querystring",
							"locationName": "MaxItems",
							"type": "integer"
						},
						"Marker": {
							"location": "querystring",
							"locationName": "Marker"
						},
						"CreationToken": {
							"location": "querystring",
							"locationName": "CreationToken"
						},
						"FileSystemId": {
							"location": "querystring",
							"locationName": "FileSystemId"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Marker": {},
						"FileSystems": {
							"type": "list",
							"member": {
								"shape": "S4"
							}
						},
						"NextMarker": {}
					}
				}
			},
			"DescribeMountTargetSecurityGroups": {
				"http": {
					"method": "GET",
					"requestUri": "/2015-02-01/mount-targets/{MountTargetId}/security-groups",
					"responseCode": 200
				},
				"input": {
					"type": "structure",
					"required": [
						"MountTargetId"
					],
					"members": {
						"MountTargetId": {
							"location": "uri",
							"locationName": "MountTargetId"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"SecurityGroups"
					],
					"members": {
						"SecurityGroups": {
							"shape": "Sg"
						}
					}
				}
			},
			"DescribeMountTargets": {
				"http": {
					"method": "GET",
					"requestUri": "/2015-02-01/mount-targets",
					"responseCode": 200
				},
				"input": {
					"type": "structure",
					"members": {
						"MaxItems": {
							"location": "querystring",
							"locationName": "MaxItems",
							"type": "integer"
						},
						"Marker": {
							"location": "querystring",
							"locationName": "Marker"
						},
						"FileSystemId": {
							"location": "querystring",
							"locationName": "FileSystemId"
						},
						"MountTargetId": {
							"location": "querystring",
							"locationName": "MountTargetId"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Marker": {},
						"MountTargets": {
							"type": "list",
							"member": {
								"shape": "Si"
							}
						},
						"NextMarker": {}
					}
				}
			},
			"DescribeTags": {
				"http": {
					"method": "GET",
					"requestUri": "/2015-02-01/tags/{FileSystemId}/",
					"responseCode": 200
				},
				"input": {
					"type": "structure",
					"required": [
						"FileSystemId"
					],
					"members": {
						"MaxItems": {
							"location": "querystring",
							"locationName": "MaxItems",
							"type": "integer"
						},
						"Marker": {
							"location": "querystring",
							"locationName": "Marker"
						},
						"FileSystemId": {
							"location": "uri",
							"locationName": "FileSystemId"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"Tags"
					],
					"members": {
						"Marker": {},
						"Tags": {
							"shape": "Sm"
						},
						"NextMarker": {}
					}
				}
			},
			"ModifyMountTargetSecurityGroups": {
				"http": {
					"method": "PUT",
					"requestUri": "/2015-02-01/mount-targets/{MountTargetId}/security-groups",
					"responseCode": 204
				},
				"input": {
					"type": "structure",
					"required": [
						"MountTargetId"
					],
					"members": {
						"MountTargetId": {
							"location": "uri",
							"locationName": "MountTargetId"
						},
						"SecurityGroups": {
							"shape": "Sg"
						}
					}
				}
			}
		},
		"shapes": {
			"S4": {
				"type": "structure",
				"required": [
					"OwnerId",
					"CreationToken",
					"FileSystemId",
					"CreationTime",
					"LifeCycleState",
					"NumberOfMountTargets",
					"SizeInBytes",
					"PerformanceMode"
				],
				"members": {
					"OwnerId": {},
					"CreationToken": {},
					"FileSystemId": {},
					"CreationTime": {
						"type": "timestamp"
					},
					"LifeCycleState": {},
					"Name": {},
					"NumberOfMountTargets": {
						"type": "integer"
					},
					"SizeInBytes": {
						"type": "structure",
						"required": [
							"Value"
						],
						"members": {
							"Value": {
								"type": "long"
							},
							"Timestamp": {
								"type": "timestamp"
							}
						}
					},
					"PerformanceMode": {}
				}
			},
			"Sg": {
				"type": "list",
				"member": {}
			},
			"Si": {
				"type": "structure",
				"required": [
					"MountTargetId",
					"FileSystemId",
					"SubnetId",
					"LifeCycleState"
				],
				"members": {
					"OwnerId": {},
					"MountTargetId": {},
					"FileSystemId": {},
					"SubnetId": {},
					"LifeCycleState": {},
					"IpAddress": {},
					"NetworkInterfaceId": {}
				}
			},
			"Sm": {
				"type": "list",
				"member": {
					"type": "structure",
					"required": [
						"Key",
						"Value"
					],
					"members": {
						"Key": {},
						"Value": {}
					}
				}
			}
		}
	};

/***/ },
/* 341 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['elasticache'] = {};
	AWS.ElastiCache = Service.defineService('elasticache', ['2012-11-15*', '2014-03-24*', '2014-07-15*', '2014-09-30*', '2015-02-02']);
	Object.defineProperty(apiLoader.services['elasticache'], '2015-02-02', {
	  get: function get() {
	    var model = __webpack_require__(342);
	    model.paginators = __webpack_require__(343).pagination;
	    model.waiters = __webpack_require__(344).waiters;
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.ElastiCache;


/***/ },
/* 342 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2015-02-02",
			"endpointPrefix": "elasticache",
			"protocol": "query",
			"serviceFullName": "Amazon ElastiCache",
			"signatureVersion": "v4",
			"xmlNamespace": "http://elasticache.amazonaws.com/doc/2015-02-02/"
		},
		"operations": {
			"AddTagsToResource": {
				"input": {
					"type": "structure",
					"required": [
						"ResourceName",
						"Tags"
					],
					"members": {
						"ResourceName": {},
						"Tags": {
							"shape": "S3"
						}
					}
				},
				"output": {
					"shape": "S5",
					"resultWrapper": "AddTagsToResourceResult"
				}
			},
			"AuthorizeCacheSecurityGroupIngress": {
				"input": {
					"type": "structure",
					"required": [
						"CacheSecurityGroupName",
						"EC2SecurityGroupName",
						"EC2SecurityGroupOwnerId"
					],
					"members": {
						"CacheSecurityGroupName": {},
						"EC2SecurityGroupName": {},
						"EC2SecurityGroupOwnerId": {}
					}
				},
				"output": {
					"resultWrapper": "AuthorizeCacheSecurityGroupIngressResult",
					"type": "structure",
					"members": {
						"CacheSecurityGroup": {
							"shape": "S8"
						}
					}
				}
			},
			"CopySnapshot": {
				"input": {
					"type": "structure",
					"required": [
						"SourceSnapshotName",
						"TargetSnapshotName"
					],
					"members": {
						"SourceSnapshotName": {},
						"TargetSnapshotName": {},
						"TargetBucket": {}
					}
				},
				"output": {
					"resultWrapper": "CopySnapshotResult",
					"type": "structure",
					"members": {
						"Snapshot": {
							"shape": "Sd"
						}
					}
				}
			},
			"CreateCacheCluster": {
				"input": {
					"type": "structure",
					"required": [
						"CacheClusterId"
					],
					"members": {
						"CacheClusterId": {},
						"ReplicationGroupId": {},
						"AZMode": {},
						"PreferredAvailabilityZone": {},
						"PreferredAvailabilityZones": {
							"shape": "So"
						},
						"NumCacheNodes": {
							"type": "integer"
						},
						"CacheNodeType": {},
						"Engine": {},
						"EngineVersion": {},
						"CacheParameterGroupName": {},
						"CacheSubnetGroupName": {},
						"CacheSecurityGroupNames": {
							"shape": "Sp"
						},
						"SecurityGroupIds": {
							"shape": "Sq"
						},
						"Tags": {
							"shape": "S3"
						},
						"SnapshotArns": {
							"shape": "Sr"
						},
						"SnapshotName": {},
						"PreferredMaintenanceWindow": {},
						"Port": {
							"type": "integer"
						},
						"NotificationTopicArn": {},
						"AutoMinorVersionUpgrade": {
							"type": "boolean"
						},
						"SnapshotRetentionLimit": {
							"type": "integer"
						},
						"SnapshotWindow": {}
					}
				},
				"output": {
					"resultWrapper": "CreateCacheClusterResult",
					"type": "structure",
					"members": {
						"CacheCluster": {
							"shape": "Su"
						}
					}
				}
			},
			"CreateCacheParameterGroup": {
				"input": {
					"type": "structure",
					"required": [
						"CacheParameterGroupName",
						"CacheParameterGroupFamily",
						"Description"
					],
					"members": {
						"CacheParameterGroupName": {},
						"CacheParameterGroupFamily": {},
						"Description": {}
					}
				},
				"output": {
					"resultWrapper": "CreateCacheParameterGroupResult",
					"type": "structure",
					"members": {
						"CacheParameterGroup": {
							"shape": "S19"
						}
					}
				}
			},
			"CreateCacheSecurityGroup": {
				"input": {
					"type": "structure",
					"required": [
						"CacheSecurityGroupName",
						"Description"
					],
					"members": {
						"CacheSecurityGroupName": {},
						"Description": {}
					}
				},
				"output": {
					"resultWrapper": "CreateCacheSecurityGroupResult",
					"type": "structure",
					"members": {
						"CacheSecurityGroup": {
							"shape": "S8"
						}
					}
				}
			},
			"CreateCacheSubnetGroup": {
				"input": {
					"type": "structure",
					"required": [
						"CacheSubnetGroupName",
						"CacheSubnetGroupDescription",
						"SubnetIds"
					],
					"members": {
						"CacheSubnetGroupName": {},
						"CacheSubnetGroupDescription": {},
						"SubnetIds": {
							"shape": "S1d"
						}
					}
				},
				"output": {
					"resultWrapper": "CreateCacheSubnetGroupResult",
					"type": "structure",
					"members": {
						"CacheSubnetGroup": {
							"shape": "S1f"
						}
					}
				}
			},
			"CreateReplicationGroup": {
				"input": {
					"type": "structure",
					"required": [
						"ReplicationGroupId",
						"ReplicationGroupDescription"
					],
					"members": {
						"ReplicationGroupId": {},
						"ReplicationGroupDescription": {},
						"PrimaryClusterId": {},
						"AutomaticFailoverEnabled": {
							"type": "boolean"
						},
						"NumCacheClusters": {
							"type": "integer"
						},
						"PreferredCacheClusterAZs": {
							"shape": "Sl"
						},
						"NumNodeGroups": {
							"type": "integer"
						},
						"ReplicasPerNodeGroup": {
							"type": "integer"
						},
						"NodeGroupConfiguration": {
							"type": "list",
							"member": {
								"shape": "Sk",
								"locationName": "NodeGroupConfiguration"
							}
						},
						"CacheNodeType": {},
						"Engine": {},
						"EngineVersion": {},
						"CacheParameterGroupName": {},
						"CacheSubnetGroupName": {},
						"CacheSecurityGroupNames": {
							"shape": "Sp"
						},
						"SecurityGroupIds": {
							"shape": "Sq"
						},
						"Tags": {
							"shape": "S3"
						},
						"SnapshotArns": {
							"shape": "Sr"
						},
						"SnapshotName": {},
						"PreferredMaintenanceWindow": {},
						"Port": {
							"type": "integer"
						},
						"NotificationTopicArn": {},
						"AutoMinorVersionUpgrade": {
							"type": "boolean"
						},
						"SnapshotRetentionLimit": {
							"type": "integer"
						},
						"SnapshotWindow": {}
					}
				},
				"output": {
					"resultWrapper": "CreateReplicationGroupResult",
					"type": "structure",
					"members": {
						"ReplicationGroup": {
							"shape": "S1m"
						}
					}
				}
			},
			"CreateSnapshot": {
				"input": {
					"type": "structure",
					"required": [
						"SnapshotName"
					],
					"members": {
						"ReplicationGroupId": {},
						"CacheClusterId": {},
						"SnapshotName": {}
					}
				},
				"output": {
					"resultWrapper": "CreateSnapshotResult",
					"type": "structure",
					"members": {
						"Snapshot": {
							"shape": "Sd"
						}
					}
				}
			},
			"DeleteCacheCluster": {
				"input": {
					"type": "structure",
					"required": [
						"CacheClusterId"
					],
					"members": {
						"CacheClusterId": {},
						"FinalSnapshotIdentifier": {}
					}
				},
				"output": {
					"resultWrapper": "DeleteCacheClusterResult",
					"type": "structure",
					"members": {
						"CacheCluster": {
							"shape": "Su"
						}
					}
				}
			},
			"DeleteCacheParameterGroup": {
				"input": {
					"type": "structure",
					"required": [
						"CacheParameterGroupName"
					],
					"members": {
						"CacheParameterGroupName": {}
					}
				}
			},
			"DeleteCacheSecurityGroup": {
				"input": {
					"type": "structure",
					"required": [
						"CacheSecurityGroupName"
					],
					"members": {
						"CacheSecurityGroupName": {}
					}
				}
			},
			"DeleteCacheSubnetGroup": {
				"input": {
					"type": "structure",
					"required": [
						"CacheSubnetGroupName"
					],
					"members": {
						"CacheSubnetGroupName": {}
					}
				}
			},
			"DeleteReplicationGroup": {
				"input": {
					"type": "structure",
					"required": [
						"ReplicationGroupId"
					],
					"members": {
						"ReplicationGroupId": {},
						"RetainPrimaryCluster": {
							"type": "boolean"
						},
						"FinalSnapshotIdentifier": {}
					}
				},
				"output": {
					"resultWrapper": "DeleteReplicationGroupResult",
					"type": "structure",
					"members": {
						"ReplicationGroup": {
							"shape": "S1m"
						}
					}
				}
			},
			"DeleteSnapshot": {
				"input": {
					"type": "structure",
					"required": [
						"SnapshotName"
					],
					"members": {
						"SnapshotName": {}
					}
				},
				"output": {
					"resultWrapper": "DeleteSnapshotResult",
					"type": "structure",
					"members": {
						"Snapshot": {
							"shape": "Sd"
						}
					}
				}
			},
			"DescribeCacheClusters": {
				"input": {
					"type": "structure",
					"members": {
						"CacheClusterId": {},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {},
						"ShowCacheNodeInfo": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"resultWrapper": "DescribeCacheClustersResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"CacheClusters": {
							"type": "list",
							"member": {
								"shape": "Su",
								"locationName": "CacheCluster"
							}
						}
					}
				}
			},
			"DescribeCacheEngineVersions": {
				"input": {
					"type": "structure",
					"members": {
						"Engine": {},
						"EngineVersion": {},
						"CacheParameterGroupFamily": {},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {},
						"DefaultOnly": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"resultWrapper": "DescribeCacheEngineVersionsResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"CacheEngineVersions": {
							"type": "list",
							"member": {
								"locationName": "CacheEngineVersion",
								"type": "structure",
								"members": {
									"Engine": {},
									"EngineVersion": {},
									"CacheParameterGroupFamily": {},
									"CacheEngineDescription": {},
									"CacheEngineVersionDescription": {}
								}
							}
						}
					}
				}
			},
			"DescribeCacheParameterGroups": {
				"input": {
					"type": "structure",
					"members": {
						"CacheParameterGroupName": {},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeCacheParameterGroupsResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"CacheParameterGroups": {
							"type": "list",
							"member": {
								"shape": "S19",
								"locationName": "CacheParameterGroup"
							}
						}
					}
				}
			},
			"DescribeCacheParameters": {
				"input": {
					"type": "structure",
					"required": [
						"CacheParameterGroupName"
					],
					"members": {
						"CacheParameterGroupName": {},
						"Source": {},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeCacheParametersResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"Parameters": {
							"shape": "S2h"
						},
						"CacheNodeTypeSpecificParameters": {
							"shape": "S2k"
						}
					}
				}
			},
			"DescribeCacheSecurityGroups": {
				"input": {
					"type": "structure",
					"members": {
						"CacheSecurityGroupName": {},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeCacheSecurityGroupsResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"CacheSecurityGroups": {
							"type": "list",
							"member": {
								"shape": "S8",
								"locationName": "CacheSecurityGroup"
							}
						}
					}
				}
			},
			"DescribeCacheSubnetGroups": {
				"input": {
					"type": "structure",
					"members": {
						"CacheSubnetGroupName": {},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeCacheSubnetGroupsResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"CacheSubnetGroups": {
							"type": "list",
							"member": {
								"shape": "S1f",
								"locationName": "CacheSubnetGroup"
							}
						}
					}
				}
			},
			"DescribeEngineDefaultParameters": {
				"input": {
					"type": "structure",
					"required": [
						"CacheParameterGroupFamily"
					],
					"members": {
						"CacheParameterGroupFamily": {},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeEngineDefaultParametersResult",
					"type": "structure",
					"members": {
						"EngineDefaults": {
							"type": "structure",
							"members": {
								"CacheParameterGroupFamily": {},
								"Marker": {},
								"Parameters": {
									"shape": "S2h"
								},
								"CacheNodeTypeSpecificParameters": {
									"shape": "S2k"
								}
							},
							"wrapper": true
						}
					}
				}
			},
			"DescribeEvents": {
				"input": {
					"type": "structure",
					"members": {
						"SourceIdentifier": {},
						"SourceType": {},
						"StartTime": {
							"type": "timestamp"
						},
						"EndTime": {
							"type": "timestamp"
						},
						"Duration": {
							"type": "integer"
						},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeEventsResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"Events": {
							"type": "list",
							"member": {
								"locationName": "Event",
								"type": "structure",
								"members": {
									"SourceIdentifier": {},
									"SourceType": {},
									"Message": {},
									"Date": {
										"type": "timestamp"
									}
								}
							}
						}
					}
				}
			},
			"DescribeReplicationGroups": {
				"input": {
					"type": "structure",
					"members": {
						"ReplicationGroupId": {},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeReplicationGroupsResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"ReplicationGroups": {
							"type": "list",
							"member": {
								"shape": "S1m",
								"locationName": "ReplicationGroup"
							}
						}
					}
				}
			},
			"DescribeReservedCacheNodes": {
				"input": {
					"type": "structure",
					"members": {
						"ReservedCacheNodeId": {},
						"ReservedCacheNodesOfferingId": {},
						"CacheNodeType": {},
						"Duration": {},
						"ProductDescription": {},
						"OfferingType": {},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeReservedCacheNodesResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"ReservedCacheNodes": {
							"type": "list",
							"member": {
								"shape": "S38",
								"locationName": "ReservedCacheNode"
							}
						}
					}
				}
			},
			"DescribeReservedCacheNodesOfferings": {
				"input": {
					"type": "structure",
					"members": {
						"ReservedCacheNodesOfferingId": {},
						"CacheNodeType": {},
						"Duration": {},
						"ProductDescription": {},
						"OfferingType": {},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeReservedCacheNodesOfferingsResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"ReservedCacheNodesOfferings": {
							"type": "list",
							"member": {
								"locationName": "ReservedCacheNodesOffering",
								"type": "structure",
								"members": {
									"ReservedCacheNodesOfferingId": {},
									"CacheNodeType": {},
									"Duration": {
										"type": "integer"
									},
									"FixedPrice": {
										"type": "double"
									},
									"UsagePrice": {
										"type": "double"
									},
									"ProductDescription": {},
									"OfferingType": {},
									"RecurringCharges": {
										"shape": "S3a"
									}
								},
								"wrapper": true
							}
						}
					}
				}
			},
			"DescribeSnapshots": {
				"input": {
					"type": "structure",
					"members": {
						"ReplicationGroupId": {},
						"CacheClusterId": {},
						"SnapshotName": {},
						"SnapshotSource": {},
						"Marker": {},
						"MaxRecords": {
							"type": "integer"
						},
						"ShowNodeGroupConfig": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"resultWrapper": "DescribeSnapshotsResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"Snapshots": {
							"type": "list",
							"member": {
								"shape": "Sd",
								"locationName": "Snapshot"
							}
						}
					}
				}
			},
			"ListAllowedNodeTypeModifications": {
				"input": {
					"type": "structure",
					"members": {
						"CacheClusterId": {},
						"ReplicationGroupId": {}
					}
				},
				"output": {
					"resultWrapper": "ListAllowedNodeTypeModificationsResult",
					"type": "structure",
					"members": {
						"ScaleUpModifications": {
							"type": "list",
							"member": {}
						}
					}
				}
			},
			"ListTagsForResource": {
				"input": {
					"type": "structure",
					"required": [
						"ResourceName"
					],
					"members": {
						"ResourceName": {}
					}
				},
				"output": {
					"shape": "S5",
					"resultWrapper": "ListTagsForResourceResult"
				}
			},
			"ModifyCacheCluster": {
				"input": {
					"type": "structure",
					"required": [
						"CacheClusterId"
					],
					"members": {
						"CacheClusterId": {},
						"NumCacheNodes": {
							"type": "integer"
						},
						"CacheNodeIdsToRemove": {
							"shape": "Sy"
						},
						"AZMode": {},
						"NewAvailabilityZones": {
							"shape": "So"
						},
						"CacheSecurityGroupNames": {
							"shape": "Sp"
						},
						"SecurityGroupIds": {
							"shape": "Sq"
						},
						"PreferredMaintenanceWindow": {},
						"NotificationTopicArn": {},
						"CacheParameterGroupName": {},
						"NotificationTopicStatus": {},
						"ApplyImmediately": {
							"type": "boolean"
						},
						"EngineVersion": {},
						"AutoMinorVersionUpgrade": {
							"type": "boolean"
						},
						"SnapshotRetentionLimit": {
							"type": "integer"
						},
						"SnapshotWindow": {},
						"CacheNodeType": {}
					}
				},
				"output": {
					"resultWrapper": "ModifyCacheClusterResult",
					"type": "structure",
					"members": {
						"CacheCluster": {
							"shape": "Su"
						}
					}
				}
			},
			"ModifyCacheParameterGroup": {
				"input": {
					"type": "structure",
					"required": [
						"CacheParameterGroupName",
						"ParameterNameValues"
					],
					"members": {
						"CacheParameterGroupName": {},
						"ParameterNameValues": {
							"shape": "S3q"
						}
					}
				},
				"output": {
					"shape": "S3s",
					"resultWrapper": "ModifyCacheParameterGroupResult"
				}
			},
			"ModifyCacheSubnetGroup": {
				"input": {
					"type": "structure",
					"required": [
						"CacheSubnetGroupName"
					],
					"members": {
						"CacheSubnetGroupName": {},
						"CacheSubnetGroupDescription": {},
						"SubnetIds": {
							"shape": "S1d"
						}
					}
				},
				"output": {
					"resultWrapper": "ModifyCacheSubnetGroupResult",
					"type": "structure",
					"members": {
						"CacheSubnetGroup": {
							"shape": "S1f"
						}
					}
				}
			},
			"ModifyReplicationGroup": {
				"input": {
					"type": "structure",
					"required": [
						"ReplicationGroupId"
					],
					"members": {
						"ReplicationGroupId": {},
						"ReplicationGroupDescription": {},
						"PrimaryClusterId": {},
						"SnapshottingClusterId": {},
						"AutomaticFailoverEnabled": {
							"type": "boolean"
						},
						"CacheSecurityGroupNames": {
							"shape": "Sp"
						},
						"SecurityGroupIds": {
							"shape": "Sq"
						},
						"PreferredMaintenanceWindow": {},
						"NotificationTopicArn": {},
						"CacheParameterGroupName": {},
						"NotificationTopicStatus": {},
						"ApplyImmediately": {
							"type": "boolean"
						},
						"EngineVersion": {},
						"AutoMinorVersionUpgrade": {
							"type": "boolean"
						},
						"SnapshotRetentionLimit": {
							"type": "integer"
						},
						"SnapshotWindow": {},
						"CacheNodeType": {}
					}
				},
				"output": {
					"resultWrapper": "ModifyReplicationGroupResult",
					"type": "structure",
					"members": {
						"ReplicationGroup": {
							"shape": "S1m"
						}
					}
				}
			},
			"PurchaseReservedCacheNodesOffering": {
				"input": {
					"type": "structure",
					"required": [
						"ReservedCacheNodesOfferingId"
					],
					"members": {
						"ReservedCacheNodesOfferingId": {},
						"ReservedCacheNodeId": {},
						"CacheNodeCount": {
							"type": "integer"
						}
					}
				},
				"output": {
					"resultWrapper": "PurchaseReservedCacheNodesOfferingResult",
					"type": "structure",
					"members": {
						"ReservedCacheNode": {
							"shape": "S38"
						}
					}
				}
			},
			"RebootCacheCluster": {
				"input": {
					"type": "structure",
					"required": [
						"CacheClusterId",
						"CacheNodeIdsToReboot"
					],
					"members": {
						"CacheClusterId": {},
						"CacheNodeIdsToReboot": {
							"shape": "Sy"
						}
					}
				},
				"output": {
					"resultWrapper": "RebootCacheClusterResult",
					"type": "structure",
					"members": {
						"CacheCluster": {
							"shape": "Su"
						}
					}
				}
			},
			"RemoveTagsFromResource": {
				"input": {
					"type": "structure",
					"required": [
						"ResourceName",
						"TagKeys"
					],
					"members": {
						"ResourceName": {},
						"TagKeys": {
							"type": "list",
							"member": {}
						}
					}
				},
				"output": {
					"shape": "S5",
					"resultWrapper": "RemoveTagsFromResourceResult"
				}
			},
			"ResetCacheParameterGroup": {
				"input": {
					"type": "structure",
					"required": [
						"CacheParameterGroupName"
					],
					"members": {
						"CacheParameterGroupName": {},
						"ResetAllParameters": {
							"type": "boolean"
						},
						"ParameterNameValues": {
							"shape": "S3q"
						}
					}
				},
				"output": {
					"shape": "S3s",
					"resultWrapper": "ResetCacheParameterGroupResult"
				}
			},
			"RevokeCacheSecurityGroupIngress": {
				"input": {
					"type": "structure",
					"required": [
						"CacheSecurityGroupName",
						"EC2SecurityGroupName",
						"EC2SecurityGroupOwnerId"
					],
					"members": {
						"CacheSecurityGroupName": {},
						"EC2SecurityGroupName": {},
						"EC2SecurityGroupOwnerId": {}
					}
				},
				"output": {
					"resultWrapper": "RevokeCacheSecurityGroupIngressResult",
					"type": "structure",
					"members": {
						"CacheSecurityGroup": {
							"shape": "S8"
						}
					}
				}
			}
		},
		"shapes": {
			"S3": {
				"type": "list",
				"member": {
					"locationName": "Tag",
					"type": "structure",
					"members": {
						"Key": {},
						"Value": {}
					}
				}
			},
			"S5": {
				"type": "structure",
				"members": {
					"TagList": {
						"shape": "S3"
					}
				}
			},
			"S8": {
				"type": "structure",
				"members": {
					"OwnerId": {},
					"CacheSecurityGroupName": {},
					"Description": {},
					"EC2SecurityGroups": {
						"type": "list",
						"member": {
							"locationName": "EC2SecurityGroup",
							"type": "structure",
							"members": {
								"Status": {},
								"EC2SecurityGroupName": {},
								"EC2SecurityGroupOwnerId": {}
							}
						}
					}
				},
				"wrapper": true
			},
			"Sd": {
				"type": "structure",
				"members": {
					"SnapshotName": {},
					"ReplicationGroupId": {},
					"ReplicationGroupDescription": {},
					"CacheClusterId": {},
					"SnapshotStatus": {},
					"SnapshotSource": {},
					"CacheNodeType": {},
					"Engine": {},
					"EngineVersion": {},
					"NumCacheNodes": {
						"type": "integer"
					},
					"PreferredAvailabilityZone": {},
					"CacheClusterCreateTime": {
						"type": "timestamp"
					},
					"PreferredMaintenanceWindow": {},
					"TopicArn": {},
					"Port": {
						"type": "integer"
					},
					"CacheParameterGroupName": {},
					"CacheSubnetGroupName": {},
					"VpcId": {},
					"AutoMinorVersionUpgrade": {
						"type": "boolean"
					},
					"SnapshotRetentionLimit": {
						"type": "integer"
					},
					"SnapshotWindow": {},
					"NumNodeGroups": {
						"type": "integer"
					},
					"AutomaticFailover": {},
					"NodeSnapshots": {
						"type": "list",
						"member": {
							"locationName": "NodeSnapshot",
							"type": "structure",
							"members": {
								"CacheClusterId": {},
								"NodeGroupId": {},
								"CacheNodeId": {},
								"NodeGroupConfiguration": {
									"shape": "Sk"
								},
								"CacheSize": {},
								"CacheNodeCreateTime": {
									"type": "timestamp"
								},
								"SnapshotCreateTime": {
									"type": "timestamp"
								}
							},
							"wrapper": true
						}
					}
				},
				"wrapper": true
			},
			"Sk": {
				"type": "structure",
				"members": {
					"Slots": {},
					"ReplicaCount": {
						"type": "integer"
					},
					"PrimaryAvailabilityZone": {},
					"ReplicaAvailabilityZones": {
						"shape": "Sl"
					}
				}
			},
			"Sl": {
				"type": "list",
				"member": {
					"locationName": "AvailabilityZone"
				}
			},
			"So": {
				"type": "list",
				"member": {
					"locationName": "PreferredAvailabilityZone"
				}
			},
			"Sp": {
				"type": "list",
				"member": {
					"locationName": "CacheSecurityGroupName"
				}
			},
			"Sq": {
				"type": "list",
				"member": {
					"locationName": "SecurityGroupId"
				}
			},
			"Sr": {
				"type": "list",
				"member": {
					"locationName": "SnapshotArn"
				}
			},
			"Su": {
				"type": "structure",
				"members": {
					"CacheClusterId": {},
					"ConfigurationEndpoint": {
						"shape": "Sv"
					},
					"ClientDownloadLandingPage": {},
					"CacheNodeType": {},
					"Engine": {},
					"EngineVersion": {},
					"CacheClusterStatus": {},
					"NumCacheNodes": {
						"type": "integer"
					},
					"PreferredAvailabilityZone": {},
					"CacheClusterCreateTime": {
						"type": "timestamp"
					},
					"PreferredMaintenanceWindow": {},
					"PendingModifiedValues": {
						"type": "structure",
						"members": {
							"NumCacheNodes": {
								"type": "integer"
							},
							"CacheNodeIdsToRemove": {
								"shape": "Sy"
							},
							"EngineVersion": {},
							"CacheNodeType": {}
						}
					},
					"NotificationConfiguration": {
						"type": "structure",
						"members": {
							"TopicArn": {},
							"TopicStatus": {}
						}
					},
					"CacheSecurityGroups": {
						"type": "list",
						"member": {
							"locationName": "CacheSecurityGroup",
							"type": "structure",
							"members": {
								"CacheSecurityGroupName": {},
								"Status": {}
							}
						}
					},
					"CacheParameterGroup": {
						"type": "structure",
						"members": {
							"CacheParameterGroupName": {},
							"ParameterApplyStatus": {},
							"CacheNodeIdsToReboot": {
								"shape": "Sy"
							}
						}
					},
					"CacheSubnetGroupName": {},
					"CacheNodes": {
						"type": "list",
						"member": {
							"locationName": "CacheNode",
							"type": "structure",
							"members": {
								"CacheNodeId": {},
								"CacheNodeStatus": {},
								"CacheNodeCreateTime": {
									"type": "timestamp"
								},
								"Endpoint": {
									"shape": "Sv"
								},
								"ParameterGroupStatus": {},
								"SourceCacheNodeId": {},
								"CustomerAvailabilityZone": {}
							}
						}
					},
					"AutoMinorVersionUpgrade": {
						"type": "boolean"
					},
					"SecurityGroups": {
						"type": "list",
						"member": {
							"type": "structure",
							"members": {
								"SecurityGroupId": {},
								"Status": {}
							}
						}
					},
					"ReplicationGroupId": {},
					"SnapshotRetentionLimit": {
						"type": "integer"
					},
					"SnapshotWindow": {}
				},
				"wrapper": true
			},
			"Sv": {
				"type": "structure",
				"members": {
					"Address": {},
					"Port": {
						"type": "integer"
					}
				}
			},
			"Sy": {
				"type": "list",
				"member": {
					"locationName": "CacheNodeId"
				}
			},
			"S19": {
				"type": "structure",
				"members": {
					"CacheParameterGroupName": {},
					"CacheParameterGroupFamily": {},
					"Description": {}
				},
				"wrapper": true
			},
			"S1d": {
				"type": "list",
				"member": {
					"locationName": "SubnetIdentifier"
				}
			},
			"S1f": {
				"type": "structure",
				"members": {
					"CacheSubnetGroupName": {},
					"CacheSubnetGroupDescription": {},
					"VpcId": {},
					"Subnets": {
						"type": "list",
						"member": {
							"locationName": "Subnet",
							"type": "structure",
							"members": {
								"SubnetIdentifier": {},
								"SubnetAvailabilityZone": {
									"type": "structure",
									"members": {
										"Name": {}
									},
									"wrapper": true
								}
							}
						}
					}
				},
				"wrapper": true
			},
			"S1m": {
				"type": "structure",
				"members": {
					"ReplicationGroupId": {},
					"Description": {},
					"Status": {},
					"PendingModifiedValues": {
						"type": "structure",
						"members": {
							"PrimaryClusterId": {},
							"AutomaticFailoverStatus": {}
						}
					},
					"MemberClusters": {
						"type": "list",
						"member": {
							"locationName": "ClusterId"
						}
					},
					"NodeGroups": {
						"type": "list",
						"member": {
							"locationName": "NodeGroup",
							"type": "structure",
							"members": {
								"NodeGroupId": {},
								"Status": {},
								"PrimaryEndpoint": {
									"shape": "Sv"
								},
								"Slots": {},
								"NodeGroupMembers": {
									"type": "list",
									"member": {
										"locationName": "NodeGroupMember",
										"type": "structure",
										"members": {
											"CacheClusterId": {},
											"CacheNodeId": {},
											"ReadEndpoint": {
												"shape": "Sv"
											},
											"PreferredAvailabilityZone": {},
											"CurrentRole": {}
										}
									}
								}
							}
						}
					},
					"SnapshottingClusterId": {},
					"AutomaticFailover": {},
					"ConfigurationEndpoint": {
						"shape": "Sv"
					},
					"SnapshotRetentionLimit": {
						"type": "integer"
					},
					"SnapshotWindow": {}
				},
				"wrapper": true
			},
			"S2h": {
				"type": "list",
				"member": {
					"locationName": "Parameter",
					"type": "structure",
					"members": {
						"ParameterName": {},
						"ParameterValue": {},
						"Description": {},
						"Source": {},
						"DataType": {},
						"AllowedValues": {},
						"IsModifiable": {
							"type": "boolean"
						},
						"MinimumEngineVersion": {},
						"ChangeType": {}
					}
				}
			},
			"S2k": {
				"type": "list",
				"member": {
					"locationName": "CacheNodeTypeSpecificParameter",
					"type": "structure",
					"members": {
						"ParameterName": {},
						"Description": {},
						"Source": {},
						"DataType": {},
						"AllowedValues": {},
						"IsModifiable": {
							"type": "boolean"
						},
						"MinimumEngineVersion": {},
						"CacheNodeTypeSpecificValues": {
							"type": "list",
							"member": {
								"locationName": "CacheNodeTypeSpecificValue",
								"type": "structure",
								"members": {
									"CacheNodeType": {},
									"Value": {}
								}
							}
						},
						"ChangeType": {}
					}
				}
			},
			"S38": {
				"type": "structure",
				"members": {
					"ReservedCacheNodeId": {},
					"ReservedCacheNodesOfferingId": {},
					"CacheNodeType": {},
					"StartTime": {
						"type": "timestamp"
					},
					"Duration": {
						"type": "integer"
					},
					"FixedPrice": {
						"type": "double"
					},
					"UsagePrice": {
						"type": "double"
					},
					"CacheNodeCount": {
						"type": "integer"
					},
					"ProductDescription": {},
					"OfferingType": {},
					"State": {},
					"RecurringCharges": {
						"shape": "S3a"
					}
				},
				"wrapper": true
			},
			"S3a": {
				"type": "list",
				"member": {
					"locationName": "RecurringCharge",
					"type": "structure",
					"members": {
						"RecurringChargeAmount": {
							"type": "double"
						},
						"RecurringChargeFrequency": {}
					},
					"wrapper": true
				}
			},
			"S3q": {
				"type": "list",
				"member": {
					"locationName": "ParameterNameValue",
					"type": "structure",
					"members": {
						"ParameterName": {},
						"ParameterValue": {}
					}
				}
			},
			"S3s": {
				"type": "structure",
				"members": {
					"CacheParameterGroupName": {}
				}
			}
		}
	};

/***/ },
/* 343 */
/***/ function(module, exports) {

	module.exports = {
		"pagination": {
			"DescribeCacheClusters": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "CacheClusters"
			},
			"DescribeCacheEngineVersions": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "CacheEngineVersions"
			},
			"DescribeCacheParameterGroups": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "CacheParameterGroups"
			},
			"DescribeCacheParameters": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "Parameters"
			},
			"DescribeCacheSecurityGroups": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "CacheSecurityGroups"
			},
			"DescribeCacheSubnetGroups": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "CacheSubnetGroups"
			},
			"DescribeEngineDefaultParameters": {
				"input_token": "Marker",
				"output_token": "EngineDefaults.Marker",
				"limit_key": "MaxRecords",
				"result_key": "EngineDefaults.Parameters"
			},
			"DescribeEvents": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "Events"
			},
			"DescribeReservedCacheNodes": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "ReservedCacheNodes"
			},
			"DescribeReservedCacheNodesOfferings": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "ReservedCacheNodesOfferings"
			},
			"DescribeReplicationGroups": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "ReplicationGroups"
			},
			"DescribeSnapshots": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "Snapshots"
			}
		}
	};

/***/ },
/* 344 */
/***/ function(module, exports) {

	module.exports = {
		"version": 2,
		"waiters": {
			"CacheClusterAvailable": {
				"acceptors": [
					{
						"argument": "CacheClusters[].CacheClusterStatus",
						"expected": "available",
						"matcher": "pathAll",
						"state": "success"
					},
					{
						"argument": "CacheClusters[].CacheClusterStatus",
						"expected": "deleted",
						"matcher": "pathAny",
						"state": "failure"
					},
					{
						"argument": "CacheClusters[].CacheClusterStatus",
						"expected": "deleting",
						"matcher": "pathAny",
						"state": "failure"
					},
					{
						"argument": "CacheClusters[].CacheClusterStatus",
						"expected": "incompatible-network",
						"matcher": "pathAny",
						"state": "failure"
					},
					{
						"argument": "CacheClusters[].CacheClusterStatus",
						"expected": "restore-failed",
						"matcher": "pathAny",
						"state": "failure"
					}
				],
				"delay": 15,
				"description": "Wait until ElastiCache cluster is available.",
				"maxAttempts": 40,
				"operation": "DescribeCacheClusters"
			},
			"CacheClusterDeleted": {
				"acceptors": [
					{
						"argument": "CacheClusters[].CacheClusterStatus",
						"expected": "deleted",
						"matcher": "pathAll",
						"state": "success"
					},
					{
						"expected": "CacheClusterNotFound",
						"matcher": "error",
						"state": "success"
					},
					{
						"argument": "CacheClusters[].CacheClusterStatus",
						"expected": "available",
						"matcher": "pathAny",
						"state": "failure"
					},
					{
						"argument": "CacheClusters[].CacheClusterStatus",
						"expected": "creating",
						"matcher": "pathAny",
						"state": "failure"
					},
					{
						"argument": "CacheClusters[].CacheClusterStatus",
						"expected": "incompatible-network",
						"matcher": "pathAny",
						"state": "failure"
					},
					{
						"argument": "CacheClusters[].CacheClusterStatus",
						"expected": "modifying",
						"matcher": "pathAny",
						"state": "failure"
					},
					{
						"argument": "CacheClusters[].CacheClusterStatus",
						"expected": "restore-failed",
						"matcher": "pathAny",
						"state": "failure"
					},
					{
						"argument": "CacheClusters[].CacheClusterStatus",
						"expected": "snapshotting",
						"matcher": "pathAny",
						"state": "failure"
					}
				],
				"delay": 15,
				"description": "Wait until ElastiCache cluster is deleted.",
				"maxAttempts": 40,
				"operation": "DescribeCacheClusters"
			},
			"ReplicationGroupAvailable": {
				"acceptors": [
					{
						"argument": "ReplicationGroups[].Status",
						"expected": "available",
						"matcher": "pathAll",
						"state": "success"
					},
					{
						"argument": "ReplicationGroups[].Status",
						"expected": "deleted",
						"matcher": "pathAny",
						"state": "failure"
					}
				],
				"delay": 15,
				"description": "Wait until ElastiCache replication group is available.",
				"maxAttempts": 40,
				"operation": "DescribeReplicationGroups"
			},
			"ReplicationGroupDeleted": {
				"acceptors": [
					{
						"argument": "ReplicationGroups[].Status",
						"expected": "deleted",
						"matcher": "pathAll",
						"state": "success"
					},
					{
						"argument": "ReplicationGroups[].Status",
						"expected": "available",
						"matcher": "pathAny",
						"state": "failure"
					},
					{
						"expected": "ReplicationGroupNotFoundFault",
						"matcher": "error",
						"state": "success"
					}
				],
				"delay": 15,
				"description": "Wait until ElastiCache replication group is deleted.",
				"maxAttempts": 40,
				"operation": "DescribeReplicationGroups"
			}
		}
	};

/***/ },
/* 345 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['elasticbeanstalk'] = {};
	AWS.ElasticBeanstalk = Service.defineService('elasticbeanstalk', ['2010-12-01']);
	Object.defineProperty(apiLoader.services['elasticbeanstalk'], '2010-12-01', {
	  get: function get() {
	    var model = __webpack_require__(346);
	    model.paginators = __webpack_require__(347).pagination;
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.ElasticBeanstalk;


/***/ },
/* 346 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2010-12-01",
			"endpointPrefix": "elasticbeanstalk",
			"protocol": "query",
			"serviceAbbreviation": "Elastic Beanstalk",
			"serviceFullName": "AWS Elastic Beanstalk",
			"signatureVersion": "v4",
			"xmlNamespace": "http://elasticbeanstalk.amazonaws.com/docs/2010-12-01/"
		},
		"operations": {
			"AbortEnvironmentUpdate": {
				"input": {
					"type": "structure",
					"members": {
						"EnvironmentId": {},
						"EnvironmentName": {}
					}
				}
			},
			"ApplyEnvironmentManagedAction": {
				"input": {
					"type": "structure",
					"required": [
						"ActionId"
					],
					"members": {
						"EnvironmentName": {},
						"EnvironmentId": {},
						"ActionId": {}
					}
				},
				"output": {
					"resultWrapper": "ApplyEnvironmentManagedActionResult",
					"type": "structure",
					"members": {
						"ActionId": {},
						"ActionDescription": {},
						"ActionType": {},
						"Status": {}
					}
				}
			},
			"CheckDNSAvailability": {
				"input": {
					"type": "structure",
					"required": [
						"CNAMEPrefix"
					],
					"members": {
						"CNAMEPrefix": {}
					}
				},
				"output": {
					"resultWrapper": "CheckDNSAvailabilityResult",
					"type": "structure",
					"members": {
						"Available": {
							"type": "boolean"
						},
						"FullyQualifiedCNAME": {}
					}
				}
			},
			"ComposeEnvironments": {
				"input": {
					"type": "structure",
					"members": {
						"ApplicationName": {},
						"GroupName": {},
						"VersionLabels": {
							"type": "list",
							"member": {}
						}
					}
				},
				"output": {
					"shape": "Si",
					"resultWrapper": "ComposeEnvironmentsResult"
				}
			},
			"CreateApplication": {
				"input": {
					"type": "structure",
					"required": [
						"ApplicationName"
					],
					"members": {
						"ApplicationName": {},
						"Description": {}
					}
				},
				"output": {
					"shape": "S14",
					"resultWrapper": "CreateApplicationResult"
				}
			},
			"CreateApplicationVersion": {
				"input": {
					"type": "structure",
					"required": [
						"ApplicationName",
						"VersionLabel"
					],
					"members": {
						"ApplicationName": {},
						"VersionLabel": {},
						"Description": {},
						"SourceBuildInformation": {
							"shape": "S19"
						},
						"SourceBundle": {
							"shape": "S1d"
						},
						"AutoCreateApplication": {
							"type": "boolean"
						},
						"Process": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"shape": "S1i",
					"resultWrapper": "CreateApplicationVersionResult"
				}
			},
			"CreateConfigurationTemplate": {
				"input": {
					"type": "structure",
					"required": [
						"ApplicationName",
						"TemplateName"
					],
					"members": {
						"ApplicationName": {},
						"TemplateName": {},
						"SolutionStackName": {},
						"SourceConfiguration": {
							"type": "structure",
							"members": {
								"ApplicationName": {},
								"TemplateName": {}
							}
						},
						"EnvironmentId": {},
						"Description": {},
						"OptionSettings": {
							"shape": "S1n"
						}
					}
				},
				"output": {
					"shape": "S1t",
					"resultWrapper": "CreateConfigurationTemplateResult"
				}
			},
			"CreateEnvironment": {
				"input": {
					"type": "structure",
					"required": [
						"ApplicationName"
					],
					"members": {
						"ApplicationName": {},
						"EnvironmentName": {},
						"GroupName": {},
						"Description": {},
						"CNAMEPrefix": {},
						"Tier": {
							"shape": "S10"
						},
						"Tags": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"Key": {},
									"Value": {}
								}
							}
						},
						"VersionLabel": {},
						"TemplateName": {},
						"SolutionStackName": {},
						"OptionSettings": {
							"shape": "S1n"
						},
						"OptionsToRemove": {
							"shape": "S20"
						}
					}
				},
				"output": {
					"shape": "Sk",
					"resultWrapper": "CreateEnvironmentResult"
				}
			},
			"CreateStorageLocation": {
				"output": {
					"resultWrapper": "CreateStorageLocationResult",
					"type": "structure",
					"members": {
						"S3Bucket": {}
					}
				}
			},
			"DeleteApplication": {
				"input": {
					"type": "structure",
					"required": [
						"ApplicationName"
					],
					"members": {
						"ApplicationName": {},
						"TerminateEnvByForce": {
							"type": "boolean"
						}
					}
				}
			},
			"DeleteApplicationVersion": {
				"input": {
					"type": "structure",
					"required": [
						"ApplicationName",
						"VersionLabel"
					],
					"members": {
						"ApplicationName": {},
						"VersionLabel": {},
						"DeleteSourceBundle": {
							"type": "boolean"
						}
					}
				}
			},
			"DeleteConfigurationTemplate": {
				"input": {
					"type": "structure",
					"required": [
						"ApplicationName",
						"TemplateName"
					],
					"members": {
						"ApplicationName": {},
						"TemplateName": {}
					}
				}
			},
			"DeleteEnvironmentConfiguration": {
				"input": {
					"type": "structure",
					"required": [
						"ApplicationName",
						"EnvironmentName"
					],
					"members": {
						"ApplicationName": {},
						"EnvironmentName": {}
					}
				}
			},
			"DescribeApplicationVersions": {
				"input": {
					"type": "structure",
					"members": {
						"ApplicationName": {},
						"VersionLabels": {
							"shape": "S16"
						},
						"MaxRecords": {
							"type": "integer"
						},
						"NextToken": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeApplicationVersionsResult",
					"type": "structure",
					"members": {
						"ApplicationVersions": {
							"type": "list",
							"member": {
								"shape": "S1j"
							}
						},
						"NextToken": {}
					}
				}
			},
			"DescribeApplications": {
				"input": {
					"type": "structure",
					"members": {
						"ApplicationNames": {
							"type": "list",
							"member": {}
						}
					}
				},
				"output": {
					"resultWrapper": "DescribeApplicationsResult",
					"type": "structure",
					"members": {
						"Applications": {
							"type": "list",
							"member": {
								"shape": "S15"
							}
						}
					}
				}
			},
			"DescribeConfigurationOptions": {
				"input": {
					"type": "structure",
					"members": {
						"ApplicationName": {},
						"TemplateName": {},
						"EnvironmentName": {},
						"SolutionStackName": {},
						"Options": {
							"shape": "S20"
						}
					}
				},
				"output": {
					"resultWrapper": "DescribeConfigurationOptionsResult",
					"type": "structure",
					"members": {
						"SolutionStackName": {},
						"Options": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"Namespace": {},
									"Name": {},
									"DefaultValue": {},
									"ChangeSeverity": {},
									"UserDefined": {
										"type": "boolean"
									},
									"ValueType": {},
									"ValueOptions": {
										"type": "list",
										"member": {}
									},
									"MinValue": {
										"type": "integer"
									},
									"MaxValue": {
										"type": "integer"
									},
									"MaxLength": {
										"type": "integer"
									},
									"Regex": {
										"type": "structure",
										"members": {
											"Pattern": {},
											"Label": {}
										}
									}
								}
							}
						}
					}
				}
			},
			"DescribeConfigurationSettings": {
				"input": {
					"type": "structure",
					"required": [
						"ApplicationName"
					],
					"members": {
						"ApplicationName": {},
						"TemplateName": {},
						"EnvironmentName": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeConfigurationSettingsResult",
					"type": "structure",
					"members": {
						"ConfigurationSettings": {
							"type": "list",
							"member": {
								"shape": "S1t"
							}
						}
					}
				}
			},
			"DescribeEnvironmentHealth": {
				"input": {
					"type": "structure",
					"members": {
						"EnvironmentName": {},
						"EnvironmentId": {},
						"AttributeNames": {
							"type": "list",
							"member": {}
						}
					}
				},
				"output": {
					"resultWrapper": "DescribeEnvironmentHealthResult",
					"type": "structure",
					"members": {
						"EnvironmentName": {},
						"HealthStatus": {},
						"Status": {},
						"Color": {},
						"Causes": {
							"shape": "S35"
						},
						"ApplicationMetrics": {
							"shape": "S37"
						},
						"InstancesHealth": {
							"type": "structure",
							"members": {
								"NoData": {
									"type": "integer"
								},
								"Unknown": {
									"type": "integer"
								},
								"Pending": {
									"type": "integer"
								},
								"Ok": {
									"type": "integer"
								},
								"Info": {
									"type": "integer"
								},
								"Warning": {
									"type": "integer"
								},
								"Degraded": {
									"type": "integer"
								},
								"Severe": {
									"type": "integer"
								}
							}
						},
						"RefreshedAt": {
							"type": "timestamp"
						}
					}
				}
			},
			"DescribeEnvironmentManagedActionHistory": {
				"input": {
					"type": "structure",
					"members": {
						"EnvironmentId": {},
						"EnvironmentName": {},
						"NextToken": {},
						"MaxItems": {
							"type": "integer"
						}
					}
				},
				"output": {
					"resultWrapper": "DescribeEnvironmentManagedActionHistoryResult",
					"type": "structure",
					"members": {
						"ManagedActionHistoryItems": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"ActionId": {},
									"ActionType": {},
									"ActionDescription": {},
									"FailureType": {},
									"Status": {},
									"FailureDescription": {},
									"ExecutedTime": {
										"type": "timestamp"
									},
									"FinishedTime": {
										"type": "timestamp"
									}
								}
							}
						},
						"NextToken": {}
					}
				}
			},
			"DescribeEnvironmentManagedActions": {
				"input": {
					"type": "structure",
					"members": {
						"EnvironmentName": {},
						"EnvironmentId": {},
						"Status": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeEnvironmentManagedActionsResult",
					"type": "structure",
					"members": {
						"ManagedActions": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"ActionId": {},
									"ActionDescription": {},
									"ActionType": {},
									"Status": {},
									"WindowStartTime": {
										"type": "timestamp"
									}
								}
							}
						}
					}
				}
			},
			"DescribeEnvironmentResources": {
				"input": {
					"type": "structure",
					"members": {
						"EnvironmentId": {},
						"EnvironmentName": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeEnvironmentResourcesResult",
					"type": "structure",
					"members": {
						"EnvironmentResources": {
							"type": "structure",
							"members": {
								"EnvironmentName": {},
								"AutoScalingGroups": {
									"type": "list",
									"member": {
										"type": "structure",
										"members": {
											"Name": {}
										}
									}
								},
								"Instances": {
									"type": "list",
									"member": {
										"type": "structure",
										"members": {
											"Id": {}
										}
									}
								},
								"LaunchConfigurations": {
									"type": "list",
									"member": {
										"type": "structure",
										"members": {
											"Name": {}
										}
									}
								},
								"LoadBalancers": {
									"type": "list",
									"member": {
										"type": "structure",
										"members": {
											"Name": {}
										}
									}
								},
								"Triggers": {
									"type": "list",
									"member": {
										"type": "structure",
										"members": {
											"Name": {}
										}
									}
								},
								"Queues": {
									"type": "list",
									"member": {
										"type": "structure",
										"members": {
											"Name": {},
											"URL": {}
										}
									}
								}
							}
						}
					}
				}
			},
			"DescribeEnvironments": {
				"input": {
					"type": "structure",
					"members": {
						"ApplicationName": {},
						"VersionLabel": {},
						"EnvironmentIds": {
							"type": "list",
							"member": {}
						},
						"EnvironmentNames": {
							"type": "list",
							"member": {}
						},
						"IncludeDeleted": {
							"type": "boolean"
						},
						"IncludedDeletedBackTo": {
							"type": "timestamp"
						}
					}
				},
				"output": {
					"shape": "Si",
					"resultWrapper": "DescribeEnvironmentsResult"
				}
			},
			"DescribeEvents": {
				"input": {
					"type": "structure",
					"members": {
						"ApplicationName": {},
						"VersionLabel": {},
						"TemplateName": {},
						"EnvironmentId": {},
						"EnvironmentName": {},
						"RequestId": {},
						"Severity": {},
						"StartTime": {
							"type": "timestamp"
						},
						"EndTime": {
							"type": "timestamp"
						},
						"MaxRecords": {
							"type": "integer"
						},
						"NextToken": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeEventsResult",
					"type": "structure",
					"members": {
						"Events": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"EventDate": {
										"type": "timestamp"
									},
									"Message": {},
									"ApplicationName": {},
									"VersionLabel": {},
									"TemplateName": {},
									"EnvironmentName": {},
									"RequestId": {},
									"Severity": {}
								}
							}
						},
						"NextToken": {}
					}
				}
			},
			"DescribeInstancesHealth": {
				"input": {
					"type": "structure",
					"members": {
						"EnvironmentName": {},
						"EnvironmentId": {},
						"AttributeNames": {
							"type": "list",
							"member": {}
						},
						"NextToken": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeInstancesHealthResult",
					"type": "structure",
					"members": {
						"InstanceHealthList": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"InstanceId": {},
									"HealthStatus": {},
									"Color": {},
									"Causes": {
										"shape": "S35"
									},
									"LaunchedAt": {
										"type": "timestamp"
									},
									"ApplicationMetrics": {
										"shape": "S37"
									},
									"System": {
										"type": "structure",
										"members": {
											"CPUUtilization": {
												"type": "structure",
												"members": {
													"User": {
														"type": "double"
													},
													"Nice": {
														"type": "double"
													},
													"System": {
														"type": "double"
													},
													"Idle": {
														"type": "double"
													},
													"IOWait": {
														"type": "double"
													},
													"IRQ": {
														"type": "double"
													},
													"SoftIRQ": {
														"type": "double"
													}
												}
											},
											"LoadAverage": {
												"type": "list",
												"member": {
													"type": "double"
												}
											}
										}
									},
									"Deployment": {
										"type": "structure",
										"members": {
											"VersionLabel": {},
											"DeploymentId": {
												"type": "long"
											},
											"Status": {},
											"DeploymentTime": {
												"type": "timestamp"
											}
										}
									},
									"AvailabilityZone": {},
									"InstanceType": {}
								}
							}
						},
						"RefreshedAt": {
							"type": "timestamp"
						},
						"NextToken": {}
					}
				}
			},
			"ListAvailableSolutionStacks": {
				"output": {
					"resultWrapper": "ListAvailableSolutionStacksResult",
					"type": "structure",
					"members": {
						"SolutionStacks": {
							"type": "list",
							"member": {}
						},
						"SolutionStackDetails": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"SolutionStackName": {},
									"PermittedFileTypes": {
										"type": "list",
										"member": {}
									}
								}
							}
						}
					}
				}
			},
			"RebuildEnvironment": {
				"input": {
					"type": "structure",
					"members": {
						"EnvironmentId": {},
						"EnvironmentName": {}
					}
				}
			},
			"RequestEnvironmentInfo": {
				"input": {
					"type": "structure",
					"required": [
						"InfoType"
					],
					"members": {
						"EnvironmentId": {},
						"EnvironmentName": {},
						"InfoType": {}
					}
				}
			},
			"RestartAppServer": {
				"input": {
					"type": "structure",
					"members": {
						"EnvironmentId": {},
						"EnvironmentName": {}
					}
				}
			},
			"RetrieveEnvironmentInfo": {
				"input": {
					"type": "structure",
					"required": [
						"InfoType"
					],
					"members": {
						"EnvironmentId": {},
						"EnvironmentName": {},
						"InfoType": {}
					}
				},
				"output": {
					"resultWrapper": "RetrieveEnvironmentInfoResult",
					"type": "structure",
					"members": {
						"EnvironmentInfo": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"InfoType": {},
									"Ec2InstanceId": {},
									"SampleTimestamp": {
										"type": "timestamp"
									},
									"Message": {}
								}
							}
						}
					}
				}
			},
			"SwapEnvironmentCNAMEs": {
				"input": {
					"type": "structure",
					"members": {
						"SourceEnvironmentId": {},
						"SourceEnvironmentName": {},
						"DestinationEnvironmentId": {},
						"DestinationEnvironmentName": {}
					}
				}
			},
			"TerminateEnvironment": {
				"input": {
					"type": "structure",
					"members": {
						"EnvironmentId": {},
						"EnvironmentName": {},
						"TerminateResources": {
							"type": "boolean"
						},
						"ForceTerminate": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"shape": "Sk",
					"resultWrapper": "TerminateEnvironmentResult"
				}
			},
			"UpdateApplication": {
				"input": {
					"type": "structure",
					"required": [
						"ApplicationName"
					],
					"members": {
						"ApplicationName": {},
						"Description": {}
					}
				},
				"output": {
					"shape": "S14",
					"resultWrapper": "UpdateApplicationResult"
				}
			},
			"UpdateApplicationVersion": {
				"input": {
					"type": "structure",
					"required": [
						"ApplicationName",
						"VersionLabel"
					],
					"members": {
						"ApplicationName": {},
						"VersionLabel": {},
						"Description": {}
					}
				},
				"output": {
					"shape": "S1i",
					"resultWrapper": "UpdateApplicationVersionResult"
				}
			},
			"UpdateConfigurationTemplate": {
				"input": {
					"type": "structure",
					"required": [
						"ApplicationName",
						"TemplateName"
					],
					"members": {
						"ApplicationName": {},
						"TemplateName": {},
						"Description": {},
						"OptionSettings": {
							"shape": "S1n"
						},
						"OptionsToRemove": {
							"shape": "S20"
						}
					}
				},
				"output": {
					"shape": "S1t",
					"resultWrapper": "UpdateConfigurationTemplateResult"
				}
			},
			"UpdateEnvironment": {
				"input": {
					"type": "structure",
					"members": {
						"ApplicationName": {},
						"EnvironmentId": {},
						"EnvironmentName": {},
						"GroupName": {},
						"Description": {},
						"Tier": {
							"shape": "S10"
						},
						"VersionLabel": {},
						"TemplateName": {},
						"SolutionStackName": {},
						"OptionSettings": {
							"shape": "S1n"
						},
						"OptionsToRemove": {
							"shape": "S20"
						}
					}
				},
				"output": {
					"shape": "Sk",
					"resultWrapper": "UpdateEnvironmentResult"
				}
			},
			"ValidateConfigurationSettings": {
				"input": {
					"type": "structure",
					"required": [
						"ApplicationName",
						"OptionSettings"
					],
					"members": {
						"ApplicationName": {},
						"TemplateName": {},
						"EnvironmentName": {},
						"OptionSettings": {
							"shape": "S1n"
						}
					}
				},
				"output": {
					"resultWrapper": "ValidateConfigurationSettingsResult",
					"type": "structure",
					"members": {
						"Messages": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"Message": {},
									"Severity": {},
									"Namespace": {},
									"OptionName": {}
								}
							}
						}
					}
				}
			}
		},
		"shapes": {
			"Si": {
				"type": "structure",
				"members": {
					"Environments": {
						"type": "list",
						"member": {
							"shape": "Sk"
						}
					}
				}
			},
			"Sk": {
				"type": "structure",
				"members": {
					"EnvironmentName": {},
					"EnvironmentId": {},
					"ApplicationName": {},
					"VersionLabel": {},
					"SolutionStackName": {},
					"TemplateName": {},
					"Description": {},
					"EndpointURL": {},
					"CNAME": {},
					"DateCreated": {
						"type": "timestamp"
					},
					"DateUpdated": {
						"type": "timestamp"
					},
					"Status": {},
					"AbortableOperationInProgress": {
						"type": "boolean"
					},
					"Health": {},
					"HealthStatus": {},
					"Resources": {
						"type": "structure",
						"members": {
							"LoadBalancer": {
								"type": "structure",
								"members": {
									"LoadBalancerName": {},
									"Domain": {},
									"Listeners": {
										"type": "list",
										"member": {
											"type": "structure",
											"members": {
												"Protocol": {},
												"Port": {
													"type": "integer"
												}
											}
										}
									}
								}
							}
						}
					},
					"Tier": {
						"shape": "S10"
					},
					"EnvironmentLinks": {
						"type": "list",
						"member": {
							"type": "structure",
							"members": {
								"LinkName": {},
								"EnvironmentName": {}
							}
						}
					}
				}
			},
			"S10": {
				"type": "structure",
				"members": {
					"Name": {},
					"Type": {},
					"Version": {}
				}
			},
			"S14": {
				"type": "structure",
				"members": {
					"Application": {
						"shape": "S15"
					}
				}
			},
			"S15": {
				"type": "structure",
				"members": {
					"ApplicationName": {},
					"Description": {},
					"DateCreated": {
						"type": "timestamp"
					},
					"DateUpdated": {
						"type": "timestamp"
					},
					"Versions": {
						"shape": "S16"
					},
					"ConfigurationTemplates": {
						"type": "list",
						"member": {}
					}
				}
			},
			"S16": {
				"type": "list",
				"member": {}
			},
			"S19": {
				"type": "structure",
				"required": [
					"SourceType",
					"SourceRepository",
					"SourceLocation"
				],
				"members": {
					"SourceType": {},
					"SourceRepository": {},
					"SourceLocation": {}
				}
			},
			"S1d": {
				"type": "structure",
				"members": {
					"S3Bucket": {},
					"S3Key": {}
				}
			},
			"S1i": {
				"type": "structure",
				"members": {
					"ApplicationVersion": {
						"shape": "S1j"
					}
				}
			},
			"S1j": {
				"type": "structure",
				"members": {
					"ApplicationName": {},
					"Description": {},
					"VersionLabel": {},
					"SourceBuildInformation": {
						"shape": "S19"
					},
					"SourceBundle": {
						"shape": "S1d"
					},
					"DateCreated": {
						"type": "timestamp"
					},
					"DateUpdated": {
						"type": "timestamp"
					},
					"Status": {}
				}
			},
			"S1n": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"ResourceName": {},
						"Namespace": {},
						"OptionName": {},
						"Value": {}
					}
				}
			},
			"S1t": {
				"type": "structure",
				"members": {
					"SolutionStackName": {},
					"ApplicationName": {},
					"TemplateName": {},
					"Description": {},
					"EnvironmentName": {},
					"DeploymentStatus": {},
					"DateCreated": {
						"type": "timestamp"
					},
					"DateUpdated": {
						"type": "timestamp"
					},
					"OptionSettings": {
						"shape": "S1n"
					}
				}
			},
			"S20": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"ResourceName": {},
						"Namespace": {},
						"OptionName": {}
					}
				}
			},
			"S35": {
				"type": "list",
				"member": {}
			},
			"S37": {
				"type": "structure",
				"members": {
					"Duration": {
						"type": "integer"
					},
					"RequestCount": {
						"type": "integer"
					},
					"StatusCodes": {
						"type": "structure",
						"members": {
							"Status2xx": {
								"type": "integer"
							},
							"Status3xx": {
								"type": "integer"
							},
							"Status4xx": {
								"type": "integer"
							},
							"Status5xx": {
								"type": "integer"
							}
						}
					},
					"Latency": {
						"type": "structure",
						"members": {
							"P999": {
								"type": "double"
							},
							"P99": {
								"type": "double"
							},
							"P95": {
								"type": "double"
							},
							"P90": {
								"type": "double"
							},
							"P85": {
								"type": "double"
							},
							"P75": {
								"type": "double"
							},
							"P50": {
								"type": "double"
							},
							"P10": {
								"type": "double"
							}
						}
					}
				}
			}
		}
	};

/***/ },
/* 347 */
/***/ function(module, exports) {

	module.exports = {
		"pagination": {
			"DescribeApplicationVersions": {
				"result_key": "ApplicationVersions"
			},
			"DescribeApplications": {
				"result_key": "Applications"
			},
			"DescribeConfigurationOptions": {
				"result_key": "Options"
			},
			"DescribeEnvironments": {
				"result_key": "Environments"
			},
			"DescribeEvents": {
				"input_token": "NextToken",
				"output_token": "NextToken",
				"limit_key": "MaxRecords",
				"result_key": "Events"
			},
			"ListAvailableSolutionStacks": {
				"result_key": "SolutionStacks"
			}
		}
	};

/***/ },
/* 348 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['elb'] = {};
	AWS.ELB = Service.defineService('elb', ['2012-06-01']);
	Object.defineProperty(apiLoader.services['elb'], '2012-06-01', {
	  get: function get() {
	    var model = __webpack_require__(349);
	    model.paginators = __webpack_require__(350).pagination;
	    model.waiters = __webpack_require__(351).waiters;
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.ELB;


/***/ },
/* 349 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2012-06-01",
			"endpointPrefix": "elasticloadbalancing",
			"protocol": "query",
			"serviceFullName": "Elastic Load Balancing",
			"signatureVersion": "v4",
			"xmlNamespace": "http://elasticloadbalancing.amazonaws.com/doc/2012-06-01/"
		},
		"operations": {
			"AddTags": {
				"input": {
					"type": "structure",
					"required": [
						"LoadBalancerNames",
						"Tags"
					],
					"members": {
						"LoadBalancerNames": {
							"shape": "S2"
						},
						"Tags": {
							"shape": "S4"
						}
					}
				},
				"output": {
					"resultWrapper": "AddTagsResult",
					"type": "structure",
					"members": {}
				}
			},
			"ApplySecurityGroupsToLoadBalancer": {
				"input": {
					"type": "structure",
					"required": [
						"LoadBalancerName",
						"SecurityGroups"
					],
					"members": {
						"LoadBalancerName": {},
						"SecurityGroups": {
							"shape": "Sa"
						}
					}
				},
				"output": {
					"resultWrapper": "ApplySecurityGroupsToLoadBalancerResult",
					"type": "structure",
					"members": {
						"SecurityGroups": {
							"shape": "Sa"
						}
					}
				}
			},
			"AttachLoadBalancerToSubnets": {
				"input": {
					"type": "structure",
					"required": [
						"LoadBalancerName",
						"Subnets"
					],
					"members": {
						"LoadBalancerName": {},
						"Subnets": {
							"shape": "Se"
						}
					}
				},
				"output": {
					"resultWrapper": "AttachLoadBalancerToSubnetsResult",
					"type": "structure",
					"members": {
						"Subnets": {
							"shape": "Se"
						}
					}
				}
			},
			"ConfigureHealthCheck": {
				"input": {
					"type": "structure",
					"required": [
						"LoadBalancerName",
						"HealthCheck"
					],
					"members": {
						"LoadBalancerName": {},
						"HealthCheck": {
							"shape": "Si"
						}
					}
				},
				"output": {
					"resultWrapper": "ConfigureHealthCheckResult",
					"type": "structure",
					"members": {
						"HealthCheck": {
							"shape": "Si"
						}
					}
				}
			},
			"CreateAppCookieStickinessPolicy": {
				"input": {
					"type": "structure",
					"required": [
						"LoadBalancerName",
						"PolicyName",
						"CookieName"
					],
					"members": {
						"LoadBalancerName": {},
						"PolicyName": {},
						"CookieName": {}
					}
				},
				"output": {
					"resultWrapper": "CreateAppCookieStickinessPolicyResult",
					"type": "structure",
					"members": {}
				}
			},
			"CreateLBCookieStickinessPolicy": {
				"input": {
					"type": "structure",
					"required": [
						"LoadBalancerName",
						"PolicyName"
					],
					"members": {
						"LoadBalancerName": {},
						"PolicyName": {},
						"CookieExpirationPeriod": {
							"type": "long"
						}
					}
				},
				"output": {
					"resultWrapper": "CreateLBCookieStickinessPolicyResult",
					"type": "structure",
					"members": {}
				}
			},
			"CreateLoadBalancer": {
				"input": {
					"type": "structure",
					"required": [
						"LoadBalancerName",
						"Listeners"
					],
					"members": {
						"LoadBalancerName": {},
						"Listeners": {
							"shape": "Sx"
						},
						"AvailabilityZones": {
							"shape": "S13"
						},
						"Subnets": {
							"shape": "Se"
						},
						"SecurityGroups": {
							"shape": "Sa"
						},
						"Scheme": {},
						"Tags": {
							"shape": "S4"
						}
					}
				},
				"output": {
					"resultWrapper": "CreateLoadBalancerResult",
					"type": "structure",
					"members": {
						"DNSName": {}
					}
				}
			},
			"CreateLoadBalancerListeners": {
				"input": {
					"type": "structure",
					"required": [
						"LoadBalancerName",
						"Listeners"
					],
					"members": {
						"LoadBalancerName": {},
						"Listeners": {
							"shape": "Sx"
						}
					}
				},
				"output": {
					"resultWrapper": "CreateLoadBalancerListenersResult",
					"type": "structure",
					"members": {}
				}
			},
			"CreateLoadBalancerPolicy": {
				"input": {
					"type": "structure",
					"required": [
						"LoadBalancerName",
						"PolicyName",
						"PolicyTypeName"
					],
					"members": {
						"LoadBalancerName": {},
						"PolicyName": {},
						"PolicyTypeName": {},
						"PolicyAttributes": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"AttributeName": {},
									"AttributeValue": {}
								}
							}
						}
					}
				},
				"output": {
					"resultWrapper": "CreateLoadBalancerPolicyResult",
					"type": "structure",
					"members": {}
				}
			},
			"DeleteLoadBalancer": {
				"input": {
					"type": "structure",
					"required": [
						"LoadBalancerName"
					],
					"members": {
						"LoadBalancerName": {}
					}
				},
				"output": {
					"resultWrapper": "DeleteLoadBalancerResult",
					"type": "structure",
					"members": {}
				}
			},
			"DeleteLoadBalancerListeners": {
				"input": {
					"type": "structure",
					"required": [
						"LoadBalancerName",
						"LoadBalancerPorts"
					],
					"members": {
						"LoadBalancerName": {},
						"LoadBalancerPorts": {
							"type": "list",
							"member": {
								"type": "integer"
							}
						}
					}
				},
				"output": {
					"resultWrapper": "DeleteLoadBalancerListenersResult",
					"type": "structure",
					"members": {}
				}
			},
			"DeleteLoadBalancerPolicy": {
				"input": {
					"type": "structure",
					"required": [
						"LoadBalancerName",
						"PolicyName"
					],
					"members": {
						"LoadBalancerName": {},
						"PolicyName": {}
					}
				},
				"output": {
					"resultWrapper": "DeleteLoadBalancerPolicyResult",
					"type": "structure",
					"members": {}
				}
			},
			"DeregisterInstancesFromLoadBalancer": {
				"input": {
					"type": "structure",
					"required": [
						"LoadBalancerName",
						"Instances"
					],
					"members": {
						"LoadBalancerName": {},
						"Instances": {
							"shape": "S1p"
						}
					}
				},
				"output": {
					"resultWrapper": "DeregisterInstancesFromLoadBalancerResult",
					"type": "structure",
					"members": {
						"Instances": {
							"shape": "S1p"
						}
					}
				}
			},
			"DescribeInstanceHealth": {
				"input": {
					"type": "structure",
					"required": [
						"LoadBalancerName"
					],
					"members": {
						"LoadBalancerName": {},
						"Instances": {
							"shape": "S1p"
						}
					}
				},
				"output": {
					"resultWrapper": "DescribeInstanceHealthResult",
					"type": "structure",
					"members": {
						"InstanceStates": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"InstanceId": {},
									"State": {},
									"ReasonCode": {},
									"Description": {}
								}
							}
						}
					}
				}
			},
			"DescribeLoadBalancerAttributes": {
				"input": {
					"type": "structure",
					"required": [
						"LoadBalancerName"
					],
					"members": {
						"LoadBalancerName": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeLoadBalancerAttributesResult",
					"type": "structure",
					"members": {
						"LoadBalancerAttributes": {
							"shape": "S22"
						}
					}
				}
			},
			"DescribeLoadBalancerPolicies": {
				"input": {
					"type": "structure",
					"members": {
						"LoadBalancerName": {},
						"PolicyNames": {
							"shape": "S2k"
						}
					}
				},
				"output": {
					"resultWrapper": "DescribeLoadBalancerPoliciesResult",
					"type": "structure",
					"members": {
						"PolicyDescriptions": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"PolicyName": {},
									"PolicyTypeName": {},
									"PolicyAttributeDescriptions": {
										"type": "list",
										"member": {
											"type": "structure",
											"members": {
												"AttributeName": {},
												"AttributeValue": {}
											}
										}
									}
								}
							}
						}
					}
				}
			},
			"DescribeLoadBalancerPolicyTypes": {
				"input": {
					"type": "structure",
					"members": {
						"PolicyTypeNames": {
							"type": "list",
							"member": {}
						}
					}
				},
				"output": {
					"resultWrapper": "DescribeLoadBalancerPolicyTypesResult",
					"type": "structure",
					"members": {
						"PolicyTypeDescriptions": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"PolicyTypeName": {},
									"Description": {},
									"PolicyAttributeTypeDescriptions": {
										"type": "list",
										"member": {
											"type": "structure",
											"members": {
												"AttributeName": {},
												"AttributeType": {},
												"Description": {},
												"DefaultValue": {},
												"Cardinality": {}
											}
										}
									}
								}
							}
						}
					}
				}
			},
			"DescribeLoadBalancers": {
				"input": {
					"type": "structure",
					"members": {
						"LoadBalancerNames": {
							"shape": "S2"
						},
						"Marker": {},
						"PageSize": {
							"type": "integer"
						}
					}
				},
				"output": {
					"resultWrapper": "DescribeLoadBalancersResult",
					"type": "structure",
					"members": {
						"LoadBalancerDescriptions": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"LoadBalancerName": {},
									"DNSName": {},
									"CanonicalHostedZoneName": {},
									"CanonicalHostedZoneNameID": {},
									"ListenerDescriptions": {
										"type": "list",
										"member": {
											"type": "structure",
											"members": {
												"Listener": {
													"shape": "Sy"
												},
												"PolicyNames": {
													"shape": "S2k"
												}
											}
										}
									},
									"Policies": {
										"type": "structure",
										"members": {
											"AppCookieStickinessPolicies": {
												"type": "list",
												"member": {
													"type": "structure",
													"members": {
														"PolicyName": {},
														"CookieName": {}
													}
												}
											},
											"LBCookieStickinessPolicies": {
												"type": "list",
												"member": {
													"type": "structure",
													"members": {
														"PolicyName": {},
														"CookieExpirationPeriod": {
															"type": "long"
														}
													}
												}
											},
											"OtherPolicies": {
												"shape": "S2k"
											}
										}
									},
									"BackendServerDescriptions": {
										"type": "list",
										"member": {
											"type": "structure",
											"members": {
												"InstancePort": {
													"type": "integer"
												},
												"PolicyNames": {
													"shape": "S2k"
												}
											}
										}
									},
									"AvailabilityZones": {
										"shape": "S13"
									},
									"Subnets": {
										"shape": "Se"
									},
									"VPCId": {},
									"Instances": {
										"shape": "S1p"
									},
									"HealthCheck": {
										"shape": "Si"
									},
									"SourceSecurityGroup": {
										"type": "structure",
										"members": {
											"OwnerAlias": {},
											"GroupName": {}
										}
									},
									"SecurityGroups": {
										"shape": "Sa"
									},
									"CreatedTime": {
										"type": "timestamp"
									},
									"Scheme": {}
								}
							}
						},
						"NextMarker": {}
					}
				}
			},
			"DescribeTags": {
				"input": {
					"type": "structure",
					"required": [
						"LoadBalancerNames"
					],
					"members": {
						"LoadBalancerNames": {
							"type": "list",
							"member": {}
						}
					}
				},
				"output": {
					"resultWrapper": "DescribeTagsResult",
					"type": "structure",
					"members": {
						"TagDescriptions": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"LoadBalancerName": {},
									"Tags": {
										"shape": "S4"
									}
								}
							}
						}
					}
				}
			},
			"DetachLoadBalancerFromSubnets": {
				"input": {
					"type": "structure",
					"required": [
						"LoadBalancerName",
						"Subnets"
					],
					"members": {
						"LoadBalancerName": {},
						"Subnets": {
							"shape": "Se"
						}
					}
				},
				"output": {
					"resultWrapper": "DetachLoadBalancerFromSubnetsResult",
					"type": "structure",
					"members": {
						"Subnets": {
							"shape": "Se"
						}
					}
				}
			},
			"DisableAvailabilityZonesForLoadBalancer": {
				"input": {
					"type": "structure",
					"required": [
						"LoadBalancerName",
						"AvailabilityZones"
					],
					"members": {
						"LoadBalancerName": {},
						"AvailabilityZones": {
							"shape": "S13"
						}
					}
				},
				"output": {
					"resultWrapper": "DisableAvailabilityZonesForLoadBalancerResult",
					"type": "structure",
					"members": {
						"AvailabilityZones": {
							"shape": "S13"
						}
					}
				}
			},
			"EnableAvailabilityZonesForLoadBalancer": {
				"input": {
					"type": "structure",
					"required": [
						"LoadBalancerName",
						"AvailabilityZones"
					],
					"members": {
						"LoadBalancerName": {},
						"AvailabilityZones": {
							"shape": "S13"
						}
					}
				},
				"output": {
					"resultWrapper": "EnableAvailabilityZonesForLoadBalancerResult",
					"type": "structure",
					"members": {
						"AvailabilityZones": {
							"shape": "S13"
						}
					}
				}
			},
			"ModifyLoadBalancerAttributes": {
				"input": {
					"type": "structure",
					"required": [
						"LoadBalancerName",
						"LoadBalancerAttributes"
					],
					"members": {
						"LoadBalancerName": {},
						"LoadBalancerAttributes": {
							"shape": "S22"
						}
					}
				},
				"output": {
					"resultWrapper": "ModifyLoadBalancerAttributesResult",
					"type": "structure",
					"members": {
						"LoadBalancerName": {},
						"LoadBalancerAttributes": {
							"shape": "S22"
						}
					}
				}
			},
			"RegisterInstancesWithLoadBalancer": {
				"input": {
					"type": "structure",
					"required": [
						"LoadBalancerName",
						"Instances"
					],
					"members": {
						"LoadBalancerName": {},
						"Instances": {
							"shape": "S1p"
						}
					}
				},
				"output": {
					"resultWrapper": "RegisterInstancesWithLoadBalancerResult",
					"type": "structure",
					"members": {
						"Instances": {
							"shape": "S1p"
						}
					}
				}
			},
			"RemoveTags": {
				"input": {
					"type": "structure",
					"required": [
						"LoadBalancerNames",
						"Tags"
					],
					"members": {
						"LoadBalancerNames": {
							"shape": "S2"
						},
						"Tags": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"Key": {}
								}
							}
						}
					}
				},
				"output": {
					"resultWrapper": "RemoveTagsResult",
					"type": "structure",
					"members": {}
				}
			},
			"SetLoadBalancerListenerSSLCertificate": {
				"input": {
					"type": "structure",
					"required": [
						"LoadBalancerName",
						"LoadBalancerPort",
						"SSLCertificateId"
					],
					"members": {
						"LoadBalancerName": {},
						"LoadBalancerPort": {
							"type": "integer"
						},
						"SSLCertificateId": {}
					}
				},
				"output": {
					"resultWrapper": "SetLoadBalancerListenerSSLCertificateResult",
					"type": "structure",
					"members": {}
				}
			},
			"SetLoadBalancerPoliciesForBackendServer": {
				"input": {
					"type": "structure",
					"required": [
						"LoadBalancerName",
						"InstancePort",
						"PolicyNames"
					],
					"members": {
						"LoadBalancerName": {},
						"InstancePort": {
							"type": "integer"
						},
						"PolicyNames": {
							"shape": "S2k"
						}
					}
				},
				"output": {
					"resultWrapper": "SetLoadBalancerPoliciesForBackendServerResult",
					"type": "structure",
					"members": {}
				}
			},
			"SetLoadBalancerPoliciesOfListener": {
				"input": {
					"type": "structure",
					"required": [
						"LoadBalancerName",
						"LoadBalancerPort",
						"PolicyNames"
					],
					"members": {
						"LoadBalancerName": {},
						"LoadBalancerPort": {
							"type": "integer"
						},
						"PolicyNames": {
							"shape": "S2k"
						}
					}
				},
				"output": {
					"resultWrapper": "SetLoadBalancerPoliciesOfListenerResult",
					"type": "structure",
					"members": {}
				}
			}
		},
		"shapes": {
			"S2": {
				"type": "list",
				"member": {}
			},
			"S4": {
				"type": "list",
				"member": {
					"type": "structure",
					"required": [
						"Key"
					],
					"members": {
						"Key": {},
						"Value": {}
					}
				}
			},
			"Sa": {
				"type": "list",
				"member": {}
			},
			"Se": {
				"type": "list",
				"member": {}
			},
			"Si": {
				"type": "structure",
				"required": [
					"Target",
					"Interval",
					"Timeout",
					"UnhealthyThreshold",
					"HealthyThreshold"
				],
				"members": {
					"Target": {},
					"Interval": {
						"type": "integer"
					},
					"Timeout": {
						"type": "integer"
					},
					"UnhealthyThreshold": {
						"type": "integer"
					},
					"HealthyThreshold": {
						"type": "integer"
					}
				}
			},
			"Sx": {
				"type": "list",
				"member": {
					"shape": "Sy"
				}
			},
			"Sy": {
				"type": "structure",
				"required": [
					"Protocol",
					"LoadBalancerPort",
					"InstancePort"
				],
				"members": {
					"Protocol": {},
					"LoadBalancerPort": {
						"type": "integer"
					},
					"InstanceProtocol": {},
					"InstancePort": {
						"type": "integer"
					},
					"SSLCertificateId": {}
				}
			},
			"S13": {
				"type": "list",
				"member": {}
			},
			"S1p": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"InstanceId": {}
					}
				}
			},
			"S22": {
				"type": "structure",
				"members": {
					"CrossZoneLoadBalancing": {
						"type": "structure",
						"required": [
							"Enabled"
						],
						"members": {
							"Enabled": {
								"type": "boolean"
							}
						}
					},
					"AccessLog": {
						"type": "structure",
						"required": [
							"Enabled"
						],
						"members": {
							"Enabled": {
								"type": "boolean"
							},
							"S3BucketName": {},
							"EmitInterval": {
								"type": "integer"
							},
							"S3BucketPrefix": {}
						}
					},
					"ConnectionDraining": {
						"type": "structure",
						"required": [
							"Enabled"
						],
						"members": {
							"Enabled": {
								"type": "boolean"
							},
							"Timeout": {
								"type": "integer"
							}
						}
					},
					"ConnectionSettings": {
						"type": "structure",
						"required": [
							"IdleTimeout"
						],
						"members": {
							"IdleTimeout": {
								"type": "integer"
							}
						}
					},
					"AdditionalAttributes": {
						"type": "list",
						"member": {
							"type": "structure",
							"members": {
								"Key": {},
								"Value": {}
							}
						}
					}
				}
			},
			"S2k": {
				"type": "list",
				"member": {}
			}
		}
	};

/***/ },
/* 350 */
/***/ function(module, exports) {

	module.exports = {
		"pagination": {
			"DescribeInstanceHealth": {
				"result_key": "InstanceStates"
			},
			"DescribeLoadBalancerPolicies": {
				"result_key": "PolicyDescriptions"
			},
			"DescribeLoadBalancerPolicyTypes": {
				"result_key": "PolicyTypeDescriptions"
			},
			"DescribeLoadBalancers": {
				"input_token": "Marker",
				"output_token": "NextMarker",
				"result_key": "LoadBalancerDescriptions"
			}
		}
	};

/***/ },
/* 351 */
/***/ function(module, exports) {

	module.exports = {
		"version": 2,
		"waiters": {
			"InstanceDeregistered": {
				"delay": 15,
				"operation": "DescribeInstanceHealth",
				"maxAttempts": 40,
				"acceptors": [
					{
						"expected": "OutOfService",
						"matcher": "pathAll",
						"state": "success",
						"argument": "InstanceStates[].State"
					},
					{
						"matcher": "error",
						"expected": "InvalidInstance",
						"state": "success"
					}
				]
			},
			"AnyInstanceInService": {
				"acceptors": [
					{
						"argument": "InstanceStates[].State",
						"expected": "InService",
						"matcher": "pathAny",
						"state": "success"
					}
				],
				"delay": 15,
				"maxAttempts": 40,
				"operation": "DescribeInstanceHealth"
			},
			"InstanceInService": {
				"acceptors": [
					{
						"argument": "InstanceStates[].State",
						"expected": "InService",
						"matcher": "pathAll",
						"state": "success"
					}
				],
				"delay": 15,
				"maxAttempts": 40,
				"operation": "DescribeInstanceHealth"
			}
		}
	};

/***/ },
/* 352 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['elbv2'] = {};
	AWS.ELBv2 = Service.defineService('elbv2', ['2015-12-01']);
	Object.defineProperty(apiLoader.services['elbv2'], '2015-12-01', {
	  get: function get() {
	    var model = __webpack_require__(353);
	    model.paginators = __webpack_require__(354).pagination;
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.ELBv2;


/***/ },
/* 353 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2015-12-01",
			"endpointPrefix": "elasticloadbalancing",
			"protocol": "query",
			"serviceAbbreviation": "Elastic Load Balancing v2",
			"serviceFullName": "Elastic Load Balancing",
			"signatureVersion": "v4",
			"xmlNamespace": "http://elasticloadbalancing.amazonaws.com/doc/2015-12-01/"
		},
		"operations": {
			"AddTags": {
				"input": {
					"type": "structure",
					"required": [
						"ResourceArns",
						"Tags"
					],
					"members": {
						"ResourceArns": {
							"shape": "S2"
						},
						"Tags": {
							"shape": "S4"
						}
					}
				},
				"output": {
					"resultWrapper": "AddTagsResult",
					"type": "structure",
					"members": {}
				}
			},
			"CreateListener": {
				"input": {
					"type": "structure",
					"required": [
						"LoadBalancerArn",
						"Protocol",
						"Port",
						"DefaultActions"
					],
					"members": {
						"LoadBalancerArn": {},
						"Protocol": {},
						"Port": {
							"type": "integer"
						},
						"SslPolicy": {},
						"Certificates": {
							"shape": "Se"
						},
						"DefaultActions": {
							"shape": "Sh"
						}
					}
				},
				"output": {
					"resultWrapper": "CreateListenerResult",
					"type": "structure",
					"members": {
						"Listeners": {
							"shape": "Sm"
						}
					}
				}
			},
			"CreateLoadBalancer": {
				"input": {
					"type": "structure",
					"required": [
						"Name",
						"Subnets"
					],
					"members": {
						"Name": {},
						"Subnets": {
							"shape": "Sr"
						},
						"SecurityGroups": {
							"shape": "St"
						},
						"Scheme": {},
						"Tags": {
							"shape": "S4"
						}
					}
				},
				"output": {
					"resultWrapper": "CreateLoadBalancerResult",
					"type": "structure",
					"members": {
						"LoadBalancers": {
							"shape": "Sx"
						}
					}
				}
			},
			"CreateRule": {
				"input": {
					"type": "structure",
					"required": [
						"ListenerArn",
						"Conditions",
						"Priority",
						"Actions"
					],
					"members": {
						"ListenerArn": {},
						"Conditions": {
							"shape": "S1b"
						},
						"Priority": {
							"type": "integer"
						},
						"Actions": {
							"shape": "Sh"
						}
					}
				},
				"output": {
					"resultWrapper": "CreateRuleResult",
					"type": "structure",
					"members": {
						"Rules": {
							"shape": "S1i"
						}
					}
				}
			},
			"CreateTargetGroup": {
				"input": {
					"type": "structure",
					"required": [
						"Name",
						"Protocol",
						"Port",
						"VpcId"
					],
					"members": {
						"Name": {},
						"Protocol": {},
						"Port": {
							"type": "integer"
						},
						"VpcId": {},
						"HealthCheckProtocol": {},
						"HealthCheckPort": {},
						"HealthCheckPath": {},
						"HealthCheckIntervalSeconds": {
							"type": "integer"
						},
						"HealthCheckTimeoutSeconds": {
							"type": "integer"
						},
						"HealthyThresholdCount": {
							"type": "integer"
						},
						"UnhealthyThresholdCount": {
							"type": "integer"
						},
						"Matcher": {
							"shape": "S1u"
						}
					}
				},
				"output": {
					"resultWrapper": "CreateTargetGroupResult",
					"type": "structure",
					"members": {
						"TargetGroups": {
							"shape": "S1x"
						}
					}
				}
			},
			"DeleteListener": {
				"input": {
					"type": "structure",
					"required": [
						"ListenerArn"
					],
					"members": {
						"ListenerArn": {}
					}
				},
				"output": {
					"resultWrapper": "DeleteListenerResult",
					"type": "structure",
					"members": {}
				}
			},
			"DeleteLoadBalancer": {
				"input": {
					"type": "structure",
					"required": [
						"LoadBalancerArn"
					],
					"members": {
						"LoadBalancerArn": {}
					}
				},
				"output": {
					"resultWrapper": "DeleteLoadBalancerResult",
					"type": "structure",
					"members": {}
				}
			},
			"DeleteRule": {
				"input": {
					"type": "structure",
					"required": [
						"RuleArn"
					],
					"members": {
						"RuleArn": {}
					}
				},
				"output": {
					"resultWrapper": "DeleteRuleResult",
					"type": "structure",
					"members": {}
				}
			},
			"DeleteTargetGroup": {
				"input": {
					"type": "structure",
					"required": [
						"TargetGroupArn"
					],
					"members": {
						"TargetGroupArn": {}
					}
				},
				"output": {
					"resultWrapper": "DeleteTargetGroupResult",
					"type": "structure",
					"members": {}
				}
			},
			"DeregisterTargets": {
				"input": {
					"type": "structure",
					"required": [
						"TargetGroupArn",
						"Targets"
					],
					"members": {
						"TargetGroupArn": {},
						"Targets": {
							"shape": "S29"
						}
					}
				},
				"output": {
					"resultWrapper": "DeregisterTargetsResult",
					"type": "structure",
					"members": {}
				}
			},
			"DescribeListeners": {
				"input": {
					"type": "structure",
					"members": {
						"LoadBalancerArn": {},
						"ListenerArns": {
							"type": "list",
							"member": {}
						},
						"Marker": {},
						"PageSize": {
							"type": "integer"
						}
					}
				},
				"output": {
					"resultWrapper": "DescribeListenersResult",
					"type": "structure",
					"members": {
						"Listeners": {
							"shape": "Sm"
						},
						"NextMarker": {}
					}
				}
			},
			"DescribeLoadBalancerAttributes": {
				"input": {
					"type": "structure",
					"required": [
						"LoadBalancerArn"
					],
					"members": {
						"LoadBalancerArn": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeLoadBalancerAttributesResult",
					"type": "structure",
					"members": {
						"Attributes": {
							"shape": "S2k"
						}
					}
				}
			},
			"DescribeLoadBalancers": {
				"input": {
					"type": "structure",
					"members": {
						"LoadBalancerArns": {
							"shape": "S1z"
						},
						"Names": {
							"type": "list",
							"member": {}
						},
						"Marker": {},
						"PageSize": {
							"type": "integer"
						}
					}
				},
				"output": {
					"resultWrapper": "DescribeLoadBalancersResult",
					"type": "structure",
					"members": {
						"LoadBalancers": {
							"shape": "Sx"
						},
						"NextMarker": {}
					}
				}
			},
			"DescribeRules": {
				"input": {
					"type": "structure",
					"members": {
						"ListenerArn": {},
						"RuleArns": {
							"type": "list",
							"member": {}
						}
					}
				},
				"output": {
					"resultWrapper": "DescribeRulesResult",
					"type": "structure",
					"members": {
						"Rules": {
							"shape": "S1i"
						}
					}
				}
			},
			"DescribeSSLPolicies": {
				"input": {
					"type": "structure",
					"members": {
						"Names": {
							"type": "list",
							"member": {}
						},
						"Marker": {},
						"PageSize": {
							"type": "integer"
						}
					}
				},
				"output": {
					"resultWrapper": "DescribeSSLPoliciesResult",
					"type": "structure",
					"members": {
						"SslPolicies": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"SslProtocols": {
										"type": "list",
										"member": {}
									},
									"Ciphers": {
										"type": "list",
										"member": {
											"type": "structure",
											"members": {
												"Name": {},
												"Priority": {
													"type": "integer"
												}
											}
										}
									},
									"Name": {}
								}
							}
						},
						"NextMarker": {}
					}
				}
			},
			"DescribeTags": {
				"input": {
					"type": "structure",
					"required": [
						"ResourceArns"
					],
					"members": {
						"ResourceArns": {
							"shape": "S2"
						}
					}
				},
				"output": {
					"resultWrapper": "DescribeTagsResult",
					"type": "structure",
					"members": {
						"TagDescriptions": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"ResourceArn": {},
									"Tags": {
										"shape": "S4"
									}
								}
							}
						}
					}
				}
			},
			"DescribeTargetGroupAttributes": {
				"input": {
					"type": "structure",
					"required": [
						"TargetGroupArn"
					],
					"members": {
						"TargetGroupArn": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeTargetGroupAttributesResult",
					"type": "structure",
					"members": {
						"Attributes": {
							"shape": "S3b"
						}
					}
				}
			},
			"DescribeTargetGroups": {
				"input": {
					"type": "structure",
					"members": {
						"LoadBalancerArn": {},
						"TargetGroupArns": {
							"type": "list",
							"member": {}
						},
						"Names": {
							"type": "list",
							"member": {}
						},
						"Marker": {},
						"PageSize": {
							"type": "integer"
						}
					}
				},
				"output": {
					"resultWrapper": "DescribeTargetGroupsResult",
					"type": "structure",
					"members": {
						"TargetGroups": {
							"shape": "S1x"
						},
						"NextMarker": {}
					}
				}
			},
			"DescribeTargetHealth": {
				"input": {
					"type": "structure",
					"required": [
						"TargetGroupArn"
					],
					"members": {
						"TargetGroupArn": {},
						"Targets": {
							"shape": "S29"
						}
					}
				},
				"output": {
					"resultWrapper": "DescribeTargetHealthResult",
					"type": "structure",
					"members": {
						"TargetHealthDescriptions": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"Target": {
										"shape": "S2a"
									},
									"HealthCheckPort": {},
									"TargetHealth": {
										"type": "structure",
										"members": {
											"State": {},
											"Reason": {},
											"Description": {}
										}
									}
								}
							}
						}
					}
				}
			},
			"ModifyListener": {
				"input": {
					"type": "structure",
					"required": [
						"ListenerArn"
					],
					"members": {
						"ListenerArn": {},
						"Port": {
							"type": "integer"
						},
						"Protocol": {},
						"SslPolicy": {},
						"Certificates": {
							"shape": "Se"
						},
						"DefaultActions": {
							"shape": "Sh"
						}
					}
				},
				"output": {
					"resultWrapper": "ModifyListenerResult",
					"type": "structure",
					"members": {
						"Listeners": {
							"shape": "Sm"
						}
					}
				}
			},
			"ModifyLoadBalancerAttributes": {
				"input": {
					"type": "structure",
					"required": [
						"LoadBalancerArn",
						"Attributes"
					],
					"members": {
						"LoadBalancerArn": {},
						"Attributes": {
							"shape": "S2k"
						}
					}
				},
				"output": {
					"resultWrapper": "ModifyLoadBalancerAttributesResult",
					"type": "structure",
					"members": {
						"Attributes": {
							"shape": "S2k"
						}
					}
				}
			},
			"ModifyRule": {
				"input": {
					"type": "structure",
					"required": [
						"RuleArn"
					],
					"members": {
						"RuleArn": {},
						"Conditions": {
							"shape": "S1b"
						},
						"Actions": {
							"shape": "Sh"
						}
					}
				},
				"output": {
					"resultWrapper": "ModifyRuleResult",
					"type": "structure",
					"members": {
						"Rules": {
							"shape": "S1i"
						}
					}
				}
			},
			"ModifyTargetGroup": {
				"input": {
					"type": "structure",
					"required": [
						"TargetGroupArn"
					],
					"members": {
						"TargetGroupArn": {},
						"HealthCheckProtocol": {},
						"HealthCheckPort": {},
						"HealthCheckPath": {},
						"HealthCheckIntervalSeconds": {
							"type": "integer"
						},
						"HealthCheckTimeoutSeconds": {
							"type": "integer"
						},
						"HealthyThresholdCount": {
							"type": "integer"
						},
						"UnhealthyThresholdCount": {
							"type": "integer"
						},
						"Matcher": {
							"shape": "S1u"
						}
					}
				},
				"output": {
					"resultWrapper": "ModifyTargetGroupResult",
					"type": "structure",
					"members": {
						"TargetGroups": {
							"shape": "S1x"
						}
					}
				}
			},
			"ModifyTargetGroupAttributes": {
				"input": {
					"type": "structure",
					"required": [
						"TargetGroupArn",
						"Attributes"
					],
					"members": {
						"TargetGroupArn": {},
						"Attributes": {
							"shape": "S3b"
						}
					}
				},
				"output": {
					"resultWrapper": "ModifyTargetGroupAttributesResult",
					"type": "structure",
					"members": {
						"Attributes": {
							"shape": "S3b"
						}
					}
				}
			},
			"RegisterTargets": {
				"input": {
					"type": "structure",
					"required": [
						"TargetGroupArn",
						"Targets"
					],
					"members": {
						"TargetGroupArn": {},
						"Targets": {
							"shape": "S29"
						}
					}
				},
				"output": {
					"resultWrapper": "RegisterTargetsResult",
					"type": "structure",
					"members": {}
				}
			},
			"RemoveTags": {
				"input": {
					"type": "structure",
					"required": [
						"ResourceArns",
						"TagKeys"
					],
					"members": {
						"ResourceArns": {
							"shape": "S2"
						},
						"TagKeys": {
							"type": "list",
							"member": {}
						}
					}
				},
				"output": {
					"resultWrapper": "RemoveTagsResult",
					"type": "structure",
					"members": {}
				}
			},
			"SetRulePriorities": {
				"input": {
					"type": "structure",
					"required": [
						"RulePriorities"
					],
					"members": {
						"RulePriorities": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"RuleArn": {},
									"Priority": {
										"type": "integer"
									}
								}
							}
						}
					}
				},
				"output": {
					"resultWrapper": "SetRulePrioritiesResult",
					"type": "structure",
					"members": {
						"Rules": {
							"shape": "S1i"
						}
					}
				}
			},
			"SetSecurityGroups": {
				"input": {
					"type": "structure",
					"required": [
						"LoadBalancerArn",
						"SecurityGroups"
					],
					"members": {
						"LoadBalancerArn": {},
						"SecurityGroups": {
							"shape": "St"
						}
					}
				},
				"output": {
					"resultWrapper": "SetSecurityGroupsResult",
					"type": "structure",
					"members": {
						"SecurityGroupIds": {
							"shape": "St"
						}
					}
				}
			},
			"SetSubnets": {
				"input": {
					"type": "structure",
					"required": [
						"LoadBalancerArn",
						"Subnets"
					],
					"members": {
						"LoadBalancerArn": {},
						"Subnets": {
							"shape": "Sr"
						}
					}
				},
				"output": {
					"resultWrapper": "SetSubnetsResult",
					"type": "structure",
					"members": {
						"AvailabilityZones": {
							"shape": "S17"
						}
					}
				}
			}
		},
		"shapes": {
			"S2": {
				"type": "list",
				"member": {}
			},
			"S4": {
				"type": "list",
				"member": {
					"type": "structure",
					"required": [
						"Key"
					],
					"members": {
						"Key": {},
						"Value": {}
					}
				}
			},
			"Se": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"CertificateArn": {}
					}
				}
			},
			"Sh": {
				"type": "list",
				"member": {
					"type": "structure",
					"required": [
						"Type",
						"TargetGroupArn"
					],
					"members": {
						"Type": {},
						"TargetGroupArn": {}
					}
				}
			},
			"Sm": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"ListenerArn": {},
						"LoadBalancerArn": {},
						"Port": {
							"type": "integer"
						},
						"Protocol": {},
						"Certificates": {
							"shape": "Se"
						},
						"SslPolicy": {},
						"DefaultActions": {
							"shape": "Sh"
						}
					}
				}
			},
			"Sr": {
				"type": "list",
				"member": {}
			},
			"St": {
				"type": "list",
				"member": {}
			},
			"Sx": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"LoadBalancerArn": {},
						"DNSName": {},
						"CanonicalHostedZoneId": {},
						"CreatedTime": {
							"type": "timestamp"
						},
						"LoadBalancerName": {},
						"Scheme": {},
						"VpcId": {},
						"State": {
							"type": "structure",
							"members": {
								"Code": {},
								"Reason": {}
							}
						},
						"Type": {},
						"AvailabilityZones": {
							"shape": "S17"
						},
						"SecurityGroups": {
							"shape": "St"
						}
					}
				}
			},
			"S17": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"ZoneName": {},
						"SubnetId": {}
					}
				}
			},
			"S1b": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"Field": {},
						"Values": {
							"type": "list",
							"member": {}
						}
					}
				}
			},
			"S1i": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"RuleArn": {},
						"Priority": {},
						"Conditions": {
							"shape": "S1b"
						},
						"Actions": {
							"shape": "Sh"
						},
						"IsDefault": {
							"type": "boolean"
						}
					}
				}
			},
			"S1u": {
				"type": "structure",
				"required": [
					"HttpCode"
				],
				"members": {
					"HttpCode": {}
				}
			},
			"S1x": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"TargetGroupArn": {},
						"TargetGroupName": {},
						"Protocol": {},
						"Port": {
							"type": "integer"
						},
						"VpcId": {},
						"HealthCheckProtocol": {},
						"HealthCheckPort": {},
						"HealthCheckIntervalSeconds": {
							"type": "integer"
						},
						"HealthCheckTimeoutSeconds": {
							"type": "integer"
						},
						"HealthyThresholdCount": {
							"type": "integer"
						},
						"UnhealthyThresholdCount": {
							"type": "integer"
						},
						"HealthCheckPath": {},
						"Matcher": {
							"shape": "S1u"
						},
						"LoadBalancerArns": {
							"shape": "S1z"
						}
					}
				}
			},
			"S1z": {
				"type": "list",
				"member": {}
			},
			"S29": {
				"type": "list",
				"member": {
					"shape": "S2a"
				}
			},
			"S2a": {
				"type": "structure",
				"required": [
					"Id"
				],
				"members": {
					"Id": {},
					"Port": {
						"type": "integer"
					}
				}
			},
			"S2k": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"Key": {},
						"Value": {}
					}
				}
			},
			"S3b": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"Key": {},
						"Value": {}
					}
				}
			}
		}
	};

/***/ },
/* 354 */
/***/ function(module, exports) {

	module.exports = {
		"pagination": {
			"DescribeTargetGroups": {
				"input_token": "Marker",
				"output_token": "NextMarker",
				"result_key": "TargetGroups"
			},
			"DescribeListeners": {
				"input_token": "Marker",
				"output_token": "NextMarker",
				"result_key": "Listeners"
			},
			"DescribeLoadBalancers": {
				"input_token": "Marker",
				"output_token": "NextMarker",
				"result_key": "LoadBalancers"
			}
		}
	};

/***/ },
/* 355 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['emr'] = {};
	AWS.EMR = Service.defineService('emr', ['2009-03-31']);
	Object.defineProperty(apiLoader.services['emr'], '2009-03-31', {
	  get: function get() {
	    var model = __webpack_require__(356);
	    model.paginators = __webpack_require__(357).pagination;
	    model.waiters = __webpack_require__(358).waiters;
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.EMR;


/***/ },
/* 356 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2009-03-31",
			"endpointPrefix": "elasticmapreduce",
			"jsonVersion": "1.1",
			"protocol": "json",
			"serviceAbbreviation": "Amazon EMR",
			"serviceFullName": "Amazon Elastic MapReduce",
			"signatureVersion": "v4",
			"targetPrefix": "ElasticMapReduce",
			"timestampFormat": "unixTimestamp"
		},
		"operations": {
			"AddInstanceGroups": {
				"input": {
					"type": "structure",
					"required": [
						"InstanceGroups",
						"JobFlowId"
					],
					"members": {
						"InstanceGroups": {
							"shape": "S2"
						},
						"JobFlowId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"JobFlowId": {},
						"InstanceGroupIds": {
							"type": "list",
							"member": {}
						}
					}
				}
			},
			"AddJobFlowSteps": {
				"input": {
					"type": "structure",
					"required": [
						"JobFlowId",
						"Steps"
					],
					"members": {
						"JobFlowId": {},
						"Steps": {
							"shape": "Sl"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"StepIds": {
							"type": "list",
							"member": {}
						}
					}
				}
			},
			"AddTags": {
				"input": {
					"type": "structure",
					"required": [
						"ResourceId",
						"Tags"
					],
					"members": {
						"ResourceId": {},
						"Tags": {
							"shape": "Sx"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"CreateSecurityConfiguration": {
				"input": {
					"type": "structure",
					"required": [
						"Name",
						"SecurityConfiguration"
					],
					"members": {
						"Name": {},
						"SecurityConfiguration": {}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"Name",
						"CreationDateTime"
					],
					"members": {
						"Name": {},
						"CreationDateTime": {
							"type": "timestamp"
						}
					}
				}
			},
			"DeleteSecurityConfiguration": {
				"input": {
					"type": "structure",
					"required": [
						"Name"
					],
					"members": {
						"Name": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"DescribeCluster": {
				"input": {
					"type": "structure",
					"required": [
						"ClusterId"
					],
					"members": {
						"ClusterId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Cluster": {
							"type": "structure",
							"members": {
								"Id": {},
								"Name": {},
								"Status": {
									"shape": "S19"
								},
								"Ec2InstanceAttributes": {
									"type": "structure",
									"members": {
										"Ec2KeyName": {},
										"Ec2SubnetId": {},
										"Ec2AvailabilityZone": {},
										"IamInstanceProfile": {},
										"EmrManagedMasterSecurityGroup": {},
										"EmrManagedSlaveSecurityGroup": {},
										"ServiceAccessSecurityGroup": {},
										"AdditionalMasterSecurityGroups": {
											"shape": "S1f"
										},
										"AdditionalSlaveSecurityGroups": {
											"shape": "S1f"
										}
									}
								},
								"LogUri": {},
								"RequestedAmiVersion": {},
								"RunningAmiVersion": {},
								"ReleaseLabel": {},
								"AutoTerminate": {
									"type": "boolean"
								},
								"TerminationProtected": {
									"type": "boolean"
								},
								"VisibleToAllUsers": {
									"type": "boolean"
								},
								"Applications": {
									"shape": "S1h"
								},
								"Tags": {
									"shape": "Sx"
								},
								"ServiceRole": {},
								"NormalizedInstanceHours": {
									"type": "integer"
								},
								"MasterPublicDnsName": {},
								"Configurations": {
									"shape": "S9"
								},
								"SecurityConfiguration": {}
							}
						}
					}
				}
			},
			"DescribeJobFlows": {
				"input": {
					"type": "structure",
					"members": {
						"CreatedAfter": {
							"type": "timestamp"
						},
						"CreatedBefore": {
							"type": "timestamp"
						},
						"JobFlowIds": {
							"shape": "Ss"
						},
						"JobFlowStates": {
							"type": "list",
							"member": {}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"JobFlows": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"JobFlowId",
									"Name",
									"ExecutionStatusDetail",
									"Instances"
								],
								"members": {
									"JobFlowId": {},
									"Name": {},
									"LogUri": {},
									"AmiVersion": {},
									"ExecutionStatusDetail": {
										"type": "structure",
										"required": [
											"State",
											"CreationDateTime"
										],
										"members": {
											"State": {},
											"CreationDateTime": {
												"type": "timestamp"
											},
											"StartDateTime": {
												"type": "timestamp"
											},
											"ReadyDateTime": {
												"type": "timestamp"
											},
											"EndDateTime": {
												"type": "timestamp"
											},
											"LastStateChangeReason": {}
										}
									},
									"Instances": {
										"type": "structure",
										"required": [
											"MasterInstanceType",
											"SlaveInstanceType",
											"InstanceCount"
										],
										"members": {
											"MasterInstanceType": {},
											"MasterPublicDnsName": {},
											"MasterInstanceId": {},
											"SlaveInstanceType": {},
											"InstanceCount": {
												"type": "integer"
											},
											"InstanceGroups": {
												"type": "list",
												"member": {
													"type": "structure",
													"required": [
														"Market",
														"InstanceRole",
														"InstanceType",
														"InstanceRequestCount",
														"InstanceRunningCount",
														"State",
														"CreationDateTime"
													],
													"members": {
														"InstanceGroupId": {},
														"Name": {},
														"Market": {},
														"InstanceRole": {},
														"BidPrice": {},
														"InstanceType": {},
														"InstanceRequestCount": {
															"type": "integer"
														},
														"InstanceRunningCount": {
															"type": "integer"
														},
														"State": {},
														"LastStateChangeReason": {},
														"CreationDateTime": {
															"type": "timestamp"
														},
														"StartDateTime": {
															"type": "timestamp"
														},
														"ReadyDateTime": {
															"type": "timestamp"
														},
														"EndDateTime": {
															"type": "timestamp"
														}
													}
												}
											},
											"NormalizedInstanceHours": {
												"type": "integer"
											},
											"Ec2KeyName": {},
											"Ec2SubnetId": {},
											"Placement": {
												"shape": "S1u"
											},
											"KeepJobFlowAliveWhenNoSteps": {
												"type": "boolean"
											},
											"TerminationProtected": {
												"type": "boolean"
											},
											"HadoopVersion": {}
										}
									},
									"Steps": {
										"type": "list",
										"member": {
											"type": "structure",
											"required": [
												"StepConfig",
												"ExecutionStatusDetail"
											],
											"members": {
												"StepConfig": {
													"shape": "Sm"
												},
												"ExecutionStatusDetail": {
													"type": "structure",
													"required": [
														"State",
														"CreationDateTime"
													],
													"members": {
														"State": {},
														"CreationDateTime": {
															"type": "timestamp"
														},
														"StartDateTime": {
															"type": "timestamp"
														},
														"EndDateTime": {
															"type": "timestamp"
														},
														"LastStateChangeReason": {}
													}
												}
											}
										}
									},
									"BootstrapActions": {
										"type": "list",
										"member": {
											"type": "structure",
											"members": {
												"BootstrapActionConfig": {
													"shape": "S21"
												}
											}
										}
									},
									"SupportedProducts": {
										"shape": "S23"
									},
									"VisibleToAllUsers": {
										"type": "boolean"
									},
									"JobFlowRole": {},
									"ServiceRole": {}
								}
							}
						}
					}
				},
				"deprecated": true
			},
			"DescribeSecurityConfiguration": {
				"input": {
					"type": "structure",
					"required": [
						"Name"
					],
					"members": {
						"Name": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Name": {},
						"SecurityConfiguration": {},
						"CreationDateTime": {
							"type": "timestamp"
						}
					}
				}
			},
			"DescribeStep": {
				"input": {
					"type": "structure",
					"required": [
						"ClusterId",
						"StepId"
					],
					"members": {
						"ClusterId": {},
						"StepId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Step": {
							"type": "structure",
							"members": {
								"Id": {},
								"Name": {},
								"Config": {
									"shape": "S2a"
								},
								"ActionOnFailure": {},
								"Status": {
									"shape": "S2b"
								}
							}
						}
					}
				}
			},
			"ListBootstrapActions": {
				"input": {
					"type": "structure",
					"required": [
						"ClusterId"
					],
					"members": {
						"ClusterId": {},
						"Marker": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"BootstrapActions": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"Name": {},
									"ScriptPath": {},
									"Args": {
										"shape": "S1f"
									}
								}
							}
						},
						"Marker": {}
					}
				}
			},
			"ListClusters": {
				"input": {
					"type": "structure",
					"members": {
						"CreatedAfter": {
							"type": "timestamp"
						},
						"CreatedBefore": {
							"type": "timestamp"
						},
						"ClusterStates": {
							"type": "list",
							"member": {}
						},
						"Marker": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Clusters": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"Id": {},
									"Name": {},
									"Status": {
										"shape": "S19"
									},
									"NormalizedInstanceHours": {
										"type": "integer"
									}
								}
							}
						},
						"Marker": {}
					}
				}
			},
			"ListInstanceGroups": {
				"input": {
					"type": "structure",
					"required": [
						"ClusterId"
					],
					"members": {
						"ClusterId": {},
						"Marker": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"InstanceGroups": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"Id": {},
									"Name": {},
									"Market": {},
									"InstanceGroupType": {},
									"BidPrice": {},
									"InstanceType": {},
									"RequestedInstanceCount": {
										"type": "integer"
									},
									"RunningInstanceCount": {
										"type": "integer"
									},
									"Status": {
										"type": "structure",
										"members": {
											"State": {},
											"StateChangeReason": {
												"type": "structure",
												"members": {
													"Code": {},
													"Message": {}
												}
											},
											"Timeline": {
												"type": "structure",
												"members": {
													"CreationDateTime": {
														"type": "timestamp"
													},
													"ReadyDateTime": {
														"type": "timestamp"
													},
													"EndDateTime": {
														"type": "timestamp"
													}
												}
											}
										}
									},
									"Configurations": {
										"shape": "S9"
									},
									"EbsBlockDevices": {
										"type": "list",
										"member": {
											"type": "structure",
											"members": {
												"VolumeSpecification": {
													"shape": "Sg"
												},
												"Device": {}
											}
										}
									},
									"EbsOptimized": {
										"type": "boolean"
									},
									"ShrinkPolicy": {
										"shape": "S33"
									}
								}
							}
						},
						"Marker": {}
					}
				}
			},
			"ListInstances": {
				"input": {
					"type": "structure",
					"required": [
						"ClusterId"
					],
					"members": {
						"ClusterId": {},
						"InstanceGroupId": {},
						"InstanceGroupTypes": {
							"type": "list",
							"member": {}
						},
						"InstanceStates": {
							"type": "list",
							"member": {}
						},
						"Marker": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Instances": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"Id": {},
									"Ec2InstanceId": {},
									"PublicDnsName": {},
									"PublicIpAddress": {},
									"PrivateDnsName": {},
									"PrivateIpAddress": {},
									"Status": {
										"type": "structure",
										"members": {
											"State": {},
											"StateChangeReason": {
												"type": "structure",
												"members": {
													"Code": {},
													"Message": {}
												}
											},
											"Timeline": {
												"type": "structure",
												"members": {
													"CreationDateTime": {
														"type": "timestamp"
													},
													"ReadyDateTime": {
														"type": "timestamp"
													},
													"EndDateTime": {
														"type": "timestamp"
													}
												}
											}
										}
									},
									"InstanceGroupId": {},
									"EbsVolumes": {
										"type": "list",
										"member": {
											"type": "structure",
											"members": {
												"Device": {},
												"VolumeId": {}
											}
										}
									}
								}
							}
						},
						"Marker": {}
					}
				}
			},
			"ListSecurityConfigurations": {
				"input": {
					"type": "structure",
					"members": {
						"Marker": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"SecurityConfigurations": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"Name": {},
									"CreationDateTime": {
										"type": "timestamp"
									}
								}
							}
						},
						"Marker": {}
					}
				}
			},
			"ListSteps": {
				"input": {
					"type": "structure",
					"required": [
						"ClusterId"
					],
					"members": {
						"ClusterId": {},
						"StepStates": {
							"type": "list",
							"member": {}
						},
						"StepIds": {
							"shape": "Ss"
						},
						"Marker": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Steps": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"Id": {},
									"Name": {},
									"Config": {
										"shape": "S2a"
									},
									"ActionOnFailure": {},
									"Status": {
										"shape": "S2b"
									}
								}
							}
						},
						"Marker": {}
					}
				}
			},
			"ModifyInstanceGroups": {
				"input": {
					"type": "structure",
					"members": {
						"InstanceGroups": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"InstanceGroupId"
								],
								"members": {
									"InstanceGroupId": {},
									"InstanceCount": {
										"type": "integer"
									},
									"EC2InstanceIdsToTerminate": {
										"type": "list",
										"member": {}
									},
									"ShrinkPolicy": {
										"shape": "S33"
									}
								}
							}
						}
					}
				}
			},
			"RemoveTags": {
				"input": {
					"type": "structure",
					"required": [
						"ResourceId",
						"TagKeys"
					],
					"members": {
						"ResourceId": {},
						"TagKeys": {
							"shape": "S1f"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"RunJobFlow": {
				"input": {
					"type": "structure",
					"required": [
						"Name",
						"Instances"
					],
					"members": {
						"Name": {},
						"LogUri": {},
						"AdditionalInfo": {},
						"AmiVersion": {},
						"ReleaseLabel": {},
						"Instances": {
							"type": "structure",
							"members": {
								"MasterInstanceType": {},
								"SlaveInstanceType": {},
								"InstanceCount": {
									"type": "integer"
								},
								"InstanceGroups": {
									"shape": "S2"
								},
								"Ec2KeyName": {},
								"Placement": {
									"shape": "S1u"
								},
								"KeepJobFlowAliveWhenNoSteps": {
									"type": "boolean"
								},
								"TerminationProtected": {
									"type": "boolean"
								},
								"HadoopVersion": {},
								"Ec2SubnetId": {},
								"EmrManagedMasterSecurityGroup": {},
								"EmrManagedSlaveSecurityGroup": {},
								"ServiceAccessSecurityGroup": {},
								"AdditionalMasterSecurityGroups": {
									"shape": "S41"
								},
								"AdditionalSlaveSecurityGroups": {
									"shape": "S41"
								}
							}
						},
						"Steps": {
							"shape": "Sl"
						},
						"BootstrapActions": {
							"type": "list",
							"member": {
								"shape": "S21"
							}
						},
						"SupportedProducts": {
							"shape": "S23"
						},
						"NewSupportedProducts": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"Name": {},
									"Args": {
										"shape": "Ss"
									}
								}
							}
						},
						"Applications": {
							"shape": "S1h"
						},
						"Configurations": {
							"shape": "S9"
						},
						"VisibleToAllUsers": {
							"type": "boolean"
						},
						"JobFlowRole": {},
						"ServiceRole": {},
						"Tags": {
							"shape": "Sx"
						},
						"SecurityConfiguration": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"JobFlowId": {}
					}
				}
			},
			"SetTerminationProtection": {
				"input": {
					"type": "structure",
					"required": [
						"JobFlowIds",
						"TerminationProtected"
					],
					"members": {
						"JobFlowIds": {
							"shape": "Ss"
						},
						"TerminationProtected": {
							"type": "boolean"
						}
					}
				}
			},
			"SetVisibleToAllUsers": {
				"input": {
					"type": "structure",
					"required": [
						"JobFlowIds",
						"VisibleToAllUsers"
					],
					"members": {
						"JobFlowIds": {
							"shape": "Ss"
						},
						"VisibleToAllUsers": {
							"type": "boolean"
						}
					}
				}
			},
			"TerminateJobFlows": {
				"input": {
					"type": "structure",
					"required": [
						"JobFlowIds"
					],
					"members": {
						"JobFlowIds": {
							"shape": "Ss"
						}
					}
				}
			}
		},
		"shapes": {
			"S2": {
				"type": "list",
				"member": {
					"type": "structure",
					"required": [
						"InstanceRole",
						"InstanceType",
						"InstanceCount"
					],
					"members": {
						"Name": {},
						"Market": {},
						"InstanceRole": {},
						"BidPrice": {},
						"InstanceType": {},
						"InstanceCount": {
							"type": "integer"
						},
						"Configurations": {
							"shape": "S9"
						},
						"EbsConfiguration": {
							"type": "structure",
							"members": {
								"EbsBlockDeviceConfigs": {
									"type": "list",
									"member": {
										"type": "structure",
										"required": [
											"VolumeSpecification"
										],
										"members": {
											"VolumeSpecification": {
												"shape": "Sg"
											},
											"VolumesPerInstance": {
												"type": "integer"
											}
										}
									}
								},
								"EbsOptimized": {
									"type": "boolean"
								}
							}
						}
					}
				}
			},
			"S9": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"Classification": {},
						"Configurations": {
							"shape": "S9"
						},
						"Properties": {
							"shape": "Sc"
						}
					}
				}
			},
			"Sc": {
				"type": "map",
				"key": {},
				"value": {}
			},
			"Sg": {
				"type": "structure",
				"required": [
					"VolumeType",
					"SizeInGB"
				],
				"members": {
					"VolumeType": {},
					"Iops": {
						"type": "integer"
					},
					"SizeInGB": {
						"type": "integer"
					}
				}
			},
			"Sl": {
				"type": "list",
				"member": {
					"shape": "Sm"
				}
			},
			"Sm": {
				"type": "structure",
				"required": [
					"Name",
					"HadoopJarStep"
				],
				"members": {
					"Name": {},
					"ActionOnFailure": {},
					"HadoopJarStep": {
						"type": "structure",
						"required": [
							"Jar"
						],
						"members": {
							"Properties": {
								"type": "list",
								"member": {
									"type": "structure",
									"members": {
										"Key": {},
										"Value": {}
									}
								}
							},
							"Jar": {},
							"MainClass": {},
							"Args": {
								"shape": "Ss"
							}
						}
					}
				}
			},
			"Ss": {
				"type": "list",
				"member": {}
			},
			"Sx": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"Key": {},
						"Value": {}
					}
				}
			},
			"S19": {
				"type": "structure",
				"members": {
					"State": {},
					"StateChangeReason": {
						"type": "structure",
						"members": {
							"Code": {},
							"Message": {}
						}
					},
					"Timeline": {
						"type": "structure",
						"members": {
							"CreationDateTime": {
								"type": "timestamp"
							},
							"ReadyDateTime": {
								"type": "timestamp"
							},
							"EndDateTime": {
								"type": "timestamp"
							}
						}
					}
				}
			},
			"S1f": {
				"type": "list",
				"member": {}
			},
			"S1h": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"Name": {},
						"Version": {},
						"Args": {
							"shape": "S1f"
						},
						"AdditionalInfo": {
							"shape": "Sc"
						}
					}
				}
			},
			"S1u": {
				"type": "structure",
				"required": [
					"AvailabilityZone"
				],
				"members": {
					"AvailabilityZone": {}
				}
			},
			"S21": {
				"type": "structure",
				"required": [
					"Name",
					"ScriptBootstrapAction"
				],
				"members": {
					"Name": {},
					"ScriptBootstrapAction": {
						"type": "structure",
						"required": [
							"Path"
						],
						"members": {
							"Path": {},
							"Args": {
								"shape": "Ss"
							}
						}
					}
				}
			},
			"S23": {
				"type": "list",
				"member": {}
			},
			"S2a": {
				"type": "structure",
				"members": {
					"Jar": {},
					"Properties": {
						"shape": "Sc"
					},
					"MainClass": {},
					"Args": {
						"shape": "S1f"
					}
				}
			},
			"S2b": {
				"type": "structure",
				"members": {
					"State": {},
					"StateChangeReason": {
						"type": "structure",
						"members": {
							"Code": {},
							"Message": {}
						}
					},
					"FailureDetails": {
						"type": "structure",
						"members": {
							"Reason": {},
							"Message": {},
							"LogFile": {}
						}
					},
					"Timeline": {
						"type": "structure",
						"members": {
							"CreationDateTime": {
								"type": "timestamp"
							},
							"StartDateTime": {
								"type": "timestamp"
							},
							"EndDateTime": {
								"type": "timestamp"
							}
						}
					}
				}
			},
			"S33": {
				"type": "structure",
				"members": {
					"DecommissionTimeout": {
						"type": "integer"
					},
					"InstanceResizePolicy": {
						"type": "structure",
						"members": {
							"InstancesToTerminate": {
								"shape": "S35"
							},
							"InstancesToProtect": {
								"shape": "S35"
							},
							"InstanceTerminationTimeout": {
								"type": "integer"
							}
						}
					}
				}
			},
			"S35": {
				"type": "list",
				"member": {}
			},
			"S41": {
				"type": "list",
				"member": {}
			}
		}
	};

/***/ },
/* 357 */
/***/ function(module, exports) {

	module.exports = {
		"pagination": {
			"DescribeJobFlows": {
				"result_key": "JobFlows"
			},
			"ListBootstrapActions": {
				"input_token": "Marker",
				"output_token": "Marker",
				"result_key": "BootstrapActions"
			},
			"ListClusters": {
				"input_token": "Marker",
				"output_token": "Marker",
				"result_key": "Clusters"
			},
			"ListInstanceGroups": {
				"input_token": "Marker",
				"output_token": "Marker",
				"result_key": "InstanceGroups"
			},
			"ListInstances": {
				"input_token": "Marker",
				"output_token": "Marker",
				"result_key": "Instances"
			},
			"ListSteps": {
				"input_token": "Marker",
				"output_token": "Marker",
				"result_key": "Steps"
			}
		}
	};

/***/ },
/* 358 */
/***/ function(module, exports) {

	module.exports = {
		"version": 2,
		"waiters": {
			"ClusterRunning": {
				"delay": 30,
				"operation": "DescribeCluster",
				"maxAttempts": 60,
				"acceptors": [
					{
						"state": "success",
						"matcher": "path",
						"argument": "Cluster.Status.State",
						"expected": "RUNNING"
					},
					{
						"state": "success",
						"matcher": "path",
						"argument": "Cluster.Status.State",
						"expected": "WAITING"
					},
					{
						"state": "failure",
						"matcher": "path",
						"argument": "Cluster.Status.State",
						"expected": "TERMINATING"
					},
					{
						"state": "failure",
						"matcher": "path",
						"argument": "Cluster.Status.State",
						"expected": "TERMINATED"
					},
					{
						"state": "failure",
						"matcher": "path",
						"argument": "Cluster.Status.State",
						"expected": "TERMINATED_WITH_ERRORS"
					}
				]
			},
			"StepComplete": {
				"delay": 30,
				"operation": "DescribeStep",
				"maxAttempts": 60,
				"acceptors": [
					{
						"state": "success",
						"matcher": "path",
						"argument": "Step.Status.State",
						"expected": "COMPLETED"
					},
					{
						"state": "failure",
						"matcher": "path",
						"argument": "Step.Status.State",
						"expected": "FAILED"
					},
					{
						"state": "failure",
						"matcher": "path",
						"argument": "Step.Status.State",
						"expected": "CANCELLED"
					}
				]
			}
		}
	};

/***/ },
/* 359 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['es'] = {};
	AWS.ES = Service.defineService('es', ['2015-01-01']);
	Object.defineProperty(apiLoader.services['es'], '2015-01-01', {
	  get: function get() {
	    var model = __webpack_require__(360);
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.ES;


/***/ },
/* 360 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2015-01-01",
			"endpointPrefix": "es",
			"protocol": "rest-json",
			"serviceFullName": "Amazon Elasticsearch Service",
			"signatureVersion": "v4"
		},
		"operations": {
			"AddTags": {
				"http": {
					"requestUri": "/2015-01-01/tags"
				},
				"input": {
					"type": "structure",
					"required": [
						"ARN",
						"TagList"
					],
					"members": {
						"ARN": {},
						"TagList": {
							"shape": "S3"
						}
					}
				}
			},
			"CreateElasticsearchDomain": {
				"http": {
					"requestUri": "/2015-01-01/es/domain"
				},
				"input": {
					"type": "structure",
					"required": [
						"DomainName"
					],
					"members": {
						"DomainName": {},
						"ElasticsearchVersion": {},
						"ElasticsearchClusterConfig": {
							"shape": "Sa"
						},
						"EBSOptions": {
							"shape": "Se"
						},
						"AccessPolicies": {},
						"SnapshotOptions": {
							"shape": "Sh"
						},
						"AdvancedOptions": {
							"shape": "Si"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"DomainStatus": {
							"shape": "Sl"
						}
					}
				}
			},
			"DeleteElasticsearchDomain": {
				"http": {
					"method": "DELETE",
					"requestUri": "/2015-01-01/es/domain/{DomainName}"
				},
				"input": {
					"type": "structure",
					"required": [
						"DomainName"
					],
					"members": {
						"DomainName": {
							"location": "uri",
							"locationName": "DomainName"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"DomainStatus": {
							"shape": "Sl"
						}
					}
				}
			},
			"DescribeElasticsearchDomain": {
				"http": {
					"method": "GET",
					"requestUri": "/2015-01-01/es/domain/{DomainName}"
				},
				"input": {
					"type": "structure",
					"required": [
						"DomainName"
					],
					"members": {
						"DomainName": {
							"location": "uri",
							"locationName": "DomainName"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"DomainStatus"
					],
					"members": {
						"DomainStatus": {
							"shape": "Sl"
						}
					}
				}
			},
			"DescribeElasticsearchDomainConfig": {
				"http": {
					"method": "GET",
					"requestUri": "/2015-01-01/es/domain/{DomainName}/config"
				},
				"input": {
					"type": "structure",
					"required": [
						"DomainName"
					],
					"members": {
						"DomainName": {
							"location": "uri",
							"locationName": "DomainName"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"DomainConfig"
					],
					"members": {
						"DomainConfig": {
							"shape": "Su"
						}
					}
				}
			},
			"DescribeElasticsearchDomains": {
				"http": {
					"requestUri": "/2015-01-01/es/domain-info"
				},
				"input": {
					"type": "structure",
					"required": [
						"DomainNames"
					],
					"members": {
						"DomainNames": {
							"type": "list",
							"member": {}
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"DomainStatusList"
					],
					"members": {
						"DomainStatusList": {
							"type": "list",
							"member": {
								"shape": "Sl"
							}
						}
					}
				}
			},
			"ListDomainNames": {
				"http": {
					"method": "GET",
					"requestUri": "/2015-01-01/domain"
				},
				"output": {
					"type": "structure",
					"members": {
						"DomainNames": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"DomainName": {}
								}
							}
						}
					}
				}
			},
			"ListTags": {
				"http": {
					"method": "GET",
					"requestUri": "/2015-01-01/tags/"
				},
				"input": {
					"type": "structure",
					"required": [
						"ARN"
					],
					"members": {
						"ARN": {
							"location": "querystring",
							"locationName": "arn"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"TagList": {
							"shape": "S3"
						}
					}
				}
			},
			"RemoveTags": {
				"http": {
					"requestUri": "/2015-01-01/tags-removal"
				},
				"input": {
					"type": "structure",
					"required": [
						"ARN",
						"TagKeys"
					],
					"members": {
						"ARN": {},
						"TagKeys": {
							"type": "list",
							"member": {}
						}
					}
				}
			},
			"UpdateElasticsearchDomainConfig": {
				"http": {
					"requestUri": "/2015-01-01/es/domain/{DomainName}/config"
				},
				"input": {
					"type": "structure",
					"required": [
						"DomainName"
					],
					"members": {
						"DomainName": {
							"location": "uri",
							"locationName": "DomainName"
						},
						"ElasticsearchClusterConfig": {
							"shape": "Sa"
						},
						"EBSOptions": {
							"shape": "Se"
						},
						"SnapshotOptions": {
							"shape": "Sh"
						},
						"AdvancedOptions": {
							"shape": "Si"
						},
						"AccessPolicies": {}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"DomainConfig"
					],
					"members": {
						"DomainConfig": {
							"shape": "Su"
						}
					}
				}
			}
		},
		"shapes": {
			"S3": {
				"type": "list",
				"member": {
					"type": "structure",
					"required": [
						"Key",
						"Value"
					],
					"members": {
						"Key": {},
						"Value": {}
					}
				}
			},
			"Sa": {
				"type": "structure",
				"members": {
					"InstanceType": {},
					"InstanceCount": {
						"type": "integer"
					},
					"DedicatedMasterEnabled": {
						"type": "boolean"
					},
					"ZoneAwarenessEnabled": {
						"type": "boolean"
					},
					"DedicatedMasterType": {},
					"DedicatedMasterCount": {
						"type": "integer"
					}
				}
			},
			"Se": {
				"type": "structure",
				"members": {
					"EBSEnabled": {
						"type": "boolean"
					},
					"VolumeType": {},
					"VolumeSize": {
						"type": "integer"
					},
					"Iops": {
						"type": "integer"
					}
				}
			},
			"Sh": {
				"type": "structure",
				"members": {
					"AutomatedSnapshotStartHour": {
						"type": "integer"
					}
				}
			},
			"Si": {
				"type": "map",
				"key": {},
				"value": {}
			},
			"Sl": {
				"type": "structure",
				"required": [
					"DomainId",
					"DomainName",
					"ARN",
					"ElasticsearchClusterConfig"
				],
				"members": {
					"DomainId": {},
					"DomainName": {},
					"ARN": {},
					"Created": {
						"type": "boolean"
					},
					"Deleted": {
						"type": "boolean"
					},
					"Endpoint": {},
					"Processing": {
						"type": "boolean"
					},
					"ElasticsearchVersion": {},
					"ElasticsearchClusterConfig": {
						"shape": "Sa"
					},
					"EBSOptions": {
						"shape": "Se"
					},
					"AccessPolicies": {},
					"SnapshotOptions": {
						"shape": "Sh"
					},
					"AdvancedOptions": {
						"shape": "Si"
					}
				}
			},
			"Su": {
				"type": "structure",
				"members": {
					"ElasticsearchVersion": {
						"type": "structure",
						"required": [
							"Options",
							"Status"
						],
						"members": {
							"Options": {},
							"Status": {
								"shape": "Sw"
							}
						}
					},
					"ElasticsearchClusterConfig": {
						"type": "structure",
						"required": [
							"Options",
							"Status"
						],
						"members": {
							"Options": {
								"shape": "Sa"
							},
							"Status": {
								"shape": "Sw"
							}
						}
					},
					"EBSOptions": {
						"type": "structure",
						"required": [
							"Options",
							"Status"
						],
						"members": {
							"Options": {
								"shape": "Se"
							},
							"Status": {
								"shape": "Sw"
							}
						}
					},
					"AccessPolicies": {
						"type": "structure",
						"required": [
							"Options",
							"Status"
						],
						"members": {
							"Options": {},
							"Status": {
								"shape": "Sw"
							}
						}
					},
					"SnapshotOptions": {
						"type": "structure",
						"required": [
							"Options",
							"Status"
						],
						"members": {
							"Options": {
								"shape": "Sh"
							},
							"Status": {
								"shape": "Sw"
							}
						}
					},
					"AdvancedOptions": {
						"type": "structure",
						"required": [
							"Options",
							"Status"
						],
						"members": {
							"Options": {
								"shape": "Si"
							},
							"Status": {
								"shape": "Sw"
							}
						}
					}
				}
			},
			"Sw": {
				"type": "structure",
				"required": [
					"CreationDate",
					"UpdateDate",
					"State"
				],
				"members": {
					"CreationDate": {
						"type": "timestamp"
					},
					"UpdateDate": {
						"type": "timestamp"
					},
					"UpdateVersion": {
						"type": "integer"
					},
					"State": {},
					"PendingDeletion": {
						"type": "boolean"
					}
				}
			}
		}
	};

/***/ },
/* 361 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['elastictranscoder'] = {};
	AWS.ElasticTranscoder = Service.defineService('elastictranscoder', ['2012-09-25']);
	Object.defineProperty(apiLoader.services['elastictranscoder'], '2012-09-25', {
	  get: function get() {
	    var model = __webpack_require__(362);
	    model.paginators = __webpack_require__(363).pagination;
	    model.waiters = __webpack_require__(364).waiters;
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.ElasticTranscoder;


/***/ },
/* 362 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2012-09-25",
			"endpointPrefix": "elastictranscoder",
			"protocol": "rest-json",
			"serviceFullName": "Amazon Elastic Transcoder",
			"signatureVersion": "v4"
		},
		"operations": {
			"CancelJob": {
				"http": {
					"method": "DELETE",
					"requestUri": "/2012-09-25/jobs/{Id}",
					"responseCode": 202
				},
				"input": {
					"type": "structure",
					"required": [
						"Id"
					],
					"members": {
						"Id": {
							"location": "uri",
							"locationName": "Id"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"CreateJob": {
				"http": {
					"requestUri": "/2012-09-25/jobs",
					"responseCode": 201
				},
				"input": {
					"type": "structure",
					"required": [
						"PipelineId",
						"Input"
					],
					"members": {
						"PipelineId": {},
						"Input": {
							"shape": "S5"
						},
						"Output": {
							"shape": "Sk"
						},
						"Outputs": {
							"type": "list",
							"member": {
								"shape": "Sk"
							}
						},
						"OutputKeyPrefix": {},
						"Playlists": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"Name": {},
									"Format": {},
									"OutputKeys": {
										"shape": "S1j"
									},
									"HlsContentProtection": {
										"shape": "S1k"
									},
									"PlayReadyDrm": {
										"shape": "S1o"
									}
								}
							}
						},
						"UserMetadata": {
							"shape": "S1t"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Job": {
							"shape": "S1w"
						}
					}
				}
			},
			"CreatePipeline": {
				"http": {
					"requestUri": "/2012-09-25/pipelines",
					"responseCode": 201
				},
				"input": {
					"type": "structure",
					"required": [
						"Name",
						"InputBucket",
						"Role"
					],
					"members": {
						"Name": {},
						"InputBucket": {},
						"OutputBucket": {},
						"Role": {},
						"AwsKmsKeyArn": {},
						"Notifications": {
							"shape": "S28"
						},
						"ContentConfig": {
							"shape": "S2a"
						},
						"ThumbnailConfig": {
							"shape": "S2a"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Pipeline": {
							"shape": "S2j"
						},
						"Warnings": {
							"shape": "S2l"
						}
					}
				}
			},
			"CreatePreset": {
				"http": {
					"requestUri": "/2012-09-25/presets",
					"responseCode": 201
				},
				"input": {
					"type": "structure",
					"required": [
						"Name",
						"Container"
					],
					"members": {
						"Name": {},
						"Description": {},
						"Container": {},
						"Video": {
							"shape": "S2p"
						},
						"Audio": {
							"shape": "S35"
						},
						"Thumbnails": {
							"shape": "S3g"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Preset": {
							"shape": "S3k"
						},
						"Warning": {}
					}
				}
			},
			"DeletePipeline": {
				"http": {
					"method": "DELETE",
					"requestUri": "/2012-09-25/pipelines/{Id}",
					"responseCode": 202
				},
				"input": {
					"type": "structure",
					"required": [
						"Id"
					],
					"members": {
						"Id": {
							"location": "uri",
							"locationName": "Id"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"DeletePreset": {
				"http": {
					"method": "DELETE",
					"requestUri": "/2012-09-25/presets/{Id}",
					"responseCode": 202
				},
				"input": {
					"type": "structure",
					"required": [
						"Id"
					],
					"members": {
						"Id": {
							"location": "uri",
							"locationName": "Id"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"ListJobsByPipeline": {
				"http": {
					"method": "GET",
					"requestUri": "/2012-09-25/jobsByPipeline/{PipelineId}"
				},
				"input": {
					"type": "structure",
					"required": [
						"PipelineId"
					],
					"members": {
						"PipelineId": {
							"location": "uri",
							"locationName": "PipelineId"
						},
						"Ascending": {
							"location": "querystring",
							"locationName": "Ascending"
						},
						"PageToken": {
							"location": "querystring",
							"locationName": "PageToken"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Jobs": {
							"shape": "S3t"
						},
						"NextPageToken": {}
					}
				}
			},
			"ListJobsByStatus": {
				"http": {
					"method": "GET",
					"requestUri": "/2012-09-25/jobsByStatus/{Status}"
				},
				"input": {
					"type": "structure",
					"required": [
						"Status"
					],
					"members": {
						"Status": {
							"location": "uri",
							"locationName": "Status"
						},
						"Ascending": {
							"location": "querystring",
							"locationName": "Ascending"
						},
						"PageToken": {
							"location": "querystring",
							"locationName": "PageToken"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Jobs": {
							"shape": "S3t"
						},
						"NextPageToken": {}
					}
				}
			},
			"ListPipelines": {
				"http": {
					"method": "GET",
					"requestUri": "/2012-09-25/pipelines"
				},
				"input": {
					"type": "structure",
					"members": {
						"Ascending": {
							"location": "querystring",
							"locationName": "Ascending"
						},
						"PageToken": {
							"location": "querystring",
							"locationName": "PageToken"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Pipelines": {
							"type": "list",
							"member": {
								"shape": "S2j"
							}
						},
						"NextPageToken": {}
					}
				}
			},
			"ListPresets": {
				"http": {
					"method": "GET",
					"requestUri": "/2012-09-25/presets"
				},
				"input": {
					"type": "structure",
					"members": {
						"Ascending": {
							"location": "querystring",
							"locationName": "Ascending"
						},
						"PageToken": {
							"location": "querystring",
							"locationName": "PageToken"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Presets": {
							"type": "list",
							"member": {
								"shape": "S3k"
							}
						},
						"NextPageToken": {}
					}
				}
			},
			"ReadJob": {
				"http": {
					"method": "GET",
					"requestUri": "/2012-09-25/jobs/{Id}"
				},
				"input": {
					"type": "structure",
					"required": [
						"Id"
					],
					"members": {
						"Id": {
							"location": "uri",
							"locationName": "Id"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Job": {
							"shape": "S1w"
						}
					}
				}
			},
			"ReadPipeline": {
				"http": {
					"method": "GET",
					"requestUri": "/2012-09-25/pipelines/{Id}"
				},
				"input": {
					"type": "structure",
					"required": [
						"Id"
					],
					"members": {
						"Id": {
							"location": "uri",
							"locationName": "Id"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Pipeline": {
							"shape": "S2j"
						},
						"Warnings": {
							"shape": "S2l"
						}
					}
				}
			},
			"ReadPreset": {
				"http": {
					"method": "GET",
					"requestUri": "/2012-09-25/presets/{Id}"
				},
				"input": {
					"type": "structure",
					"required": [
						"Id"
					],
					"members": {
						"Id": {
							"location": "uri",
							"locationName": "Id"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Preset": {
							"shape": "S3k"
						}
					}
				}
			},
			"TestRole": {
				"http": {
					"requestUri": "/2012-09-25/roleTests",
					"responseCode": 200
				},
				"input": {
					"type": "structure",
					"required": [
						"Role",
						"InputBucket",
						"OutputBucket",
						"Topics"
					],
					"members": {
						"Role": {},
						"InputBucket": {},
						"OutputBucket": {},
						"Topics": {
							"type": "list",
							"member": {}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Success": {},
						"Messages": {
							"type": "list",
							"member": {}
						}
					}
				}
			},
			"UpdatePipeline": {
				"http": {
					"method": "PUT",
					"requestUri": "/2012-09-25/pipelines/{Id}",
					"responseCode": 200
				},
				"input": {
					"type": "structure",
					"required": [
						"Id"
					],
					"members": {
						"Id": {
							"location": "uri",
							"locationName": "Id"
						},
						"Name": {},
						"InputBucket": {},
						"Role": {},
						"AwsKmsKeyArn": {},
						"Notifications": {
							"shape": "S28"
						},
						"ContentConfig": {
							"shape": "S2a"
						},
						"ThumbnailConfig": {
							"shape": "S2a"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Pipeline": {
							"shape": "S2j"
						},
						"Warnings": {
							"shape": "S2l"
						}
					}
				}
			},
			"UpdatePipelineNotifications": {
				"http": {
					"requestUri": "/2012-09-25/pipelines/{Id}/notifications"
				},
				"input": {
					"type": "structure",
					"required": [
						"Id",
						"Notifications"
					],
					"members": {
						"Id": {
							"location": "uri",
							"locationName": "Id"
						},
						"Notifications": {
							"shape": "S28"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Pipeline": {
							"shape": "S2j"
						}
					}
				}
			},
			"UpdatePipelineStatus": {
				"http": {
					"requestUri": "/2012-09-25/pipelines/{Id}/status"
				},
				"input": {
					"type": "structure",
					"required": [
						"Id",
						"Status"
					],
					"members": {
						"Id": {
							"location": "uri",
							"locationName": "Id"
						},
						"Status": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Pipeline": {
							"shape": "S2j"
						}
					}
				}
			}
		},
		"shapes": {
			"S5": {
				"type": "structure",
				"members": {
					"Key": {},
					"FrameRate": {},
					"Resolution": {},
					"AspectRatio": {},
					"Interlaced": {},
					"Container": {},
					"Encryption": {
						"shape": "Sc"
					},
					"DetectedProperties": {
						"type": "structure",
						"members": {
							"Width": {
								"type": "integer"
							},
							"Height": {
								"type": "integer"
							},
							"FrameRate": {},
							"FileSize": {
								"type": "long"
							},
							"DurationMillis": {
								"type": "long"
							}
						}
					}
				}
			},
			"Sc": {
				"type": "structure",
				"members": {
					"Mode": {},
					"Key": {},
					"KeyMd5": {},
					"InitializationVector": {}
				}
			},
			"Sk": {
				"type": "structure",
				"members": {
					"Key": {},
					"ThumbnailPattern": {},
					"ThumbnailEncryption": {
						"shape": "Sc"
					},
					"Rotate": {},
					"PresetId": {},
					"SegmentDuration": {},
					"Watermarks": {
						"shape": "So"
					},
					"AlbumArt": {
						"shape": "Ss"
					},
					"Composition": {
						"shape": "S10"
					},
					"Captions": {
						"shape": "S14"
					},
					"Encryption": {
						"shape": "Sc"
					}
				}
			},
			"So": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"PresetWatermarkId": {},
						"InputKey": {},
						"Encryption": {
							"shape": "Sc"
						}
					}
				}
			},
			"Ss": {
				"type": "structure",
				"members": {
					"MergePolicy": {},
					"Artwork": {
						"type": "list",
						"member": {
							"type": "structure",
							"members": {
								"InputKey": {},
								"MaxWidth": {},
								"MaxHeight": {},
								"SizingPolicy": {},
								"PaddingPolicy": {},
								"AlbumArtFormat": {},
								"Encryption": {
									"shape": "Sc"
								}
							}
						}
					}
				}
			},
			"S10": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"TimeSpan": {
							"type": "structure",
							"members": {
								"StartTime": {},
								"Duration": {}
							}
						}
					}
				}
			},
			"S14": {
				"type": "structure",
				"members": {
					"MergePolicy": {},
					"CaptionSources": {
						"type": "list",
						"member": {
							"type": "structure",
							"members": {
								"Key": {},
								"Language": {},
								"TimeOffset": {},
								"Label": {},
								"Encryption": {
									"shape": "Sc"
								}
							}
						}
					},
					"CaptionFormats": {
						"type": "list",
						"member": {
							"type": "structure",
							"members": {
								"Format": {},
								"Pattern": {},
								"Encryption": {
									"shape": "Sc"
								}
							}
						}
					}
				}
			},
			"S1j": {
				"type": "list",
				"member": {}
			},
			"S1k": {
				"type": "structure",
				"members": {
					"Method": {},
					"Key": {},
					"KeyMd5": {},
					"InitializationVector": {},
					"LicenseAcquisitionUrl": {},
					"KeyStoragePolicy": {}
				}
			},
			"S1o": {
				"type": "structure",
				"members": {
					"Format": {},
					"Key": {},
					"KeyMd5": {},
					"KeyId": {},
					"InitializationVector": {},
					"LicenseAcquisitionUrl": {}
				}
			},
			"S1t": {
				"type": "map",
				"key": {},
				"value": {}
			},
			"S1w": {
				"type": "structure",
				"members": {
					"Id": {},
					"Arn": {},
					"PipelineId": {},
					"Input": {
						"shape": "S5"
					},
					"Output": {
						"shape": "S1x"
					},
					"Outputs": {
						"type": "list",
						"member": {
							"shape": "S1x"
						}
					},
					"OutputKeyPrefix": {},
					"Playlists": {
						"type": "list",
						"member": {
							"type": "structure",
							"members": {
								"Name": {},
								"Format": {},
								"OutputKeys": {
									"shape": "S1j"
								},
								"HlsContentProtection": {
									"shape": "S1k"
								},
								"PlayReadyDrm": {
									"shape": "S1o"
								},
								"Status": {},
								"StatusDetail": {}
							}
						}
					},
					"Status": {},
					"UserMetadata": {
						"shape": "S1t"
					},
					"Timing": {
						"type": "structure",
						"members": {
							"SubmitTimeMillis": {
								"type": "long"
							},
							"StartTimeMillis": {
								"type": "long"
							},
							"FinishTimeMillis": {
								"type": "long"
							}
						}
					}
				}
			},
			"S1x": {
				"type": "structure",
				"members": {
					"Id": {},
					"Key": {},
					"ThumbnailPattern": {},
					"ThumbnailEncryption": {
						"shape": "Sc"
					},
					"Rotate": {},
					"PresetId": {},
					"SegmentDuration": {},
					"Status": {},
					"StatusDetail": {},
					"Duration": {
						"type": "long"
					},
					"Width": {
						"type": "integer"
					},
					"Height": {
						"type": "integer"
					},
					"FrameRate": {},
					"FileSize": {
						"type": "long"
					},
					"DurationMillis": {
						"type": "long"
					},
					"Watermarks": {
						"shape": "So"
					},
					"AlbumArt": {
						"shape": "Ss"
					},
					"Composition": {
						"shape": "S10"
					},
					"Captions": {
						"shape": "S14"
					},
					"Encryption": {
						"shape": "Sc"
					},
					"AppliedColorSpaceConversion": {}
				}
			},
			"S28": {
				"type": "structure",
				"members": {
					"Progressing": {},
					"Completed": {},
					"Warning": {},
					"Error": {}
				}
			},
			"S2a": {
				"type": "structure",
				"members": {
					"Bucket": {},
					"StorageClass": {},
					"Permissions": {
						"type": "list",
						"member": {
							"type": "structure",
							"members": {
								"GranteeType": {},
								"Grantee": {},
								"Access": {
									"type": "list",
									"member": {}
								}
							}
						}
					}
				}
			},
			"S2j": {
				"type": "structure",
				"members": {
					"Id": {},
					"Arn": {},
					"Name": {},
					"Status": {},
					"InputBucket": {},
					"OutputBucket": {},
					"Role": {},
					"AwsKmsKeyArn": {},
					"Notifications": {
						"shape": "S28"
					},
					"ContentConfig": {
						"shape": "S2a"
					},
					"ThumbnailConfig": {
						"shape": "S2a"
					}
				}
			},
			"S2l": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"Code": {},
						"Message": {}
					}
				}
			},
			"S2p": {
				"type": "structure",
				"members": {
					"Codec": {},
					"CodecOptions": {
						"type": "map",
						"key": {},
						"value": {}
					},
					"KeyframesMaxDist": {},
					"FixedGOP": {},
					"BitRate": {},
					"FrameRate": {},
					"MaxFrameRate": {},
					"Resolution": {},
					"AspectRatio": {},
					"MaxWidth": {},
					"MaxHeight": {},
					"DisplayAspectRatio": {},
					"SizingPolicy": {},
					"PaddingPolicy": {},
					"Watermarks": {
						"type": "list",
						"member": {
							"type": "structure",
							"members": {
								"Id": {},
								"MaxWidth": {},
								"MaxHeight": {},
								"SizingPolicy": {},
								"HorizontalAlign": {},
								"HorizontalOffset": {},
								"VerticalAlign": {},
								"VerticalOffset": {},
								"Opacity": {},
								"Target": {}
							}
						}
					}
				}
			},
			"S35": {
				"type": "structure",
				"members": {
					"Codec": {},
					"SampleRate": {},
					"BitRate": {},
					"Channels": {},
					"AudioPackingMode": {},
					"CodecOptions": {
						"type": "structure",
						"members": {
							"Profile": {},
							"BitDepth": {},
							"BitOrder": {},
							"Signed": {}
						}
					}
				}
			},
			"S3g": {
				"type": "structure",
				"members": {
					"Format": {},
					"Interval": {},
					"Resolution": {},
					"AspectRatio": {},
					"MaxWidth": {},
					"MaxHeight": {},
					"SizingPolicy": {},
					"PaddingPolicy": {}
				}
			},
			"S3k": {
				"type": "structure",
				"members": {
					"Id": {},
					"Arn": {},
					"Name": {},
					"Description": {},
					"Container": {},
					"Audio": {
						"shape": "S35"
					},
					"Video": {
						"shape": "S2p"
					},
					"Thumbnails": {
						"shape": "S3g"
					},
					"Type": {}
				}
			},
			"S3t": {
				"type": "list",
				"member": {
					"shape": "S1w"
				}
			}
		}
	};

/***/ },
/* 363 */
/***/ function(module, exports) {

	module.exports = {
		"pagination": {
			"ListJobsByPipeline": {
				"input_token": "PageToken",
				"output_token": "NextPageToken",
				"result_key": "Jobs"
			},
			"ListJobsByStatus": {
				"input_token": "PageToken",
				"output_token": "NextPageToken",
				"result_key": "Jobs"
			},
			"ListPipelines": {
				"input_token": "PageToken",
				"output_token": "NextPageToken",
				"result_key": "Pipelines"
			},
			"ListPresets": {
				"input_token": "PageToken",
				"output_token": "NextPageToken",
				"result_key": "Presets"
			}
		}
	};

/***/ },
/* 364 */
/***/ function(module, exports) {

	module.exports = {
		"version": 2,
		"waiters": {
			"JobComplete": {
				"delay": 30,
				"operation": "ReadJob",
				"maxAttempts": 120,
				"acceptors": [
					{
						"expected": "Complete",
						"matcher": "path",
						"state": "success",
						"argument": "Job.Status"
					},
					{
						"expected": "Canceled",
						"matcher": "path",
						"state": "failure",
						"argument": "Job.Status"
					},
					{
						"expected": "Error",
						"matcher": "path",
						"state": "failure",
						"argument": "Job.Status"
					}
				]
			}
		}
	};

/***/ },
/* 365 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['firehose'] = {};
	AWS.Firehose = Service.defineService('firehose', ['2015-08-04']);
	Object.defineProperty(apiLoader.services['firehose'], '2015-08-04', {
	  get: function get() {
	    var model = __webpack_require__(366);
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.Firehose;


/***/ },
/* 366 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2015-08-04",
			"endpointPrefix": "firehose",
			"jsonVersion": "1.1",
			"protocol": "json",
			"serviceAbbreviation": "Firehose",
			"serviceFullName": "Amazon Kinesis Firehose",
			"signatureVersion": "v4",
			"targetPrefix": "Firehose_20150804"
		},
		"operations": {
			"CreateDeliveryStream": {
				"input": {
					"type": "structure",
					"required": [
						"DeliveryStreamName"
					],
					"members": {
						"DeliveryStreamName": {},
						"S3DestinationConfiguration": {
							"shape": "S3"
						},
						"RedshiftDestinationConfiguration": {
							"type": "structure",
							"required": [
								"RoleARN",
								"ClusterJDBCURL",
								"CopyCommand",
								"Username",
								"Password",
								"S3Configuration"
							],
							"members": {
								"RoleARN": {},
								"ClusterJDBCURL": {},
								"CopyCommand": {
									"shape": "Sl"
								},
								"Username": {
									"shape": "Sp"
								},
								"Password": {
									"shape": "Sq"
								},
								"RetryOptions": {
									"shape": "Sr"
								},
								"S3Configuration": {
									"shape": "S3"
								},
								"CloudWatchLoggingOptions": {
									"shape": "Sf"
								}
							}
						},
						"ElasticsearchDestinationConfiguration": {
							"type": "structure",
							"required": [
								"RoleARN",
								"DomainARN",
								"IndexName",
								"TypeName",
								"S3Configuration"
							],
							"members": {
								"RoleARN": {},
								"DomainARN": {},
								"IndexName": {},
								"TypeName": {},
								"IndexRotationPeriod": {},
								"BufferingHints": {
									"shape": "Sy"
								},
								"RetryOptions": {
									"shape": "S11"
								},
								"S3BackupMode": {},
								"S3Configuration": {
									"shape": "S3"
								},
								"CloudWatchLoggingOptions": {
									"shape": "Sf"
								}
							}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"DeliveryStreamARN": {}
					}
				}
			},
			"DeleteDeliveryStream": {
				"input": {
					"type": "structure",
					"required": [
						"DeliveryStreamName"
					],
					"members": {
						"DeliveryStreamName": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"DescribeDeliveryStream": {
				"input": {
					"type": "structure",
					"required": [
						"DeliveryStreamName"
					],
					"members": {
						"DeliveryStreamName": {},
						"Limit": {
							"type": "integer"
						},
						"ExclusiveStartDestinationId": {}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"DeliveryStreamDescription"
					],
					"members": {
						"DeliveryStreamDescription": {
							"type": "structure",
							"required": [
								"DeliveryStreamName",
								"DeliveryStreamARN",
								"DeliveryStreamStatus",
								"VersionId",
								"Destinations",
								"HasMoreDestinations"
							],
							"members": {
								"DeliveryStreamName": {},
								"DeliveryStreamARN": {},
								"DeliveryStreamStatus": {},
								"VersionId": {},
								"CreateTimestamp": {
									"type": "timestamp"
								},
								"LastUpdateTimestamp": {
									"type": "timestamp"
								},
								"Destinations": {
									"type": "list",
									"member": {
										"type": "structure",
										"required": [
											"DestinationId"
										],
										"members": {
											"DestinationId": {},
											"S3DestinationDescription": {
												"shape": "S1i"
											},
											"RedshiftDestinationDescription": {
												"type": "structure",
												"required": [
													"RoleARN",
													"ClusterJDBCURL",
													"CopyCommand",
													"Username",
													"S3DestinationDescription"
												],
												"members": {
													"RoleARN": {},
													"ClusterJDBCURL": {},
													"CopyCommand": {
														"shape": "Sl"
													},
													"Username": {
														"shape": "Sp"
													},
													"RetryOptions": {
														"shape": "Sr"
													},
													"S3DestinationDescription": {
														"shape": "S1i"
													},
													"CloudWatchLoggingOptions": {
														"shape": "Sf"
													}
												}
											},
											"ElasticsearchDestinationDescription": {
												"type": "structure",
												"members": {
													"RoleARN": {},
													"DomainARN": {},
													"IndexName": {},
													"TypeName": {},
													"IndexRotationPeriod": {},
													"BufferingHints": {
														"shape": "Sy"
													},
													"RetryOptions": {
														"shape": "S11"
													},
													"S3BackupMode": {},
													"S3DestinationDescription": {
														"shape": "S1i"
													},
													"CloudWatchLoggingOptions": {
														"shape": "Sf"
													}
												}
											}
										}
									}
								},
								"HasMoreDestinations": {
									"type": "boolean"
								}
							}
						}
					}
				}
			},
			"ListDeliveryStreams": {
				"input": {
					"type": "structure",
					"members": {
						"Limit": {
							"type": "integer"
						},
						"ExclusiveStartDeliveryStreamName": {}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"DeliveryStreamNames",
						"HasMoreDeliveryStreams"
					],
					"members": {
						"DeliveryStreamNames": {
							"type": "list",
							"member": {}
						},
						"HasMoreDeliveryStreams": {
							"type": "boolean"
						}
					}
				}
			},
			"PutRecord": {
				"input": {
					"type": "structure",
					"required": [
						"DeliveryStreamName",
						"Record"
					],
					"members": {
						"DeliveryStreamName": {},
						"Record": {
							"shape": "S1q"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"RecordId"
					],
					"members": {
						"RecordId": {}
					}
				}
			},
			"PutRecordBatch": {
				"input": {
					"type": "structure",
					"required": [
						"DeliveryStreamName",
						"Records"
					],
					"members": {
						"DeliveryStreamName": {},
						"Records": {
							"type": "list",
							"member": {
								"shape": "S1q"
							}
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"FailedPutCount",
						"RequestResponses"
					],
					"members": {
						"FailedPutCount": {
							"type": "integer"
						},
						"RequestResponses": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"RecordId": {},
									"ErrorCode": {},
									"ErrorMessage": {}
								}
							}
						}
					}
				}
			},
			"UpdateDestination": {
				"input": {
					"type": "structure",
					"required": [
						"DeliveryStreamName",
						"CurrentDeliveryStreamVersionId",
						"DestinationId"
					],
					"members": {
						"DeliveryStreamName": {},
						"CurrentDeliveryStreamVersionId": {},
						"DestinationId": {},
						"S3DestinationUpdate": {
							"shape": "S23"
						},
						"RedshiftDestinationUpdate": {
							"type": "structure",
							"members": {
								"RoleARN": {},
								"ClusterJDBCURL": {},
								"CopyCommand": {
									"shape": "Sl"
								},
								"Username": {
									"shape": "Sp"
								},
								"Password": {
									"shape": "Sq"
								},
								"RetryOptions": {
									"shape": "Sr"
								},
								"S3Update": {
									"shape": "S23"
								},
								"CloudWatchLoggingOptions": {
									"shape": "Sf"
								}
							}
						},
						"ElasticsearchDestinationUpdate": {
							"type": "structure",
							"members": {
								"RoleARN": {},
								"DomainARN": {},
								"IndexName": {},
								"TypeName": {},
								"IndexRotationPeriod": {},
								"BufferingHints": {
									"shape": "Sy"
								},
								"RetryOptions": {
									"shape": "S11"
								},
								"S3Update": {
									"shape": "S23"
								},
								"CloudWatchLoggingOptions": {
									"shape": "Sf"
								}
							}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			}
		},
		"shapes": {
			"S3": {
				"type": "structure",
				"required": [
					"RoleARN",
					"BucketARN"
				],
				"members": {
					"RoleARN": {},
					"BucketARN": {},
					"Prefix": {},
					"BufferingHints": {
						"shape": "S7"
					},
					"CompressionFormat": {},
					"EncryptionConfiguration": {
						"shape": "Sb"
					},
					"CloudWatchLoggingOptions": {
						"shape": "Sf"
					}
				}
			},
			"S7": {
				"type": "structure",
				"members": {
					"SizeInMBs": {
						"type": "integer"
					},
					"IntervalInSeconds": {
						"type": "integer"
					}
				}
			},
			"Sb": {
				"type": "structure",
				"members": {
					"NoEncryptionConfig": {},
					"KMSEncryptionConfig": {
						"type": "structure",
						"required": [
							"AWSKMSKeyARN"
						],
						"members": {
							"AWSKMSKeyARN": {}
						}
					}
				}
			},
			"Sf": {
				"type": "structure",
				"members": {
					"Enabled": {
						"type": "boolean"
					},
					"LogGroupName": {},
					"LogStreamName": {}
				}
			},
			"Sl": {
				"type": "structure",
				"required": [
					"DataTableName"
				],
				"members": {
					"DataTableName": {},
					"DataTableColumns": {},
					"CopyOptions": {}
				}
			},
			"Sp": {
				"type": "string",
				"sensitive": true
			},
			"Sq": {
				"type": "string",
				"sensitive": true
			},
			"Sr": {
				"type": "structure",
				"members": {
					"DurationInSeconds": {
						"type": "integer"
					}
				}
			},
			"Sy": {
				"type": "structure",
				"members": {
					"IntervalInSeconds": {
						"type": "integer"
					},
					"SizeInMBs": {
						"type": "integer"
					}
				}
			},
			"S11": {
				"type": "structure",
				"members": {
					"DurationInSeconds": {
						"type": "integer"
					}
				}
			},
			"S1i": {
				"type": "structure",
				"required": [
					"RoleARN",
					"BucketARN",
					"BufferingHints",
					"CompressionFormat",
					"EncryptionConfiguration"
				],
				"members": {
					"RoleARN": {},
					"BucketARN": {},
					"Prefix": {},
					"BufferingHints": {
						"shape": "S7"
					},
					"CompressionFormat": {},
					"EncryptionConfiguration": {
						"shape": "Sb"
					},
					"CloudWatchLoggingOptions": {
						"shape": "Sf"
					}
				}
			},
			"S1q": {
				"type": "structure",
				"required": [
					"Data"
				],
				"members": {
					"Data": {
						"type": "blob"
					}
				}
			},
			"S23": {
				"type": "structure",
				"members": {
					"RoleARN": {},
					"BucketARN": {},
					"Prefix": {},
					"BufferingHints": {
						"shape": "S7"
					},
					"CompressionFormat": {},
					"EncryptionConfiguration": {
						"shape": "Sb"
					},
					"CloudWatchLoggingOptions": {
						"shape": "Sf"
					}
				}
			}
		}
	};

/***/ },
/* 367 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['gamelift'] = {};
	AWS.GameLift = Service.defineService('gamelift', ['2015-10-01']);
	Object.defineProperty(apiLoader.services['gamelift'], '2015-10-01', {
	  get: function get() {
	    var model = __webpack_require__(368);
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.GameLift;


/***/ },
/* 368 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2015-10-01",
			"endpointPrefix": "gamelift",
			"jsonVersion": "1.1",
			"protocol": "json",
			"serviceFullName": "Amazon GameLift",
			"signatureVersion": "v4",
			"targetPrefix": "GameLift"
		},
		"operations": {
			"CreateAlias": {
				"input": {
					"type": "structure",
					"required": [
						"Name",
						"RoutingStrategy"
					],
					"members": {
						"Name": {},
						"Description": {},
						"RoutingStrategy": {
							"shape": "S4"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Alias": {
							"shape": "S9"
						}
					}
				}
			},
			"CreateBuild": {
				"input": {
					"type": "structure",
					"members": {
						"Name": {},
						"Version": {},
						"StorageLocation": {
							"shape": "Sd"
						},
						"OperatingSystem": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Build": {
							"shape": "Sh"
						},
						"UploadCredentials": {
							"shape": "Sl"
						},
						"StorageLocation": {
							"shape": "Sd"
						}
					}
				}
			},
			"CreateFleet": {
				"input": {
					"type": "structure",
					"required": [
						"Name",
						"BuildId",
						"EC2InstanceType"
					],
					"members": {
						"Name": {},
						"Description": {},
						"BuildId": {},
						"ServerLaunchPath": {},
						"ServerLaunchParameters": {},
						"LogPaths": {
							"shape": "Sn"
						},
						"EC2InstanceType": {},
						"EC2InboundPermissions": {
							"shape": "Sp"
						},
						"NewGameSessionProtectionPolicy": {},
						"RuntimeConfiguration": {
							"shape": "Sv"
						},
						"ResourceCreationLimitPolicy": {
							"shape": "Sz"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"FleetAttributes": {
							"shape": "S12"
						}
					}
				}
			},
			"CreateGameSession": {
				"input": {
					"type": "structure",
					"required": [
						"MaximumPlayerSessionCount"
					],
					"members": {
						"FleetId": {},
						"AliasId": {},
						"MaximumPlayerSessionCount": {
							"type": "integer"
						},
						"Name": {},
						"GameProperties": {
							"shape": "S15"
						},
						"CreatorId": {},
						"GameSessionId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"GameSession": {
							"shape": "S1b"
						}
					}
				}
			},
			"CreatePlayerSession": {
				"input": {
					"type": "structure",
					"required": [
						"GameSessionId",
						"PlayerId"
					],
					"members": {
						"GameSessionId": {},
						"PlayerId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"PlayerSession": {
							"shape": "S1i"
						}
					}
				}
			},
			"CreatePlayerSessions": {
				"input": {
					"type": "structure",
					"required": [
						"GameSessionId",
						"PlayerIds"
					],
					"members": {
						"GameSessionId": {},
						"PlayerIds": {
							"type": "list",
							"member": {}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"PlayerSessions": {
							"shape": "S1o"
						}
					}
				}
			},
			"DeleteAlias": {
				"input": {
					"type": "structure",
					"required": [
						"AliasId"
					],
					"members": {
						"AliasId": {}
					}
				}
			},
			"DeleteBuild": {
				"input": {
					"type": "structure",
					"required": [
						"BuildId"
					],
					"members": {
						"BuildId": {}
					}
				}
			},
			"DeleteFleet": {
				"input": {
					"type": "structure",
					"required": [
						"FleetId"
					],
					"members": {
						"FleetId": {}
					}
				}
			},
			"DeleteScalingPolicy": {
				"input": {
					"type": "structure",
					"required": [
						"Name",
						"FleetId"
					],
					"members": {
						"Name": {},
						"FleetId": {}
					}
				}
			},
			"DescribeAlias": {
				"input": {
					"type": "structure",
					"required": [
						"AliasId"
					],
					"members": {
						"AliasId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Alias": {
							"shape": "S9"
						}
					}
				}
			},
			"DescribeBuild": {
				"input": {
					"type": "structure",
					"required": [
						"BuildId"
					],
					"members": {
						"BuildId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Build": {
							"shape": "Sh"
						}
					}
				}
			},
			"DescribeEC2InstanceLimits": {
				"input": {
					"type": "structure",
					"members": {
						"EC2InstanceType": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"EC2InstanceLimits": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"EC2InstanceType": {},
									"CurrentInstances": {
										"type": "integer"
									},
									"InstanceLimit": {
										"type": "integer"
									}
								}
							}
						}
					}
				}
			},
			"DescribeFleetAttributes": {
				"input": {
					"type": "structure",
					"members": {
						"FleetIds": {
							"shape": "S22"
						},
						"Limit": {
							"type": "integer"
						},
						"NextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"FleetAttributes": {
							"type": "list",
							"member": {
								"shape": "S12"
							}
						},
						"NextToken": {}
					}
				}
			},
			"DescribeFleetCapacity": {
				"input": {
					"type": "structure",
					"members": {
						"FleetIds": {
							"shape": "S22"
						},
						"Limit": {
							"type": "integer"
						},
						"NextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"FleetCapacity": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"FleetId": {},
									"InstanceType": {},
									"InstanceCounts": {
										"type": "structure",
										"members": {
											"DESIRED": {
												"type": "integer"
											},
											"MINIMUM": {
												"type": "integer"
											},
											"MAXIMUM": {
												"type": "integer"
											},
											"PENDING": {
												"type": "integer"
											},
											"ACTIVE": {
												"type": "integer"
											},
											"IDLE": {
												"type": "integer"
											},
											"TERMINATING": {
												"type": "integer"
											}
										}
									}
								}
							}
						},
						"NextToken": {}
					}
				}
			},
			"DescribeFleetEvents": {
				"input": {
					"type": "structure",
					"required": [
						"FleetId"
					],
					"members": {
						"FleetId": {},
						"StartTime": {
							"type": "timestamp"
						},
						"EndTime": {
							"type": "timestamp"
						},
						"Limit": {
							"type": "integer"
						},
						"NextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Events": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"EventId": {},
									"ResourceId": {},
									"EventCode": {},
									"Message": {},
									"EventTime": {
										"type": "timestamp"
									}
								}
							}
						},
						"NextToken": {}
					}
				}
			},
			"DescribeFleetPortSettings": {
				"input": {
					"type": "structure",
					"required": [
						"FleetId"
					],
					"members": {
						"FleetId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"InboundPermissions": {
							"shape": "Sp"
						}
					}
				}
			},
			"DescribeFleetUtilization": {
				"input": {
					"type": "structure",
					"members": {
						"FleetIds": {
							"shape": "S22"
						},
						"Limit": {
							"type": "integer"
						},
						"NextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"FleetUtilization": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"FleetId": {},
									"ActiveServerProcessCount": {
										"type": "integer"
									},
									"ActiveGameSessionCount": {
										"type": "integer"
									},
									"CurrentPlayerSessionCount": {
										"type": "integer"
									},
									"MaximumPlayerSessionCount": {
										"type": "integer"
									}
								}
							}
						},
						"NextToken": {}
					}
				}
			},
			"DescribeGameSessionDetails": {
				"input": {
					"type": "structure",
					"members": {
						"FleetId": {},
						"GameSessionId": {},
						"AliasId": {},
						"StatusFilter": {},
						"Limit": {
							"type": "integer"
						},
						"NextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"GameSessionDetails": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"GameSession": {
										"shape": "S1b"
									},
									"ProtectionPolicy": {}
								}
							}
						},
						"NextToken": {}
					}
				}
			},
			"DescribeGameSessions": {
				"input": {
					"type": "structure",
					"members": {
						"FleetId": {},
						"GameSessionId": {},
						"AliasId": {},
						"StatusFilter": {},
						"Limit": {
							"type": "integer"
						},
						"NextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"GameSessions": {
							"shape": "S2r"
						},
						"NextToken": {}
					}
				}
			},
			"DescribeInstances": {
				"input": {
					"type": "structure",
					"required": [
						"FleetId"
					],
					"members": {
						"FleetId": {},
						"InstanceId": {},
						"Limit": {
							"type": "integer"
						},
						"NextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Instances": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"FleetId": {},
									"InstanceId": {},
									"IpAddress": {},
									"OperatingSystem": {},
									"Type": {},
									"Status": {},
									"CreationTime": {
										"type": "timestamp"
									}
								}
							}
						},
						"NextToken": {}
					}
				}
			},
			"DescribePlayerSessions": {
				"input": {
					"type": "structure",
					"members": {
						"GameSessionId": {},
						"PlayerId": {},
						"PlayerSessionId": {},
						"PlayerSessionStatusFilter": {},
						"Limit": {
							"type": "integer"
						},
						"NextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"PlayerSessions": {
							"shape": "S1o"
						},
						"NextToken": {}
					}
				}
			},
			"DescribeRuntimeConfiguration": {
				"input": {
					"type": "structure",
					"required": [
						"FleetId"
					],
					"members": {
						"FleetId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"RuntimeConfiguration": {
							"shape": "Sv"
						}
					}
				}
			},
			"DescribeScalingPolicies": {
				"input": {
					"type": "structure",
					"required": [
						"FleetId"
					],
					"members": {
						"FleetId": {},
						"StatusFilter": {},
						"Limit": {
							"type": "integer"
						},
						"NextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ScalingPolicies": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"FleetId": {},
									"Name": {},
									"Status": {},
									"ScalingAdjustment": {
										"type": "integer"
									},
									"ScalingAdjustmentType": {},
									"ComparisonOperator": {},
									"Threshold": {
										"type": "double"
									},
									"EvaluationPeriods": {
										"type": "integer"
									},
									"MetricName": {}
								}
							}
						},
						"NextToken": {}
					}
				}
			},
			"GetGameSessionLogUrl": {
				"input": {
					"type": "structure",
					"required": [
						"GameSessionId"
					],
					"members": {
						"GameSessionId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"PreSignedUrl": {}
					}
				}
			},
			"ListAliases": {
				"input": {
					"type": "structure",
					"members": {
						"RoutingStrategyType": {},
						"Name": {},
						"Limit": {
							"type": "integer"
						},
						"NextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Aliases": {
							"type": "list",
							"member": {
								"shape": "S9"
							}
						},
						"NextToken": {}
					}
				}
			},
			"ListBuilds": {
				"input": {
					"type": "structure",
					"members": {
						"Status": {},
						"Limit": {
							"type": "integer"
						},
						"NextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Builds": {
							"type": "list",
							"member": {
								"shape": "Sh"
							}
						},
						"NextToken": {}
					}
				}
			},
			"ListFleets": {
				"input": {
					"type": "structure",
					"members": {
						"BuildId": {},
						"Limit": {
							"type": "integer"
						},
						"NextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"FleetIds": {
							"shape": "S22"
						},
						"NextToken": {}
					}
				}
			},
			"PutScalingPolicy": {
				"input": {
					"type": "structure",
					"required": [
						"Name",
						"FleetId",
						"ScalingAdjustment",
						"ScalingAdjustmentType",
						"Threshold",
						"ComparisonOperator",
						"EvaluationPeriods",
						"MetricName"
					],
					"members": {
						"Name": {},
						"FleetId": {},
						"ScalingAdjustment": {
							"type": "integer"
						},
						"ScalingAdjustmentType": {},
						"Threshold": {
							"type": "double"
						},
						"ComparisonOperator": {},
						"EvaluationPeriods": {
							"type": "integer"
						},
						"MetricName": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Name": {}
					}
				}
			},
			"RequestUploadCredentials": {
				"input": {
					"type": "structure",
					"required": [
						"BuildId"
					],
					"members": {
						"BuildId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"UploadCredentials": {
							"shape": "Sl"
						},
						"StorageLocation": {
							"shape": "Sd"
						}
					}
				}
			},
			"ResolveAlias": {
				"input": {
					"type": "structure",
					"required": [
						"AliasId"
					],
					"members": {
						"AliasId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"FleetId": {}
					}
				}
			},
			"SearchGameSessions": {
				"input": {
					"type": "structure",
					"members": {
						"FleetId": {},
						"AliasId": {},
						"FilterExpression": {},
						"SortExpression": {},
						"Limit": {
							"type": "integer"
						},
						"NextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"GameSessions": {
							"shape": "S2r"
						},
						"NextToken": {}
					}
				}
			},
			"UpdateAlias": {
				"input": {
					"type": "structure",
					"required": [
						"AliasId"
					],
					"members": {
						"AliasId": {},
						"Name": {},
						"Description": {},
						"RoutingStrategy": {
							"shape": "S4"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Alias": {
							"shape": "S9"
						}
					}
				}
			},
			"UpdateBuild": {
				"input": {
					"type": "structure",
					"required": [
						"BuildId"
					],
					"members": {
						"BuildId": {},
						"Name": {},
						"Version": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Build": {
							"shape": "Sh"
						}
					}
				}
			},
			"UpdateFleetAttributes": {
				"input": {
					"type": "structure",
					"required": [
						"FleetId"
					],
					"members": {
						"FleetId": {},
						"Name": {},
						"Description": {},
						"NewGameSessionProtectionPolicy": {},
						"ResourceCreationLimitPolicy": {
							"shape": "Sz"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"FleetId": {}
					}
				}
			},
			"UpdateFleetCapacity": {
				"input": {
					"type": "structure",
					"required": [
						"FleetId"
					],
					"members": {
						"FleetId": {},
						"DesiredInstances": {
							"type": "integer"
						},
						"MinSize": {
							"type": "integer"
						},
						"MaxSize": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"FleetId": {}
					}
				}
			},
			"UpdateFleetPortSettings": {
				"input": {
					"type": "structure",
					"required": [
						"FleetId"
					],
					"members": {
						"FleetId": {},
						"InboundPermissionAuthorizations": {
							"shape": "Sp"
						},
						"InboundPermissionRevocations": {
							"shape": "Sp"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"FleetId": {}
					}
				}
			},
			"UpdateGameSession": {
				"input": {
					"type": "structure",
					"required": [
						"GameSessionId"
					],
					"members": {
						"GameSessionId": {},
						"MaximumPlayerSessionCount": {
							"type": "integer"
						},
						"Name": {},
						"PlayerSessionCreationPolicy": {},
						"ProtectionPolicy": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"GameSession": {
							"shape": "S1b"
						}
					}
				}
			},
			"UpdateRuntimeConfiguration": {
				"input": {
					"type": "structure",
					"required": [
						"FleetId",
						"RuntimeConfiguration"
					],
					"members": {
						"FleetId": {},
						"RuntimeConfiguration": {
							"shape": "Sv"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"RuntimeConfiguration": {
							"shape": "Sv"
						}
					}
				}
			}
		},
		"shapes": {
			"S4": {
				"type": "structure",
				"members": {
					"Type": {},
					"FleetId": {},
					"Message": {}
				}
			},
			"S9": {
				"type": "structure",
				"members": {
					"AliasId": {},
					"Name": {},
					"Description": {},
					"RoutingStrategy": {
						"shape": "S4"
					},
					"CreationTime": {
						"type": "timestamp"
					},
					"LastUpdatedTime": {
						"type": "timestamp"
					}
				}
			},
			"Sd": {
				"type": "structure",
				"members": {
					"Bucket": {},
					"Key": {},
					"RoleArn": {}
				}
			},
			"Sh": {
				"type": "structure",
				"members": {
					"BuildId": {},
					"Name": {},
					"Version": {},
					"Status": {},
					"SizeOnDisk": {
						"type": "long"
					},
					"OperatingSystem": {},
					"CreationTime": {
						"type": "timestamp"
					}
				}
			},
			"Sl": {
				"type": "structure",
				"members": {
					"AccessKeyId": {},
					"SecretAccessKey": {},
					"SessionToken": {}
				},
				"sensitive": true
			},
			"Sn": {
				"type": "list",
				"member": {}
			},
			"Sp": {
				"type": "list",
				"member": {
					"type": "structure",
					"required": [
						"FromPort",
						"ToPort",
						"IpRange",
						"Protocol"
					],
					"members": {
						"FromPort": {
							"type": "integer"
						},
						"ToPort": {
							"type": "integer"
						},
						"IpRange": {},
						"Protocol": {}
					}
				}
			},
			"Sv": {
				"type": "structure",
				"members": {
					"ServerProcesses": {
						"type": "list",
						"member": {
							"type": "structure",
							"required": [
								"LaunchPath",
								"ConcurrentExecutions"
							],
							"members": {
								"LaunchPath": {},
								"Parameters": {},
								"ConcurrentExecutions": {
									"type": "integer"
								}
							}
						}
					}
				}
			},
			"Sz": {
				"type": "structure",
				"members": {
					"NewGameSessionsPerCreator": {
						"type": "integer"
					},
					"PolicyPeriodInMinutes": {
						"type": "integer"
					}
				}
			},
			"S12": {
				"type": "structure",
				"members": {
					"FleetId": {},
					"Description": {},
					"Name": {},
					"CreationTime": {
						"type": "timestamp"
					},
					"TerminationTime": {
						"type": "timestamp"
					},
					"Status": {},
					"BuildId": {},
					"ServerLaunchPath": {},
					"ServerLaunchParameters": {},
					"LogPaths": {
						"shape": "Sn"
					},
					"NewGameSessionProtectionPolicy": {},
					"OperatingSystem": {},
					"ResourceCreationLimitPolicy": {
						"shape": "Sz"
					}
				}
			},
			"S15": {
				"type": "list",
				"member": {
					"type": "structure",
					"required": [
						"Key",
						"Value"
					],
					"members": {
						"Key": {},
						"Value": {}
					}
				}
			},
			"S1b": {
				"type": "structure",
				"members": {
					"GameSessionId": {},
					"Name": {},
					"FleetId": {},
					"CreationTime": {
						"type": "timestamp"
					},
					"TerminationTime": {
						"type": "timestamp"
					},
					"CurrentPlayerSessionCount": {
						"type": "integer"
					},
					"MaximumPlayerSessionCount": {
						"type": "integer"
					},
					"Status": {},
					"GameProperties": {
						"shape": "S15"
					},
					"IpAddress": {},
					"Port": {
						"type": "integer"
					},
					"PlayerSessionCreationPolicy": {},
					"CreatorId": {}
				}
			},
			"S1i": {
				"type": "structure",
				"members": {
					"PlayerSessionId": {},
					"PlayerId": {},
					"GameSessionId": {},
					"FleetId": {},
					"CreationTime": {
						"type": "timestamp"
					},
					"TerminationTime": {
						"type": "timestamp"
					},
					"Status": {},
					"IpAddress": {},
					"Port": {
						"type": "integer"
					}
				}
			},
			"S1o": {
				"type": "list",
				"member": {
					"shape": "S1i"
				}
			},
			"S22": {
				"type": "list",
				"member": {}
			},
			"S2r": {
				"type": "list",
				"member": {
					"shape": "S1b"
				}
			}
		}
	};

/***/ },
/* 369 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['glacier'] = {};
	AWS.Glacier = Service.defineService('glacier', ['2012-06-01']);
	__webpack_require__(370);
	Object.defineProperty(apiLoader.services['glacier'], '2012-06-01', {
	  get: function get() {
	    var model = __webpack_require__(371);
	    model.paginators = __webpack_require__(372).pagination;
	    model.waiters = __webpack_require__(373).waiters;
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.Glacier;


/***/ },
/* 370 */
/***/ function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(93);

	AWS.util.update(AWS.Glacier.prototype, {
	  /**
	   * @api private
	   */
	  setupRequestListeners: function setupRequestListeners(request) {
	    if (Array.isArray(request._events.validate)) {
	      request._events.validate.unshift(this.validateAccountId);
	    } else {
	      request.on('validate', this.validateAccountId);
	    }
	    request.removeListener('afterBuild',
	      AWS.EventListeners.Core.COMPUTE_SHA256);
	    request.on('build', this.addGlacierApiVersion);
	    request.on('build', this.addTreeHashHeaders);
	  },

	  /**
	   * @api private
	   */
	  validateAccountId: function validateAccountId(request) {
	    if (request.params.accountId !== undefined) return;
	    request.params = AWS.util.copy(request.params);
	    request.params.accountId = '-';
	  },

	  /**
	   * @api private
	   */
	  addGlacierApiVersion: function addGlacierApiVersion(request) {
	    var version = request.service.api.apiVersion;
	    request.httpRequest.headers['x-amz-glacier-version'] = version;
	  },

	  /**
	   * @api private
	   */
	  addTreeHashHeaders: function addTreeHashHeaders(request) {
	    if (request.params.body === undefined) return;

	    var hashes = request.service.computeChecksums(request.params.body);
	    request.httpRequest.headers['X-Amz-Content-Sha256'] = hashes.linearHash;

	    if (!request.httpRequest.headers['x-amz-sha256-tree-hash']) {
	      request.httpRequest.headers['x-amz-sha256-tree-hash'] = hashes.treeHash;
	    }
	  },

	  /**
	   * @!group Computing Checksums
	   */

	  /**
	   * Computes the SHA-256 linear and tree hash checksums for a given
	   * block of Buffer data. Pass the tree hash of the computed checksums
	   * as the checksum input to the {completeMultipartUpload} when performing
	   * a multi-part upload.
	   *
	   * @example Calculate checksum of 5.5MB data chunk
	   *   var glacier = new AWS.Glacier();
	   *   var data = new Buffer(5.5 * 1024 * 1024);
	   *   data.fill('0'); // fill with zeros
	   *   var results = glacier.computeChecksums(data);
	   *   // Result: { linearHash: '68aff0c5a9...', treeHash: '154e26c78f...' }
	   * @param data [Buffer, String] data to calculate the checksum for
	   * @return [map<linearHash:String,treeHash:String>] a map containing
	   *   the linearHash and treeHash properties representing hex based digests
	   *   of the respective checksums.
	   * @see completeMultipartUpload
	   */
	  computeChecksums: function computeChecksums(data) {
	    if (!AWS.util.Buffer.isBuffer(data)) data = new AWS.util.Buffer(data);

	    var mb = 1024 * 1024;
	    var hashes = [];
	    var hash = AWS.util.crypto.createHash('sha256');

	    // build leaf nodes in 1mb chunks
	    for (var i = 0; i < data.length; i += mb) {
	      var chunk = data.slice(i, Math.min(i + mb, data.length));
	      hash.update(chunk);
	      hashes.push(AWS.util.crypto.sha256(chunk));
	    }

	    return {
	      linearHash: hash.digest('hex'),
	      treeHash: this.buildHashTree(hashes)
	    };
	  },

	  /**
	   * @api private
	   */
	  buildHashTree: function buildHashTree(hashes) {
	    // merge leaf nodes
	    while (hashes.length > 1) {
	      var tmpHashes = [];
	      for (var i = 0; i < hashes.length; i += 2) {
	        if (hashes[i + 1]) {
	          var tmpHash = new AWS.util.Buffer(64);
	          tmpHash.write(hashes[i], 0, 32, 'binary');
	          tmpHash.write(hashes[i + 1], 32, 32, 'binary');
	          tmpHashes.push(AWS.util.crypto.sha256(tmpHash));
	        } else {
	          tmpHashes.push(hashes[i]);
	        }
	      }
	      hashes = tmpHashes;
	    }

	    return AWS.util.crypto.toHex(hashes[0]);
	  }
	});


/***/ },
/* 371 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2012-06-01",
			"checksumFormat": "sha256",
			"endpointPrefix": "glacier",
			"serviceFullName": "Amazon Glacier",
			"signatureVersion": "v4",
			"protocol": "rest-json"
		},
		"operations": {
			"AbortMultipartUpload": {
				"http": {
					"method": "DELETE",
					"requestUri": "/{accountId}/vaults/{vaultName}/multipart-uploads/{uploadId}",
					"responseCode": 204
				},
				"input": {
					"type": "structure",
					"members": {
						"accountId": {
							"location": "uri",
							"locationName": "accountId"
						},
						"vaultName": {
							"location": "uri",
							"locationName": "vaultName"
						},
						"uploadId": {
							"location": "uri",
							"locationName": "uploadId"
						}
					},
					"required": [
						"accountId",
						"vaultName",
						"uploadId"
					]
				}
			},
			"AbortVaultLock": {
				"http": {
					"method": "DELETE",
					"requestUri": "/{accountId}/vaults/{vaultName}/lock-policy",
					"responseCode": 204
				},
				"input": {
					"type": "structure",
					"members": {
						"accountId": {
							"location": "uri",
							"locationName": "accountId"
						},
						"vaultName": {
							"location": "uri",
							"locationName": "vaultName"
						}
					},
					"required": [
						"accountId",
						"vaultName"
					]
				}
			},
			"AddTagsToVault": {
				"http": {
					"requestUri": "/{accountId}/vaults/{vaultName}/tags?operation=add",
					"responseCode": 204
				},
				"input": {
					"type": "structure",
					"members": {
						"accountId": {
							"location": "uri",
							"locationName": "accountId"
						},
						"vaultName": {
							"location": "uri",
							"locationName": "vaultName"
						},
						"Tags": {
							"shape": "S5"
						}
					},
					"required": [
						"accountId",
						"vaultName"
					]
				}
			},
			"CompleteMultipartUpload": {
				"http": {
					"requestUri": "/{accountId}/vaults/{vaultName}/multipart-uploads/{uploadId}",
					"responseCode": 201
				},
				"input": {
					"type": "structure",
					"members": {
						"accountId": {
							"location": "uri",
							"locationName": "accountId"
						},
						"vaultName": {
							"location": "uri",
							"locationName": "vaultName"
						},
						"uploadId": {
							"location": "uri",
							"locationName": "uploadId"
						},
						"archiveSize": {
							"location": "header",
							"locationName": "x-amz-archive-size"
						},
						"checksum": {
							"location": "header",
							"locationName": "x-amz-sha256-tree-hash"
						}
					},
					"required": [
						"accountId",
						"vaultName",
						"uploadId"
					]
				},
				"output": {
					"shape": "S9"
				}
			},
			"CompleteVaultLock": {
				"http": {
					"requestUri": "/{accountId}/vaults/{vaultName}/lock-policy/{lockId}",
					"responseCode": 204
				},
				"input": {
					"type": "structure",
					"members": {
						"accountId": {
							"location": "uri",
							"locationName": "accountId"
						},
						"vaultName": {
							"location": "uri",
							"locationName": "vaultName"
						},
						"lockId": {
							"location": "uri",
							"locationName": "lockId"
						}
					},
					"required": [
						"accountId",
						"vaultName",
						"lockId"
					]
				}
			},
			"CreateVault": {
				"http": {
					"method": "PUT",
					"requestUri": "/{accountId}/vaults/{vaultName}",
					"responseCode": 201
				},
				"input": {
					"type": "structure",
					"members": {
						"accountId": {
							"location": "uri",
							"locationName": "accountId"
						},
						"vaultName": {
							"location": "uri",
							"locationName": "vaultName"
						}
					},
					"required": [
						"accountId",
						"vaultName"
					]
				},
				"output": {
					"type": "structure",
					"members": {
						"location": {
							"location": "header",
							"locationName": "Location"
						}
					}
				}
			},
			"DeleteArchive": {
				"http": {
					"method": "DELETE",
					"requestUri": "/{accountId}/vaults/{vaultName}/archives/{archiveId}",
					"responseCode": 204
				},
				"input": {
					"type": "structure",
					"members": {
						"accountId": {
							"location": "uri",
							"locationName": "accountId"
						},
						"vaultName": {
							"location": "uri",
							"locationName": "vaultName"
						},
						"archiveId": {
							"location": "uri",
							"locationName": "archiveId"
						}
					},
					"required": [
						"accountId",
						"vaultName",
						"archiveId"
					]
				}
			},
			"DeleteVault": {
				"http": {
					"method": "DELETE",
					"requestUri": "/{accountId}/vaults/{vaultName}",
					"responseCode": 204
				},
				"input": {
					"type": "structure",
					"members": {
						"accountId": {
							"location": "uri",
							"locationName": "accountId"
						},
						"vaultName": {
							"location": "uri",
							"locationName": "vaultName"
						}
					},
					"required": [
						"accountId",
						"vaultName"
					]
				}
			},
			"DeleteVaultAccessPolicy": {
				"http": {
					"method": "DELETE",
					"requestUri": "/{accountId}/vaults/{vaultName}/access-policy",
					"responseCode": 204
				},
				"input": {
					"type": "structure",
					"members": {
						"accountId": {
							"location": "uri",
							"locationName": "accountId"
						},
						"vaultName": {
							"location": "uri",
							"locationName": "vaultName"
						}
					},
					"required": [
						"accountId",
						"vaultName"
					]
				}
			},
			"DeleteVaultNotifications": {
				"http": {
					"method": "DELETE",
					"requestUri": "/{accountId}/vaults/{vaultName}/notification-configuration",
					"responseCode": 204
				},
				"input": {
					"type": "structure",
					"members": {
						"accountId": {
							"location": "uri",
							"locationName": "accountId"
						},
						"vaultName": {
							"location": "uri",
							"locationName": "vaultName"
						}
					},
					"required": [
						"accountId",
						"vaultName"
					]
				}
			},
			"DescribeJob": {
				"http": {
					"method": "GET",
					"requestUri": "/{accountId}/vaults/{vaultName}/jobs/{jobId}"
				},
				"input": {
					"type": "structure",
					"members": {
						"accountId": {
							"location": "uri",
							"locationName": "accountId"
						},
						"vaultName": {
							"location": "uri",
							"locationName": "vaultName"
						},
						"jobId": {
							"location": "uri",
							"locationName": "jobId"
						}
					},
					"required": [
						"accountId",
						"vaultName",
						"jobId"
					]
				},
				"output": {
					"shape": "Si"
				}
			},
			"DescribeVault": {
				"http": {
					"method": "GET",
					"requestUri": "/{accountId}/vaults/{vaultName}"
				},
				"input": {
					"type": "structure",
					"members": {
						"accountId": {
							"location": "uri",
							"locationName": "accountId"
						},
						"vaultName": {
							"location": "uri",
							"locationName": "vaultName"
						}
					},
					"required": [
						"accountId",
						"vaultName"
					]
				},
				"output": {
					"shape": "Sq"
				}
			},
			"GetDataRetrievalPolicy": {
				"http": {
					"method": "GET",
					"requestUri": "/{accountId}/policies/data-retrieval"
				},
				"input": {
					"type": "structure",
					"members": {
						"accountId": {
							"location": "uri",
							"locationName": "accountId"
						}
					},
					"required": [
						"accountId"
					]
				},
				"output": {
					"type": "structure",
					"members": {
						"Policy": {
							"shape": "Su"
						}
					}
				}
			},
			"GetJobOutput": {
				"http": {
					"method": "GET",
					"requestUri": "/{accountId}/vaults/{vaultName}/jobs/{jobId}/output"
				},
				"input": {
					"type": "structure",
					"members": {
						"accountId": {
							"location": "uri",
							"locationName": "accountId"
						},
						"vaultName": {
							"location": "uri",
							"locationName": "vaultName"
						},
						"jobId": {
							"location": "uri",
							"locationName": "jobId"
						},
						"range": {
							"location": "header",
							"locationName": "Range"
						}
					},
					"required": [
						"accountId",
						"vaultName",
						"jobId"
					]
				},
				"output": {
					"type": "structure",
					"members": {
						"body": {
							"shape": "S10"
						},
						"checksum": {
							"location": "header",
							"locationName": "x-amz-sha256-tree-hash"
						},
						"status": {
							"location": "statusCode",
							"type": "integer"
						},
						"contentRange": {
							"location": "header",
							"locationName": "Content-Range"
						},
						"acceptRanges": {
							"location": "header",
							"locationName": "Accept-Ranges"
						},
						"contentType": {
							"location": "header",
							"locationName": "Content-Type"
						},
						"archiveDescription": {
							"location": "header",
							"locationName": "x-amz-archive-description"
						}
					},
					"payload": "body"
				}
			},
			"GetVaultAccessPolicy": {
				"http": {
					"method": "GET",
					"requestUri": "/{accountId}/vaults/{vaultName}/access-policy"
				},
				"input": {
					"type": "structure",
					"members": {
						"accountId": {
							"location": "uri",
							"locationName": "accountId"
						},
						"vaultName": {
							"location": "uri",
							"locationName": "vaultName"
						}
					},
					"required": [
						"accountId",
						"vaultName"
					]
				},
				"output": {
					"type": "structure",
					"members": {
						"policy": {
							"shape": "S14"
						}
					},
					"payload": "policy"
				}
			},
			"GetVaultLock": {
				"http": {
					"method": "GET",
					"requestUri": "/{accountId}/vaults/{vaultName}/lock-policy"
				},
				"input": {
					"type": "structure",
					"members": {
						"accountId": {
							"location": "uri",
							"locationName": "accountId"
						},
						"vaultName": {
							"location": "uri",
							"locationName": "vaultName"
						}
					},
					"required": [
						"accountId",
						"vaultName"
					]
				},
				"output": {
					"type": "structure",
					"members": {
						"Policy": {},
						"State": {},
						"ExpirationDate": {},
						"CreationDate": {}
					}
				}
			},
			"GetVaultNotifications": {
				"http": {
					"method": "GET",
					"requestUri": "/{accountId}/vaults/{vaultName}/notification-configuration"
				},
				"input": {
					"type": "structure",
					"members": {
						"accountId": {
							"location": "uri",
							"locationName": "accountId"
						},
						"vaultName": {
							"location": "uri",
							"locationName": "vaultName"
						}
					},
					"required": [
						"accountId",
						"vaultName"
					]
				},
				"output": {
					"type": "structure",
					"members": {
						"vaultNotificationConfig": {
							"shape": "S19"
						}
					},
					"payload": "vaultNotificationConfig"
				}
			},
			"InitiateJob": {
				"http": {
					"requestUri": "/{accountId}/vaults/{vaultName}/jobs",
					"responseCode": 202
				},
				"input": {
					"type": "structure",
					"members": {
						"accountId": {
							"location": "uri",
							"locationName": "accountId"
						},
						"vaultName": {
							"location": "uri",
							"locationName": "vaultName"
						},
						"jobParameters": {
							"type": "structure",
							"members": {
								"Format": {},
								"Type": {},
								"ArchiveId": {},
								"Description": {},
								"SNSTopic": {},
								"RetrievalByteRange": {},
								"InventoryRetrievalParameters": {
									"type": "structure",
									"members": {
										"StartDate": {},
										"EndDate": {},
										"Limit": {},
										"Marker": {}
									}
								}
							}
						}
					},
					"required": [
						"accountId",
						"vaultName"
					],
					"payload": "jobParameters"
				},
				"output": {
					"type": "structure",
					"members": {
						"location": {
							"location": "header",
							"locationName": "Location"
						},
						"jobId": {
							"location": "header",
							"locationName": "x-amz-job-id"
						}
					}
				}
			},
			"InitiateMultipartUpload": {
				"http": {
					"requestUri": "/{accountId}/vaults/{vaultName}/multipart-uploads",
					"responseCode": 201
				},
				"input": {
					"type": "structure",
					"members": {
						"accountId": {
							"location": "uri",
							"locationName": "accountId"
						},
						"vaultName": {
							"location": "uri",
							"locationName": "vaultName"
						},
						"archiveDescription": {
							"location": "header",
							"locationName": "x-amz-archive-description"
						},
						"partSize": {
							"location": "header",
							"locationName": "x-amz-part-size"
						}
					},
					"required": [
						"accountId",
						"vaultName"
					]
				},
				"output": {
					"type": "structure",
					"members": {
						"location": {
							"location": "header",
							"locationName": "Location"
						},
						"uploadId": {
							"location": "header",
							"locationName": "x-amz-multipart-upload-id"
						}
					}
				}
			},
			"InitiateVaultLock": {
				"http": {
					"requestUri": "/{accountId}/vaults/{vaultName}/lock-policy",
					"responseCode": 201
				},
				"input": {
					"type": "structure",
					"members": {
						"accountId": {
							"location": "uri",
							"locationName": "accountId"
						},
						"vaultName": {
							"location": "uri",
							"locationName": "vaultName"
						},
						"policy": {
							"type": "structure",
							"members": {
								"Policy": {}
							}
						}
					},
					"required": [
						"accountId",
						"vaultName"
					],
					"payload": "policy"
				},
				"output": {
					"type": "structure",
					"members": {
						"lockId": {
							"location": "header",
							"locationName": "x-amz-lock-id"
						}
					}
				}
			},
			"ListJobs": {
				"http": {
					"method": "GET",
					"requestUri": "/{accountId}/vaults/{vaultName}/jobs"
				},
				"input": {
					"type": "structure",
					"members": {
						"accountId": {
							"location": "uri",
							"locationName": "accountId"
						},
						"vaultName": {
							"location": "uri",
							"locationName": "vaultName"
						},
						"limit": {
							"location": "querystring",
							"locationName": "limit"
						},
						"marker": {
							"location": "querystring",
							"locationName": "marker"
						},
						"statuscode": {
							"location": "querystring",
							"locationName": "statuscode"
						},
						"completed": {
							"location": "querystring",
							"locationName": "completed"
						}
					},
					"required": [
						"accountId",
						"vaultName"
					]
				},
				"output": {
					"type": "structure",
					"members": {
						"JobList": {
							"type": "list",
							"member": {
								"shape": "Si"
							}
						},
						"Marker": {}
					}
				}
			},
			"ListMultipartUploads": {
				"http": {
					"method": "GET",
					"requestUri": "/{accountId}/vaults/{vaultName}/multipart-uploads"
				},
				"input": {
					"type": "structure",
					"members": {
						"accountId": {
							"location": "uri",
							"locationName": "accountId"
						},
						"vaultName": {
							"location": "uri",
							"locationName": "vaultName"
						},
						"marker": {
							"location": "querystring",
							"locationName": "marker"
						},
						"limit": {
							"location": "querystring",
							"locationName": "limit"
						}
					},
					"required": [
						"accountId",
						"vaultName"
					]
				},
				"output": {
					"type": "structure",
					"members": {
						"UploadsList": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"MultipartUploadId": {},
									"VaultARN": {},
									"ArchiveDescription": {},
									"PartSizeInBytes": {
										"type": "long"
									},
									"CreationDate": {}
								}
							}
						},
						"Marker": {}
					}
				}
			},
			"ListParts": {
				"http": {
					"method": "GET",
					"requestUri": "/{accountId}/vaults/{vaultName}/multipart-uploads/{uploadId}"
				},
				"input": {
					"type": "structure",
					"members": {
						"accountId": {
							"location": "uri",
							"locationName": "accountId"
						},
						"vaultName": {
							"location": "uri",
							"locationName": "vaultName"
						},
						"uploadId": {
							"location": "uri",
							"locationName": "uploadId"
						},
						"marker": {
							"location": "querystring",
							"locationName": "marker"
						},
						"limit": {
							"location": "querystring",
							"locationName": "limit"
						}
					},
					"required": [
						"accountId",
						"vaultName",
						"uploadId"
					]
				},
				"output": {
					"type": "structure",
					"members": {
						"MultipartUploadId": {},
						"VaultARN": {},
						"ArchiveDescription": {},
						"PartSizeInBytes": {
							"type": "long"
						},
						"CreationDate": {},
						"Parts": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"RangeInBytes": {},
									"SHA256TreeHash": {}
								}
							}
						},
						"Marker": {}
					}
				}
			},
			"ListTagsForVault": {
				"http": {
					"method": "GET",
					"requestUri": "/{accountId}/vaults/{vaultName}/tags"
				},
				"input": {
					"type": "structure",
					"members": {
						"accountId": {
							"location": "uri",
							"locationName": "accountId"
						},
						"vaultName": {
							"location": "uri",
							"locationName": "vaultName"
						}
					},
					"required": [
						"accountId",
						"vaultName"
					]
				},
				"output": {
					"type": "structure",
					"members": {
						"Tags": {
							"shape": "S5"
						}
					}
				}
			},
			"ListVaults": {
				"http": {
					"method": "GET",
					"requestUri": "/{accountId}/vaults"
				},
				"input": {
					"type": "structure",
					"members": {
						"accountId": {
							"location": "uri",
							"locationName": "accountId"
						},
						"marker": {
							"location": "querystring",
							"locationName": "marker"
						},
						"limit": {
							"location": "querystring",
							"locationName": "limit"
						}
					},
					"required": [
						"accountId"
					]
				},
				"output": {
					"type": "structure",
					"members": {
						"VaultList": {
							"type": "list",
							"member": {
								"shape": "Sq"
							}
						},
						"Marker": {}
					}
				}
			},
			"RemoveTagsFromVault": {
				"http": {
					"requestUri": "/{accountId}/vaults/{vaultName}/tags?operation=remove",
					"responseCode": 204
				},
				"input": {
					"type": "structure",
					"members": {
						"accountId": {
							"location": "uri",
							"locationName": "accountId"
						},
						"vaultName": {
							"location": "uri",
							"locationName": "vaultName"
						},
						"TagKeys": {
							"type": "list",
							"member": {}
						}
					},
					"required": [
						"accountId",
						"vaultName"
					]
				}
			},
			"SetDataRetrievalPolicy": {
				"http": {
					"method": "PUT",
					"requestUri": "/{accountId}/policies/data-retrieval",
					"responseCode": 204
				},
				"input": {
					"type": "structure",
					"members": {
						"accountId": {
							"location": "uri",
							"locationName": "accountId"
						},
						"Policy": {
							"shape": "Su"
						}
					},
					"required": [
						"accountId"
					]
				}
			},
			"SetVaultAccessPolicy": {
				"http": {
					"method": "PUT",
					"requestUri": "/{accountId}/vaults/{vaultName}/access-policy",
					"responseCode": 204
				},
				"input": {
					"type": "structure",
					"members": {
						"accountId": {
							"location": "uri",
							"locationName": "accountId"
						},
						"vaultName": {
							"location": "uri",
							"locationName": "vaultName"
						},
						"policy": {
							"shape": "S14"
						}
					},
					"required": [
						"accountId",
						"vaultName"
					],
					"payload": "policy"
				}
			},
			"SetVaultNotifications": {
				"http": {
					"method": "PUT",
					"requestUri": "/{accountId}/vaults/{vaultName}/notification-configuration",
					"responseCode": 204
				},
				"input": {
					"type": "structure",
					"members": {
						"accountId": {
							"location": "uri",
							"locationName": "accountId"
						},
						"vaultName": {
							"location": "uri",
							"locationName": "vaultName"
						},
						"vaultNotificationConfig": {
							"shape": "S19"
						}
					},
					"required": [
						"accountId",
						"vaultName"
					],
					"payload": "vaultNotificationConfig"
				}
			},
			"UploadArchive": {
				"http": {
					"requestUri": "/{accountId}/vaults/{vaultName}/archives",
					"responseCode": 201
				},
				"input": {
					"type": "structure",
					"members": {
						"vaultName": {
							"location": "uri",
							"locationName": "vaultName"
						},
						"accountId": {
							"location": "uri",
							"locationName": "accountId"
						},
						"archiveDescription": {
							"location": "header",
							"locationName": "x-amz-archive-description"
						},
						"checksum": {
							"location": "header",
							"locationName": "x-amz-sha256-tree-hash"
						},
						"body": {
							"shape": "S10"
						}
					},
					"required": [
						"vaultName",
						"accountId"
					],
					"payload": "body"
				},
				"output": {
					"shape": "S9"
				}
			},
			"UploadMultipartPart": {
				"http": {
					"method": "PUT",
					"requestUri": "/{accountId}/vaults/{vaultName}/multipart-uploads/{uploadId}",
					"responseCode": 204
				},
				"input": {
					"type": "structure",
					"members": {
						"accountId": {
							"location": "uri",
							"locationName": "accountId"
						},
						"vaultName": {
							"location": "uri",
							"locationName": "vaultName"
						},
						"uploadId": {
							"location": "uri",
							"locationName": "uploadId"
						},
						"checksum": {
							"location": "header",
							"locationName": "x-amz-sha256-tree-hash"
						},
						"range": {
							"location": "header",
							"locationName": "Content-Range"
						},
						"body": {
							"shape": "S10"
						}
					},
					"required": [
						"accountId",
						"vaultName",
						"uploadId"
					],
					"payload": "body"
				},
				"output": {
					"type": "structure",
					"members": {
						"checksum": {
							"location": "header",
							"locationName": "x-amz-sha256-tree-hash"
						}
					}
				}
			}
		},
		"shapes": {
			"S5": {
				"type": "map",
				"key": {},
				"value": {}
			},
			"S9": {
				"type": "structure",
				"members": {
					"location": {
						"location": "header",
						"locationName": "Location"
					},
					"checksum": {
						"location": "header",
						"locationName": "x-amz-sha256-tree-hash"
					},
					"archiveId": {
						"location": "header",
						"locationName": "x-amz-archive-id"
					}
				}
			},
			"Si": {
				"type": "structure",
				"members": {
					"JobId": {},
					"JobDescription": {},
					"Action": {},
					"ArchiveId": {},
					"VaultARN": {},
					"CreationDate": {},
					"Completed": {
						"type": "boolean"
					},
					"StatusCode": {},
					"StatusMessage": {},
					"ArchiveSizeInBytes": {
						"type": "long"
					},
					"InventorySizeInBytes": {
						"type": "long"
					},
					"SNSTopic": {},
					"CompletionDate": {},
					"SHA256TreeHash": {},
					"ArchiveSHA256TreeHash": {},
					"RetrievalByteRange": {},
					"InventoryRetrievalParameters": {
						"type": "structure",
						"members": {
							"Format": {},
							"StartDate": {},
							"EndDate": {},
							"Limit": {},
							"Marker": {}
						}
					}
				}
			},
			"Sq": {
				"type": "structure",
				"members": {
					"VaultARN": {},
					"VaultName": {},
					"CreationDate": {},
					"LastInventoryDate": {},
					"NumberOfArchives": {
						"type": "long"
					},
					"SizeInBytes": {
						"type": "long"
					}
				}
			},
			"Su": {
				"type": "structure",
				"members": {
					"Rules": {
						"type": "list",
						"member": {
							"type": "structure",
							"members": {
								"Strategy": {},
								"BytesPerHour": {
									"type": "long"
								}
							}
						}
					}
				}
			},
			"S10": {
				"type": "blob",
				"streaming": true
			},
			"S14": {
				"type": "structure",
				"members": {
					"Policy": {}
				}
			},
			"S19": {
				"type": "structure",
				"members": {
					"SNSTopic": {},
					"Events": {
						"type": "list",
						"member": {}
					}
				}
			}
		},
		"examples": {}
	};

/***/ },
/* 372 */
/***/ function(module, exports) {

	module.exports = {
		"pagination": {
			"ListJobs": {
				"input_token": "marker",
				"output_token": "Marker",
				"limit_key": "limit",
				"result_key": "JobList"
			},
			"ListMultipartUploads": {
				"input_token": "marker",
				"output_token": "Marker",
				"limit_key": "limit",
				"result_key": "UploadsList"
			},
			"ListParts": {
				"input_token": "marker",
				"output_token": "Marker",
				"limit_key": "limit",
				"result_key": "Parts"
			},
			"ListVaults": {
				"input_token": "marker",
				"output_token": "Marker",
				"limit_key": "limit",
				"result_key": "VaultList"
			}
		}
	};

/***/ },
/* 373 */
/***/ function(module, exports) {

	module.exports = {
		"version": 2,
		"waiters": {
			"VaultExists": {
				"operation": "DescribeVault",
				"delay": 3,
				"maxAttempts": 15,
				"acceptors": [
					{
						"state": "success",
						"matcher": "status",
						"expected": 200
					},
					{
						"state": "retry",
						"matcher": "error",
						"expected": "ResourceNotFoundException"
					}
				]
			},
			"VaultNotExists": {
				"operation": "DescribeVault",
				"delay": 3,
				"maxAttempts": 15,
				"acceptors": [
					{
						"state": "retry",
						"matcher": "status",
						"expected": 200
					},
					{
						"state": "success",
						"matcher": "error",
						"expected": "ResourceNotFoundException"
					}
				]
			}
		}
	};

/***/ },
/* 374 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['iam'] = {};
	AWS.IAM = Service.defineService('iam', ['2010-05-08']);
	Object.defineProperty(apiLoader.services['iam'], '2010-05-08', {
	  get: function get() {
	    var model = __webpack_require__(375);
	    model.paginators = __webpack_require__(376).pagination;
	    model.waiters = __webpack_require__(377).waiters;
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.IAM;


/***/ },
/* 375 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2010-05-08",
			"endpointPrefix": "iam",
			"globalEndpoint": "iam.amazonaws.com",
			"protocol": "query",
			"serviceAbbreviation": "IAM",
			"serviceFullName": "AWS Identity and Access Management",
			"signatureVersion": "v4",
			"xmlNamespace": "https://iam.amazonaws.com/doc/2010-05-08/"
		},
		"operations": {
			"AddClientIDToOpenIDConnectProvider": {
				"input": {
					"type": "structure",
					"required": [
						"OpenIDConnectProviderArn",
						"ClientID"
					],
					"members": {
						"OpenIDConnectProviderArn": {},
						"ClientID": {}
					}
				}
			},
			"AddRoleToInstanceProfile": {
				"input": {
					"type": "structure",
					"required": [
						"InstanceProfileName",
						"RoleName"
					],
					"members": {
						"InstanceProfileName": {},
						"RoleName": {}
					}
				}
			},
			"AddUserToGroup": {
				"input": {
					"type": "structure",
					"required": [
						"GroupName",
						"UserName"
					],
					"members": {
						"GroupName": {},
						"UserName": {}
					}
				}
			},
			"AttachGroupPolicy": {
				"input": {
					"type": "structure",
					"required": [
						"GroupName",
						"PolicyArn"
					],
					"members": {
						"GroupName": {},
						"PolicyArn": {}
					}
				}
			},
			"AttachRolePolicy": {
				"input": {
					"type": "structure",
					"required": [
						"RoleName",
						"PolicyArn"
					],
					"members": {
						"RoleName": {},
						"PolicyArn": {}
					}
				}
			},
			"AttachUserPolicy": {
				"input": {
					"type": "structure",
					"required": [
						"UserName",
						"PolicyArn"
					],
					"members": {
						"UserName": {},
						"PolicyArn": {}
					}
				}
			},
			"ChangePassword": {
				"input": {
					"type": "structure",
					"required": [
						"OldPassword",
						"NewPassword"
					],
					"members": {
						"OldPassword": {
							"shape": "Sf"
						},
						"NewPassword": {
							"shape": "Sf"
						}
					}
				}
			},
			"CreateAccessKey": {
				"input": {
					"type": "structure",
					"members": {
						"UserName": {}
					}
				},
				"output": {
					"resultWrapper": "CreateAccessKeyResult",
					"type": "structure",
					"required": [
						"AccessKey"
					],
					"members": {
						"AccessKey": {
							"type": "structure",
							"required": [
								"UserName",
								"AccessKeyId",
								"Status",
								"SecretAccessKey"
							],
							"members": {
								"UserName": {},
								"AccessKeyId": {},
								"Status": {},
								"SecretAccessKey": {
									"type": "string",
									"sensitive": true
								},
								"CreateDate": {
									"type": "timestamp"
								}
							}
						}
					}
				}
			},
			"CreateAccountAlias": {
				"input": {
					"type": "structure",
					"required": [
						"AccountAlias"
					],
					"members": {
						"AccountAlias": {}
					}
				}
			},
			"CreateGroup": {
				"input": {
					"type": "structure",
					"required": [
						"GroupName"
					],
					"members": {
						"Path": {},
						"GroupName": {}
					}
				},
				"output": {
					"resultWrapper": "CreateGroupResult",
					"type": "structure",
					"required": [
						"Group"
					],
					"members": {
						"Group": {
							"shape": "Ss"
						}
					}
				}
			},
			"CreateInstanceProfile": {
				"input": {
					"type": "structure",
					"required": [
						"InstanceProfileName"
					],
					"members": {
						"InstanceProfileName": {},
						"Path": {}
					}
				},
				"output": {
					"resultWrapper": "CreateInstanceProfileResult",
					"type": "structure",
					"required": [
						"InstanceProfile"
					],
					"members": {
						"InstanceProfile": {
							"shape": "Sw"
						}
					}
				}
			},
			"CreateLoginProfile": {
				"input": {
					"type": "structure",
					"required": [
						"UserName",
						"Password"
					],
					"members": {
						"UserName": {},
						"Password": {
							"shape": "Sf"
						},
						"PasswordResetRequired": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"resultWrapper": "CreateLoginProfileResult",
					"type": "structure",
					"required": [
						"LoginProfile"
					],
					"members": {
						"LoginProfile": {
							"shape": "S13"
						}
					}
				}
			},
			"CreateOpenIDConnectProvider": {
				"input": {
					"type": "structure",
					"required": [
						"Url",
						"ThumbprintList"
					],
					"members": {
						"Url": {},
						"ClientIDList": {
							"shape": "S16"
						},
						"ThumbprintList": {
							"shape": "S17"
						}
					}
				},
				"output": {
					"resultWrapper": "CreateOpenIDConnectProviderResult",
					"type": "structure",
					"members": {
						"OpenIDConnectProviderArn": {}
					}
				}
			},
			"CreatePolicy": {
				"input": {
					"type": "structure",
					"required": [
						"PolicyName",
						"PolicyDocument"
					],
					"members": {
						"PolicyName": {},
						"Path": {},
						"PolicyDocument": {},
						"Description": {}
					}
				},
				"output": {
					"resultWrapper": "CreatePolicyResult",
					"type": "structure",
					"members": {
						"Policy": {
							"shape": "S1f"
						}
					}
				}
			},
			"CreatePolicyVersion": {
				"input": {
					"type": "structure",
					"required": [
						"PolicyArn",
						"PolicyDocument"
					],
					"members": {
						"PolicyArn": {},
						"PolicyDocument": {},
						"SetAsDefault": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"resultWrapper": "CreatePolicyVersionResult",
					"type": "structure",
					"members": {
						"PolicyVersion": {
							"shape": "S1k"
						}
					}
				}
			},
			"CreateRole": {
				"input": {
					"type": "structure",
					"required": [
						"RoleName",
						"AssumeRolePolicyDocument"
					],
					"members": {
						"Path": {},
						"RoleName": {},
						"AssumeRolePolicyDocument": {}
					}
				},
				"output": {
					"resultWrapper": "CreateRoleResult",
					"type": "structure",
					"required": [
						"Role"
					],
					"members": {
						"Role": {
							"shape": "Sy"
						}
					}
				}
			},
			"CreateSAMLProvider": {
				"input": {
					"type": "structure",
					"required": [
						"SAMLMetadataDocument",
						"Name"
					],
					"members": {
						"SAMLMetadataDocument": {},
						"Name": {}
					}
				},
				"output": {
					"resultWrapper": "CreateSAMLProviderResult",
					"type": "structure",
					"members": {
						"SAMLProviderArn": {}
					}
				}
			},
			"CreateUser": {
				"input": {
					"type": "structure",
					"required": [
						"UserName"
					],
					"members": {
						"Path": {},
						"UserName": {}
					}
				},
				"output": {
					"resultWrapper": "CreateUserResult",
					"type": "structure",
					"members": {
						"User": {
							"shape": "S1t"
						}
					}
				}
			},
			"CreateVirtualMFADevice": {
				"input": {
					"type": "structure",
					"required": [
						"VirtualMFADeviceName"
					],
					"members": {
						"Path": {},
						"VirtualMFADeviceName": {}
					}
				},
				"output": {
					"resultWrapper": "CreateVirtualMFADeviceResult",
					"type": "structure",
					"required": [
						"VirtualMFADevice"
					],
					"members": {
						"VirtualMFADevice": {
							"shape": "S1x"
						}
					}
				}
			},
			"DeactivateMFADevice": {
				"input": {
					"type": "structure",
					"required": [
						"UserName",
						"SerialNumber"
					],
					"members": {
						"UserName": {},
						"SerialNumber": {}
					}
				}
			},
			"DeleteAccessKey": {
				"input": {
					"type": "structure",
					"required": [
						"AccessKeyId"
					],
					"members": {
						"UserName": {},
						"AccessKeyId": {}
					}
				}
			},
			"DeleteAccountAlias": {
				"input": {
					"type": "structure",
					"required": [
						"AccountAlias"
					],
					"members": {
						"AccountAlias": {}
					}
				}
			},
			"DeleteAccountPasswordPolicy": {},
			"DeleteGroup": {
				"input": {
					"type": "structure",
					"required": [
						"GroupName"
					],
					"members": {
						"GroupName": {}
					}
				}
			},
			"DeleteGroupPolicy": {
				"input": {
					"type": "structure",
					"required": [
						"GroupName",
						"PolicyName"
					],
					"members": {
						"GroupName": {},
						"PolicyName": {}
					}
				}
			},
			"DeleteInstanceProfile": {
				"input": {
					"type": "structure",
					"required": [
						"InstanceProfileName"
					],
					"members": {
						"InstanceProfileName": {}
					}
				}
			},
			"DeleteLoginProfile": {
				"input": {
					"type": "structure",
					"required": [
						"UserName"
					],
					"members": {
						"UserName": {}
					}
				}
			},
			"DeleteOpenIDConnectProvider": {
				"input": {
					"type": "structure",
					"required": [
						"OpenIDConnectProviderArn"
					],
					"members": {
						"OpenIDConnectProviderArn": {}
					}
				}
			},
			"DeletePolicy": {
				"input": {
					"type": "structure",
					"required": [
						"PolicyArn"
					],
					"members": {
						"PolicyArn": {}
					}
				}
			},
			"DeletePolicyVersion": {
				"input": {
					"type": "structure",
					"required": [
						"PolicyArn",
						"VersionId"
					],
					"members": {
						"PolicyArn": {},
						"VersionId": {}
					}
				}
			},
			"DeleteRole": {
				"input": {
					"type": "structure",
					"required": [
						"RoleName"
					],
					"members": {
						"RoleName": {}
					}
				}
			},
			"DeleteRolePolicy": {
				"input": {
					"type": "structure",
					"required": [
						"RoleName",
						"PolicyName"
					],
					"members": {
						"RoleName": {},
						"PolicyName": {}
					}
				}
			},
			"DeleteSAMLProvider": {
				"input": {
					"type": "structure",
					"required": [
						"SAMLProviderArn"
					],
					"members": {
						"SAMLProviderArn": {}
					}
				}
			},
			"DeleteSSHPublicKey": {
				"input": {
					"type": "structure",
					"required": [
						"UserName",
						"SSHPublicKeyId"
					],
					"members": {
						"UserName": {},
						"SSHPublicKeyId": {}
					}
				}
			},
			"DeleteServerCertificate": {
				"input": {
					"type": "structure",
					"required": [
						"ServerCertificateName"
					],
					"members": {
						"ServerCertificateName": {}
					}
				}
			},
			"DeleteSigningCertificate": {
				"input": {
					"type": "structure",
					"required": [
						"CertificateId"
					],
					"members": {
						"UserName": {},
						"CertificateId": {}
					}
				}
			},
			"DeleteUser": {
				"input": {
					"type": "structure",
					"required": [
						"UserName"
					],
					"members": {
						"UserName": {}
					}
				}
			},
			"DeleteUserPolicy": {
				"input": {
					"type": "structure",
					"required": [
						"UserName",
						"PolicyName"
					],
					"members": {
						"UserName": {},
						"PolicyName": {}
					}
				}
			},
			"DeleteVirtualMFADevice": {
				"input": {
					"type": "structure",
					"required": [
						"SerialNumber"
					],
					"members": {
						"SerialNumber": {}
					}
				}
			},
			"DetachGroupPolicy": {
				"input": {
					"type": "structure",
					"required": [
						"GroupName",
						"PolicyArn"
					],
					"members": {
						"GroupName": {},
						"PolicyArn": {}
					}
				}
			},
			"DetachRolePolicy": {
				"input": {
					"type": "structure",
					"required": [
						"RoleName",
						"PolicyArn"
					],
					"members": {
						"RoleName": {},
						"PolicyArn": {}
					}
				}
			},
			"DetachUserPolicy": {
				"input": {
					"type": "structure",
					"required": [
						"UserName",
						"PolicyArn"
					],
					"members": {
						"UserName": {},
						"PolicyArn": {}
					}
				}
			},
			"EnableMFADevice": {
				"input": {
					"type": "structure",
					"required": [
						"UserName",
						"SerialNumber",
						"AuthenticationCode1",
						"AuthenticationCode2"
					],
					"members": {
						"UserName": {},
						"SerialNumber": {},
						"AuthenticationCode1": {},
						"AuthenticationCode2": {}
					}
				}
			},
			"GenerateCredentialReport": {
				"output": {
					"resultWrapper": "GenerateCredentialReportResult",
					"type": "structure",
					"members": {
						"State": {},
						"Description": {}
					}
				}
			},
			"GetAccessKeyLastUsed": {
				"input": {
					"type": "structure",
					"required": [
						"AccessKeyId"
					],
					"members": {
						"AccessKeyId": {}
					}
				},
				"output": {
					"resultWrapper": "GetAccessKeyLastUsedResult",
					"type": "structure",
					"members": {
						"UserName": {},
						"AccessKeyLastUsed": {
							"type": "structure",
							"required": [
								"LastUsedDate",
								"ServiceName",
								"Region"
							],
							"members": {
								"LastUsedDate": {
									"type": "timestamp"
								},
								"ServiceName": {},
								"Region": {}
							}
						}
					}
				}
			},
			"GetAccountAuthorizationDetails": {
				"input": {
					"type": "structure",
					"members": {
						"Filter": {
							"type": "list",
							"member": {}
						},
						"MaxItems": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "GetAccountAuthorizationDetailsResult",
					"type": "structure",
					"members": {
						"UserDetailList": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"Path": {},
									"UserName": {},
									"UserId": {},
									"Arn": {},
									"CreateDate": {
										"type": "timestamp"
									},
									"UserPolicyList": {
										"shape": "S36"
									},
									"GroupList": {
										"type": "list",
										"member": {}
									},
									"AttachedManagedPolicies": {
										"shape": "S39"
									}
								}
							}
						},
						"GroupDetailList": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"Path": {},
									"GroupName": {},
									"GroupId": {},
									"Arn": {},
									"CreateDate": {
										"type": "timestamp"
									},
									"GroupPolicyList": {
										"shape": "S36"
									},
									"AttachedManagedPolicies": {
										"shape": "S39"
									}
								}
							}
						},
						"RoleDetailList": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"Path": {},
									"RoleName": {},
									"RoleId": {},
									"Arn": {},
									"CreateDate": {
										"type": "timestamp"
									},
									"AssumeRolePolicyDocument": {},
									"InstanceProfileList": {
										"shape": "S3f"
									},
									"RolePolicyList": {
										"shape": "S36"
									},
									"AttachedManagedPolicies": {
										"shape": "S39"
									}
								}
							}
						},
						"Policies": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"PolicyName": {},
									"PolicyId": {},
									"Arn": {},
									"Path": {},
									"DefaultVersionId": {},
									"AttachmentCount": {
										"type": "integer"
									},
									"IsAttachable": {
										"type": "boolean"
									},
									"Description": {},
									"CreateDate": {
										"type": "timestamp"
									},
									"UpdateDate": {
										"type": "timestamp"
									},
									"PolicyVersionList": {
										"shape": "S3i"
									}
								}
							}
						},
						"IsTruncated": {
							"type": "boolean"
						},
						"Marker": {}
					}
				}
			},
			"GetAccountPasswordPolicy": {
				"output": {
					"resultWrapper": "GetAccountPasswordPolicyResult",
					"type": "structure",
					"required": [
						"PasswordPolicy"
					],
					"members": {
						"PasswordPolicy": {
							"type": "structure",
							"members": {
								"MinimumPasswordLength": {
									"type": "integer"
								},
								"RequireSymbols": {
									"type": "boolean"
								},
								"RequireNumbers": {
									"type": "boolean"
								},
								"RequireUppercaseCharacters": {
									"type": "boolean"
								},
								"RequireLowercaseCharacters": {
									"type": "boolean"
								},
								"AllowUsersToChangePassword": {
									"type": "boolean"
								},
								"ExpirePasswords": {
									"type": "boolean"
								},
								"MaxPasswordAge": {
									"type": "integer"
								},
								"PasswordReusePrevention": {
									"type": "integer"
								},
								"HardExpiry": {
									"type": "boolean"
								}
							}
						}
					}
				}
			},
			"GetAccountSummary": {
				"output": {
					"resultWrapper": "GetAccountSummaryResult",
					"type": "structure",
					"members": {
						"SummaryMap": {
							"type": "map",
							"key": {},
							"value": {
								"type": "integer"
							}
						}
					}
				}
			},
			"GetContextKeysForCustomPolicy": {
				"input": {
					"type": "structure",
					"required": [
						"PolicyInputList"
					],
					"members": {
						"PolicyInputList": {
							"shape": "S3u"
						}
					}
				},
				"output": {
					"shape": "S3v",
					"resultWrapper": "GetContextKeysForCustomPolicyResult"
				}
			},
			"GetContextKeysForPrincipalPolicy": {
				"input": {
					"type": "structure",
					"required": [
						"PolicySourceArn"
					],
					"members": {
						"PolicySourceArn": {},
						"PolicyInputList": {
							"shape": "S3u"
						}
					}
				},
				"output": {
					"shape": "S3v",
					"resultWrapper": "GetContextKeysForPrincipalPolicyResult"
				}
			},
			"GetCredentialReport": {
				"output": {
					"resultWrapper": "GetCredentialReportResult",
					"type": "structure",
					"members": {
						"Content": {
							"type": "blob"
						},
						"ReportFormat": {},
						"GeneratedTime": {
							"type": "timestamp"
						}
					}
				}
			},
			"GetGroup": {
				"input": {
					"type": "structure",
					"required": [
						"GroupName"
					],
					"members": {
						"GroupName": {},
						"Marker": {},
						"MaxItems": {
							"type": "integer"
						}
					}
				},
				"output": {
					"resultWrapper": "GetGroupResult",
					"type": "structure",
					"required": [
						"Group",
						"Users"
					],
					"members": {
						"Group": {
							"shape": "Ss"
						},
						"Users": {
							"shape": "S44"
						},
						"IsTruncated": {
							"type": "boolean"
						},
						"Marker": {}
					}
				}
			},
			"GetGroupPolicy": {
				"input": {
					"type": "structure",
					"required": [
						"GroupName",
						"PolicyName"
					],
					"members": {
						"GroupName": {},
						"PolicyName": {}
					}
				},
				"output": {
					"resultWrapper": "GetGroupPolicyResult",
					"type": "structure",
					"required": [
						"GroupName",
						"PolicyName",
						"PolicyDocument"
					],
					"members": {
						"GroupName": {},
						"PolicyName": {},
						"PolicyDocument": {}
					}
				}
			},
			"GetInstanceProfile": {
				"input": {
					"type": "structure",
					"required": [
						"InstanceProfileName"
					],
					"members": {
						"InstanceProfileName": {}
					}
				},
				"output": {
					"resultWrapper": "GetInstanceProfileResult",
					"type": "structure",
					"required": [
						"InstanceProfile"
					],
					"members": {
						"InstanceProfile": {
							"shape": "Sw"
						}
					}
				}
			},
			"GetLoginProfile": {
				"input": {
					"type": "structure",
					"required": [
						"UserName"
					],
					"members": {
						"UserName": {}
					}
				},
				"output": {
					"resultWrapper": "GetLoginProfileResult",
					"type": "structure",
					"required": [
						"LoginProfile"
					],
					"members": {
						"LoginProfile": {
							"shape": "S13"
						}
					}
				}
			},
			"GetOpenIDConnectProvider": {
				"input": {
					"type": "structure",
					"required": [
						"OpenIDConnectProviderArn"
					],
					"members": {
						"OpenIDConnectProviderArn": {}
					}
				},
				"output": {
					"resultWrapper": "GetOpenIDConnectProviderResult",
					"type": "structure",
					"members": {
						"Url": {},
						"ClientIDList": {
							"shape": "S16"
						},
						"ThumbprintList": {
							"shape": "S17"
						},
						"CreateDate": {
							"type": "timestamp"
						}
					}
				}
			},
			"GetPolicy": {
				"input": {
					"type": "structure",
					"required": [
						"PolicyArn"
					],
					"members": {
						"PolicyArn": {}
					}
				},
				"output": {
					"resultWrapper": "GetPolicyResult",
					"type": "structure",
					"members": {
						"Policy": {
							"shape": "S1f"
						}
					}
				}
			},
			"GetPolicyVersion": {
				"input": {
					"type": "structure",
					"required": [
						"PolicyArn",
						"VersionId"
					],
					"members": {
						"PolicyArn": {},
						"VersionId": {}
					}
				},
				"output": {
					"resultWrapper": "GetPolicyVersionResult",
					"type": "structure",
					"members": {
						"PolicyVersion": {
							"shape": "S1k"
						}
					}
				}
			},
			"GetRole": {
				"input": {
					"type": "structure",
					"required": [
						"RoleName"
					],
					"members": {
						"RoleName": {}
					}
				},
				"output": {
					"resultWrapper": "GetRoleResult",
					"type": "structure",
					"required": [
						"Role"
					],
					"members": {
						"Role": {
							"shape": "Sy"
						}
					}
				}
			},
			"GetRolePolicy": {
				"input": {
					"type": "structure",
					"required": [
						"RoleName",
						"PolicyName"
					],
					"members": {
						"RoleName": {},
						"PolicyName": {}
					}
				},
				"output": {
					"resultWrapper": "GetRolePolicyResult",
					"type": "structure",
					"required": [
						"RoleName",
						"PolicyName",
						"PolicyDocument"
					],
					"members": {
						"RoleName": {},
						"PolicyName": {},
						"PolicyDocument": {}
					}
				}
			},
			"GetSAMLProvider": {
				"input": {
					"type": "structure",
					"required": [
						"SAMLProviderArn"
					],
					"members": {
						"SAMLProviderArn": {}
					}
				},
				"output": {
					"resultWrapper": "GetSAMLProviderResult",
					"type": "structure",
					"members": {
						"SAMLMetadataDocument": {},
						"CreateDate": {
							"type": "timestamp"
						},
						"ValidUntil": {
							"type": "timestamp"
						}
					}
				}
			},
			"GetSSHPublicKey": {
				"input": {
					"type": "structure",
					"required": [
						"UserName",
						"SSHPublicKeyId",
						"Encoding"
					],
					"members": {
						"UserName": {},
						"SSHPublicKeyId": {},
						"Encoding": {}
					}
				},
				"output": {
					"resultWrapper": "GetSSHPublicKeyResult",
					"type": "structure",
					"members": {
						"SSHPublicKey": {
							"shape": "S4q"
						}
					}
				}
			},
			"GetServerCertificate": {
				"input": {
					"type": "structure",
					"required": [
						"ServerCertificateName"
					],
					"members": {
						"ServerCertificateName": {}
					}
				},
				"output": {
					"resultWrapper": "GetServerCertificateResult",
					"type": "structure",
					"required": [
						"ServerCertificate"
					],
					"members": {
						"ServerCertificate": {
							"type": "structure",
							"required": [
								"ServerCertificateMetadata",
								"CertificateBody"
							],
							"members": {
								"ServerCertificateMetadata": {
									"shape": "S4w"
								},
								"CertificateBody": {},
								"CertificateChain": {}
							}
						}
					}
				}
			},
			"GetUser": {
				"input": {
					"type": "structure",
					"members": {
						"UserName": {}
					}
				},
				"output": {
					"resultWrapper": "GetUserResult",
					"type": "structure",
					"required": [
						"User"
					],
					"members": {
						"User": {
							"shape": "S1t"
						}
					}
				}
			},
			"GetUserPolicy": {
				"input": {
					"type": "structure",
					"required": [
						"UserName",
						"PolicyName"
					],
					"members": {
						"UserName": {},
						"PolicyName": {}
					}
				},
				"output": {
					"resultWrapper": "GetUserPolicyResult",
					"type": "structure",
					"required": [
						"UserName",
						"PolicyName",
						"PolicyDocument"
					],
					"members": {
						"UserName": {},
						"PolicyName": {},
						"PolicyDocument": {}
					}
				}
			},
			"ListAccessKeys": {
				"input": {
					"type": "structure",
					"members": {
						"UserName": {},
						"Marker": {},
						"MaxItems": {
							"type": "integer"
						}
					}
				},
				"output": {
					"resultWrapper": "ListAccessKeysResult",
					"type": "structure",
					"required": [
						"AccessKeyMetadata"
					],
					"members": {
						"AccessKeyMetadata": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"UserName": {},
									"AccessKeyId": {},
									"Status": {},
									"CreateDate": {
										"type": "timestamp"
									}
								}
							}
						},
						"IsTruncated": {
							"type": "boolean"
						},
						"Marker": {}
					}
				}
			},
			"ListAccountAliases": {
				"input": {
					"type": "structure",
					"members": {
						"Marker": {},
						"MaxItems": {
							"type": "integer"
						}
					}
				},
				"output": {
					"resultWrapper": "ListAccountAliasesResult",
					"type": "structure",
					"required": [
						"AccountAliases"
					],
					"members": {
						"AccountAliases": {
							"type": "list",
							"member": {}
						},
						"IsTruncated": {
							"type": "boolean"
						},
						"Marker": {}
					}
				}
			},
			"ListAttachedGroupPolicies": {
				"input": {
					"type": "structure",
					"required": [
						"GroupName"
					],
					"members": {
						"GroupName": {},
						"PathPrefix": {},
						"Marker": {},
						"MaxItems": {
							"type": "integer"
						}
					}
				},
				"output": {
					"resultWrapper": "ListAttachedGroupPoliciesResult",
					"type": "structure",
					"members": {
						"AttachedPolicies": {
							"shape": "S39"
						},
						"IsTruncated": {
							"type": "boolean"
						},
						"Marker": {}
					}
				}
			},
			"ListAttachedRolePolicies": {
				"input": {
					"type": "structure",
					"required": [
						"RoleName"
					],
					"members": {
						"RoleName": {},
						"PathPrefix": {},
						"Marker": {},
						"MaxItems": {
							"type": "integer"
						}
					}
				},
				"output": {
					"resultWrapper": "ListAttachedRolePoliciesResult",
					"type": "structure",
					"members": {
						"AttachedPolicies": {
							"shape": "S39"
						},
						"IsTruncated": {
							"type": "boolean"
						},
						"Marker": {}
					}
				}
			},
			"ListAttachedUserPolicies": {
				"input": {
					"type": "structure",
					"required": [
						"UserName"
					],
					"members": {
						"UserName": {},
						"PathPrefix": {},
						"Marker": {},
						"MaxItems": {
							"type": "integer"
						}
					}
				},
				"output": {
					"resultWrapper": "ListAttachedUserPoliciesResult",
					"type": "structure",
					"members": {
						"AttachedPolicies": {
							"shape": "S39"
						},
						"IsTruncated": {
							"type": "boolean"
						},
						"Marker": {}
					}
				}
			},
			"ListEntitiesForPolicy": {
				"input": {
					"type": "structure",
					"required": [
						"PolicyArn"
					],
					"members": {
						"PolicyArn": {},
						"EntityFilter": {},
						"PathPrefix": {},
						"Marker": {},
						"MaxItems": {
							"type": "integer"
						}
					}
				},
				"output": {
					"resultWrapper": "ListEntitiesForPolicyResult",
					"type": "structure",
					"members": {
						"PolicyGroups": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"GroupName": {},
									"GroupId": {}
								}
							}
						},
						"PolicyUsers": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"UserName": {},
									"UserId": {}
								}
							}
						},
						"PolicyRoles": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"RoleName": {},
									"RoleId": {}
								}
							}
						},
						"IsTruncated": {
							"type": "boolean"
						},
						"Marker": {}
					}
				}
			},
			"ListGroupPolicies": {
				"input": {
					"type": "structure",
					"required": [
						"GroupName"
					],
					"members": {
						"GroupName": {},
						"Marker": {},
						"MaxItems": {
							"type": "integer"
						}
					}
				},
				"output": {
					"resultWrapper": "ListGroupPoliciesResult",
					"type": "structure",
					"required": [
						"PolicyNames"
					],
					"members": {
						"PolicyNames": {
							"shape": "S5q"
						},
						"IsTruncated": {
							"type": "boolean"
						},
						"Marker": {}
					}
				}
			},
			"ListGroups": {
				"input": {
					"type": "structure",
					"members": {
						"PathPrefix": {},
						"Marker": {},
						"MaxItems": {
							"type": "integer"
						}
					}
				},
				"output": {
					"resultWrapper": "ListGroupsResult",
					"type": "structure",
					"required": [
						"Groups"
					],
					"members": {
						"Groups": {
							"shape": "S5u"
						},
						"IsTruncated": {
							"type": "boolean"
						},
						"Marker": {}
					}
				}
			},
			"ListGroupsForUser": {
				"input": {
					"type": "structure",
					"required": [
						"UserName"
					],
					"members": {
						"UserName": {},
						"Marker": {},
						"MaxItems": {
							"type": "integer"
						}
					}
				},
				"output": {
					"resultWrapper": "ListGroupsForUserResult",
					"type": "structure",
					"required": [
						"Groups"
					],
					"members": {
						"Groups": {
							"shape": "S5u"
						},
						"IsTruncated": {
							"type": "boolean"
						},
						"Marker": {}
					}
				}
			},
			"ListInstanceProfiles": {
				"input": {
					"type": "structure",
					"members": {
						"PathPrefix": {},
						"Marker": {},
						"MaxItems": {
							"type": "integer"
						}
					}
				},
				"output": {
					"resultWrapper": "ListInstanceProfilesResult",
					"type": "structure",
					"required": [
						"InstanceProfiles"
					],
					"members": {
						"InstanceProfiles": {
							"shape": "S3f"
						},
						"IsTruncated": {
							"type": "boolean"
						},
						"Marker": {}
					}
				}
			},
			"ListInstanceProfilesForRole": {
				"input": {
					"type": "structure",
					"required": [
						"RoleName"
					],
					"members": {
						"RoleName": {},
						"Marker": {},
						"MaxItems": {
							"type": "integer"
						}
					}
				},
				"output": {
					"resultWrapper": "ListInstanceProfilesForRoleResult",
					"type": "structure",
					"required": [
						"InstanceProfiles"
					],
					"members": {
						"InstanceProfiles": {
							"shape": "S3f"
						},
						"IsTruncated": {
							"type": "boolean"
						},
						"Marker": {}
					}
				}
			},
			"ListMFADevices": {
				"input": {
					"type": "structure",
					"members": {
						"UserName": {},
						"Marker": {},
						"MaxItems": {
							"type": "integer"
						}
					}
				},
				"output": {
					"resultWrapper": "ListMFADevicesResult",
					"type": "structure",
					"required": [
						"MFADevices"
					],
					"members": {
						"MFADevices": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"UserName",
									"SerialNumber",
									"EnableDate"
								],
								"members": {
									"UserName": {},
									"SerialNumber": {},
									"EnableDate": {
										"type": "timestamp"
									}
								}
							}
						},
						"IsTruncated": {
							"type": "boolean"
						},
						"Marker": {}
					}
				}
			},
			"ListOpenIDConnectProviders": {
				"input": {
					"type": "structure",
					"members": {}
				},
				"output": {
					"resultWrapper": "ListOpenIDConnectProvidersResult",
					"type": "structure",
					"members": {
						"OpenIDConnectProviderList": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"Arn": {}
								}
							}
						}
					}
				}
			},
			"ListPolicies": {
				"input": {
					"type": "structure",
					"members": {
						"Scope": {},
						"OnlyAttached": {
							"type": "boolean"
						},
						"PathPrefix": {},
						"Marker": {},
						"MaxItems": {
							"type": "integer"
						}
					}
				},
				"output": {
					"resultWrapper": "ListPoliciesResult",
					"type": "structure",
					"members": {
						"Policies": {
							"type": "list",
							"member": {
								"shape": "S1f"
							}
						},
						"IsTruncated": {
							"type": "boolean"
						},
						"Marker": {}
					}
				}
			},
			"ListPolicyVersions": {
				"input": {
					"type": "structure",
					"required": [
						"PolicyArn"
					],
					"members": {
						"PolicyArn": {},
						"Marker": {},
						"MaxItems": {
							"type": "integer"
						}
					}
				},
				"output": {
					"resultWrapper": "ListPolicyVersionsResult",
					"type": "structure",
					"members": {
						"Versions": {
							"shape": "S3i"
						},
						"IsTruncated": {
							"type": "boolean"
						},
						"Marker": {}
					}
				}
			},
			"ListRolePolicies": {
				"input": {
					"type": "structure",
					"required": [
						"RoleName"
					],
					"members": {
						"RoleName": {},
						"Marker": {},
						"MaxItems": {
							"type": "integer"
						}
					}
				},
				"output": {
					"resultWrapper": "ListRolePoliciesResult",
					"type": "structure",
					"required": [
						"PolicyNames"
					],
					"members": {
						"PolicyNames": {
							"shape": "S5q"
						},
						"IsTruncated": {
							"type": "boolean"
						},
						"Marker": {}
					}
				}
			},
			"ListRoles": {
				"input": {
					"type": "structure",
					"members": {
						"PathPrefix": {},
						"Marker": {},
						"MaxItems": {
							"type": "integer"
						}
					}
				},
				"output": {
					"resultWrapper": "ListRolesResult",
					"type": "structure",
					"required": [
						"Roles"
					],
					"members": {
						"Roles": {
							"shape": "Sx"
						},
						"IsTruncated": {
							"type": "boolean"
						},
						"Marker": {}
					}
				}
			},
			"ListSAMLProviders": {
				"input": {
					"type": "structure",
					"members": {}
				},
				"output": {
					"resultWrapper": "ListSAMLProvidersResult",
					"type": "structure",
					"members": {
						"SAMLProviderList": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"Arn": {},
									"ValidUntil": {
										"type": "timestamp"
									},
									"CreateDate": {
										"type": "timestamp"
									}
								}
							}
						}
					}
				}
			},
			"ListSSHPublicKeys": {
				"input": {
					"type": "structure",
					"members": {
						"UserName": {},
						"Marker": {},
						"MaxItems": {
							"type": "integer"
						}
					}
				},
				"output": {
					"resultWrapper": "ListSSHPublicKeysResult",
					"type": "structure",
					"members": {
						"SSHPublicKeys": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"UserName",
									"SSHPublicKeyId",
									"Status",
									"UploadDate"
								],
								"members": {
									"UserName": {},
									"SSHPublicKeyId": {},
									"Status": {},
									"UploadDate": {
										"type": "timestamp"
									}
								}
							}
						},
						"IsTruncated": {
							"type": "boolean"
						},
						"Marker": {}
					}
				}
			},
			"ListServerCertificates": {
				"input": {
					"type": "structure",
					"members": {
						"PathPrefix": {},
						"Marker": {},
						"MaxItems": {
							"type": "integer"
						}
					}
				},
				"output": {
					"resultWrapper": "ListServerCertificatesResult",
					"type": "structure",
					"required": [
						"ServerCertificateMetadataList"
					],
					"members": {
						"ServerCertificateMetadataList": {
							"type": "list",
							"member": {
								"shape": "S4w"
							}
						},
						"IsTruncated": {
							"type": "boolean"
						},
						"Marker": {}
					}
				}
			},
			"ListSigningCertificates": {
				"input": {
					"type": "structure",
					"members": {
						"UserName": {},
						"Marker": {},
						"MaxItems": {
							"type": "integer"
						}
					}
				},
				"output": {
					"resultWrapper": "ListSigningCertificatesResult",
					"type": "structure",
					"required": [
						"Certificates"
					],
					"members": {
						"Certificates": {
							"type": "list",
							"member": {
								"shape": "S6x"
							}
						},
						"IsTruncated": {
							"type": "boolean"
						},
						"Marker": {}
					}
				}
			},
			"ListUserPolicies": {
				"input": {
					"type": "structure",
					"required": [
						"UserName"
					],
					"members": {
						"UserName": {},
						"Marker": {},
						"MaxItems": {
							"type": "integer"
						}
					}
				},
				"output": {
					"resultWrapper": "ListUserPoliciesResult",
					"type": "structure",
					"required": [
						"PolicyNames"
					],
					"members": {
						"PolicyNames": {
							"shape": "S5q"
						},
						"IsTruncated": {
							"type": "boolean"
						},
						"Marker": {}
					}
				}
			},
			"ListUsers": {
				"input": {
					"type": "structure",
					"members": {
						"PathPrefix": {},
						"Marker": {},
						"MaxItems": {
							"type": "integer"
						}
					}
				},
				"output": {
					"resultWrapper": "ListUsersResult",
					"type": "structure",
					"required": [
						"Users"
					],
					"members": {
						"Users": {
							"shape": "S44"
						},
						"IsTruncated": {
							"type": "boolean"
						},
						"Marker": {}
					}
				}
			},
			"ListVirtualMFADevices": {
				"input": {
					"type": "structure",
					"members": {
						"AssignmentStatus": {},
						"Marker": {},
						"MaxItems": {
							"type": "integer"
						}
					}
				},
				"output": {
					"resultWrapper": "ListVirtualMFADevicesResult",
					"type": "structure",
					"required": [
						"VirtualMFADevices"
					],
					"members": {
						"VirtualMFADevices": {
							"type": "list",
							"member": {
								"shape": "S1x"
							}
						},
						"IsTruncated": {
							"type": "boolean"
						},
						"Marker": {}
					}
				}
			},
			"PutGroupPolicy": {
				"input": {
					"type": "structure",
					"required": [
						"GroupName",
						"PolicyName",
						"PolicyDocument"
					],
					"members": {
						"GroupName": {},
						"PolicyName": {},
						"PolicyDocument": {}
					}
				}
			},
			"PutRolePolicy": {
				"input": {
					"type": "structure",
					"required": [
						"RoleName",
						"PolicyName",
						"PolicyDocument"
					],
					"members": {
						"RoleName": {},
						"PolicyName": {},
						"PolicyDocument": {}
					}
				}
			},
			"PutUserPolicy": {
				"input": {
					"type": "structure",
					"required": [
						"UserName",
						"PolicyName",
						"PolicyDocument"
					],
					"members": {
						"UserName": {},
						"PolicyName": {},
						"PolicyDocument": {}
					}
				}
			},
			"RemoveClientIDFromOpenIDConnectProvider": {
				"input": {
					"type": "structure",
					"required": [
						"OpenIDConnectProviderArn",
						"ClientID"
					],
					"members": {
						"OpenIDConnectProviderArn": {},
						"ClientID": {}
					}
				}
			},
			"RemoveRoleFromInstanceProfile": {
				"input": {
					"type": "structure",
					"required": [
						"InstanceProfileName",
						"RoleName"
					],
					"members": {
						"InstanceProfileName": {},
						"RoleName": {}
					}
				}
			},
			"RemoveUserFromGroup": {
				"input": {
					"type": "structure",
					"required": [
						"GroupName",
						"UserName"
					],
					"members": {
						"GroupName": {},
						"UserName": {}
					}
				}
			},
			"ResyncMFADevice": {
				"input": {
					"type": "structure",
					"required": [
						"UserName",
						"SerialNumber",
						"AuthenticationCode1",
						"AuthenticationCode2"
					],
					"members": {
						"UserName": {},
						"SerialNumber": {},
						"AuthenticationCode1": {},
						"AuthenticationCode2": {}
					}
				}
			},
			"SetDefaultPolicyVersion": {
				"input": {
					"type": "structure",
					"required": [
						"PolicyArn",
						"VersionId"
					],
					"members": {
						"PolicyArn": {},
						"VersionId": {}
					}
				}
			},
			"SimulateCustomPolicy": {
				"input": {
					"type": "structure",
					"required": [
						"PolicyInputList",
						"ActionNames"
					],
					"members": {
						"PolicyInputList": {
							"shape": "S3u"
						},
						"ActionNames": {
							"shape": "S7f"
						},
						"ResourceArns": {
							"shape": "S7h"
						},
						"ResourcePolicy": {},
						"ResourceOwner": {},
						"CallerArn": {},
						"ContextEntries": {
							"shape": "S7j"
						},
						"ResourceHandlingOption": {},
						"MaxItems": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"shape": "S7p",
					"resultWrapper": "SimulateCustomPolicyResult"
				}
			},
			"SimulatePrincipalPolicy": {
				"input": {
					"type": "structure",
					"required": [
						"PolicySourceArn",
						"ActionNames"
					],
					"members": {
						"PolicySourceArn": {},
						"PolicyInputList": {
							"shape": "S3u"
						},
						"ActionNames": {
							"shape": "S7f"
						},
						"ResourceArns": {
							"shape": "S7h"
						},
						"ResourcePolicy": {},
						"ResourceOwner": {},
						"CallerArn": {},
						"ContextEntries": {
							"shape": "S7j"
						},
						"ResourceHandlingOption": {},
						"MaxItems": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"shape": "S7p",
					"resultWrapper": "SimulatePrincipalPolicyResult"
				}
			},
			"UpdateAccessKey": {
				"input": {
					"type": "structure",
					"required": [
						"AccessKeyId",
						"Status"
					],
					"members": {
						"UserName": {},
						"AccessKeyId": {},
						"Status": {}
					}
				}
			},
			"UpdateAccountPasswordPolicy": {
				"input": {
					"type": "structure",
					"members": {
						"MinimumPasswordLength": {
							"type": "integer"
						},
						"RequireSymbols": {
							"type": "boolean"
						},
						"RequireNumbers": {
							"type": "boolean"
						},
						"RequireUppercaseCharacters": {
							"type": "boolean"
						},
						"RequireLowercaseCharacters": {
							"type": "boolean"
						},
						"AllowUsersToChangePassword": {
							"type": "boolean"
						},
						"MaxPasswordAge": {
							"type": "integer"
						},
						"PasswordReusePrevention": {
							"type": "integer"
						},
						"HardExpiry": {
							"type": "boolean"
						}
					}
				}
			},
			"UpdateAssumeRolePolicy": {
				"input": {
					"type": "structure",
					"required": [
						"RoleName",
						"PolicyDocument"
					],
					"members": {
						"RoleName": {},
						"PolicyDocument": {}
					}
				}
			},
			"UpdateGroup": {
				"input": {
					"type": "structure",
					"required": [
						"GroupName"
					],
					"members": {
						"GroupName": {},
						"NewPath": {},
						"NewGroupName": {}
					}
				}
			},
			"UpdateLoginProfile": {
				"input": {
					"type": "structure",
					"required": [
						"UserName"
					],
					"members": {
						"UserName": {},
						"Password": {
							"shape": "Sf"
						},
						"PasswordResetRequired": {
							"type": "boolean"
						}
					}
				}
			},
			"UpdateOpenIDConnectProviderThumbprint": {
				"input": {
					"type": "structure",
					"required": [
						"OpenIDConnectProviderArn",
						"ThumbprintList"
					],
					"members": {
						"OpenIDConnectProviderArn": {},
						"ThumbprintList": {
							"shape": "S17"
						}
					}
				}
			},
			"UpdateSAMLProvider": {
				"input": {
					"type": "structure",
					"required": [
						"SAMLMetadataDocument",
						"SAMLProviderArn"
					],
					"members": {
						"SAMLMetadataDocument": {},
						"SAMLProviderArn": {}
					}
				},
				"output": {
					"resultWrapper": "UpdateSAMLProviderResult",
					"type": "structure",
					"members": {
						"SAMLProviderArn": {}
					}
				}
			},
			"UpdateSSHPublicKey": {
				"input": {
					"type": "structure",
					"required": [
						"UserName",
						"SSHPublicKeyId",
						"Status"
					],
					"members": {
						"UserName": {},
						"SSHPublicKeyId": {},
						"Status": {}
					}
				}
			},
			"UpdateServerCertificate": {
				"input": {
					"type": "structure",
					"required": [
						"ServerCertificateName"
					],
					"members": {
						"ServerCertificateName": {},
						"NewPath": {},
						"NewServerCertificateName": {}
					}
				}
			},
			"UpdateSigningCertificate": {
				"input": {
					"type": "structure",
					"required": [
						"CertificateId",
						"Status"
					],
					"members": {
						"UserName": {},
						"CertificateId": {},
						"Status": {}
					}
				}
			},
			"UpdateUser": {
				"input": {
					"type": "structure",
					"required": [
						"UserName"
					],
					"members": {
						"UserName": {},
						"NewPath": {},
						"NewUserName": {}
					}
				}
			},
			"UploadSSHPublicKey": {
				"input": {
					"type": "structure",
					"required": [
						"UserName",
						"SSHPublicKeyBody"
					],
					"members": {
						"UserName": {},
						"SSHPublicKeyBody": {}
					}
				},
				"output": {
					"resultWrapper": "UploadSSHPublicKeyResult",
					"type": "structure",
					"members": {
						"SSHPublicKey": {
							"shape": "S4q"
						}
					}
				}
			},
			"UploadServerCertificate": {
				"input": {
					"type": "structure",
					"required": [
						"ServerCertificateName",
						"CertificateBody",
						"PrivateKey"
					],
					"members": {
						"Path": {},
						"ServerCertificateName": {},
						"CertificateBody": {},
						"PrivateKey": {
							"type": "string",
							"sensitive": true
						},
						"CertificateChain": {}
					}
				},
				"output": {
					"resultWrapper": "UploadServerCertificateResult",
					"type": "structure",
					"members": {
						"ServerCertificateMetadata": {
							"shape": "S4w"
						}
					}
				}
			},
			"UploadSigningCertificate": {
				"input": {
					"type": "structure",
					"required": [
						"CertificateBody"
					],
					"members": {
						"UserName": {},
						"CertificateBody": {}
					}
				},
				"output": {
					"resultWrapper": "UploadSigningCertificateResult",
					"type": "structure",
					"required": [
						"Certificate"
					],
					"members": {
						"Certificate": {
							"shape": "S6x"
						}
					}
				}
			}
		},
		"shapes": {
			"Sf": {
				"type": "string",
				"sensitive": true
			},
			"Ss": {
				"type": "structure",
				"required": [
					"Path",
					"GroupName",
					"GroupId",
					"Arn",
					"CreateDate"
				],
				"members": {
					"Path": {},
					"GroupName": {},
					"GroupId": {},
					"Arn": {},
					"CreateDate": {
						"type": "timestamp"
					}
				}
			},
			"Sw": {
				"type": "structure",
				"required": [
					"Path",
					"InstanceProfileName",
					"InstanceProfileId",
					"Arn",
					"CreateDate",
					"Roles"
				],
				"members": {
					"Path": {},
					"InstanceProfileName": {},
					"InstanceProfileId": {},
					"Arn": {},
					"CreateDate": {
						"type": "timestamp"
					},
					"Roles": {
						"shape": "Sx"
					}
				}
			},
			"Sx": {
				"type": "list",
				"member": {
					"shape": "Sy"
				}
			},
			"Sy": {
				"type": "structure",
				"required": [
					"Path",
					"RoleName",
					"RoleId",
					"Arn",
					"CreateDate"
				],
				"members": {
					"Path": {},
					"RoleName": {},
					"RoleId": {},
					"Arn": {},
					"CreateDate": {
						"type": "timestamp"
					},
					"AssumeRolePolicyDocument": {}
				}
			},
			"S13": {
				"type": "structure",
				"required": [
					"UserName",
					"CreateDate"
				],
				"members": {
					"UserName": {},
					"CreateDate": {
						"type": "timestamp"
					},
					"PasswordResetRequired": {
						"type": "boolean"
					}
				}
			},
			"S16": {
				"type": "list",
				"member": {}
			},
			"S17": {
				"type": "list",
				"member": {}
			},
			"S1f": {
				"type": "structure",
				"members": {
					"PolicyName": {},
					"PolicyId": {},
					"Arn": {},
					"Path": {},
					"DefaultVersionId": {},
					"AttachmentCount": {
						"type": "integer"
					},
					"IsAttachable": {
						"type": "boolean"
					},
					"Description": {},
					"CreateDate": {
						"type": "timestamp"
					},
					"UpdateDate": {
						"type": "timestamp"
					}
				}
			},
			"S1k": {
				"type": "structure",
				"members": {
					"Document": {},
					"VersionId": {},
					"IsDefaultVersion": {
						"type": "boolean"
					},
					"CreateDate": {
						"type": "timestamp"
					}
				}
			},
			"S1t": {
				"type": "structure",
				"required": [
					"Path",
					"UserName",
					"UserId",
					"Arn",
					"CreateDate"
				],
				"members": {
					"Path": {},
					"UserName": {},
					"UserId": {},
					"Arn": {},
					"CreateDate": {
						"type": "timestamp"
					},
					"PasswordLastUsed": {
						"type": "timestamp"
					}
				}
			},
			"S1x": {
				"type": "structure",
				"required": [
					"SerialNumber"
				],
				"members": {
					"SerialNumber": {},
					"Base32StringSeed": {
						"shape": "S1z"
					},
					"QRCodePNG": {
						"shape": "S1z"
					},
					"User": {
						"shape": "S1t"
					},
					"EnableDate": {
						"type": "timestamp"
					}
				}
			},
			"S1z": {
				"type": "blob",
				"sensitive": true
			},
			"S36": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"PolicyName": {},
						"PolicyDocument": {}
					}
				}
			},
			"S39": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"PolicyName": {},
						"PolicyArn": {}
					}
				}
			},
			"S3f": {
				"type": "list",
				"member": {
					"shape": "Sw"
				}
			},
			"S3i": {
				"type": "list",
				"member": {
					"shape": "S1k"
				}
			},
			"S3u": {
				"type": "list",
				"member": {}
			},
			"S3v": {
				"type": "structure",
				"members": {
					"ContextKeyNames": {
						"shape": "S3w"
					}
				}
			},
			"S3w": {
				"type": "list",
				"member": {}
			},
			"S44": {
				"type": "list",
				"member": {
					"shape": "S1t"
				}
			},
			"S4q": {
				"type": "structure",
				"required": [
					"UserName",
					"SSHPublicKeyId",
					"Fingerprint",
					"SSHPublicKeyBody",
					"Status"
				],
				"members": {
					"UserName": {},
					"SSHPublicKeyId": {},
					"Fingerprint": {},
					"SSHPublicKeyBody": {},
					"Status": {},
					"UploadDate": {
						"type": "timestamp"
					}
				}
			},
			"S4w": {
				"type": "structure",
				"required": [
					"Path",
					"ServerCertificateName",
					"ServerCertificateId",
					"Arn"
				],
				"members": {
					"Path": {},
					"ServerCertificateName": {},
					"ServerCertificateId": {},
					"Arn": {},
					"UploadDate": {
						"type": "timestamp"
					},
					"Expiration": {
						"type": "timestamp"
					}
				}
			},
			"S5q": {
				"type": "list",
				"member": {}
			},
			"S5u": {
				"type": "list",
				"member": {
					"shape": "Ss"
				}
			},
			"S6x": {
				"type": "structure",
				"required": [
					"UserName",
					"CertificateId",
					"CertificateBody",
					"Status"
				],
				"members": {
					"UserName": {},
					"CertificateId": {},
					"CertificateBody": {},
					"Status": {},
					"UploadDate": {
						"type": "timestamp"
					}
				}
			},
			"S7f": {
				"type": "list",
				"member": {}
			},
			"S7h": {
				"type": "list",
				"member": {}
			},
			"S7j": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"ContextKeyName": {},
						"ContextKeyValues": {
							"type": "list",
							"member": {}
						},
						"ContextKeyType": {}
					}
				}
			},
			"S7p": {
				"type": "structure",
				"members": {
					"EvaluationResults": {
						"type": "list",
						"member": {
							"type": "structure",
							"required": [
								"EvalActionName",
								"EvalDecision"
							],
							"members": {
								"EvalActionName": {},
								"EvalResourceName": {},
								"EvalDecision": {},
								"MatchedStatements": {
									"shape": "S7t"
								},
								"MissingContextValues": {
									"shape": "S3w"
								},
								"EvalDecisionDetails": {
									"shape": "S80"
								},
								"ResourceSpecificResults": {
									"type": "list",
									"member": {
										"type": "structure",
										"required": [
											"EvalResourceName",
											"EvalResourceDecision"
										],
										"members": {
											"EvalResourceName": {},
											"EvalResourceDecision": {},
											"MatchedStatements": {
												"shape": "S7t"
											},
											"MissingContextValues": {
												"shape": "S3w"
											},
											"EvalDecisionDetails": {
												"shape": "S80"
											}
										}
									}
								}
							}
						}
					},
					"IsTruncated": {
						"type": "boolean"
					},
					"Marker": {}
				}
			},
			"S7t": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"SourcePolicyId": {},
						"SourcePolicyType": {},
						"StartPosition": {
							"shape": "S7x"
						},
						"EndPosition": {
							"shape": "S7x"
						}
					}
				}
			},
			"S7x": {
				"type": "structure",
				"members": {
					"Line": {
						"type": "integer"
					},
					"Column": {
						"type": "integer"
					}
				}
			},
			"S80": {
				"type": "map",
				"key": {},
				"value": {}
			}
		}
	};

/***/ },
/* 376 */
/***/ function(module, exports) {

	module.exports = {
		"pagination": {
			"GetAccountAuthorizationDetails": {
				"input_token": "Marker",
				"limit_key": "MaxItems",
				"more_results": "IsTruncated",
				"output_token": "Marker",
				"result_key": [
					"UserDetailList",
					"GroupDetailList",
					"RoleDetailList",
					"Policies"
				]
			},
			"GetGroup": {
				"input_token": "Marker",
				"limit_key": "MaxItems",
				"more_results": "IsTruncated",
				"output_token": "Marker",
				"result_key": "Users"
			},
			"ListAccessKeys": {
				"input_token": "Marker",
				"limit_key": "MaxItems",
				"more_results": "IsTruncated",
				"output_token": "Marker",
				"result_key": "AccessKeyMetadata"
			},
			"ListAccountAliases": {
				"input_token": "Marker",
				"limit_key": "MaxItems",
				"more_results": "IsTruncated",
				"output_token": "Marker",
				"result_key": "AccountAliases"
			},
			"ListAttachedGroupPolicies": {
				"input_token": "Marker",
				"limit_key": "MaxItems",
				"more_results": "IsTruncated",
				"output_token": "Marker",
				"result_key": "AttachedPolicies"
			},
			"ListAttachedRolePolicies": {
				"input_token": "Marker",
				"limit_key": "MaxItems",
				"more_results": "IsTruncated",
				"output_token": "Marker",
				"result_key": "AttachedPolicies"
			},
			"ListAttachedUserPolicies": {
				"input_token": "Marker",
				"limit_key": "MaxItems",
				"more_results": "IsTruncated",
				"output_token": "Marker",
				"result_key": "AttachedPolicies"
			},
			"ListEntitiesForPolicy": {
				"input_token": "Marker",
				"limit_key": "MaxItems",
				"more_results": "IsTruncated",
				"output_token": "Marker",
				"result_key": [
					"PolicyGroups",
					"PolicyUsers",
					"PolicyRoles"
				]
			},
			"ListGroupPolicies": {
				"input_token": "Marker",
				"limit_key": "MaxItems",
				"more_results": "IsTruncated",
				"output_token": "Marker",
				"result_key": "PolicyNames"
			},
			"ListGroups": {
				"input_token": "Marker",
				"limit_key": "MaxItems",
				"more_results": "IsTruncated",
				"output_token": "Marker",
				"result_key": "Groups"
			},
			"ListGroupsForUser": {
				"input_token": "Marker",
				"limit_key": "MaxItems",
				"more_results": "IsTruncated",
				"output_token": "Marker",
				"result_key": "Groups"
			},
			"ListInstanceProfiles": {
				"input_token": "Marker",
				"limit_key": "MaxItems",
				"more_results": "IsTruncated",
				"output_token": "Marker",
				"result_key": "InstanceProfiles"
			},
			"ListInstanceProfilesForRole": {
				"input_token": "Marker",
				"limit_key": "MaxItems",
				"more_results": "IsTruncated",
				"output_token": "Marker",
				"result_key": "InstanceProfiles"
			},
			"ListMFADevices": {
				"input_token": "Marker",
				"limit_key": "MaxItems",
				"more_results": "IsTruncated",
				"output_token": "Marker",
				"result_key": "MFADevices"
			},
			"ListPolicies": {
				"input_token": "Marker",
				"limit_key": "MaxItems",
				"more_results": "IsTruncated",
				"output_token": "Marker",
				"result_key": "Policies"
			},
			"ListPolicyVersions": {
				"input_token": "Marker",
				"limit_key": "MaxItems",
				"more_results": "IsTruncated",
				"output_token": "Marker",
				"result_key": "Versions"
			},
			"ListRolePolicies": {
				"input_token": "Marker",
				"limit_key": "MaxItems",
				"more_results": "IsTruncated",
				"output_token": "Marker",
				"result_key": "PolicyNames"
			},
			"ListRoles": {
				"input_token": "Marker",
				"limit_key": "MaxItems",
				"more_results": "IsTruncated",
				"output_token": "Marker",
				"result_key": "Roles"
			},
			"ListSAMLProviders": {
				"result_key": "SAMLProviderList"
			},
			"ListServerCertificates": {
				"input_token": "Marker",
				"limit_key": "MaxItems",
				"more_results": "IsTruncated",
				"output_token": "Marker",
				"result_key": "ServerCertificateMetadataList"
			},
			"ListSigningCertificates": {
				"input_token": "Marker",
				"limit_key": "MaxItems",
				"more_results": "IsTruncated",
				"output_token": "Marker",
				"result_key": "Certificates"
			},
			"ListSSHPublicKeys": {
				"input_token": "Marker",
				"limit_key": "MaxItems",
				"more_results": "IsTruncated",
				"output_token": "Marker",
				"result_key": "SSHPublicKeys"
			},
			"ListUserPolicies": {
				"input_token": "Marker",
				"limit_key": "MaxItems",
				"more_results": "IsTruncated",
				"output_token": "Marker",
				"result_key": "PolicyNames"
			},
			"ListUsers": {
				"input_token": "Marker",
				"limit_key": "MaxItems",
				"more_results": "IsTruncated",
				"output_token": "Marker",
				"result_key": "Users"
			},
			"ListVirtualMFADevices": {
				"input_token": "Marker",
				"limit_key": "MaxItems",
				"more_results": "IsTruncated",
				"output_token": "Marker",
				"result_key": "VirtualMFADevices"
			},
			"SimulateCustomPolicy": {
				"input_token": "Marker",
				"limit_key": "MaxItems",
				"more_results": "IsTruncated",
				"output_token": "Marker",
				"result_key": "EvaluationResults"
			},
			"SimulatePrincipalPolicy": {
				"input_token": "Marker",
				"limit_key": "MaxItems",
				"more_results": "IsTruncated",
				"output_token": "Marker",
				"result_key": "EvaluationResults"
			}
		}
	};

/***/ },
/* 377 */
/***/ function(module, exports) {

	module.exports = {
		"version": 2,
		"waiters": {
			"InstanceProfileExists": {
				"delay": 1,
				"operation": "GetInstanceProfile",
				"maxAttempts": 40,
				"acceptors": [
					{
						"expected": 200,
						"matcher": "status",
						"state": "success"
					},
					{
						"state": "retry",
						"matcher": "status",
						"expected": 404
					}
				]
			},
			"UserExists": {
				"delay": 1,
				"operation": "GetUser",
				"maxAttempts": 20,
				"acceptors": [
					{
						"state": "success",
						"matcher": "status",
						"expected": 200
					},
					{
						"state": "retry",
						"matcher": "error",
						"expected": "NoSuchEntity"
					}
				]
			}
		}
	};

/***/ },
/* 378 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['importexport'] = {};
	AWS.ImportExport = Service.defineService('importexport', ['2010-06-01']);
	Object.defineProperty(apiLoader.services['importexport'], '2010-06-01', {
	  get: function get() {
	    var model = __webpack_require__(379);
	    model.paginators = __webpack_require__(380).pagination;
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.ImportExport;


/***/ },
/* 379 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2010-06-01",
			"endpointPrefix": "importexport",
			"globalEndpoint": "importexport.amazonaws.com",
			"serviceFullName": "AWS Import/Export",
			"signatureVersion": "v2",
			"xmlNamespace": "http://importexport.amazonaws.com/doc/2010-06-01/",
			"protocol": "query"
		},
		"operations": {
			"CancelJob": {
				"http": {
					"requestUri": "/?Operation=CancelJob"
				},
				"input": {
					"type": "structure",
					"required": [
						"JobId"
					],
					"members": {
						"JobId": {},
						"APIVersion": {}
					}
				},
				"output": {
					"resultWrapper": "CancelJobResult",
					"type": "structure",
					"members": {
						"Success": {
							"type": "boolean"
						}
					}
				}
			},
			"CreateJob": {
				"http": {
					"requestUri": "/?Operation=CreateJob"
				},
				"input": {
					"type": "structure",
					"required": [
						"JobType",
						"Manifest",
						"ValidateOnly"
					],
					"members": {
						"JobType": {},
						"Manifest": {},
						"ManifestAddendum": {},
						"ValidateOnly": {
							"type": "boolean"
						},
						"APIVersion": {}
					}
				},
				"output": {
					"resultWrapper": "CreateJobResult",
					"type": "structure",
					"members": {
						"JobId": {},
						"JobType": {},
						"Signature": {},
						"SignatureFileContents": {},
						"WarningMessage": {},
						"ArtifactList": {
							"shape": "Sf"
						}
					}
				}
			},
			"GetShippingLabel": {
				"http": {
					"requestUri": "/?Operation=GetShippingLabel"
				},
				"input": {
					"type": "structure",
					"required": [
						"jobIds"
					],
					"members": {
						"jobIds": {
							"type": "list",
							"member": {}
						},
						"name": {},
						"company": {},
						"phoneNumber": {},
						"country": {},
						"stateOrProvince": {},
						"city": {},
						"postalCode": {},
						"street1": {},
						"street2": {},
						"street3": {},
						"APIVersion": {}
					}
				},
				"output": {
					"resultWrapper": "GetShippingLabelResult",
					"type": "structure",
					"members": {
						"ShippingLabelURL": {},
						"Warning": {}
					}
				}
			},
			"GetStatus": {
				"http": {
					"requestUri": "/?Operation=GetStatus"
				},
				"input": {
					"type": "structure",
					"required": [
						"JobId"
					],
					"members": {
						"JobId": {},
						"APIVersion": {}
					}
				},
				"output": {
					"resultWrapper": "GetStatusResult",
					"type": "structure",
					"members": {
						"JobId": {},
						"JobType": {},
						"LocationCode": {},
						"LocationMessage": {},
						"ProgressCode": {},
						"ProgressMessage": {},
						"Carrier": {},
						"TrackingNumber": {},
						"LogBucket": {},
						"LogKey": {},
						"ErrorCount": {
							"type": "integer"
						},
						"Signature": {},
						"SignatureFileContents": {},
						"CurrentManifest": {},
						"CreationDate": {
							"type": "timestamp"
						},
						"ArtifactList": {
							"shape": "Sf"
						}
					}
				}
			},
			"ListJobs": {
				"http": {
					"requestUri": "/?Operation=ListJobs"
				},
				"input": {
					"type": "structure",
					"members": {
						"MaxJobs": {
							"type": "integer"
						},
						"Marker": {},
						"APIVersion": {}
					}
				},
				"output": {
					"resultWrapper": "ListJobsResult",
					"type": "structure",
					"members": {
						"Jobs": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"JobId": {},
									"CreationDate": {
										"type": "timestamp"
									},
									"IsCanceled": {
										"type": "boolean"
									},
									"JobType": {}
								}
							}
						},
						"IsTruncated": {
							"type": "boolean"
						}
					}
				}
			},
			"UpdateJob": {
				"http": {
					"requestUri": "/?Operation=UpdateJob"
				},
				"input": {
					"type": "structure",
					"required": [
						"JobId",
						"Manifest",
						"JobType",
						"ValidateOnly"
					],
					"members": {
						"JobId": {},
						"Manifest": {},
						"JobType": {},
						"ValidateOnly": {
							"type": "boolean"
						},
						"APIVersion": {}
					}
				},
				"output": {
					"resultWrapper": "UpdateJobResult",
					"type": "structure",
					"members": {
						"Success": {
							"type": "boolean"
						},
						"WarningMessage": {},
						"ArtifactList": {
							"shape": "Sf"
						}
					}
				}
			}
		},
		"shapes": {
			"Sf": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"Description": {},
						"URL": {}
					}
				}
			}
		},
		"examples": {}
	};

/***/ },
/* 380 */
/***/ function(module, exports) {

	module.exports = {
		"pagination": {
			"ListJobs": {
				"input_token": "Marker",
				"output_token": "Jobs[-1].JobId",
				"more_results": "IsTruncated",
				"limit_key": "MaxJobs",
				"result_key": "Jobs"
			}
		}
	};

/***/ },
/* 381 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['inspector'] = {};
	AWS.Inspector = Service.defineService('inspector', ['2015-08-18*', '2016-02-16']);
	Object.defineProperty(apiLoader.services['inspector'], '2016-02-16', {
	  get: function get() {
	    var model = __webpack_require__(382);
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.Inspector;


/***/ },
/* 382 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2016-02-16",
			"endpointPrefix": "inspector",
			"jsonVersion": "1.1",
			"protocol": "json",
			"serviceFullName": "Amazon Inspector",
			"signatureVersion": "v4",
			"targetPrefix": "InspectorService"
		},
		"operations": {
			"AddAttributesToFindings": {
				"input": {
					"type": "structure",
					"required": [
						"findingArns",
						"attributes"
					],
					"members": {
						"findingArns": {
							"shape": "S2"
						},
						"attributes": {
							"shape": "S4"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"failedItems"
					],
					"members": {
						"failedItems": {
							"shape": "S9"
						}
					}
				}
			},
			"CreateAssessmentTarget": {
				"input": {
					"type": "structure",
					"required": [
						"assessmentTargetName",
						"resourceGroupArn"
					],
					"members": {
						"assessmentTargetName": {},
						"resourceGroupArn": {}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"assessmentTargetArn"
					],
					"members": {
						"assessmentTargetArn": {}
					}
				}
			},
			"CreateAssessmentTemplate": {
				"input": {
					"type": "structure",
					"required": [
						"assessmentTargetArn",
						"assessmentTemplateName",
						"durationInSeconds",
						"rulesPackageArns"
					],
					"members": {
						"assessmentTargetArn": {},
						"assessmentTemplateName": {},
						"durationInSeconds": {
							"type": "integer"
						},
						"rulesPackageArns": {
							"shape": "Sj"
						},
						"userAttributesForFindings": {
							"shape": "S4"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"assessmentTemplateArn"
					],
					"members": {
						"assessmentTemplateArn": {}
					}
				}
			},
			"CreateResourceGroup": {
				"input": {
					"type": "structure",
					"required": [
						"resourceGroupTags"
					],
					"members": {
						"resourceGroupTags": {
							"shape": "Sm"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"resourceGroupArn"
					],
					"members": {
						"resourceGroupArn": {}
					}
				}
			},
			"DeleteAssessmentRun": {
				"input": {
					"type": "structure",
					"required": [
						"assessmentRunArn"
					],
					"members": {
						"assessmentRunArn": {}
					}
				}
			},
			"DeleteAssessmentTarget": {
				"input": {
					"type": "structure",
					"required": [
						"assessmentTargetArn"
					],
					"members": {
						"assessmentTargetArn": {}
					}
				}
			},
			"DeleteAssessmentTemplate": {
				"input": {
					"type": "structure",
					"required": [
						"assessmentTemplateArn"
					],
					"members": {
						"assessmentTemplateArn": {}
					}
				}
			},
			"DescribeAssessmentRuns": {
				"input": {
					"type": "structure",
					"required": [
						"assessmentRunArns"
					],
					"members": {
						"assessmentRunArns": {
							"shape": "Sv"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"assessmentRuns",
						"failedItems"
					],
					"members": {
						"assessmentRuns": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"arn",
									"name",
									"assessmentTemplateArn",
									"state",
									"durationInSeconds",
									"rulesPackageArns",
									"userAttributesForFindings",
									"createdAt",
									"stateChangedAt",
									"dataCollected",
									"stateChanges",
									"notifications"
								],
								"members": {
									"arn": {},
									"name": {},
									"assessmentTemplateArn": {},
									"state": {},
									"durationInSeconds": {
										"type": "integer"
									},
									"rulesPackageArns": {
										"type": "list",
										"member": {}
									},
									"userAttributesForFindings": {
										"shape": "S4"
									},
									"createdAt": {
										"type": "timestamp"
									},
									"startedAt": {
										"type": "timestamp"
									},
									"completedAt": {
										"type": "timestamp"
									},
									"stateChangedAt": {
										"type": "timestamp"
									},
									"dataCollected": {
										"type": "boolean"
									},
									"stateChanges": {
										"type": "list",
										"member": {
											"type": "structure",
											"required": [
												"stateChangedAt",
												"state"
											],
											"members": {
												"stateChangedAt": {
													"type": "timestamp"
												},
												"state": {}
											}
										}
									},
									"notifications": {
										"type": "list",
										"member": {
											"type": "structure",
											"required": [
												"date",
												"event",
												"error"
											],
											"members": {
												"date": {
													"type": "timestamp"
												},
												"event": {},
												"message": {},
												"error": {
													"type": "boolean"
												},
												"snsTopicArn": {},
												"snsPublishStatusCode": {}
											}
										}
									}
								}
							}
						},
						"failedItems": {
							"shape": "S9"
						}
					}
				}
			},
			"DescribeAssessmentTargets": {
				"input": {
					"type": "structure",
					"required": [
						"assessmentTargetArns"
					],
					"members": {
						"assessmentTargetArns": {
							"shape": "Sv"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"assessmentTargets",
						"failedItems"
					],
					"members": {
						"assessmentTargets": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"arn",
									"name",
									"resourceGroupArn",
									"createdAt",
									"updatedAt"
								],
								"members": {
									"arn": {},
									"name": {},
									"resourceGroupArn": {},
									"createdAt": {
										"type": "timestamp"
									},
									"updatedAt": {
										"type": "timestamp"
									}
								}
							}
						},
						"failedItems": {
							"shape": "S9"
						}
					}
				}
			},
			"DescribeAssessmentTemplates": {
				"input": {
					"type": "structure",
					"required": [
						"assessmentTemplateArns"
					],
					"members": {
						"assessmentTemplateArns": {
							"shape": "Sv"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"assessmentTemplates",
						"failedItems"
					],
					"members": {
						"assessmentTemplates": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"arn",
									"name",
									"assessmentTargetArn",
									"durationInSeconds",
									"rulesPackageArns",
									"userAttributesForFindings",
									"createdAt"
								],
								"members": {
									"arn": {},
									"name": {},
									"assessmentTargetArn": {},
									"durationInSeconds": {
										"type": "integer"
									},
									"rulesPackageArns": {
										"shape": "Sj"
									},
									"userAttributesForFindings": {
										"shape": "S4"
									},
									"createdAt": {
										"type": "timestamp"
									}
								}
							}
						},
						"failedItems": {
							"shape": "S9"
						}
					}
				}
			},
			"DescribeCrossAccountAccessRole": {
				"output": {
					"type": "structure",
					"required": [
						"roleArn",
						"valid",
						"registeredAt"
					],
					"members": {
						"roleArn": {},
						"valid": {
							"type": "boolean"
						},
						"registeredAt": {
							"type": "timestamp"
						}
					}
				}
			},
			"DescribeFindings": {
				"input": {
					"type": "structure",
					"required": [
						"findingArns"
					],
					"members": {
						"findingArns": {
							"shape": "Sv"
						},
						"locale": {}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"findings",
						"failedItems"
					],
					"members": {
						"findings": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"arn",
									"attributes",
									"userAttributes",
									"createdAt",
									"updatedAt"
								],
								"members": {
									"arn": {},
									"schemaVersion": {
										"type": "integer"
									},
									"service": {},
									"serviceAttributes": {
										"type": "structure",
										"required": [
											"schemaVersion"
										],
										"members": {
											"schemaVersion": {
												"type": "integer"
											},
											"assessmentRunArn": {},
											"rulesPackageArn": {}
										}
									},
									"assetType": {},
									"assetAttributes": {
										"type": "structure",
										"required": [
											"schemaVersion"
										],
										"members": {
											"schemaVersion": {
												"type": "integer"
											},
											"agentId": {},
											"autoScalingGroup": {},
											"amiId": {},
											"hostname": {},
											"ipv4Addresses": {
												"type": "list",
												"member": {}
											}
										}
									},
									"id": {},
									"title": {},
									"description": {},
									"recommendation": {},
									"severity": {},
									"numericSeverity": {
										"type": "double"
									},
									"confidence": {
										"type": "integer"
									},
									"indicatorOfCompromise": {
										"type": "boolean"
									},
									"attributes": {
										"shape": "S24"
									},
									"userAttributes": {
										"shape": "S4"
									},
									"createdAt": {
										"type": "timestamp"
									},
									"updatedAt": {
										"type": "timestamp"
									}
								}
							}
						},
						"failedItems": {
							"shape": "S9"
						}
					}
				}
			},
			"DescribeResourceGroups": {
				"input": {
					"type": "structure",
					"required": [
						"resourceGroupArns"
					],
					"members": {
						"resourceGroupArns": {
							"shape": "Sv"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"resourceGroups",
						"failedItems"
					],
					"members": {
						"resourceGroups": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"arn",
									"tags",
									"createdAt"
								],
								"members": {
									"arn": {},
									"tags": {
										"shape": "Sm"
									},
									"createdAt": {
										"type": "timestamp"
									}
								}
							}
						},
						"failedItems": {
							"shape": "S9"
						}
					}
				}
			},
			"DescribeRulesPackages": {
				"input": {
					"type": "structure",
					"required": [
						"rulesPackageArns"
					],
					"members": {
						"rulesPackageArns": {
							"shape": "Sv"
						},
						"locale": {}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"rulesPackages",
						"failedItems"
					],
					"members": {
						"rulesPackages": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"arn",
									"name",
									"version",
									"provider"
								],
								"members": {
									"arn": {},
									"name": {},
									"version": {},
									"provider": {},
									"description": {}
								}
							}
						},
						"failedItems": {
							"shape": "S9"
						}
					}
				}
			},
			"GetTelemetryMetadata": {
				"input": {
					"type": "structure",
					"required": [
						"assessmentRunArn"
					],
					"members": {
						"assessmentRunArn": {}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"telemetryMetadata"
					],
					"members": {
						"telemetryMetadata": {
							"shape": "S2i"
						}
					}
				}
			},
			"ListAssessmentRunAgents": {
				"input": {
					"type": "structure",
					"required": [
						"assessmentRunArn"
					],
					"members": {
						"assessmentRunArn": {},
						"filter": {
							"type": "structure",
							"required": [
								"agentHealths",
								"agentHealthCodes"
							],
							"members": {
								"agentHealths": {
									"type": "list",
									"member": {}
								},
								"agentHealthCodes": {
									"type": "list",
									"member": {}
								}
							}
						},
						"nextToken": {},
						"maxResults": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"assessmentRunAgents"
					],
					"members": {
						"assessmentRunAgents": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"agentId",
									"assessmentRunArn",
									"agentHealth",
									"agentHealthCode",
									"telemetryMetadata"
								],
								"members": {
									"agentId": {},
									"assessmentRunArn": {},
									"agentHealth": {},
									"agentHealthCode": {},
									"agentHealthDetails": {},
									"autoScalingGroup": {},
									"telemetryMetadata": {
										"shape": "S2i"
									}
								}
							}
						},
						"nextToken": {}
					}
				}
			},
			"ListAssessmentRuns": {
				"input": {
					"type": "structure",
					"members": {
						"assessmentTemplateArns": {
							"shape": "S2y"
						},
						"filter": {
							"type": "structure",
							"members": {
								"namePattern": {},
								"states": {
									"type": "list",
									"member": {}
								},
								"durationRange": {
									"shape": "S32"
								},
								"rulesPackageArns": {
									"shape": "S33"
								},
								"startTimeRange": {
									"shape": "S34"
								},
								"completionTimeRange": {
									"shape": "S34"
								},
								"stateChangeTimeRange": {
									"shape": "S34"
								}
							}
						},
						"nextToken": {},
						"maxResults": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"assessmentRunArns"
					],
					"members": {
						"assessmentRunArns": {
							"shape": "S36"
						},
						"nextToken": {}
					}
				}
			},
			"ListAssessmentTargets": {
				"input": {
					"type": "structure",
					"members": {
						"filter": {
							"type": "structure",
							"members": {
								"assessmentTargetNamePattern": {}
							}
						},
						"nextToken": {},
						"maxResults": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"assessmentTargetArns"
					],
					"members": {
						"assessmentTargetArns": {
							"shape": "S36"
						},
						"nextToken": {}
					}
				}
			},
			"ListAssessmentTemplates": {
				"input": {
					"type": "structure",
					"members": {
						"assessmentTargetArns": {
							"shape": "S2y"
						},
						"filter": {
							"type": "structure",
							"members": {
								"namePattern": {},
								"durationRange": {
									"shape": "S32"
								},
								"rulesPackageArns": {
									"shape": "S33"
								}
							}
						},
						"nextToken": {},
						"maxResults": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"assessmentTemplateArns"
					],
					"members": {
						"assessmentTemplateArns": {
							"shape": "S36"
						},
						"nextToken": {}
					}
				}
			},
			"ListEventSubscriptions": {
				"input": {
					"type": "structure",
					"members": {
						"resourceArn": {},
						"nextToken": {},
						"maxResults": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"subscriptions"
					],
					"members": {
						"subscriptions": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"resourceArn",
									"topicArn",
									"eventSubscriptions"
								],
								"members": {
									"resourceArn": {},
									"topicArn": {},
									"eventSubscriptions": {
										"type": "list",
										"member": {
											"type": "structure",
											"required": [
												"event",
												"subscribedAt"
											],
											"members": {
												"event": {},
												"subscribedAt": {
													"type": "timestamp"
												}
											}
										}
									}
								}
							}
						},
						"nextToken": {}
					}
				}
			},
			"ListFindings": {
				"input": {
					"type": "structure",
					"members": {
						"assessmentRunArns": {
							"shape": "S2y"
						},
						"filter": {
							"type": "structure",
							"members": {
								"agentIds": {
									"type": "list",
									"member": {}
								},
								"autoScalingGroups": {
									"type": "list",
									"member": {}
								},
								"ruleNames": {
									"type": "list",
									"member": {}
								},
								"severities": {
									"type": "list",
									"member": {}
								},
								"rulesPackageArns": {
									"shape": "S33"
								},
								"attributes": {
									"shape": "S24"
								},
								"userAttributes": {
									"shape": "S24"
								},
								"creationTimeRange": {
									"shape": "S34"
								}
							}
						},
						"nextToken": {},
						"maxResults": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"findingArns"
					],
					"members": {
						"findingArns": {
							"shape": "S36"
						},
						"nextToken": {}
					}
				}
			},
			"ListRulesPackages": {
				"input": {
					"type": "structure",
					"members": {
						"nextToken": {},
						"maxResults": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"rulesPackageArns"
					],
					"members": {
						"rulesPackageArns": {
							"shape": "S36"
						},
						"nextToken": {}
					}
				}
			},
			"ListTagsForResource": {
				"input": {
					"type": "structure",
					"required": [
						"resourceArn"
					],
					"members": {
						"resourceArn": {}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"tags"
					],
					"members": {
						"tags": {
							"shape": "S3w"
						}
					}
				}
			},
			"PreviewAgents": {
				"input": {
					"type": "structure",
					"required": [
						"previewAgentsArn"
					],
					"members": {
						"previewAgentsArn": {},
						"nextToken": {},
						"maxResults": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"agentPreviews"
					],
					"members": {
						"agentPreviews": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"agentId"
								],
								"members": {
									"agentId": {},
									"autoScalingGroup": {}
								}
							}
						},
						"nextToken": {}
					}
				}
			},
			"RegisterCrossAccountAccessRole": {
				"input": {
					"type": "structure",
					"required": [
						"roleArn"
					],
					"members": {
						"roleArn": {}
					}
				}
			},
			"RemoveAttributesFromFindings": {
				"input": {
					"type": "structure",
					"required": [
						"findingArns",
						"attributeKeys"
					],
					"members": {
						"findingArns": {
							"shape": "S2"
						},
						"attributeKeys": {
							"type": "list",
							"member": {}
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"failedItems"
					],
					"members": {
						"failedItems": {
							"shape": "S9"
						}
					}
				}
			},
			"SetTagsForResource": {
				"input": {
					"type": "structure",
					"required": [
						"resourceArn"
					],
					"members": {
						"resourceArn": {},
						"tags": {
							"shape": "S3w"
						}
					}
				}
			},
			"StartAssessmentRun": {
				"input": {
					"type": "structure",
					"required": [
						"assessmentTemplateArn"
					],
					"members": {
						"assessmentTemplateArn": {},
						"assessmentRunName": {}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"assessmentRunArn"
					],
					"members": {
						"assessmentRunArn": {}
					}
				}
			},
			"StopAssessmentRun": {
				"input": {
					"type": "structure",
					"required": [
						"assessmentRunArn"
					],
					"members": {
						"assessmentRunArn": {}
					}
				}
			},
			"SubscribeToEvent": {
				"input": {
					"type": "structure",
					"required": [
						"resourceArn",
						"event",
						"topicArn"
					],
					"members": {
						"resourceArn": {},
						"event": {},
						"topicArn": {}
					}
				}
			},
			"UnsubscribeFromEvent": {
				"input": {
					"type": "structure",
					"required": [
						"resourceArn",
						"event",
						"topicArn"
					],
					"members": {
						"resourceArn": {},
						"event": {},
						"topicArn": {}
					}
				}
			},
			"UpdateAssessmentTarget": {
				"input": {
					"type": "structure",
					"required": [
						"assessmentTargetArn",
						"assessmentTargetName",
						"resourceGroupArn"
					],
					"members": {
						"assessmentTargetArn": {},
						"assessmentTargetName": {},
						"resourceGroupArn": {}
					}
				}
			}
		},
		"shapes": {
			"S2": {
				"type": "list",
				"member": {}
			},
			"S4": {
				"type": "list",
				"member": {
					"shape": "S5"
				}
			},
			"S5": {
				"type": "structure",
				"required": [
					"key"
				],
				"members": {
					"key": {},
					"value": {}
				}
			},
			"S9": {
				"type": "map",
				"key": {},
				"value": {
					"type": "structure",
					"required": [
						"failureCode",
						"retryable"
					],
					"members": {
						"failureCode": {},
						"retryable": {
							"type": "boolean"
						}
					}
				}
			},
			"Sj": {
				"type": "list",
				"member": {}
			},
			"Sm": {
				"type": "list",
				"member": {
					"type": "structure",
					"required": [
						"key"
					],
					"members": {
						"key": {},
						"value": {}
					}
				}
			},
			"Sv": {
				"type": "list",
				"member": {}
			},
			"S24": {
				"type": "list",
				"member": {
					"shape": "S5"
				}
			},
			"S2i": {
				"type": "list",
				"member": {
					"type": "structure",
					"required": [
						"messageType",
						"count"
					],
					"members": {
						"messageType": {},
						"count": {
							"type": "long"
						},
						"dataSize": {
							"type": "long"
						}
					}
				}
			},
			"S2y": {
				"type": "list",
				"member": {}
			},
			"S32": {
				"type": "structure",
				"members": {
					"minSeconds": {
						"type": "integer"
					},
					"maxSeconds": {
						"type": "integer"
					}
				}
			},
			"S33": {
				"type": "list",
				"member": {}
			},
			"S34": {
				"type": "structure",
				"members": {
					"beginDate": {
						"type": "timestamp"
					},
					"endDate": {
						"type": "timestamp"
					}
				}
			},
			"S36": {
				"type": "list",
				"member": {}
			},
			"S3w": {
				"type": "list",
				"member": {
					"type": "structure",
					"required": [
						"key"
					],
					"members": {
						"key": {},
						"value": {}
					}
				}
			}
		}
	};

/***/ },
/* 383 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['iot'] = {};
	AWS.Iot = Service.defineService('iot', ['2015-05-28']);
	Object.defineProperty(apiLoader.services['iot'], '2015-05-28', {
	  get: function get() {
	    var model = __webpack_require__(384);
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.Iot;


/***/ },
/* 384 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2015-05-28",
			"endpointPrefix": "iot",
			"serviceFullName": "AWS IoT",
			"signatureVersion": "v4",
			"signingName": "execute-api",
			"protocol": "rest-json"
		},
		"operations": {
			"AcceptCertificateTransfer": {
				"http": {
					"method": "PATCH",
					"requestUri": "/accept-certificate-transfer/{certificateId}"
				},
				"input": {
					"type": "structure",
					"required": [
						"certificateId"
					],
					"members": {
						"certificateId": {
							"location": "uri",
							"locationName": "certificateId"
						},
						"setAsActive": {
							"location": "querystring",
							"locationName": "setAsActive",
							"type": "boolean"
						}
					}
				}
			},
			"AttachPrincipalPolicy": {
				"http": {
					"method": "PUT",
					"requestUri": "/principal-policies/{policyName}"
				},
				"input": {
					"type": "structure",
					"required": [
						"policyName",
						"principal"
					],
					"members": {
						"policyName": {
							"location": "uri",
							"locationName": "policyName"
						},
						"principal": {
							"location": "header",
							"locationName": "x-amzn-iot-principal"
						}
					}
				}
			},
			"AttachThingPrincipal": {
				"http": {
					"method": "PUT",
					"requestUri": "/things/{thingName}/principals"
				},
				"input": {
					"type": "structure",
					"required": [
						"thingName",
						"principal"
					],
					"members": {
						"thingName": {
							"location": "uri",
							"locationName": "thingName"
						},
						"principal": {
							"location": "header",
							"locationName": "x-amzn-principal"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"CancelCertificateTransfer": {
				"http": {
					"method": "PATCH",
					"requestUri": "/cancel-certificate-transfer/{certificateId}"
				},
				"input": {
					"type": "structure",
					"required": [
						"certificateId"
					],
					"members": {
						"certificateId": {
							"location": "uri",
							"locationName": "certificateId"
						}
					}
				}
			},
			"CreateCertificateFromCsr": {
				"http": {
					"requestUri": "/certificates"
				},
				"input": {
					"type": "structure",
					"required": [
						"certificateSigningRequest"
					],
					"members": {
						"certificateSigningRequest": {},
						"setAsActive": {
							"location": "querystring",
							"locationName": "setAsActive",
							"type": "boolean"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"certificateArn": {},
						"certificateId": {},
						"certificatePem": {}
					}
				}
			},
			"CreateKeysAndCertificate": {
				"http": {
					"requestUri": "/keys-and-certificate"
				},
				"input": {
					"type": "structure",
					"members": {
						"setAsActive": {
							"location": "querystring",
							"locationName": "setAsActive",
							"type": "boolean"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"certificateArn": {},
						"certificateId": {},
						"certificatePem": {},
						"keyPair": {
							"type": "structure",
							"members": {
								"PublicKey": {},
								"PrivateKey": {
									"type": "string",
									"sensitive": true
								}
							}
						}
					}
				}
			},
			"CreatePolicy": {
				"http": {
					"requestUri": "/policies/{policyName}"
				},
				"input": {
					"type": "structure",
					"required": [
						"policyName",
						"policyDocument"
					],
					"members": {
						"policyName": {
							"location": "uri",
							"locationName": "policyName"
						},
						"policyDocument": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"policyName": {},
						"policyArn": {},
						"policyDocument": {},
						"policyVersionId": {}
					}
				}
			},
			"CreatePolicyVersion": {
				"http": {
					"requestUri": "/policies/{policyName}/version"
				},
				"input": {
					"type": "structure",
					"required": [
						"policyName",
						"policyDocument"
					],
					"members": {
						"policyName": {
							"location": "uri",
							"locationName": "policyName"
						},
						"policyDocument": {},
						"setAsDefault": {
							"location": "querystring",
							"locationName": "setAsDefault",
							"type": "boolean"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"policyArn": {},
						"policyDocument": {},
						"policyVersionId": {},
						"isDefaultVersion": {
							"type": "boolean"
						}
					}
				}
			},
			"CreateThing": {
				"http": {
					"requestUri": "/things/{thingName}"
				},
				"input": {
					"type": "structure",
					"required": [
						"thingName"
					],
					"members": {
						"thingName": {
							"location": "uri",
							"locationName": "thingName"
						},
						"thingTypeName": {},
						"attributePayload": {
							"shape": "Sw"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"thingName": {},
						"thingArn": {}
					}
				}
			},
			"CreateThingType": {
				"http": {
					"requestUri": "/thing-types/{thingTypeName}"
				},
				"input": {
					"type": "structure",
					"required": [
						"thingTypeName"
					],
					"members": {
						"thingTypeName": {
							"location": "uri",
							"locationName": "thingTypeName"
						},
						"thingTypeProperties": {
							"shape": "S14"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"thingTypeName": {},
						"thingTypeArn": {}
					}
				}
			},
			"CreateTopicRule": {
				"http": {
					"requestUri": "/rules/{ruleName}"
				},
				"input": {
					"type": "structure",
					"required": [
						"ruleName",
						"topicRulePayload"
					],
					"members": {
						"ruleName": {
							"location": "uri",
							"locationName": "ruleName"
						},
						"topicRulePayload": {
							"shape": "S1b"
						}
					},
					"payload": "topicRulePayload"
				}
			},
			"DeleteCACertificate": {
				"http": {
					"method": "DELETE",
					"requestUri": "/cacertificate/{caCertificateId}"
				},
				"input": {
					"type": "structure",
					"required": [
						"certificateId"
					],
					"members": {
						"certificateId": {
							"location": "uri",
							"locationName": "caCertificateId"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"DeleteCertificate": {
				"http": {
					"method": "DELETE",
					"requestUri": "/certificates/{certificateId}"
				},
				"input": {
					"type": "structure",
					"required": [
						"certificateId"
					],
					"members": {
						"certificateId": {
							"location": "uri",
							"locationName": "certificateId"
						}
					}
				}
			},
			"DeletePolicy": {
				"http": {
					"method": "DELETE",
					"requestUri": "/policies/{policyName}"
				},
				"input": {
					"type": "structure",
					"required": [
						"policyName"
					],
					"members": {
						"policyName": {
							"location": "uri",
							"locationName": "policyName"
						}
					}
				}
			},
			"DeletePolicyVersion": {
				"http": {
					"method": "DELETE",
					"requestUri": "/policies/{policyName}/version/{policyVersionId}"
				},
				"input": {
					"type": "structure",
					"required": [
						"policyName",
						"policyVersionId"
					],
					"members": {
						"policyName": {
							"location": "uri",
							"locationName": "policyName"
						},
						"policyVersionId": {
							"location": "uri",
							"locationName": "policyVersionId"
						}
					}
				}
			},
			"DeleteRegistrationCode": {
				"http": {
					"method": "DELETE",
					"requestUri": "/registrationcode"
				},
				"input": {
					"type": "structure",
					"members": {}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"DeleteThing": {
				"http": {
					"method": "DELETE",
					"requestUri": "/things/{thingName}"
				},
				"input": {
					"type": "structure",
					"required": [
						"thingName"
					],
					"members": {
						"thingName": {
							"location": "uri",
							"locationName": "thingName"
						},
						"expectedVersion": {
							"location": "querystring",
							"locationName": "expectedVersion",
							"type": "long"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"DeleteThingType": {
				"http": {
					"method": "DELETE",
					"requestUri": "/thing-types/{thingTypeName}"
				},
				"input": {
					"type": "structure",
					"required": [
						"thingTypeName"
					],
					"members": {
						"thingTypeName": {
							"location": "uri",
							"locationName": "thingTypeName"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"DeleteTopicRule": {
				"http": {
					"method": "DELETE",
					"requestUri": "/rules/{ruleName}"
				},
				"input": {
					"type": "structure",
					"members": {
						"ruleName": {
							"location": "uri",
							"locationName": "ruleName"
						}
					},
					"required": [
						"ruleName"
					]
				}
			},
			"DeprecateThingType": {
				"http": {
					"requestUri": "/thing-types/{thingTypeName}/deprecate"
				},
				"input": {
					"type": "structure",
					"required": [
						"thingTypeName"
					],
					"members": {
						"thingTypeName": {
							"location": "uri",
							"locationName": "thingTypeName"
						},
						"undoDeprecate": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"DescribeCACertificate": {
				"http": {
					"method": "GET",
					"requestUri": "/cacertificate/{caCertificateId}"
				},
				"input": {
					"type": "structure",
					"required": [
						"certificateId"
					],
					"members": {
						"certificateId": {
							"location": "uri",
							"locationName": "caCertificateId"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"certificateDescription": {
							"type": "structure",
							"members": {
								"certificateArn": {},
								"certificateId": {},
								"status": {},
								"certificatePem": {},
								"ownedBy": {},
								"creationDate": {
									"type": "timestamp"
								},
								"autoRegistrationStatus": {}
							}
						}
					}
				}
			},
			"DescribeCertificate": {
				"http": {
					"method": "GET",
					"requestUri": "/certificates/{certificateId}"
				},
				"input": {
					"type": "structure",
					"required": [
						"certificateId"
					],
					"members": {
						"certificateId": {
							"location": "uri",
							"locationName": "certificateId"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"certificateDescription": {
							"type": "structure",
							"members": {
								"certificateArn": {},
								"certificateId": {},
								"caCertificateId": {},
								"status": {},
								"certificatePem": {},
								"ownedBy": {},
								"previousOwnedBy": {},
								"creationDate": {
									"type": "timestamp"
								},
								"lastModifiedDate": {
									"type": "timestamp"
								},
								"transferData": {
									"type": "structure",
									"members": {
										"transferMessage": {},
										"rejectReason": {},
										"transferDate": {
											"type": "timestamp"
										},
										"acceptDate": {
											"type": "timestamp"
										},
										"rejectDate": {
											"type": "timestamp"
										}
									}
								}
							}
						}
					}
				}
			},
			"DescribeEndpoint": {
				"http": {
					"method": "GET",
					"requestUri": "/endpoint"
				},
				"input": {
					"type": "structure",
					"members": {}
				},
				"output": {
					"type": "structure",
					"members": {
						"endpointAddress": {}
					}
				}
			},
			"DescribeThing": {
				"http": {
					"method": "GET",
					"requestUri": "/things/{thingName}"
				},
				"input": {
					"type": "structure",
					"required": [
						"thingName"
					],
					"members": {
						"thingName": {
							"location": "uri",
							"locationName": "thingName"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"defaultClientId": {},
						"thingName": {},
						"thingTypeName": {},
						"attributes": {
							"shape": "Sx"
						},
						"version": {
							"type": "long"
						}
					}
				}
			},
			"DescribeThingType": {
				"http": {
					"method": "GET",
					"requestUri": "/thing-types/{thingTypeName}"
				},
				"input": {
					"type": "structure",
					"required": [
						"thingTypeName"
					],
					"members": {
						"thingTypeName": {
							"location": "uri",
							"locationName": "thingTypeName"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"thingTypeName": {},
						"thingTypeProperties": {
							"shape": "S14"
						},
						"thingTypeMetadata": {
							"shape": "S3u"
						}
					}
				}
			},
			"DetachPrincipalPolicy": {
				"http": {
					"method": "DELETE",
					"requestUri": "/principal-policies/{policyName}"
				},
				"input": {
					"type": "structure",
					"required": [
						"policyName",
						"principal"
					],
					"members": {
						"policyName": {
							"location": "uri",
							"locationName": "policyName"
						},
						"principal": {
							"location": "header",
							"locationName": "x-amzn-iot-principal"
						}
					}
				}
			},
			"DetachThingPrincipal": {
				"http": {
					"method": "DELETE",
					"requestUri": "/things/{thingName}/principals"
				},
				"input": {
					"type": "structure",
					"required": [
						"thingName",
						"principal"
					],
					"members": {
						"thingName": {
							"location": "uri",
							"locationName": "thingName"
						},
						"principal": {
							"location": "header",
							"locationName": "x-amzn-principal"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"DisableTopicRule": {
				"http": {
					"requestUri": "/rules/{ruleName}/disable"
				},
				"input": {
					"type": "structure",
					"required": [
						"ruleName"
					],
					"members": {
						"ruleName": {
							"location": "uri",
							"locationName": "ruleName"
						}
					}
				}
			},
			"EnableTopicRule": {
				"http": {
					"requestUri": "/rules/{ruleName}/enable"
				},
				"input": {
					"type": "structure",
					"required": [
						"ruleName"
					],
					"members": {
						"ruleName": {
							"location": "uri",
							"locationName": "ruleName"
						}
					}
				}
			},
			"GetLoggingOptions": {
				"http": {
					"method": "GET",
					"requestUri": "/loggingOptions"
				},
				"input": {
					"type": "structure",
					"members": {}
				},
				"output": {
					"type": "structure",
					"members": {
						"roleArn": {},
						"logLevel": {}
					}
				}
			},
			"GetPolicy": {
				"http": {
					"method": "GET",
					"requestUri": "/policies/{policyName}"
				},
				"input": {
					"type": "structure",
					"required": [
						"policyName"
					],
					"members": {
						"policyName": {
							"location": "uri",
							"locationName": "policyName"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"policyName": {},
						"policyArn": {},
						"policyDocument": {},
						"defaultVersionId": {}
					}
				}
			},
			"GetPolicyVersion": {
				"http": {
					"method": "GET",
					"requestUri": "/policies/{policyName}/version/{policyVersionId}"
				},
				"input": {
					"type": "structure",
					"required": [
						"policyName",
						"policyVersionId"
					],
					"members": {
						"policyName": {
							"location": "uri",
							"locationName": "policyName"
						},
						"policyVersionId": {
							"location": "uri",
							"locationName": "policyVersionId"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"policyArn": {},
						"policyName": {},
						"policyDocument": {},
						"policyVersionId": {},
						"isDefaultVersion": {
							"type": "boolean"
						}
					}
				}
			},
			"GetRegistrationCode": {
				"http": {
					"method": "GET",
					"requestUri": "/registrationcode"
				},
				"input": {
					"type": "structure",
					"members": {}
				},
				"output": {
					"type": "structure",
					"members": {
						"registrationCode": {}
					}
				}
			},
			"GetTopicRule": {
				"http": {
					"method": "GET",
					"requestUri": "/rules/{ruleName}"
				},
				"input": {
					"type": "structure",
					"required": [
						"ruleName"
					],
					"members": {
						"ruleName": {
							"location": "uri",
							"locationName": "ruleName"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ruleArn": {},
						"rule": {
							"type": "structure",
							"members": {
								"ruleName": {},
								"sql": {},
								"description": {},
								"createdAt": {
									"type": "timestamp"
								},
								"actions": {
									"shape": "S1e"
								},
								"ruleDisabled": {
									"type": "boolean"
								},
								"awsIotSqlVersion": {}
							}
						}
					}
				}
			},
			"ListCACertificates": {
				"http": {
					"method": "GET",
					"requestUri": "/cacertificates"
				},
				"input": {
					"type": "structure",
					"members": {
						"pageSize": {
							"location": "querystring",
							"locationName": "pageSize",
							"type": "integer"
						},
						"marker": {
							"location": "querystring",
							"locationName": "marker"
						},
						"ascendingOrder": {
							"location": "querystring",
							"locationName": "isAscendingOrder",
							"type": "boolean"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"certificates": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"certificateArn": {},
									"certificateId": {},
									"status": {},
									"creationDate": {
										"type": "timestamp"
									}
								}
							}
						},
						"nextMarker": {}
					}
				}
			},
			"ListCertificates": {
				"http": {
					"method": "GET",
					"requestUri": "/certificates"
				},
				"input": {
					"type": "structure",
					"members": {
						"pageSize": {
							"location": "querystring",
							"locationName": "pageSize",
							"type": "integer"
						},
						"marker": {
							"location": "querystring",
							"locationName": "marker"
						},
						"ascendingOrder": {
							"location": "querystring",
							"locationName": "isAscendingOrder",
							"type": "boolean"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"certificates": {
							"shape": "S4r"
						},
						"nextMarker": {}
					}
				}
			},
			"ListCertificatesByCA": {
				"http": {
					"method": "GET",
					"requestUri": "/certificates-by-ca/{caCertificateId}"
				},
				"input": {
					"type": "structure",
					"required": [
						"caCertificateId"
					],
					"members": {
						"caCertificateId": {
							"location": "uri",
							"locationName": "caCertificateId"
						},
						"pageSize": {
							"location": "querystring",
							"locationName": "pageSize",
							"type": "integer"
						},
						"marker": {
							"location": "querystring",
							"locationName": "marker"
						},
						"ascendingOrder": {
							"location": "querystring",
							"locationName": "isAscendingOrder",
							"type": "boolean"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"certificates": {
							"shape": "S4r"
						},
						"nextMarker": {}
					}
				}
			},
			"ListOutgoingCertificates": {
				"http": {
					"method": "GET",
					"requestUri": "/certificates-out-going"
				},
				"input": {
					"type": "structure",
					"members": {
						"pageSize": {
							"location": "querystring",
							"locationName": "pageSize",
							"type": "integer"
						},
						"marker": {
							"location": "querystring",
							"locationName": "marker"
						},
						"ascendingOrder": {
							"location": "querystring",
							"locationName": "isAscendingOrder",
							"type": "boolean"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"outgoingCertificates": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"certificateArn": {},
									"certificateId": {},
									"transferredTo": {},
									"transferDate": {
										"type": "timestamp"
									},
									"transferMessage": {},
									"creationDate": {
										"type": "timestamp"
									}
								}
							}
						},
						"nextMarker": {}
					}
				}
			},
			"ListPolicies": {
				"http": {
					"method": "GET",
					"requestUri": "/policies"
				},
				"input": {
					"type": "structure",
					"members": {
						"marker": {
							"location": "querystring",
							"locationName": "marker"
						},
						"pageSize": {
							"location": "querystring",
							"locationName": "pageSize",
							"type": "integer"
						},
						"ascendingOrder": {
							"location": "querystring",
							"locationName": "isAscendingOrder",
							"type": "boolean"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"policies": {
							"shape": "S51"
						},
						"nextMarker": {}
					}
				}
			},
			"ListPolicyPrincipals": {
				"http": {
					"method": "GET",
					"requestUri": "/policy-principals"
				},
				"input": {
					"type": "structure",
					"required": [
						"policyName"
					],
					"members": {
						"policyName": {
							"location": "header",
							"locationName": "x-amzn-iot-policy"
						},
						"marker": {
							"location": "querystring",
							"locationName": "marker"
						},
						"pageSize": {
							"location": "querystring",
							"locationName": "pageSize",
							"type": "integer"
						},
						"ascendingOrder": {
							"location": "querystring",
							"locationName": "isAscendingOrder",
							"type": "boolean"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"principals": {
							"shape": "S55"
						},
						"nextMarker": {}
					}
				}
			},
			"ListPolicyVersions": {
				"http": {
					"method": "GET",
					"requestUri": "/policies/{policyName}/version"
				},
				"input": {
					"type": "structure",
					"required": [
						"policyName"
					],
					"members": {
						"policyName": {
							"location": "uri",
							"locationName": "policyName"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"policyVersions": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"versionId": {},
									"isDefaultVersion": {
										"type": "boolean"
									},
									"createDate": {
										"type": "timestamp"
									}
								}
							}
						}
					}
				}
			},
			"ListPrincipalPolicies": {
				"http": {
					"method": "GET",
					"requestUri": "/principal-policies"
				},
				"input": {
					"type": "structure",
					"required": [
						"principal"
					],
					"members": {
						"principal": {
							"location": "header",
							"locationName": "x-amzn-iot-principal"
						},
						"marker": {
							"location": "querystring",
							"locationName": "marker"
						},
						"pageSize": {
							"location": "querystring",
							"locationName": "pageSize",
							"type": "integer"
						},
						"ascendingOrder": {
							"location": "querystring",
							"locationName": "isAscendingOrder",
							"type": "boolean"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"policies": {
							"shape": "S51"
						},
						"nextMarker": {}
					}
				}
			},
			"ListPrincipalThings": {
				"http": {
					"method": "GET",
					"requestUri": "/principals/things"
				},
				"input": {
					"type": "structure",
					"required": [
						"principal"
					],
					"members": {
						"nextToken": {
							"location": "querystring",
							"locationName": "nextToken"
						},
						"maxResults": {
							"location": "querystring",
							"locationName": "maxResults",
							"type": "integer"
						},
						"principal": {
							"location": "header",
							"locationName": "x-amzn-principal"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"things": {
							"type": "list",
							"member": {}
						},
						"nextToken": {}
					}
				}
			},
			"ListThingPrincipals": {
				"http": {
					"method": "GET",
					"requestUri": "/things/{thingName}/principals"
				},
				"input": {
					"type": "structure",
					"required": [
						"thingName"
					],
					"members": {
						"thingName": {
							"location": "uri",
							"locationName": "thingName"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"principals": {
							"shape": "S55"
						}
					}
				}
			},
			"ListThingTypes": {
				"http": {
					"method": "GET",
					"requestUri": "/thing-types"
				},
				"input": {
					"type": "structure",
					"members": {
						"nextToken": {
							"location": "querystring",
							"locationName": "nextToken"
						},
						"maxResults": {
							"location": "querystring",
							"locationName": "maxResults",
							"type": "integer"
						},
						"thingTypeName": {
							"location": "querystring",
							"locationName": "thingTypeName"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"thingTypes": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"thingTypeName": {},
									"thingTypeProperties": {
										"shape": "S14"
									},
									"thingTypeMetadata": {
										"shape": "S3u"
									}
								}
							}
						},
						"nextToken": {}
					}
				}
			},
			"ListThings": {
				"http": {
					"method": "GET",
					"requestUri": "/things"
				},
				"input": {
					"type": "structure",
					"members": {
						"nextToken": {
							"location": "querystring",
							"locationName": "nextToken"
						},
						"maxResults": {
							"location": "querystring",
							"locationName": "maxResults",
							"type": "integer"
						},
						"attributeName": {
							"location": "querystring",
							"locationName": "attributeName"
						},
						"attributeValue": {
							"location": "querystring",
							"locationName": "attributeValue"
						},
						"thingTypeName": {
							"location": "querystring",
							"locationName": "thingTypeName"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"things": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"thingName": {},
									"thingTypeName": {},
									"attributes": {
										"shape": "Sx"
									},
									"version": {
										"type": "long"
									}
								}
							}
						},
						"nextToken": {}
					}
				}
			},
			"ListTopicRules": {
				"http": {
					"method": "GET",
					"requestUri": "/rules"
				},
				"input": {
					"type": "structure",
					"members": {
						"topic": {
							"location": "querystring",
							"locationName": "topic"
						},
						"maxResults": {
							"location": "querystring",
							"locationName": "maxResults",
							"type": "integer"
						},
						"nextToken": {
							"location": "querystring",
							"locationName": "nextToken"
						},
						"ruleDisabled": {
							"location": "querystring",
							"locationName": "ruleDisabled",
							"type": "boolean"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"rules": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"ruleArn": {},
									"ruleName": {},
									"topicPattern": {},
									"createdAt": {
										"type": "timestamp"
									},
									"ruleDisabled": {
										"type": "boolean"
									}
								}
							}
						},
						"nextToken": {}
					}
				}
			},
			"RegisterCACertificate": {
				"http": {
					"requestUri": "/cacertificate"
				},
				"input": {
					"type": "structure",
					"required": [
						"caCertificate",
						"verificationCertificate"
					],
					"members": {
						"caCertificate": {},
						"verificationCertificate": {},
						"setAsActive": {
							"location": "querystring",
							"locationName": "setAsActive",
							"type": "boolean"
						},
						"allowAutoRegistration": {
							"location": "querystring",
							"locationName": "allowAutoRegistration",
							"type": "boolean"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"certificateArn": {},
						"certificateId": {}
					}
				}
			},
			"RegisterCertificate": {
				"http": {
					"requestUri": "/certificate/register"
				},
				"input": {
					"type": "structure",
					"required": [
						"certificatePem"
					],
					"members": {
						"certificatePem": {},
						"caCertificatePem": {},
						"setAsActive": {
							"deprecated": true,
							"location": "querystring",
							"locationName": "setAsActive",
							"type": "boolean"
						},
						"status": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"certificateArn": {},
						"certificateId": {}
					}
				}
			},
			"RejectCertificateTransfer": {
				"http": {
					"method": "PATCH",
					"requestUri": "/reject-certificate-transfer/{certificateId}"
				},
				"input": {
					"type": "structure",
					"required": [
						"certificateId"
					],
					"members": {
						"certificateId": {
							"location": "uri",
							"locationName": "certificateId"
						},
						"rejectReason": {}
					}
				}
			},
			"ReplaceTopicRule": {
				"http": {
					"method": "PATCH",
					"requestUri": "/rules/{ruleName}"
				},
				"input": {
					"type": "structure",
					"required": [
						"ruleName",
						"topicRulePayload"
					],
					"members": {
						"ruleName": {
							"location": "uri",
							"locationName": "ruleName"
						},
						"topicRulePayload": {
							"shape": "S1b"
						}
					},
					"payload": "topicRulePayload"
				}
			},
			"SetDefaultPolicyVersion": {
				"http": {
					"method": "PATCH",
					"requestUri": "/policies/{policyName}/version/{policyVersionId}"
				},
				"input": {
					"type": "structure",
					"required": [
						"policyName",
						"policyVersionId"
					],
					"members": {
						"policyName": {
							"location": "uri",
							"locationName": "policyName"
						},
						"policyVersionId": {
							"location": "uri",
							"locationName": "policyVersionId"
						}
					}
				}
			},
			"SetLoggingOptions": {
				"http": {
					"requestUri": "/loggingOptions"
				},
				"input": {
					"type": "structure",
					"required": [
						"loggingOptionsPayload"
					],
					"members": {
						"loggingOptionsPayload": {
							"type": "structure",
							"required": [
								"roleArn"
							],
							"members": {
								"roleArn": {},
								"logLevel": {}
							}
						}
					},
					"payload": "loggingOptionsPayload"
				}
			},
			"TransferCertificate": {
				"http": {
					"method": "PATCH",
					"requestUri": "/transfer-certificate/{certificateId}"
				},
				"input": {
					"type": "structure",
					"required": [
						"certificateId",
						"targetAwsAccount"
					],
					"members": {
						"certificateId": {
							"location": "uri",
							"locationName": "certificateId"
						},
						"targetAwsAccount": {
							"location": "querystring",
							"locationName": "targetAwsAccount"
						},
						"transferMessage": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"transferredCertificateArn": {}
					}
				}
			},
			"UpdateCACertificate": {
				"http": {
					"method": "PUT",
					"requestUri": "/cacertificate/{caCertificateId}"
				},
				"input": {
					"type": "structure",
					"required": [
						"certificateId"
					],
					"members": {
						"certificateId": {
							"location": "uri",
							"locationName": "caCertificateId"
						},
						"newStatus": {
							"location": "querystring",
							"locationName": "newStatus"
						},
						"newAutoRegistrationStatus": {
							"location": "querystring",
							"locationName": "newAutoRegistrationStatus"
						}
					}
				}
			},
			"UpdateCertificate": {
				"http": {
					"method": "PUT",
					"requestUri": "/certificates/{certificateId}"
				},
				"input": {
					"type": "structure",
					"required": [
						"certificateId",
						"newStatus"
					],
					"members": {
						"certificateId": {
							"location": "uri",
							"locationName": "certificateId"
						},
						"newStatus": {
							"location": "querystring",
							"locationName": "newStatus"
						}
					}
				}
			},
			"UpdateThing": {
				"http": {
					"method": "PATCH",
					"requestUri": "/things/{thingName}"
				},
				"input": {
					"type": "structure",
					"required": [
						"thingName"
					],
					"members": {
						"thingName": {
							"location": "uri",
							"locationName": "thingName"
						},
						"thingTypeName": {},
						"attributePayload": {
							"shape": "Sw"
						},
						"expectedVersion": {
							"type": "long"
						},
						"removeThingType": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			}
		},
		"shapes": {
			"Sw": {
				"type": "structure",
				"members": {
					"attributes": {
						"shape": "Sx"
					},
					"merge": {
						"type": "boolean"
					}
				}
			},
			"Sx": {
				"type": "map",
				"key": {},
				"value": {}
			},
			"S14": {
				"type": "structure",
				"members": {
					"thingTypeDescription": {},
					"searchableAttributes": {
						"type": "list",
						"member": {}
					}
				}
			},
			"S1b": {
				"type": "structure",
				"required": [
					"sql",
					"actions"
				],
				"members": {
					"sql": {},
					"description": {},
					"actions": {
						"shape": "S1e"
					},
					"ruleDisabled": {
						"type": "boolean"
					},
					"awsIotSqlVersion": {}
				}
			},
			"S1e": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"dynamoDB": {
							"type": "structure",
							"required": [
								"tableName",
								"roleArn",
								"hashKeyField",
								"hashKeyValue"
							],
							"members": {
								"tableName": {},
								"roleArn": {},
								"operation": {},
								"hashKeyField": {},
								"hashKeyValue": {},
								"hashKeyType": {},
								"rangeKeyField": {},
								"rangeKeyValue": {},
								"rangeKeyType": {},
								"payloadField": {}
							}
						},
						"dynamoDBv2": {
							"type": "structure",
							"members": {
								"roleArn": {},
								"putItem": {
									"type": "structure",
									"required": [
										"tableName"
									],
									"members": {
										"tableName": {}
									}
								}
							}
						},
						"lambda": {
							"type": "structure",
							"required": [
								"functionArn"
							],
							"members": {
								"functionArn": {}
							}
						},
						"sns": {
							"type": "structure",
							"required": [
								"targetArn",
								"roleArn"
							],
							"members": {
								"targetArn": {},
								"roleArn": {},
								"messageFormat": {}
							}
						},
						"sqs": {
							"type": "structure",
							"required": [
								"roleArn",
								"queueUrl"
							],
							"members": {
								"roleArn": {},
								"queueUrl": {},
								"useBase64": {
									"type": "boolean"
								}
							}
						},
						"kinesis": {
							"type": "structure",
							"required": [
								"roleArn",
								"streamName"
							],
							"members": {
								"roleArn": {},
								"streamName": {},
								"partitionKey": {}
							}
						},
						"republish": {
							"type": "structure",
							"required": [
								"roleArn",
								"topic"
							],
							"members": {
								"roleArn": {},
								"topic": {}
							}
						},
						"s3": {
							"type": "structure",
							"required": [
								"roleArn",
								"bucketName",
								"key"
							],
							"members": {
								"roleArn": {},
								"bucketName": {},
								"key": {},
								"cannedAcl": {}
							}
						},
						"firehose": {
							"type": "structure",
							"required": [
								"roleArn",
								"deliveryStreamName"
							],
							"members": {
								"roleArn": {},
								"deliveryStreamName": {},
								"separator": {}
							}
						},
						"cloudwatchMetric": {
							"type": "structure",
							"required": [
								"roleArn",
								"metricNamespace",
								"metricName",
								"metricValue",
								"metricUnit"
							],
							"members": {
								"roleArn": {},
								"metricNamespace": {},
								"metricName": {},
								"metricValue": {},
								"metricUnit": {},
								"metricTimestamp": {}
							}
						},
						"cloudwatchAlarm": {
							"type": "structure",
							"required": [
								"roleArn",
								"alarmName",
								"stateReason",
								"stateValue"
							],
							"members": {
								"roleArn": {},
								"alarmName": {},
								"stateReason": {},
								"stateValue": {}
							}
						},
						"elasticsearch": {
							"type": "structure",
							"required": [
								"roleArn",
								"endpoint",
								"index",
								"type",
								"id"
							],
							"members": {
								"roleArn": {},
								"endpoint": {},
								"index": {},
								"type": {},
								"id": {}
							}
						}
					}
				}
			},
			"S3u": {
				"type": "structure",
				"members": {
					"deprecated": {
						"type": "boolean"
					},
					"deprecationDate": {
						"type": "timestamp"
					},
					"creationDate": {
						"type": "timestamp"
					}
				}
			},
			"S4r": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"certificateArn": {},
						"certificateId": {},
						"status": {},
						"creationDate": {
							"type": "timestamp"
						}
					}
				}
			},
			"S51": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"policyName": {},
						"policyArn": {}
					}
				}
			},
			"S55": {
				"type": "list",
				"member": {}
			}
		},
		"examples": {}
	};

/***/ },
/* 385 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['iotdata'] = {};
	AWS.IotData = Service.defineService('iotdata', ['2015-05-28']);
	__webpack_require__(386);
	Object.defineProperty(apiLoader.services['iotdata'], '2015-05-28', {
	  get: function get() {
	    var model = __webpack_require__(387);
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.IotData;


/***/ },
/* 386 */
/***/ function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(93);

	/**
	 * Constructs a service interface object. Each API operation is exposed as a
	 * function on service.
	 *
	 * ### Sending a Request Using IotData
	 *
	 * ```javascript
	 * var iotdata = new AWS.IotData({endpoint: 'my.host.tld'});
	 * iotdata.getThingShadow(params, function (err, data) {
	 *   if (err) console.log(err, err.stack); // an error occurred
	 *   else     console.log(data);           // successful response
	 * });
	 * ```
	 *
	 * ### Locking the API Version
	 *
	 * In order to ensure that the IotData object uses this specific API,
	 * you can construct the object by passing the `apiVersion` option to the
	 * constructor:
	 *
	 * ```javascript
	 * var iotdata = new AWS.IotData({
	 *   endpoint: 'my.host.tld',
	 *   apiVersion: '2015-05-28'
	 * });
	 * ```
	 *
	 * You can also set the API version globally in `AWS.config.apiVersions` using
	 * the **iotdata** service identifier:
	 *
	 * ```javascript
	 * AWS.config.apiVersions = {
	 *   iotdata: '2015-05-28',
	 *   // other service API versions
	 * };
	 *
	 * var iotdata = new AWS.IotData({endpoint: 'my.host.tld'});
	 * ```
	 *
	 * @note You *must* provide an `endpoint` configuration parameter when
	 *   constructing this service. See {constructor} for more information.
	 *
	 * @!method constructor(options = {})
	 *   Constructs a service object. This object has one method for each
	 *   API operation.
	 *
	 *   @example Constructing a IotData object
	 *     var iotdata = new AWS.IotData({endpoint: 'my.host.tld'});
	 *   @note You *must* provide an `endpoint` when constructing this service.
	 *   @option (see AWS.Config.constructor)
	 *
	 * @service iotdata
	 * @version 2015-05-28
	 */
	AWS.util.update(AWS.IotData.prototype, {
	    /**
	     * @api private
	     */
	    validateService: function validateService() {
	        if (!this.config.endpoint || this.config.endpoint.indexOf('{') >= 0) {
	            var msg = 'AWS.IotData requires an explicit ' +
	                '`endpoint\' configuration option.';
	            throw AWS.util.error(new Error(),
	                {name: 'InvalidEndpoint', message: msg});
	        }
	    },

	    /**
	     * @api private
	     */
	    setupRequestListeners: function setupRequestListeners(request) {
	        request.addListener('validateResponse', this.validateResponseBody)
	    },

	    /**
	     * @api private
	     */
	    validateResponseBody: function validateResponseBody(resp) {
	        var body = resp.httpResponse.body.toString() || '{}';
	        var bodyCheck = body.trim();
	        if (!bodyCheck || bodyCheck.charAt(0) !== '{') {
	            resp.httpResponse.body = '';
	        }
	    }

	});


/***/ },
/* 387 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2015-05-28",
			"endpointPrefix": "data.iot",
			"protocol": "rest-json",
			"serviceFullName": "AWS IoT Data Plane",
			"signatureVersion": "v4",
			"signingName": "iotdata"
		},
		"operations": {
			"DeleteThingShadow": {
				"http": {
					"method": "DELETE",
					"requestUri": "/things/{thingName}/shadow"
				},
				"input": {
					"type": "structure",
					"required": [
						"thingName"
					],
					"members": {
						"thingName": {
							"location": "uri",
							"locationName": "thingName"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"payload"
					],
					"members": {
						"payload": {
							"type": "blob"
						}
					},
					"payload": "payload"
				}
			},
			"GetThingShadow": {
				"http": {
					"method": "GET",
					"requestUri": "/things/{thingName}/shadow"
				},
				"input": {
					"type": "structure",
					"required": [
						"thingName"
					],
					"members": {
						"thingName": {
							"location": "uri",
							"locationName": "thingName"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"payload": {
							"type": "blob"
						}
					},
					"payload": "payload"
				}
			},
			"Publish": {
				"http": {
					"requestUri": "/topics/{topic}"
				},
				"input": {
					"type": "structure",
					"required": [
						"topic"
					],
					"members": {
						"topic": {
							"location": "uri",
							"locationName": "topic"
						},
						"qos": {
							"location": "querystring",
							"locationName": "qos",
							"type": "integer"
						},
						"payload": {
							"type": "blob"
						}
					},
					"payload": "payload"
				}
			},
			"UpdateThingShadow": {
				"http": {
					"requestUri": "/things/{thingName}/shadow"
				},
				"input": {
					"type": "structure",
					"required": [
						"thingName",
						"payload"
					],
					"members": {
						"thingName": {
							"location": "uri",
							"locationName": "thingName"
						},
						"payload": {
							"type": "blob"
						}
					},
					"payload": "payload"
				},
				"output": {
					"type": "structure",
					"members": {
						"payload": {
							"type": "blob"
						}
					},
					"payload": "payload"
				}
			}
		},
		"shapes": {}
	};

/***/ },
/* 388 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['kinesis'] = {};
	AWS.Kinesis = Service.defineService('kinesis', ['2013-12-02']);
	Object.defineProperty(apiLoader.services['kinesis'], '2013-12-02', {
	  get: function get() {
	    var model = __webpack_require__(389);
	    model.paginators = __webpack_require__(390).pagination;
	    model.waiters = __webpack_require__(391).waiters;
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.Kinesis;


/***/ },
/* 389 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2013-12-02",
			"endpointPrefix": "kinesis",
			"jsonVersion": "1.1",
			"protocol": "json",
			"serviceAbbreviation": "Kinesis",
			"serviceFullName": "Amazon Kinesis",
			"signatureVersion": "v4",
			"targetPrefix": "Kinesis_20131202"
		},
		"operations": {
			"AddTagsToStream": {
				"input": {
					"type": "structure",
					"required": [
						"StreamName",
						"Tags"
					],
					"members": {
						"StreamName": {},
						"Tags": {
							"type": "map",
							"key": {},
							"value": {}
						}
					}
				}
			},
			"CreateStream": {
				"input": {
					"type": "structure",
					"required": [
						"StreamName",
						"ShardCount"
					],
					"members": {
						"StreamName": {},
						"ShardCount": {
							"type": "integer"
						}
					}
				}
			},
			"DecreaseStreamRetentionPeriod": {
				"input": {
					"type": "structure",
					"required": [
						"StreamName",
						"RetentionPeriodHours"
					],
					"members": {
						"StreamName": {},
						"RetentionPeriodHours": {
							"type": "integer"
						}
					}
				}
			},
			"DeleteStream": {
				"input": {
					"type": "structure",
					"required": [
						"StreamName"
					],
					"members": {
						"StreamName": {}
					}
				}
			},
			"DescribeStream": {
				"input": {
					"type": "structure",
					"required": [
						"StreamName"
					],
					"members": {
						"StreamName": {},
						"Limit": {
							"type": "integer"
						},
						"ExclusiveStartShardId": {}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"StreamDescription"
					],
					"members": {
						"StreamDescription": {
							"type": "structure",
							"required": [
								"StreamName",
								"StreamARN",
								"StreamStatus",
								"Shards",
								"HasMoreShards",
								"RetentionPeriodHours",
								"EnhancedMonitoring"
							],
							"members": {
								"StreamName": {},
								"StreamARN": {},
								"StreamStatus": {},
								"Shards": {
									"type": "list",
									"member": {
										"type": "structure",
										"required": [
											"ShardId",
											"HashKeyRange",
											"SequenceNumberRange"
										],
										"members": {
											"ShardId": {},
											"ParentShardId": {},
											"AdjacentParentShardId": {},
											"HashKeyRange": {
												"type": "structure",
												"required": [
													"StartingHashKey",
													"EndingHashKey"
												],
												"members": {
													"StartingHashKey": {},
													"EndingHashKey": {}
												}
											},
											"SequenceNumberRange": {
												"type": "structure",
												"required": [
													"StartingSequenceNumber"
												],
												"members": {
													"StartingSequenceNumber": {},
													"EndingSequenceNumber": {}
												}
											}
										}
									}
								},
								"HasMoreShards": {
									"type": "boolean"
								},
								"RetentionPeriodHours": {
									"type": "integer"
								},
								"EnhancedMonitoring": {
									"type": "list",
									"member": {
										"type": "structure",
										"members": {
											"ShardLevelMetrics": {
												"shape": "Sr"
											}
										}
									}
								}
							}
						}
					}
				}
			},
			"DisableEnhancedMonitoring": {
				"input": {
					"type": "structure",
					"required": [
						"StreamName",
						"ShardLevelMetrics"
					],
					"members": {
						"StreamName": {},
						"ShardLevelMetrics": {
							"shape": "Sr"
						}
					}
				},
				"output": {
					"shape": "Su"
				}
			},
			"EnableEnhancedMonitoring": {
				"input": {
					"type": "structure",
					"required": [
						"StreamName",
						"ShardLevelMetrics"
					],
					"members": {
						"StreamName": {},
						"ShardLevelMetrics": {
							"shape": "Sr"
						}
					}
				},
				"output": {
					"shape": "Su"
				}
			},
			"GetRecords": {
				"input": {
					"type": "structure",
					"required": [
						"ShardIterator"
					],
					"members": {
						"ShardIterator": {},
						"Limit": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"Records"
					],
					"members": {
						"Records": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"SequenceNumber",
									"Data",
									"PartitionKey"
								],
								"members": {
									"SequenceNumber": {},
									"ApproximateArrivalTimestamp": {
										"type": "timestamp"
									},
									"Data": {
										"type": "blob"
									},
									"PartitionKey": {}
								}
							}
						},
						"NextShardIterator": {},
						"MillisBehindLatest": {
							"type": "long"
						}
					}
				}
			},
			"GetShardIterator": {
				"input": {
					"type": "structure",
					"required": [
						"StreamName",
						"ShardId",
						"ShardIteratorType"
					],
					"members": {
						"StreamName": {},
						"ShardId": {},
						"ShardIteratorType": {},
						"StartingSequenceNumber": {},
						"Timestamp": {
							"type": "timestamp"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ShardIterator": {}
					}
				}
			},
			"IncreaseStreamRetentionPeriod": {
				"input": {
					"type": "structure",
					"required": [
						"StreamName",
						"RetentionPeriodHours"
					],
					"members": {
						"StreamName": {},
						"RetentionPeriodHours": {
							"type": "integer"
						}
					}
				}
			},
			"ListStreams": {
				"input": {
					"type": "structure",
					"members": {
						"Limit": {
							"type": "integer"
						},
						"ExclusiveStartStreamName": {}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"StreamNames",
						"HasMoreStreams"
					],
					"members": {
						"StreamNames": {
							"type": "list",
							"member": {}
						},
						"HasMoreStreams": {
							"type": "boolean"
						}
					}
				}
			},
			"ListTagsForStream": {
				"input": {
					"type": "structure",
					"required": [
						"StreamName"
					],
					"members": {
						"StreamName": {},
						"ExclusiveStartTagKey": {},
						"Limit": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"Tags",
						"HasMoreTags"
					],
					"members": {
						"Tags": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"Key"
								],
								"members": {
									"Key": {},
									"Value": {}
								}
							}
						},
						"HasMoreTags": {
							"type": "boolean"
						}
					}
				}
			},
			"MergeShards": {
				"input": {
					"type": "structure",
					"required": [
						"StreamName",
						"ShardToMerge",
						"AdjacentShardToMerge"
					],
					"members": {
						"StreamName": {},
						"ShardToMerge": {},
						"AdjacentShardToMerge": {}
					}
				}
			},
			"PutRecord": {
				"input": {
					"type": "structure",
					"required": [
						"StreamName",
						"Data",
						"PartitionKey"
					],
					"members": {
						"StreamName": {},
						"Data": {
							"type": "blob"
						},
						"PartitionKey": {},
						"ExplicitHashKey": {},
						"SequenceNumberForOrdering": {}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"ShardId",
						"SequenceNumber"
					],
					"members": {
						"ShardId": {},
						"SequenceNumber": {}
					}
				}
			},
			"PutRecords": {
				"input": {
					"type": "structure",
					"required": [
						"Records",
						"StreamName"
					],
					"members": {
						"Records": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"Data",
									"PartitionKey"
								],
								"members": {
									"Data": {
										"type": "blob"
									},
									"ExplicitHashKey": {},
									"PartitionKey": {}
								}
							}
						},
						"StreamName": {}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"Records"
					],
					"members": {
						"FailedRecordCount": {
							"type": "integer"
						},
						"Records": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"SequenceNumber": {},
									"ShardId": {},
									"ErrorCode": {},
									"ErrorMessage": {}
								}
							}
						}
					}
				}
			},
			"RemoveTagsFromStream": {
				"input": {
					"type": "structure",
					"required": [
						"StreamName",
						"TagKeys"
					],
					"members": {
						"StreamName": {},
						"TagKeys": {
							"type": "list",
							"member": {}
						}
					}
				}
			},
			"SplitShard": {
				"input": {
					"type": "structure",
					"required": [
						"StreamName",
						"ShardToSplit",
						"NewStartingHashKey"
					],
					"members": {
						"StreamName": {},
						"ShardToSplit": {},
						"NewStartingHashKey": {}
					}
				}
			}
		},
		"shapes": {
			"Sr": {
				"type": "list",
				"member": {}
			},
			"Su": {
				"type": "structure",
				"members": {
					"StreamName": {},
					"CurrentShardLevelMetrics": {
						"shape": "Sr"
					},
					"DesiredShardLevelMetrics": {
						"shape": "Sr"
					}
				}
			}
		}
	};

/***/ },
/* 390 */
/***/ function(module, exports) {

	module.exports = {
		"pagination": {
			"DescribeStream": {
				"input_token": "ExclusiveStartShardId",
				"limit_key": "Limit",
				"more_results": "StreamDescription.HasMoreShards",
				"output_token": "StreamDescription.Shards[-1].ShardId",
				"result_key": "StreamDescription.Shards"
			},
			"ListStreams": {
				"input_token": "ExclusiveStartStreamName",
				"limit_key": "Limit",
				"more_results": "HasMoreStreams",
				"output_token": "StreamNames[-1]",
				"result_key": "StreamNames"
			}
		}
	};

/***/ },
/* 391 */
/***/ function(module, exports) {

	module.exports = {
		"version": 2,
		"waiters": {
			"StreamExists": {
				"delay": 10,
				"operation": "DescribeStream",
				"maxAttempts": 18,
				"acceptors": [
					{
						"expected": "ACTIVE",
						"matcher": "path",
						"state": "success",
						"argument": "StreamDescription.StreamStatus"
					}
				]
			}
		}
	};

/***/ },
/* 392 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['kinesisanalytics'] = {};
	AWS.KinesisAnalytics = Service.defineService('kinesisanalytics', ['2015-08-14']);
	Object.defineProperty(apiLoader.services['kinesisanalytics'], '2015-08-14', {
	  get: function get() {
	    var model = __webpack_require__(393);
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.KinesisAnalytics;


/***/ },
/* 393 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2015-08-14",
			"endpointPrefix": "kinesisanalytics",
			"jsonVersion": "1.1",
			"protocol": "json",
			"serviceAbbreviation": "Kinesis Analytics",
			"serviceFullName": "Amazon Kinesis Analytics",
			"signatureVersion": "v4",
			"targetPrefix": "KinesisAnalytics_20150814",
			"timestampFormat": "unixTimestamp"
		},
		"operations": {
			"AddApplicationInput": {
				"input": {
					"type": "structure",
					"required": [
						"ApplicationName",
						"CurrentApplicationVersionId",
						"Input"
					],
					"members": {
						"ApplicationName": {},
						"CurrentApplicationVersionId": {
							"type": "long"
						},
						"Input": {
							"shape": "S4"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"AddApplicationOutput": {
				"input": {
					"type": "structure",
					"required": [
						"ApplicationName",
						"CurrentApplicationVersionId",
						"Output"
					],
					"members": {
						"ApplicationName": {},
						"CurrentApplicationVersionId": {
							"type": "long"
						},
						"Output": {
							"shape": "St"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"AddApplicationReferenceDataSource": {
				"input": {
					"type": "structure",
					"required": [
						"ApplicationName",
						"CurrentApplicationVersionId",
						"ReferenceDataSource"
					],
					"members": {
						"ApplicationName": {},
						"CurrentApplicationVersionId": {
							"type": "long"
						},
						"ReferenceDataSource": {
							"type": "structure",
							"required": [
								"TableName",
								"ReferenceSchema"
							],
							"members": {
								"TableName": {},
								"S3ReferenceDataSource": {
									"type": "structure",
									"required": [
										"BucketARN",
										"FileKey",
										"ReferenceRoleARN"
									],
									"members": {
										"BucketARN": {},
										"FileKey": {},
										"ReferenceRoleARN": {}
									}
								},
								"ReferenceSchema": {
									"shape": "Sc"
								}
							}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"CreateApplication": {
				"input": {
					"type": "structure",
					"required": [
						"ApplicationName"
					],
					"members": {
						"ApplicationName": {},
						"ApplicationDescription": {},
						"Inputs": {
							"type": "list",
							"member": {
								"shape": "S4"
							}
						},
						"Outputs": {
							"type": "list",
							"member": {
								"shape": "St"
							}
						},
						"ApplicationCode": {}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"ApplicationSummary"
					],
					"members": {
						"ApplicationSummary": {
							"shape": "S1b"
						}
					}
				}
			},
			"DeleteApplication": {
				"input": {
					"type": "structure",
					"required": [
						"ApplicationName",
						"CreateTimestamp"
					],
					"members": {
						"ApplicationName": {},
						"CreateTimestamp": {
							"type": "timestamp"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"DeleteApplicationOutput": {
				"input": {
					"type": "structure",
					"required": [
						"ApplicationName",
						"CurrentApplicationVersionId",
						"OutputId"
					],
					"members": {
						"ApplicationName": {},
						"CurrentApplicationVersionId": {
							"type": "long"
						},
						"OutputId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"DeleteApplicationReferenceDataSource": {
				"input": {
					"type": "structure",
					"required": [
						"ApplicationName",
						"CurrentApplicationVersionId",
						"ReferenceId"
					],
					"members": {
						"ApplicationName": {},
						"CurrentApplicationVersionId": {
							"type": "long"
						},
						"ReferenceId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"DescribeApplication": {
				"input": {
					"type": "structure",
					"required": [
						"ApplicationName"
					],
					"members": {
						"ApplicationName": {}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"ApplicationDetail"
					],
					"members": {
						"ApplicationDetail": {
							"type": "structure",
							"required": [
								"ApplicationName",
								"ApplicationARN",
								"ApplicationStatus",
								"ApplicationVersionId"
							],
							"members": {
								"ApplicationName": {},
								"ApplicationDescription": {},
								"ApplicationARN": {},
								"ApplicationStatus": {},
								"CreateTimestamp": {
									"type": "timestamp"
								},
								"LastUpdateTimestamp": {
									"type": "timestamp"
								},
								"InputDescriptions": {
									"type": "list",
									"member": {
										"type": "structure",
										"members": {
											"InputId": {},
											"NamePrefix": {},
											"InAppStreamNames": {
												"type": "list",
												"member": {}
											},
											"KinesisStreamsInputDescription": {
												"type": "structure",
												"members": {
													"ResourceARN": {},
													"RoleARN": {}
												}
											},
											"KinesisFirehoseInputDescription": {
												"type": "structure",
												"members": {
													"ResourceARN": {},
													"RoleARN": {}
												}
											},
											"InputSchema": {
												"shape": "Sc"
											},
											"InputParallelism": {
												"shape": "Sa"
											},
											"InputStartingPositionConfiguration": {
												"shape": "S1t"
											}
										}
									}
								},
								"OutputDescriptions": {
									"type": "list",
									"member": {
										"type": "structure",
										"members": {
											"OutputId": {},
											"Name": {},
											"KinesisStreamsOutputDescription": {
												"type": "structure",
												"members": {
													"ResourceARN": {},
													"RoleARN": {}
												}
											},
											"KinesisFirehoseOutputDescription": {
												"type": "structure",
												"members": {
													"ResourceARN": {},
													"RoleARN": {}
												}
											},
											"DestinationSchema": {
												"shape": "Sw"
											}
										}
									}
								},
								"ReferenceDataSourceDescriptions": {
									"type": "list",
									"member": {
										"type": "structure",
										"required": [
											"ReferenceId",
											"TableName",
											"S3ReferenceDataSourceDescription"
										],
										"members": {
											"ReferenceId": {},
											"TableName": {},
											"S3ReferenceDataSourceDescription": {
												"type": "structure",
												"required": [
													"BucketARN",
													"FileKey",
													"ReferenceRoleARN"
												],
												"members": {
													"BucketARN": {},
													"FileKey": {},
													"ReferenceRoleARN": {}
												}
											},
											"ReferenceSchema": {
												"shape": "Sc"
											}
										}
									}
								},
								"ApplicationCode": {},
								"ApplicationVersionId": {
									"type": "long"
								}
							}
						}
					}
				}
			},
			"DiscoverInputSchema": {
				"input": {
					"type": "structure",
					"required": [
						"ResourceARN",
						"RoleARN",
						"InputStartingPositionConfiguration"
					],
					"members": {
						"ResourceARN": {},
						"RoleARN": {},
						"InputStartingPositionConfiguration": {
							"shape": "S1t"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"InputSchema": {
							"shape": "Sc"
						},
						"ParsedInputRecords": {
							"type": "list",
							"member": {
								"type": "list",
								"member": {}
							}
						},
						"RawInputRecords": {
							"type": "list",
							"member": {}
						}
					}
				}
			},
			"ListApplications": {
				"input": {
					"type": "structure",
					"members": {
						"Limit": {
							"type": "integer"
						},
						"ExclusiveStartApplicationName": {}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"ApplicationSummaries",
						"HasMoreApplications"
					],
					"members": {
						"ApplicationSummaries": {
							"type": "list",
							"member": {
								"shape": "S1b"
							}
						},
						"HasMoreApplications": {
							"type": "boolean"
						}
					}
				}
			},
			"StartApplication": {
				"input": {
					"type": "structure",
					"required": [
						"ApplicationName",
						"InputConfigurations"
					],
					"members": {
						"ApplicationName": {},
						"InputConfigurations": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"Id",
									"InputStartingPositionConfiguration"
								],
								"members": {
									"Id": {},
									"InputStartingPositionConfiguration": {
										"shape": "S1t"
									}
								}
							}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"StopApplication": {
				"input": {
					"type": "structure",
					"required": [
						"ApplicationName"
					],
					"members": {
						"ApplicationName": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"UpdateApplication": {
				"input": {
					"type": "structure",
					"required": [
						"ApplicationName",
						"CurrentApplicationVersionId",
						"ApplicationUpdate"
					],
					"members": {
						"ApplicationName": {},
						"CurrentApplicationVersionId": {
							"type": "long"
						},
						"ApplicationUpdate": {
							"type": "structure",
							"members": {
								"InputUpdates": {
									"type": "list",
									"member": {
										"type": "structure",
										"required": [
											"InputId"
										],
										"members": {
											"InputId": {},
											"NamePrefixUpdate": {},
											"KinesisStreamsInputUpdate": {
												"type": "structure",
												"members": {
													"ResourceARNUpdate": {},
													"RoleARNUpdate": {}
												}
											},
											"KinesisFirehoseInputUpdate": {
												"type": "structure",
												"members": {
													"ResourceARNUpdate": {},
													"RoleARNUpdate": {}
												}
											},
											"InputSchemaUpdate": {
												"type": "structure",
												"members": {
													"RecordFormatUpdate": {
														"shape": "Sd"
													},
													"RecordEncodingUpdate": {},
													"RecordColumnUpdates": {
														"shape": "Sm"
													}
												}
											},
											"InputParallelismUpdate": {
												"type": "structure",
												"members": {
													"CountUpdate": {
														"type": "integer"
													}
												}
											}
										}
									}
								},
								"ApplicationCodeUpdate": {},
								"OutputUpdates": {
									"type": "list",
									"member": {
										"type": "structure",
										"required": [
											"OutputId"
										],
										"members": {
											"OutputId": {},
											"NameUpdate": {},
											"KinesisStreamsOutputUpdate": {
												"type": "structure",
												"members": {
													"ResourceARNUpdate": {},
													"RoleARNUpdate": {}
												}
											},
											"KinesisFirehoseOutputUpdate": {
												"type": "structure",
												"members": {
													"ResourceARNUpdate": {},
													"RoleARNUpdate": {}
												}
											},
											"DestinationSchemaUpdate": {
												"shape": "Sw"
											}
										}
									}
								},
								"ReferenceDataSourceUpdates": {
									"type": "list",
									"member": {
										"type": "structure",
										"required": [
											"ReferenceId"
										],
										"members": {
											"ReferenceId": {},
											"TableNameUpdate": {},
											"S3ReferenceDataSourceUpdate": {
												"type": "structure",
												"members": {
													"BucketARNUpdate": {},
													"FileKeyUpdate": {},
													"ReferenceRoleARNUpdate": {}
												}
											},
											"ReferenceSchemaUpdate": {
												"shape": "Sc"
											}
										}
									}
								}
							}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			}
		},
		"shapes": {
			"S4": {
				"type": "structure",
				"required": [
					"NamePrefix",
					"InputSchema"
				],
				"members": {
					"NamePrefix": {},
					"KinesisStreamsInput": {
						"type": "structure",
						"required": [
							"ResourceARN",
							"RoleARN"
						],
						"members": {
							"ResourceARN": {},
							"RoleARN": {}
						}
					},
					"KinesisFirehoseInput": {
						"type": "structure",
						"required": [
							"ResourceARN",
							"RoleARN"
						],
						"members": {
							"ResourceARN": {},
							"RoleARN": {}
						}
					},
					"InputParallelism": {
						"shape": "Sa"
					},
					"InputSchema": {
						"shape": "Sc"
					}
				}
			},
			"Sa": {
				"type": "structure",
				"members": {
					"Count": {
						"type": "integer"
					}
				}
			},
			"Sc": {
				"type": "structure",
				"required": [
					"RecordFormat",
					"RecordColumns"
				],
				"members": {
					"RecordFormat": {
						"shape": "Sd"
					},
					"RecordEncoding": {},
					"RecordColumns": {
						"shape": "Sm"
					}
				}
			},
			"Sd": {
				"type": "structure",
				"required": [
					"RecordFormatType"
				],
				"members": {
					"RecordFormatType": {},
					"MappingParameters": {
						"type": "structure",
						"members": {
							"JSONMappingParameters": {
								"type": "structure",
								"required": [
									"RecordRowPath"
								],
								"members": {
									"RecordRowPath": {}
								}
							},
							"CSVMappingParameters": {
								"type": "structure",
								"required": [
									"RecordRowDelimiter",
									"RecordColumnDelimiter"
								],
								"members": {
									"RecordRowDelimiter": {},
									"RecordColumnDelimiter": {}
								}
							}
						}
					}
				}
			},
			"Sm": {
				"type": "list",
				"member": {
					"type": "structure",
					"required": [
						"Name",
						"SqlType"
					],
					"members": {
						"Name": {},
						"Mapping": {},
						"SqlType": {}
					}
				}
			},
			"St": {
				"type": "structure",
				"required": [
					"Name",
					"DestinationSchema"
				],
				"members": {
					"Name": {},
					"KinesisStreamsOutput": {
						"type": "structure",
						"required": [
							"ResourceARN",
							"RoleARN"
						],
						"members": {
							"ResourceARN": {},
							"RoleARN": {}
						}
					},
					"KinesisFirehoseOutput": {
						"type": "structure",
						"required": [
							"ResourceARN",
							"RoleARN"
						],
						"members": {
							"ResourceARN": {},
							"RoleARN": {}
						}
					},
					"DestinationSchema": {
						"shape": "Sw"
					}
				}
			},
			"Sw": {
				"type": "structure",
				"members": {
					"RecordFormatType": {}
				}
			},
			"S1b": {
				"type": "structure",
				"required": [
					"ApplicationName",
					"ApplicationARN",
					"ApplicationStatus"
				],
				"members": {
					"ApplicationName": {},
					"ApplicationARN": {},
					"ApplicationStatus": {}
				}
			},
			"S1t": {
				"type": "structure",
				"members": {
					"InputStartingPosition": {}
				}
			}
		}
	};

/***/ },
/* 394 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['kms'] = {};
	AWS.KMS = Service.defineService('kms', ['2014-11-01']);
	Object.defineProperty(apiLoader.services['kms'], '2014-11-01', {
	  get: function get() {
	    var model = __webpack_require__(395);
	    model.paginators = __webpack_require__(396).pagination;
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.KMS;


/***/ },
/* 395 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2014-11-01",
			"endpointPrefix": "kms",
			"jsonVersion": "1.1",
			"protocol": "json",
			"serviceAbbreviation": "KMS",
			"serviceFullName": "AWS Key Management Service",
			"signatureVersion": "v4",
			"targetPrefix": "TrentService"
		},
		"operations": {
			"CancelKeyDeletion": {
				"input": {
					"type": "structure",
					"required": [
						"KeyId"
					],
					"members": {
						"KeyId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"KeyId": {}
					}
				}
			},
			"CreateAlias": {
				"input": {
					"type": "structure",
					"required": [
						"AliasName",
						"TargetKeyId"
					],
					"members": {
						"AliasName": {},
						"TargetKeyId": {}
					}
				}
			},
			"CreateGrant": {
				"input": {
					"type": "structure",
					"required": [
						"KeyId",
						"GranteePrincipal"
					],
					"members": {
						"KeyId": {},
						"GranteePrincipal": {},
						"RetiringPrincipal": {},
						"Operations": {
							"shape": "S8"
						},
						"Constraints": {
							"shape": "Sa"
						},
						"GrantTokens": {
							"shape": "Se"
						},
						"Name": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"GrantToken": {},
						"GrantId": {}
					}
				}
			},
			"CreateKey": {
				"input": {
					"type": "structure",
					"members": {
						"Policy": {},
						"Description": {},
						"KeyUsage": {},
						"Origin": {},
						"BypassPolicyLockoutSafetyCheck": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"KeyMetadata": {
							"shape": "Sq"
						}
					}
				}
			},
			"Decrypt": {
				"input": {
					"type": "structure",
					"required": [
						"CiphertextBlob"
					],
					"members": {
						"CiphertextBlob": {
							"type": "blob"
						},
						"EncryptionContext": {
							"shape": "Sb"
						},
						"GrantTokens": {
							"shape": "Se"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"KeyId": {},
						"Plaintext": {
							"shape": "Sz"
						}
					}
				}
			},
			"DeleteAlias": {
				"input": {
					"type": "structure",
					"required": [
						"AliasName"
					],
					"members": {
						"AliasName": {}
					}
				}
			},
			"DeleteImportedKeyMaterial": {
				"input": {
					"type": "structure",
					"required": [
						"KeyId"
					],
					"members": {
						"KeyId": {}
					}
				}
			},
			"DescribeKey": {
				"input": {
					"type": "structure",
					"required": [
						"KeyId"
					],
					"members": {
						"KeyId": {},
						"GrantTokens": {
							"shape": "Se"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"KeyMetadata": {
							"shape": "Sq"
						}
					}
				}
			},
			"DisableKey": {
				"input": {
					"type": "structure",
					"required": [
						"KeyId"
					],
					"members": {
						"KeyId": {}
					}
				}
			},
			"DisableKeyRotation": {
				"input": {
					"type": "structure",
					"required": [
						"KeyId"
					],
					"members": {
						"KeyId": {}
					}
				}
			},
			"EnableKey": {
				"input": {
					"type": "structure",
					"required": [
						"KeyId"
					],
					"members": {
						"KeyId": {}
					}
				}
			},
			"EnableKeyRotation": {
				"input": {
					"type": "structure",
					"required": [
						"KeyId"
					],
					"members": {
						"KeyId": {}
					}
				}
			},
			"Encrypt": {
				"input": {
					"type": "structure",
					"required": [
						"KeyId",
						"Plaintext"
					],
					"members": {
						"KeyId": {},
						"Plaintext": {
							"shape": "Sz"
						},
						"EncryptionContext": {
							"shape": "Sb"
						},
						"GrantTokens": {
							"shape": "Se"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"CiphertextBlob": {
							"type": "blob"
						},
						"KeyId": {}
					}
				}
			},
			"GenerateDataKey": {
				"input": {
					"type": "structure",
					"required": [
						"KeyId"
					],
					"members": {
						"KeyId": {},
						"EncryptionContext": {
							"shape": "Sb"
						},
						"NumberOfBytes": {
							"type": "integer"
						},
						"KeySpec": {},
						"GrantTokens": {
							"shape": "Se"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"CiphertextBlob": {
							"type": "blob"
						},
						"Plaintext": {
							"shape": "Sz"
						},
						"KeyId": {}
					}
				}
			},
			"GenerateDataKeyWithoutPlaintext": {
				"input": {
					"type": "structure",
					"required": [
						"KeyId"
					],
					"members": {
						"KeyId": {},
						"EncryptionContext": {
							"shape": "Sb"
						},
						"KeySpec": {},
						"NumberOfBytes": {
							"type": "integer"
						},
						"GrantTokens": {
							"shape": "Se"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"CiphertextBlob": {
							"type": "blob"
						},
						"KeyId": {}
					}
				}
			},
			"GenerateRandom": {
				"input": {
					"type": "structure",
					"members": {
						"NumberOfBytes": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Plaintext": {
							"shape": "Sz"
						}
					}
				}
			},
			"GetKeyPolicy": {
				"input": {
					"type": "structure",
					"required": [
						"KeyId",
						"PolicyName"
					],
					"members": {
						"KeyId": {},
						"PolicyName": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Policy": {}
					}
				}
			},
			"GetKeyRotationStatus": {
				"input": {
					"type": "structure",
					"required": [
						"KeyId"
					],
					"members": {
						"KeyId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"KeyRotationEnabled": {
							"type": "boolean"
						}
					}
				}
			},
			"GetParametersForImport": {
				"input": {
					"type": "structure",
					"required": [
						"KeyId",
						"WrappingAlgorithm",
						"WrappingKeySpec"
					],
					"members": {
						"KeyId": {},
						"WrappingAlgorithm": {},
						"WrappingKeySpec": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"KeyId": {},
						"ImportToken": {
							"type": "blob"
						},
						"PublicKey": {
							"shape": "Sz"
						},
						"ParametersValidTo": {
							"type": "timestamp"
						}
					}
				}
			},
			"ImportKeyMaterial": {
				"input": {
					"type": "structure",
					"required": [
						"KeyId",
						"ImportToken",
						"EncryptedKeyMaterial"
					],
					"members": {
						"KeyId": {},
						"ImportToken": {
							"type": "blob"
						},
						"EncryptedKeyMaterial": {
							"type": "blob"
						},
						"ValidTo": {
							"type": "timestamp"
						},
						"ExpirationModel": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"ListAliases": {
				"input": {
					"type": "structure",
					"members": {
						"Limit": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Aliases": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"AliasName": {},
									"AliasArn": {},
									"TargetKeyId": {}
								}
							}
						},
						"NextMarker": {},
						"Truncated": {
							"type": "boolean"
						}
					}
				}
			},
			"ListGrants": {
				"input": {
					"type": "structure",
					"required": [
						"KeyId"
					],
					"members": {
						"Limit": {
							"type": "integer"
						},
						"Marker": {},
						"KeyId": {}
					}
				},
				"output": {
					"shape": "S20"
				}
			},
			"ListKeyPolicies": {
				"input": {
					"type": "structure",
					"required": [
						"KeyId"
					],
					"members": {
						"KeyId": {},
						"Limit": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"PolicyNames": {
							"type": "list",
							"member": {}
						},
						"NextMarker": {},
						"Truncated": {
							"type": "boolean"
						}
					}
				}
			},
			"ListKeys": {
				"input": {
					"type": "structure",
					"members": {
						"Limit": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Keys": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"KeyId": {},
									"KeyArn": {}
								}
							}
						},
						"NextMarker": {},
						"Truncated": {
							"type": "boolean"
						}
					}
				}
			},
			"ListRetirableGrants": {
				"input": {
					"type": "structure",
					"required": [
						"RetiringPrincipal"
					],
					"members": {
						"Limit": {
							"type": "integer"
						},
						"Marker": {},
						"RetiringPrincipal": {}
					}
				},
				"output": {
					"shape": "S20"
				}
			},
			"PutKeyPolicy": {
				"input": {
					"type": "structure",
					"required": [
						"KeyId",
						"PolicyName",
						"Policy"
					],
					"members": {
						"KeyId": {},
						"PolicyName": {},
						"Policy": {},
						"BypassPolicyLockoutSafetyCheck": {
							"type": "boolean"
						}
					}
				}
			},
			"ReEncrypt": {
				"input": {
					"type": "structure",
					"required": [
						"CiphertextBlob",
						"DestinationKeyId"
					],
					"members": {
						"CiphertextBlob": {
							"type": "blob"
						},
						"SourceEncryptionContext": {
							"shape": "Sb"
						},
						"DestinationKeyId": {},
						"DestinationEncryptionContext": {
							"shape": "Sb"
						},
						"GrantTokens": {
							"shape": "Se"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"CiphertextBlob": {
							"type": "blob"
						},
						"SourceKeyId": {},
						"KeyId": {}
					}
				}
			},
			"RetireGrant": {
				"input": {
					"type": "structure",
					"members": {
						"GrantToken": {},
						"KeyId": {},
						"GrantId": {}
					}
				}
			},
			"RevokeGrant": {
				"input": {
					"type": "structure",
					"required": [
						"KeyId",
						"GrantId"
					],
					"members": {
						"KeyId": {},
						"GrantId": {}
					}
				}
			},
			"ScheduleKeyDeletion": {
				"input": {
					"type": "structure",
					"required": [
						"KeyId"
					],
					"members": {
						"KeyId": {},
						"PendingWindowInDays": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"KeyId": {},
						"DeletionDate": {
							"type": "timestamp"
						}
					}
				}
			},
			"UpdateAlias": {
				"input": {
					"type": "structure",
					"required": [
						"AliasName",
						"TargetKeyId"
					],
					"members": {
						"AliasName": {},
						"TargetKeyId": {}
					}
				}
			},
			"UpdateKeyDescription": {
				"input": {
					"type": "structure",
					"required": [
						"KeyId",
						"Description"
					],
					"members": {
						"KeyId": {},
						"Description": {}
					}
				}
			}
		},
		"shapes": {
			"S8": {
				"type": "list",
				"member": {}
			},
			"Sa": {
				"type": "structure",
				"members": {
					"EncryptionContextSubset": {
						"shape": "Sb"
					},
					"EncryptionContextEquals": {
						"shape": "Sb"
					}
				}
			},
			"Sb": {
				"type": "map",
				"key": {},
				"value": {}
			},
			"Se": {
				"type": "list",
				"member": {}
			},
			"Sq": {
				"type": "structure",
				"required": [
					"KeyId"
				],
				"members": {
					"AWSAccountId": {},
					"KeyId": {},
					"Arn": {},
					"CreationDate": {
						"type": "timestamp"
					},
					"Enabled": {
						"type": "boolean"
					},
					"Description": {},
					"KeyUsage": {},
					"KeyState": {},
					"DeletionDate": {
						"type": "timestamp"
					},
					"ValidTo": {
						"type": "timestamp"
					},
					"Origin": {},
					"ExpirationModel": {}
				}
			},
			"Sz": {
				"type": "blob",
				"sensitive": true
			},
			"S20": {
				"type": "structure",
				"members": {
					"Grants": {
						"type": "list",
						"member": {
							"type": "structure",
							"members": {
								"KeyId": {},
								"GrantId": {},
								"Name": {},
								"CreationDate": {
									"type": "timestamp"
								},
								"GranteePrincipal": {},
								"RetiringPrincipal": {},
								"IssuingAccount": {},
								"Operations": {
									"shape": "S8"
								},
								"Constraints": {
									"shape": "Sa"
								}
							}
						}
					},
					"NextMarker": {},
					"Truncated": {
						"type": "boolean"
					}
				}
			}
		}
	};

/***/ },
/* 396 */
/***/ function(module, exports) {

	module.exports = {
		"pagination": {
			"ListAliases": {
				"limit_key": "Limit",
				"input_token": "Marker",
				"output_token": "NextMarker",
				"more_results": "Truncated",
				"result_key": "Aliases"
			},
			"ListGrants": {
				"limit_key": "Limit",
				"input_token": "Marker",
				"output_token": "NextMarker",
				"more_results": "Truncated",
				"result_key": "Grants"
			},
			"ListKeyPolicies": {
				"limit_key": "Limit",
				"input_token": "Marker",
				"output_token": "NextMarker",
				"more_results": "Truncated",
				"result_key": "PolicyNames"
			},
			"ListKeys": {
				"limit_key": "Limit",
				"input_token": "Marker",
				"output_token": "NextMarker",
				"more_results": "Truncated",
				"result_key": "Keys"
			}
		}
	};

/***/ },
/* 397 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['lambda'] = {};
	AWS.Lambda = Service.defineService('lambda', ['2014-11-11', '2015-03-31']);
	Object.defineProperty(apiLoader.services['lambda'], '2014-11-11', {
	  get: function get() {
	    var model = __webpack_require__(398);
	    model.paginators = __webpack_require__(399).pagination;
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});
	Object.defineProperty(apiLoader.services['lambda'], '2015-03-31', {
	  get: function get() {
	    var model = __webpack_require__(400);
	    model.paginators = __webpack_require__(401).pagination;
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.Lambda;


/***/ },
/* 398 */
/***/ function(module, exports) {

	module.exports = {
		"metadata": {
			"apiVersion": "2014-11-11",
			"endpointPrefix": "lambda",
			"serviceFullName": "AWS Lambda",
			"signatureVersion": "v4",
			"protocol": "rest-json"
		},
		"operations": {
			"AddEventSource": {
				"http": {
					"requestUri": "/2014-11-13/event-source-mappings/"
				},
				"input": {
					"type": "structure",
					"required": [
						"EventSource",
						"FunctionName",
						"Role"
					],
					"members": {
						"EventSource": {},
						"FunctionName": {},
						"Role": {},
						"BatchSize": {
							"type": "integer"
						},
						"Parameters": {
							"shape": "S6"
						}
					}
				},
				"output": {
					"shape": "S7"
				}
			},
			"DeleteFunction": {
				"http": {
					"method": "DELETE",
					"requestUri": "/2014-11-13/functions/{FunctionName}",
					"responseCode": 204
				},
				"input": {
					"type": "structure",
					"required": [
						"FunctionName"
					],
					"members": {
						"FunctionName": {
							"location": "uri",
							"locationName": "FunctionName"
						}
					}
				}
			},
			"GetEventSource": {
				"http": {
					"method": "GET",
					"requestUri": "/2014-11-13/event-source-mappings/{UUID}",
					"responseCode": 200
				},
				"input": {
					"type": "structure",
					"required": [
						"UUID"
					],
					"members": {
						"UUID": {
							"location": "uri",
							"locationName": "UUID"
						}
					}
				},
				"output": {
					"shape": "S7"
				}
			},
			"GetFunction": {
				"http": {
					"method": "GET",
					"requestUri": "/2014-11-13/functions/{FunctionName}",
					"responseCode": 200
				},
				"input": {
					"type": "structure",
					"required": [
						"FunctionName"
					],
					"members": {
						"FunctionName": {
							"location": "uri",
							"locationName": "FunctionName"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Configuration": {
							"shape": "Se"
						},
						"Code": {
							"type": "structure",
							"members": {
								"RepositoryType": {},
								"Location": {}
							}
						}
					}
				}
			},
			"GetFunctionConfiguration": {
				"http": {
					"method": "GET",
					"requestUri": "/2014-11-13/functions/{FunctionName}/configuration",
					"responseCode": 200
				},
				"input": {
					"type": "structure",
					"required": [
						"FunctionName"
					],
					"members": {
						"FunctionName": {
							"location": "uri",
							"locationName": "FunctionName"
						}
					}
				},
				"output": {
					"shape": "Se"
				}
			},
			"InvokeAsync": {
				"http": {
					"requestUri": "/2014-11-13/functions/{FunctionName}/invoke-async/",
					"responseCode": 202
				},
				"input": {
					"type": "structure",
					"required": [
						"FunctionName",
						"InvokeArgs"
					],
					"members": {
						"FunctionName": {
							"location": "uri",
							"locationName": "FunctionName"
						},
						"InvokeArgs": {
							"shape": "Sq"
						}
					},
					"payload": "InvokeArgs"
				},
				"output": {
					"type": "structure",
					"members": {
						"Status": {
							"location": "statusCode",
							"type": "integer"
						}
					}
				}
			},
			"ListEventSources": {
				"http": {
					"method": "GET",
					"requestUri": "/2014-11-13/event-source-mappings/",
					"responseCode": 200
				},
				"input": {
					"type": "structure",
					"members": {
						"EventSourceArn": {
							"location": "querystring",
							"locationName": "EventSource"
						},
						"FunctionName": {
							"location": "querystring",
							"locationName": "FunctionName"
						},
						"Marker": {
							"location": "querystring",
							"locationName": "Marker"
						},
						"MaxItems": {
							"location": "querystring",
							"locationName": "MaxItems",
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"NextMarker": {},
						"EventSources": {
							"type": "list",
							"member": {
								"shape": "S7"
							}
						}
					}
				}
			},
			"ListFunctions": {
				"http": {
					"method": "GET",
					"requestUri": "/2014-11-13/functions/",
					"responseCode": 200
				},
				"input": {
					"type": "structure",
					"members": {
						"Marker": {
							"location": "querystring",
							"locationName": "Marker"
						},
						"MaxItems": {
							"location": "querystring",
							"locationName": "MaxItems",
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"NextMarker": {},
						"Functions": {
							"type": "list",
							"member": {
								"shape": "Se"
							}
						}
					}
				}
			},
			"RemoveEventSource": {
				"http": {
					"method": "DELETE",
					"requestUri": "/2014-11-13/event-source-mappings/{UUID}",
					"responseCode": 204
				},
				"input": {
					"type": "structure",
					"required": [
						"UUID"
					],
					"members": {
						"UUID": {
							"location": "uri",
							"locationName": "UUID"
						}
					}
				}
			},
			"UpdateFunctionConfiguration": {
				"http": {
					"method": "PUT",
					"requestUri": "/2014-11-13/functions/{FunctionName}/configuration",
					"responseCode": 200
				},
				"input": {
					"type": "structure",
					"required": [
						"FunctionName"
					],
					"members": {
						"FunctionName": {
							"location": "uri",
							"locationName": "FunctionName"
						},
						"Role": {
							"location": "querystring",
							"locationName": "Role"
						},
						"Handler": {
							"location": "querystring",
							"locationName": "Handler"
						},
						"Description": {
							"location": "querystring",
							"locationName": "Description"
						},
						"Timeout": {
							"location": "querystring",
							"locationName": "Timeout",
							"type": "integer"
						},
						"MemorySize": {
							"location": "querystring",
							"locationName": "MemorySize",
							"type": "integer"
						}
					}
				},
				"output": {
					"shape": "Se"
				}
			},
			"UploadFunction": {
				"http": {
					"method": "PUT",
					"requestUri": "/2014-11-13/functions/{FunctionName}",
					"responseCode": 201
				},
				"input": {
					"type": "structure",
					"required": [
						"FunctionName",
						"FunctionZip",
						"Runtime",
						"Role",
						"Handler",
						"Mode"
					],
					"members": {
						"FunctionName": {
							"location": "uri",
							"locationName": "FunctionName"
						},
						"FunctionZip": {
							"shape": "Sq"
						},
						"Runtime": {
							"location": "querystring",
							"locationName": "Runtime"
						},
						"Role": {
							"location": "querystring",
							"locationName": "Role"
						},
						"Handler": {
							"location": "querystring",
							"locationName": "Handler"
						},
						"Mode": {
							"location": "querystring",
							"locationName": "Mode"
						},
						"Description": {
							"location": "querystring",
							"locationName": "Description"
						},
						"Timeout": {
							"location": "querystring",
							"locationName": "Timeout",
							"type": "integer"
						},
						"MemorySize": {
							"location": "querystring",
							"locationName": "MemorySize",
							"type": "integer"
						}
					},
					"payload": "FunctionZip"
				},
				"output": {
					"shape": "Se"
				}
			}
		},
		"shapes": {
			"S6": {
				"type": "map",
				"key": {},
				"value": {}
			},
			"S7": {
				"type": "structure",
				"members": {
					"UUID": {},
					"BatchSize": {
						"type": "integer"
					},
					"EventSource": {},
					"FunctionName": {},
					"Parameters": {
						"shape": "S6"
					},
					"Role": {},
					"LastModified": {
						"type": "timestamp"
					},
					"IsActive": {
						"type": "boolean"
					},
					"Status": {}
				}
			},
			"Se": {
				"type": "structure",
				"members": {
					"FunctionName": {},
					"FunctionARN": {},
					"ConfigurationId": {},
					"Runtime": {},
					"Role": {},
					"Handler": {},
					"Mode": {},
					"CodeSize": {
						"type": "long"
					},
					"Description": {},
					"Timeout": {
						"type": "integer"
					},
					"MemorySize": {
						"type": "integer"
					},
					"LastModified": {
						"type": "timestamp"
					}
				}
			},
			"Sq": {
				"type": "blob",
				"streaming": true
			}
		}
	};

/***/ },
/* 399 */
/***/ function(module, exports) {

	module.exports = {
		"pagination": {
			"ListEventSources": {
				"input_token": "Marker",
				"output_token": "NextMarker",
				"limit_key": "MaxItems",
				"result_key": "EventSources"
			},
			"ListFunctions": {
				"input_token": "Marker",
				"output_token": "NextMarker",
				"limit_key": "MaxItems",
				"result_key": "Functions"
			}
		}
	};

/***/ },
/* 400 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2015-03-31",
			"endpointPrefix": "lambda",
			"protocol": "rest-json",
			"serviceFullName": "AWS Lambda",
			"signatureVersion": "v4"
		},
		"operations": {
			"AddPermission": {
				"http": {
					"requestUri": "/2015-03-31/functions/{FunctionName}/policy",
					"responseCode": 201
				},
				"input": {
					"type": "structure",
					"required": [
						"FunctionName",
						"StatementId",
						"Action",
						"Principal"
					],
					"members": {
						"FunctionName": {
							"location": "uri",
							"locationName": "FunctionName"
						},
						"StatementId": {},
						"Action": {},
						"Principal": {},
						"SourceArn": {},
						"SourceAccount": {},
						"EventSourceToken": {},
						"Qualifier": {
							"location": "querystring",
							"locationName": "Qualifier"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Statement": {}
					}
				}
			},
			"CreateAlias": {
				"http": {
					"requestUri": "/2015-03-31/functions/{FunctionName}/aliases",
					"responseCode": 201
				},
				"input": {
					"type": "structure",
					"required": [
						"FunctionName",
						"Name",
						"FunctionVersion"
					],
					"members": {
						"FunctionName": {
							"location": "uri",
							"locationName": "FunctionName"
						},
						"Name": {},
						"FunctionVersion": {},
						"Description": {}
					}
				},
				"output": {
					"shape": "Sg"
				}
			},
			"CreateEventSourceMapping": {
				"http": {
					"requestUri": "/2015-03-31/event-source-mappings/",
					"responseCode": 202
				},
				"input": {
					"type": "structure",
					"required": [
						"EventSourceArn",
						"FunctionName",
						"StartingPosition"
					],
					"members": {
						"EventSourceArn": {},
						"FunctionName": {},
						"Enabled": {
							"type": "boolean"
						},
						"BatchSize": {
							"type": "integer"
						},
						"StartingPosition": {}
					}
				},
				"output": {
					"shape": "Sm"
				}
			},
			"CreateFunction": {
				"http": {
					"requestUri": "/2015-03-31/functions",
					"responseCode": 201
				},
				"input": {
					"type": "structure",
					"required": [
						"FunctionName",
						"Runtime",
						"Role",
						"Handler",
						"Code"
					],
					"members": {
						"FunctionName": {},
						"Runtime": {},
						"Role": {},
						"Handler": {},
						"Code": {
							"type": "structure",
							"members": {
								"ZipFile": {
									"type": "blob"
								},
								"S3Bucket": {},
								"S3Key": {},
								"S3ObjectVersion": {}
							}
						},
						"Description": {},
						"Timeout": {
							"type": "integer"
						},
						"MemorySize": {
							"type": "integer"
						},
						"Publish": {
							"type": "boolean"
						},
						"VpcConfig": {
							"shape": "S10"
						}
					}
				},
				"output": {
					"shape": "S15"
				}
			},
			"DeleteAlias": {
				"http": {
					"method": "DELETE",
					"requestUri": "/2015-03-31/functions/{FunctionName}/aliases/{Name}",
					"responseCode": 204
				},
				"input": {
					"type": "structure",
					"required": [
						"FunctionName",
						"Name"
					],
					"members": {
						"FunctionName": {
							"location": "uri",
							"locationName": "FunctionName"
						},
						"Name": {
							"location": "uri",
							"locationName": "Name"
						}
					}
				}
			},
			"DeleteEventSourceMapping": {
				"http": {
					"method": "DELETE",
					"requestUri": "/2015-03-31/event-source-mappings/{UUID}",
					"responseCode": 202
				},
				"input": {
					"type": "structure",
					"required": [
						"UUID"
					],
					"members": {
						"UUID": {
							"location": "uri",
							"locationName": "UUID"
						}
					}
				},
				"output": {
					"shape": "Sm"
				}
			},
			"DeleteFunction": {
				"http": {
					"method": "DELETE",
					"requestUri": "/2015-03-31/functions/{FunctionName}",
					"responseCode": 204
				},
				"input": {
					"type": "structure",
					"required": [
						"FunctionName"
					],
					"members": {
						"FunctionName": {
							"location": "uri",
							"locationName": "FunctionName"
						},
						"Qualifier": {
							"location": "querystring",
							"locationName": "Qualifier"
						}
					}
				}
			},
			"GetAlias": {
				"http": {
					"method": "GET",
					"requestUri": "/2015-03-31/functions/{FunctionName}/aliases/{Name}",
					"responseCode": 200
				},
				"input": {
					"type": "structure",
					"required": [
						"FunctionName",
						"Name"
					],
					"members": {
						"FunctionName": {
							"location": "uri",
							"locationName": "FunctionName"
						},
						"Name": {
							"location": "uri",
							"locationName": "Name"
						}
					}
				},
				"output": {
					"shape": "Sg"
				}
			},
			"GetEventSourceMapping": {
				"http": {
					"method": "GET",
					"requestUri": "/2015-03-31/event-source-mappings/{UUID}",
					"responseCode": 200
				},
				"input": {
					"type": "structure",
					"required": [
						"UUID"
					],
					"members": {
						"UUID": {
							"location": "uri",
							"locationName": "UUID"
						}
					}
				},
				"output": {
					"shape": "Sm"
				}
			},
			"GetFunction": {
				"http": {
					"method": "GET",
					"requestUri": "/2015-03-31/functions/{FunctionName}",
					"responseCode": 200
				},
				"input": {
					"type": "structure",
					"required": [
						"FunctionName"
					],
					"members": {
						"FunctionName": {
							"location": "uri",
							"locationName": "FunctionName"
						},
						"Qualifier": {
							"location": "querystring",
							"locationName": "Qualifier"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Configuration": {
							"shape": "S15"
						},
						"Code": {
							"type": "structure",
							"members": {
								"RepositoryType": {},
								"Location": {}
							}
						}
					}
				}
			},
			"GetFunctionConfiguration": {
				"http": {
					"method": "GET",
					"requestUri": "/2015-03-31/functions/{FunctionName}/configuration",
					"responseCode": 200
				},
				"input": {
					"type": "structure",
					"required": [
						"FunctionName"
					],
					"members": {
						"FunctionName": {
							"location": "uri",
							"locationName": "FunctionName"
						},
						"Qualifier": {
							"location": "querystring",
							"locationName": "Qualifier"
						}
					}
				},
				"output": {
					"shape": "S15"
				}
			},
			"GetPolicy": {
				"http": {
					"method": "GET",
					"requestUri": "/2015-03-31/functions/{FunctionName}/policy",
					"responseCode": 200
				},
				"input": {
					"type": "structure",
					"required": [
						"FunctionName"
					],
					"members": {
						"FunctionName": {
							"location": "uri",
							"locationName": "FunctionName"
						},
						"Qualifier": {
							"location": "querystring",
							"locationName": "Qualifier"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Policy": {}
					}
				}
			},
			"Invoke": {
				"http": {
					"requestUri": "/2015-03-31/functions/{FunctionName}/invocations"
				},
				"input": {
					"type": "structure",
					"required": [
						"FunctionName"
					],
					"members": {
						"FunctionName": {
							"location": "uri",
							"locationName": "FunctionName"
						},
						"InvocationType": {
							"location": "header",
							"locationName": "X-Amz-Invocation-Type"
						},
						"LogType": {
							"location": "header",
							"locationName": "X-Amz-Log-Type"
						},
						"ClientContext": {
							"location": "header",
							"locationName": "X-Amz-Client-Context"
						},
						"Payload": {
							"type": "blob"
						},
						"Qualifier": {
							"location": "querystring",
							"locationName": "Qualifier"
						}
					},
					"payload": "Payload"
				},
				"output": {
					"type": "structure",
					"members": {
						"StatusCode": {
							"location": "statusCode",
							"type": "integer"
						},
						"FunctionError": {
							"location": "header",
							"locationName": "X-Amz-Function-Error"
						},
						"LogResult": {
							"location": "header",
							"locationName": "X-Amz-Log-Result"
						},
						"Payload": {
							"type": "blob"
						}
					},
					"payload": "Payload"
				}
			},
			"InvokeAsync": {
				"http": {
					"requestUri": "/2014-11-13/functions/{FunctionName}/invoke-async/",
					"responseCode": 202
				},
				"input": {
					"type": "structure",
					"required": [
						"FunctionName",
						"InvokeArgs"
					],
					"members": {
						"FunctionName": {
							"location": "uri",
							"locationName": "FunctionName"
						},
						"InvokeArgs": {
							"type": "blob",
							"streaming": true
						}
					},
					"deprecated": true,
					"payload": "InvokeArgs"
				},
				"output": {
					"type": "structure",
					"members": {
						"Status": {
							"location": "statusCode",
							"type": "integer"
						}
					},
					"deprecated": true
				},
				"deprecated": true
			},
			"ListAliases": {
				"http": {
					"method": "GET",
					"requestUri": "/2015-03-31/functions/{FunctionName}/aliases",
					"responseCode": 200
				},
				"input": {
					"type": "structure",
					"required": [
						"FunctionName"
					],
					"members": {
						"FunctionName": {
							"location": "uri",
							"locationName": "FunctionName"
						},
						"FunctionVersion": {
							"location": "querystring",
							"locationName": "FunctionVersion"
						},
						"Marker": {
							"location": "querystring",
							"locationName": "Marker"
						},
						"MaxItems": {
							"location": "querystring",
							"locationName": "MaxItems",
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"NextMarker": {},
						"Aliases": {
							"type": "list",
							"member": {
								"shape": "Sg"
							}
						}
					}
				}
			},
			"ListEventSourceMappings": {
				"http": {
					"method": "GET",
					"requestUri": "/2015-03-31/event-source-mappings/",
					"responseCode": 200
				},
				"input": {
					"type": "structure",
					"members": {
						"EventSourceArn": {
							"location": "querystring",
							"locationName": "EventSourceArn"
						},
						"FunctionName": {
							"location": "querystring",
							"locationName": "FunctionName"
						},
						"Marker": {
							"location": "querystring",
							"locationName": "Marker"
						},
						"MaxItems": {
							"location": "querystring",
							"locationName": "MaxItems",
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"NextMarker": {},
						"EventSourceMappings": {
							"type": "list",
							"member": {
								"shape": "Sm"
							}
						}
					}
				}
			},
			"ListFunctions": {
				"http": {
					"method": "GET",
					"requestUri": "/2015-03-31/functions/",
					"responseCode": 200
				},
				"input": {
					"type": "structure",
					"members": {
						"Marker": {
							"location": "querystring",
							"locationName": "Marker"
						},
						"MaxItems": {
							"location": "querystring",
							"locationName": "MaxItems",
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"NextMarker": {},
						"Functions": {
							"shape": "S23"
						}
					}
				}
			},
			"ListVersionsByFunction": {
				"http": {
					"method": "GET",
					"requestUri": "/2015-03-31/functions/{FunctionName}/versions",
					"responseCode": 200
				},
				"input": {
					"type": "structure",
					"required": [
						"FunctionName"
					],
					"members": {
						"FunctionName": {
							"location": "uri",
							"locationName": "FunctionName"
						},
						"Marker": {
							"location": "querystring",
							"locationName": "Marker"
						},
						"MaxItems": {
							"location": "querystring",
							"locationName": "MaxItems",
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"NextMarker": {},
						"Versions": {
							"shape": "S23"
						}
					}
				}
			},
			"PublishVersion": {
				"http": {
					"requestUri": "/2015-03-31/functions/{FunctionName}/versions",
					"responseCode": 201
				},
				"input": {
					"type": "structure",
					"required": [
						"FunctionName"
					],
					"members": {
						"FunctionName": {
							"location": "uri",
							"locationName": "FunctionName"
						},
						"CodeSha256": {},
						"Description": {}
					}
				},
				"output": {
					"shape": "S15"
				}
			},
			"RemovePermission": {
				"http": {
					"method": "DELETE",
					"requestUri": "/2015-03-31/functions/{FunctionName}/policy/{StatementId}",
					"responseCode": 204
				},
				"input": {
					"type": "structure",
					"required": [
						"FunctionName",
						"StatementId"
					],
					"members": {
						"FunctionName": {
							"location": "uri",
							"locationName": "FunctionName"
						},
						"StatementId": {
							"location": "uri",
							"locationName": "StatementId"
						},
						"Qualifier": {
							"location": "querystring",
							"locationName": "Qualifier"
						}
					}
				}
			},
			"UpdateAlias": {
				"http": {
					"method": "PUT",
					"requestUri": "/2015-03-31/functions/{FunctionName}/aliases/{Name}",
					"responseCode": 200
				},
				"input": {
					"type": "structure",
					"required": [
						"FunctionName",
						"Name"
					],
					"members": {
						"FunctionName": {
							"location": "uri",
							"locationName": "FunctionName"
						},
						"Name": {
							"location": "uri",
							"locationName": "Name"
						},
						"FunctionVersion": {},
						"Description": {}
					}
				},
				"output": {
					"shape": "Sg"
				}
			},
			"UpdateEventSourceMapping": {
				"http": {
					"method": "PUT",
					"requestUri": "/2015-03-31/event-source-mappings/{UUID}",
					"responseCode": 202
				},
				"input": {
					"type": "structure",
					"required": [
						"UUID"
					],
					"members": {
						"UUID": {
							"location": "uri",
							"locationName": "UUID"
						},
						"FunctionName": {},
						"Enabled": {
							"type": "boolean"
						},
						"BatchSize": {
							"type": "integer"
						}
					}
				},
				"output": {
					"shape": "Sm"
				}
			},
			"UpdateFunctionCode": {
				"http": {
					"method": "PUT",
					"requestUri": "/2015-03-31/functions/{FunctionName}/code",
					"responseCode": 200
				},
				"input": {
					"type": "structure",
					"required": [
						"FunctionName"
					],
					"members": {
						"FunctionName": {
							"location": "uri",
							"locationName": "FunctionName"
						},
						"ZipFile": {
							"type": "blob"
						},
						"S3Bucket": {},
						"S3Key": {},
						"S3ObjectVersion": {},
						"Publish": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"shape": "S15"
				}
			},
			"UpdateFunctionConfiguration": {
				"http": {
					"method": "PUT",
					"requestUri": "/2015-03-31/functions/{FunctionName}/configuration",
					"responseCode": 200
				},
				"input": {
					"type": "structure",
					"required": [
						"FunctionName"
					],
					"members": {
						"FunctionName": {
							"location": "uri",
							"locationName": "FunctionName"
						},
						"Role": {},
						"Handler": {},
						"Description": {},
						"Timeout": {
							"type": "integer"
						},
						"MemorySize": {
							"type": "integer"
						},
						"VpcConfig": {
							"shape": "S10"
						},
						"Runtime": {}
					}
				},
				"output": {
					"shape": "S15"
				}
			}
		},
		"shapes": {
			"Sg": {
				"type": "structure",
				"members": {
					"AliasArn": {},
					"Name": {},
					"FunctionVersion": {},
					"Description": {}
				}
			},
			"Sm": {
				"type": "structure",
				"members": {
					"UUID": {},
					"BatchSize": {
						"type": "integer"
					},
					"EventSourceArn": {},
					"FunctionArn": {},
					"LastModified": {
						"type": "timestamp"
					},
					"LastProcessingResult": {},
					"State": {},
					"StateTransitionReason": {}
				}
			},
			"S10": {
				"type": "structure",
				"members": {
					"SubnetIds": {
						"shape": "S11"
					},
					"SecurityGroupIds": {
						"shape": "S13"
					}
				}
			},
			"S11": {
				"type": "list",
				"member": {}
			},
			"S13": {
				"type": "list",
				"member": {}
			},
			"S15": {
				"type": "structure",
				"members": {
					"FunctionName": {},
					"FunctionArn": {},
					"Runtime": {},
					"Role": {},
					"Handler": {},
					"CodeSize": {
						"type": "long"
					},
					"Description": {},
					"Timeout": {
						"type": "integer"
					},
					"MemorySize": {
						"type": "integer"
					},
					"LastModified": {},
					"CodeSha256": {},
					"Version": {},
					"VpcConfig": {
						"type": "structure",
						"members": {
							"SubnetIds": {
								"shape": "S11"
							},
							"SecurityGroupIds": {
								"shape": "S13"
							},
							"VpcId": {}
						}
					}
				}
			},
			"S23": {
				"type": "list",
				"member": {
					"shape": "S15"
				}
			}
		}
	};

/***/ },
/* 401 */
/***/ function(module, exports) {

	module.exports = {
		"pagination": {
			"ListEventSourceMappings": {
				"input_token": "Marker",
				"output_token": "NextMarker",
				"limit_key": "MaxItems",
				"result_key": "EventSourceMappings"
			},
			"ListFunctions": {
				"input_token": "Marker",
				"output_token": "NextMarker",
				"limit_key": "MaxItems",
				"result_key": "Functions"
			}
		}
	};

/***/ },
/* 402 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['machinelearning'] = {};
	AWS.MachineLearning = Service.defineService('machinelearning', ['2014-12-12']);
	__webpack_require__(403);
	Object.defineProperty(apiLoader.services['machinelearning'], '2014-12-12', {
	  get: function get() {
	    var model = __webpack_require__(404);
	    model.paginators = __webpack_require__(405).pagination;
	    model.waiters = __webpack_require__(406).waiters;
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.MachineLearning;


/***/ },
/* 403 */
/***/ function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(93);

	AWS.util.update(AWS.MachineLearning.prototype, {
	  /**
	   * @api private
	   */
	  setupRequestListeners: function setupRequestListeners(request) {
	    if (request.operation === 'predict') {
	      request.addListener('build', this.buildEndpoint);
	    }
	  },

	  /**
	   * Updates request endpoint from PredictEndpoint
	   * @api private
	   */
	  buildEndpoint: function buildEndpoint(request) {
	    var url = request.params.PredictEndpoint;
	    if (url) {
	      request.httpRequest.endpoint = new AWS.Endpoint(url);
	    }
	  }

	});


/***/ },
/* 404 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2014-12-12",
			"endpointPrefix": "machinelearning",
			"jsonVersion": "1.1",
			"serviceFullName": "Amazon Machine Learning",
			"signatureVersion": "v4",
			"targetPrefix": "AmazonML_20141212",
			"protocol": "json"
		},
		"operations": {
			"AddTags": {
				"input": {
					"type": "structure",
					"required": [
						"Tags",
						"ResourceId",
						"ResourceType"
					],
					"members": {
						"Tags": {
							"shape": "S2"
						},
						"ResourceId": {},
						"ResourceType": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ResourceId": {},
						"ResourceType": {}
					}
				}
			},
			"CreateBatchPrediction": {
				"input": {
					"type": "structure",
					"required": [
						"BatchPredictionId",
						"MLModelId",
						"BatchPredictionDataSourceId",
						"OutputUri"
					],
					"members": {
						"BatchPredictionId": {},
						"BatchPredictionName": {},
						"MLModelId": {},
						"BatchPredictionDataSourceId": {},
						"OutputUri": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"BatchPredictionId": {}
					}
				}
			},
			"CreateDataSourceFromRDS": {
				"input": {
					"type": "structure",
					"required": [
						"DataSourceId",
						"RDSData",
						"RoleARN"
					],
					"members": {
						"DataSourceId": {},
						"DataSourceName": {},
						"RDSData": {
							"type": "structure",
							"required": [
								"DatabaseInformation",
								"SelectSqlQuery",
								"DatabaseCredentials",
								"S3StagingLocation",
								"ResourceRole",
								"ServiceRole",
								"SubnetId",
								"SecurityGroupIds"
							],
							"members": {
								"DatabaseInformation": {
									"shape": "Sf"
								},
								"SelectSqlQuery": {},
								"DatabaseCredentials": {
									"type": "structure",
									"required": [
										"Username",
										"Password"
									],
									"members": {
										"Username": {},
										"Password": {}
									}
								},
								"S3StagingLocation": {},
								"DataRearrangement": {},
								"DataSchema": {},
								"DataSchemaUri": {},
								"ResourceRole": {},
								"ServiceRole": {},
								"SubnetId": {},
								"SecurityGroupIds": {
									"type": "list",
									"member": {}
								}
							}
						},
						"RoleARN": {},
						"ComputeStatistics": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"DataSourceId": {}
					}
				}
			},
			"CreateDataSourceFromRedshift": {
				"input": {
					"type": "structure",
					"required": [
						"DataSourceId",
						"DataSpec",
						"RoleARN"
					],
					"members": {
						"DataSourceId": {},
						"DataSourceName": {},
						"DataSpec": {
							"type": "structure",
							"required": [
								"DatabaseInformation",
								"SelectSqlQuery",
								"DatabaseCredentials",
								"S3StagingLocation"
							],
							"members": {
								"DatabaseInformation": {
									"shape": "Sy"
								},
								"SelectSqlQuery": {},
								"DatabaseCredentials": {
									"type": "structure",
									"required": [
										"Username",
										"Password"
									],
									"members": {
										"Username": {},
										"Password": {}
									}
								},
								"S3StagingLocation": {},
								"DataRearrangement": {},
								"DataSchema": {},
								"DataSchemaUri": {}
							}
						},
						"RoleARN": {},
						"ComputeStatistics": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"DataSourceId": {}
					}
				}
			},
			"CreateDataSourceFromS3": {
				"input": {
					"type": "structure",
					"required": [
						"DataSourceId",
						"DataSpec"
					],
					"members": {
						"DataSourceId": {},
						"DataSourceName": {},
						"DataSpec": {
							"type": "structure",
							"required": [
								"DataLocationS3"
							],
							"members": {
								"DataLocationS3": {},
								"DataRearrangement": {},
								"DataSchema": {},
								"DataSchemaLocationS3": {}
							}
						},
						"ComputeStatistics": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"DataSourceId": {}
					}
				}
			},
			"CreateEvaluation": {
				"input": {
					"type": "structure",
					"required": [
						"EvaluationId",
						"MLModelId",
						"EvaluationDataSourceId"
					],
					"members": {
						"EvaluationId": {},
						"EvaluationName": {},
						"MLModelId": {},
						"EvaluationDataSourceId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"EvaluationId": {}
					}
				}
			},
			"CreateMLModel": {
				"input": {
					"type": "structure",
					"required": [
						"MLModelId",
						"MLModelType",
						"TrainingDataSourceId"
					],
					"members": {
						"MLModelId": {},
						"MLModelName": {},
						"MLModelType": {},
						"Parameters": {
							"shape": "S1d"
						},
						"TrainingDataSourceId": {},
						"Recipe": {},
						"RecipeUri": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"MLModelId": {}
					}
				}
			},
			"CreateRealtimeEndpoint": {
				"input": {
					"type": "structure",
					"required": [
						"MLModelId"
					],
					"members": {
						"MLModelId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"MLModelId": {},
						"RealtimeEndpointInfo": {
							"shape": "S1j"
						}
					}
				}
			},
			"DeleteBatchPrediction": {
				"input": {
					"type": "structure",
					"required": [
						"BatchPredictionId"
					],
					"members": {
						"BatchPredictionId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"BatchPredictionId": {}
					}
				}
			},
			"DeleteDataSource": {
				"input": {
					"type": "structure",
					"required": [
						"DataSourceId"
					],
					"members": {
						"DataSourceId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"DataSourceId": {}
					}
				}
			},
			"DeleteEvaluation": {
				"input": {
					"type": "structure",
					"required": [
						"EvaluationId"
					],
					"members": {
						"EvaluationId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"EvaluationId": {}
					}
				}
			},
			"DeleteMLModel": {
				"input": {
					"type": "structure",
					"required": [
						"MLModelId"
					],
					"members": {
						"MLModelId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"MLModelId": {}
					}
				}
			},
			"DeleteRealtimeEndpoint": {
				"input": {
					"type": "structure",
					"required": [
						"MLModelId"
					],
					"members": {
						"MLModelId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"MLModelId": {},
						"RealtimeEndpointInfo": {
							"shape": "S1j"
						}
					}
				}
			},
			"DeleteTags": {
				"input": {
					"type": "structure",
					"required": [
						"TagKeys",
						"ResourceId",
						"ResourceType"
					],
					"members": {
						"TagKeys": {
							"type": "list",
							"member": {}
						},
						"ResourceId": {},
						"ResourceType": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ResourceId": {},
						"ResourceType": {}
					}
				}
			},
			"DescribeBatchPredictions": {
				"input": {
					"type": "structure",
					"members": {
						"FilterVariable": {},
						"EQ": {},
						"GT": {},
						"LT": {},
						"GE": {},
						"LE": {},
						"NE": {},
						"Prefix": {},
						"SortOrder": {},
						"NextToken": {},
						"Limit": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Results": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"BatchPredictionId": {},
									"MLModelId": {},
									"BatchPredictionDataSourceId": {},
									"InputDataLocationS3": {},
									"CreatedByIamUser": {},
									"CreatedAt": {
										"type": "timestamp"
									},
									"LastUpdatedAt": {
										"type": "timestamp"
									},
									"Name": {},
									"Status": {},
									"OutputUri": {},
									"Message": {},
									"ComputeTime": {
										"type": "long"
									},
									"FinishedAt": {
										"type": "timestamp"
									},
									"StartedAt": {
										"type": "timestamp"
									},
									"TotalRecordCount": {
										"type": "long"
									},
									"InvalidRecordCount": {
										"type": "long"
									}
								}
							}
						},
						"NextToken": {}
					}
				}
			},
			"DescribeDataSources": {
				"input": {
					"type": "structure",
					"members": {
						"FilterVariable": {},
						"EQ": {},
						"GT": {},
						"LT": {},
						"GE": {},
						"LE": {},
						"NE": {},
						"Prefix": {},
						"SortOrder": {},
						"NextToken": {},
						"Limit": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Results": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"DataSourceId": {},
									"DataLocationS3": {},
									"DataRearrangement": {},
									"CreatedByIamUser": {},
									"CreatedAt": {
										"type": "timestamp"
									},
									"LastUpdatedAt": {
										"type": "timestamp"
									},
									"DataSizeInBytes": {
										"type": "long"
									},
									"NumberOfFiles": {
										"type": "long"
									},
									"Name": {},
									"Status": {},
									"Message": {},
									"RedshiftMetadata": {
										"shape": "S2i"
									},
									"RDSMetadata": {
										"shape": "S2j"
									},
									"RoleARN": {},
									"ComputeStatistics": {
										"type": "boolean"
									},
									"ComputeTime": {
										"type": "long"
									},
									"FinishedAt": {
										"type": "timestamp"
									},
									"StartedAt": {
										"type": "timestamp"
									}
								}
							}
						},
						"NextToken": {}
					}
				}
			},
			"DescribeEvaluations": {
				"input": {
					"type": "structure",
					"members": {
						"FilterVariable": {},
						"EQ": {},
						"GT": {},
						"LT": {},
						"GE": {},
						"LE": {},
						"NE": {},
						"Prefix": {},
						"SortOrder": {},
						"NextToken": {},
						"Limit": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Results": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"EvaluationId": {},
									"MLModelId": {},
									"EvaluationDataSourceId": {},
									"InputDataLocationS3": {},
									"CreatedByIamUser": {},
									"CreatedAt": {
										"type": "timestamp"
									},
									"LastUpdatedAt": {
										"type": "timestamp"
									},
									"Name": {},
									"Status": {},
									"PerformanceMetrics": {
										"shape": "S2q"
									},
									"Message": {},
									"ComputeTime": {
										"type": "long"
									},
									"FinishedAt": {
										"type": "timestamp"
									},
									"StartedAt": {
										"type": "timestamp"
									}
								}
							}
						},
						"NextToken": {}
					}
				}
			},
			"DescribeMLModels": {
				"input": {
					"type": "structure",
					"members": {
						"FilterVariable": {},
						"EQ": {},
						"GT": {},
						"LT": {},
						"GE": {},
						"LE": {},
						"NE": {},
						"Prefix": {},
						"SortOrder": {},
						"NextToken": {},
						"Limit": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Results": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"MLModelId": {},
									"TrainingDataSourceId": {},
									"CreatedByIamUser": {},
									"CreatedAt": {
										"type": "timestamp"
									},
									"LastUpdatedAt": {
										"type": "timestamp"
									},
									"Name": {},
									"Status": {},
									"SizeInBytes": {
										"type": "long"
									},
									"EndpointInfo": {
										"shape": "S1j"
									},
									"TrainingParameters": {
										"shape": "S1d"
									},
									"InputDataLocationS3": {},
									"Algorithm": {},
									"MLModelType": {},
									"ScoreThreshold": {
										"type": "float"
									},
									"ScoreThresholdLastUpdatedAt": {
										"type": "timestamp"
									},
									"Message": {},
									"ComputeTime": {
										"type": "long"
									},
									"FinishedAt": {
										"type": "timestamp"
									},
									"StartedAt": {
										"type": "timestamp"
									}
								}
							}
						},
						"NextToken": {}
					}
				}
			},
			"DescribeTags": {
				"input": {
					"type": "structure",
					"required": [
						"ResourceId",
						"ResourceType"
					],
					"members": {
						"ResourceId": {},
						"ResourceType": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ResourceId": {},
						"ResourceType": {},
						"Tags": {
							"shape": "S2"
						}
					}
				}
			},
			"GetBatchPrediction": {
				"input": {
					"type": "structure",
					"required": [
						"BatchPredictionId"
					],
					"members": {
						"BatchPredictionId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"BatchPredictionId": {},
						"MLModelId": {},
						"BatchPredictionDataSourceId": {},
						"InputDataLocationS3": {},
						"CreatedByIamUser": {},
						"CreatedAt": {
							"type": "timestamp"
						},
						"LastUpdatedAt": {
							"type": "timestamp"
						},
						"Name": {},
						"Status": {},
						"OutputUri": {},
						"LogUri": {},
						"Message": {},
						"ComputeTime": {
							"type": "long"
						},
						"FinishedAt": {
							"type": "timestamp"
						},
						"StartedAt": {
							"type": "timestamp"
						},
						"TotalRecordCount": {
							"type": "long"
						},
						"InvalidRecordCount": {
							"type": "long"
						}
					}
				}
			},
			"GetDataSource": {
				"input": {
					"type": "structure",
					"required": [
						"DataSourceId"
					],
					"members": {
						"DataSourceId": {},
						"Verbose": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"DataSourceId": {},
						"DataLocationS3": {},
						"DataRearrangement": {},
						"CreatedByIamUser": {},
						"CreatedAt": {
							"type": "timestamp"
						},
						"LastUpdatedAt": {
							"type": "timestamp"
						},
						"DataSizeInBytes": {
							"type": "long"
						},
						"NumberOfFiles": {
							"type": "long"
						},
						"Name": {},
						"Status": {},
						"LogUri": {},
						"Message": {},
						"RedshiftMetadata": {
							"shape": "S2i"
						},
						"RDSMetadata": {
							"shape": "S2j"
						},
						"RoleARN": {},
						"ComputeStatistics": {
							"type": "boolean"
						},
						"ComputeTime": {
							"type": "long"
						},
						"FinishedAt": {
							"type": "timestamp"
						},
						"StartedAt": {
							"type": "timestamp"
						},
						"DataSourceSchema": {}
					}
				}
			},
			"GetEvaluation": {
				"input": {
					"type": "structure",
					"required": [
						"EvaluationId"
					],
					"members": {
						"EvaluationId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"EvaluationId": {},
						"MLModelId": {},
						"EvaluationDataSourceId": {},
						"InputDataLocationS3": {},
						"CreatedByIamUser": {},
						"CreatedAt": {
							"type": "timestamp"
						},
						"LastUpdatedAt": {
							"type": "timestamp"
						},
						"Name": {},
						"Status": {},
						"PerformanceMetrics": {
							"shape": "S2q"
						},
						"LogUri": {},
						"Message": {},
						"ComputeTime": {
							"type": "long"
						},
						"FinishedAt": {
							"type": "timestamp"
						},
						"StartedAt": {
							"type": "timestamp"
						}
					}
				}
			},
			"GetMLModel": {
				"input": {
					"type": "structure",
					"required": [
						"MLModelId"
					],
					"members": {
						"MLModelId": {},
						"Verbose": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"MLModelId": {},
						"TrainingDataSourceId": {},
						"CreatedByIamUser": {},
						"CreatedAt": {
							"type": "timestamp"
						},
						"LastUpdatedAt": {
							"type": "timestamp"
						},
						"Name": {},
						"Status": {},
						"SizeInBytes": {
							"type": "long"
						},
						"EndpointInfo": {
							"shape": "S1j"
						},
						"TrainingParameters": {
							"shape": "S1d"
						},
						"InputDataLocationS3": {},
						"MLModelType": {},
						"ScoreThreshold": {
							"type": "float"
						},
						"ScoreThresholdLastUpdatedAt": {
							"type": "timestamp"
						},
						"LogUri": {},
						"Message": {},
						"ComputeTime": {
							"type": "long"
						},
						"FinishedAt": {
							"type": "timestamp"
						},
						"StartedAt": {
							"type": "timestamp"
						},
						"Recipe": {},
						"Schema": {}
					}
				}
			},
			"Predict": {
				"input": {
					"type": "structure",
					"required": [
						"MLModelId",
						"Record",
						"PredictEndpoint"
					],
					"members": {
						"MLModelId": {},
						"Record": {
							"type": "map",
							"key": {},
							"value": {}
						},
						"PredictEndpoint": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Prediction": {
							"type": "structure",
							"members": {
								"predictedLabel": {},
								"predictedValue": {
									"type": "float"
								},
								"predictedScores": {
									"type": "map",
									"key": {},
									"value": {
										"type": "float"
									}
								},
								"details": {
									"type": "map",
									"key": {},
									"value": {}
								}
							}
						}
					}
				}
			},
			"UpdateBatchPrediction": {
				"input": {
					"type": "structure",
					"required": [
						"BatchPredictionId",
						"BatchPredictionName"
					],
					"members": {
						"BatchPredictionId": {},
						"BatchPredictionName": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"BatchPredictionId": {}
					}
				}
			},
			"UpdateDataSource": {
				"input": {
					"type": "structure",
					"required": [
						"DataSourceId",
						"DataSourceName"
					],
					"members": {
						"DataSourceId": {},
						"DataSourceName": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"DataSourceId": {}
					}
				}
			},
			"UpdateEvaluation": {
				"input": {
					"type": "structure",
					"required": [
						"EvaluationId",
						"EvaluationName"
					],
					"members": {
						"EvaluationId": {},
						"EvaluationName": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"EvaluationId": {}
					}
				}
			},
			"UpdateMLModel": {
				"input": {
					"type": "structure",
					"required": [
						"MLModelId"
					],
					"members": {
						"MLModelId": {},
						"MLModelName": {},
						"ScoreThreshold": {
							"type": "float"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"MLModelId": {}
					}
				}
			}
		},
		"shapes": {
			"S2": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"Key": {},
						"Value": {}
					}
				}
			},
			"Sf": {
				"type": "structure",
				"required": [
					"InstanceIdentifier",
					"DatabaseName"
				],
				"members": {
					"InstanceIdentifier": {},
					"DatabaseName": {}
				}
			},
			"Sy": {
				"type": "structure",
				"required": [
					"DatabaseName",
					"ClusterIdentifier"
				],
				"members": {
					"DatabaseName": {},
					"ClusterIdentifier": {}
				}
			},
			"S1d": {
				"type": "map",
				"key": {},
				"value": {}
			},
			"S1j": {
				"type": "structure",
				"members": {
					"PeakRequestsPerSecond": {
						"type": "integer"
					},
					"CreatedAt": {
						"type": "timestamp"
					},
					"EndpointUrl": {},
					"EndpointStatus": {}
				}
			},
			"S2i": {
				"type": "structure",
				"members": {
					"RedshiftDatabase": {
						"shape": "Sy"
					},
					"DatabaseUserName": {},
					"SelectSqlQuery": {}
				}
			},
			"S2j": {
				"type": "structure",
				"members": {
					"Database": {
						"shape": "Sf"
					},
					"DatabaseUserName": {},
					"SelectSqlQuery": {},
					"ResourceRole": {},
					"ServiceRole": {},
					"DataPipelineId": {}
				}
			},
			"S2q": {
				"type": "structure",
				"members": {
					"Properties": {
						"type": "map",
						"key": {},
						"value": {}
					}
				}
			}
		},
		"examples": {}
	};

/***/ },
/* 405 */
/***/ function(module, exports) {

	module.exports = {
		"pagination": {
			"DescribeBatchPredictions": {
				"limit_key": "Limit",
				"output_token": "NextToken",
				"input_token": "NextToken",
				"result_key": "Results"
			},
			"DescribeDataSources": {
				"limit_key": "Limit",
				"output_token": "NextToken",
				"input_token": "NextToken",
				"result_key": "Results"
			},
			"DescribeEvaluations": {
				"limit_key": "Limit",
				"output_token": "NextToken",
				"input_token": "NextToken",
				"result_key": "Results"
			},
			"DescribeMLModels": {
				"limit_key": "Limit",
				"output_token": "NextToken",
				"input_token": "NextToken",
				"result_key": "Results"
			}
		}
	};

/***/ },
/* 406 */
/***/ function(module, exports) {

	module.exports = {
		"version": 2,
		"waiters": {
			"DataSourceAvailable": {
				"delay": 30,
				"operation": "DescribeDataSources",
				"maxAttempts": 60,
				"acceptors": [
					{
						"expected": "COMPLETED",
						"matcher": "pathAll",
						"state": "success",
						"argument": "Results[].Status"
					},
					{
						"expected": "FAILED",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "Results[].Status"
					}
				]
			},
			"MLModelAvailable": {
				"delay": 30,
				"operation": "DescribeMLModels",
				"maxAttempts": 60,
				"acceptors": [
					{
						"expected": "COMPLETED",
						"matcher": "pathAll",
						"state": "success",
						"argument": "Results[].Status"
					},
					{
						"expected": "FAILED",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "Results[].Status"
					}
				]
			},
			"EvaluationAvailable": {
				"delay": 30,
				"operation": "DescribeEvaluations",
				"maxAttempts": 60,
				"acceptors": [
					{
						"expected": "COMPLETED",
						"matcher": "pathAll",
						"state": "success",
						"argument": "Results[].Status"
					},
					{
						"expected": "FAILED",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "Results[].Status"
					}
				]
			},
			"BatchPredictionAvailable": {
				"delay": 30,
				"operation": "DescribeBatchPredictions",
				"maxAttempts": 60,
				"acceptors": [
					{
						"expected": "COMPLETED",
						"matcher": "pathAll",
						"state": "success",
						"argument": "Results[].Status"
					},
					{
						"expected": "FAILED",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "Results[].Status"
					}
				]
			}
		}
	};

/***/ },
/* 407 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['marketplacecommerceanalytics'] = {};
	AWS.MarketplaceCommerceAnalytics = Service.defineService('marketplacecommerceanalytics', ['2015-07-01']);
	Object.defineProperty(apiLoader.services['marketplacecommerceanalytics'], '2015-07-01', {
	  get: function get() {
	    var model = __webpack_require__(408);
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.MarketplaceCommerceAnalytics;


/***/ },
/* 408 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2015-07-01",
			"endpointPrefix": "marketplacecommerceanalytics",
			"jsonVersion": "1.1",
			"protocol": "json",
			"serviceFullName": "AWS Marketplace Commerce Analytics",
			"signatureVersion": "v4",
			"signingName": "marketplacecommerceanalytics",
			"targetPrefix": "MarketplaceCommerceAnalytics20150701"
		},
		"operations": {
			"GenerateDataSet": {
				"input": {
					"type": "structure",
					"required": [
						"dataSetType",
						"dataSetPublicationDate",
						"roleNameArn",
						"destinationS3BucketName",
						"snsTopicArn"
					],
					"members": {
						"dataSetType": {},
						"dataSetPublicationDate": {
							"type": "timestamp"
						},
						"roleNameArn": {},
						"destinationS3BucketName": {},
						"destinationS3Prefix": {},
						"snsTopicArn": {},
						"customerDefinedValues": {
							"shape": "S8"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"dataSetRequestId": {}
					}
				}
			},
			"StartSupportDataExport": {
				"input": {
					"type": "structure",
					"required": [
						"dataSetType",
						"fromDate",
						"roleNameArn",
						"destinationS3BucketName",
						"snsTopicArn"
					],
					"members": {
						"dataSetType": {},
						"fromDate": {
							"type": "timestamp"
						},
						"roleNameArn": {},
						"destinationS3BucketName": {},
						"destinationS3Prefix": {},
						"snsTopicArn": {},
						"customerDefinedValues": {
							"shape": "S8"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"dataSetRequestId": {}
					}
				}
			}
		},
		"shapes": {
			"S8": {
				"type": "map",
				"key": {},
				"value": {}
			}
		}
	};

/***/ },
/* 409 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['marketplacemetering'] = {};
	AWS.MarketplaceMetering = Service.defineService('marketplacemetering', ['2016-01-14']);
	Object.defineProperty(apiLoader.services['marketplacemetering'], '2016-01-14', {
	  get: function get() {
	    var model = __webpack_require__(410);
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.MarketplaceMetering;


/***/ },
/* 410 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2016-01-14",
			"endpointPrefix": "metering.marketplace",
			"jsonVersion": "1.1",
			"protocol": "json",
			"serviceFullName": "AWSMarketplace Metering",
			"signatureVersion": "v4",
			"signingName": "aws-marketplace",
			"targetPrefix": "AWSMPMeteringService"
		},
		"operations": {
			"MeterUsage": {
				"input": {
					"type": "structure",
					"required": [
						"ProductCode",
						"Timestamp",
						"UsageDimension",
						"UsageQuantity",
						"DryRun"
					],
					"members": {
						"ProductCode": {},
						"Timestamp": {
							"type": "timestamp"
						},
						"UsageDimension": {},
						"UsageQuantity": {
							"type": "integer"
						},
						"DryRun": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"MeteringRecordId": {}
					}
				}
			}
		},
		"shapes": {}
	};

/***/ },
/* 411 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['mobileanalytics'] = {};
	AWS.MobileAnalytics = Service.defineService('mobileanalytics', ['2014-06-05']);
	Object.defineProperty(apiLoader.services['mobileanalytics'], '2014-06-05', {
	  get: function get() {
	    var model = __webpack_require__(412);
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.MobileAnalytics;


/***/ },
/* 412 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2014-06-05",
			"endpointPrefix": "mobileanalytics",
			"serviceFullName": "Amazon Mobile Analytics",
			"signatureVersion": "v4",
			"protocol": "rest-json"
		},
		"operations": {
			"PutEvents": {
				"http": {
					"requestUri": "/2014-06-05/events",
					"responseCode": 202
				},
				"input": {
					"type": "structure",
					"required": [
						"events",
						"clientContext"
					],
					"members": {
						"events": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"eventType",
									"timestamp"
								],
								"members": {
									"eventType": {},
									"timestamp": {},
									"session": {
										"type": "structure",
										"members": {
											"id": {},
											"duration": {
												"type": "long"
											},
											"startTimestamp": {},
											"stopTimestamp": {}
										}
									},
									"version": {},
									"attributes": {
										"type": "map",
										"key": {},
										"value": {}
									},
									"metrics": {
										"type": "map",
										"key": {},
										"value": {
											"type": "double"
										}
									}
								}
							}
						},
						"clientContext": {
							"location": "header",
							"locationName": "x-amz-Client-Context"
						},
						"clientContextEncoding": {
							"location": "header",
							"locationName": "x-amz-Client-Context-Encoding"
						}
					}
				}
			}
		},
		"shapes": {}
	};

/***/ },
/* 413 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['opsworks'] = {};
	AWS.OpsWorks = Service.defineService('opsworks', ['2013-02-18']);
	Object.defineProperty(apiLoader.services['opsworks'], '2013-02-18', {
	  get: function get() {
	    var model = __webpack_require__(414);
	    model.paginators = __webpack_require__(415).pagination;
	    model.waiters = __webpack_require__(416).waiters;
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.OpsWorks;


/***/ },
/* 414 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2013-02-18",
			"endpointPrefix": "opsworks",
			"jsonVersion": "1.1",
			"protocol": "json",
			"serviceFullName": "AWS OpsWorks",
			"signatureVersion": "v4",
			"targetPrefix": "OpsWorks_20130218"
		},
		"operations": {
			"AssignInstance": {
				"input": {
					"type": "structure",
					"required": [
						"InstanceId",
						"LayerIds"
					],
					"members": {
						"InstanceId": {},
						"LayerIds": {
							"shape": "S3"
						}
					}
				}
			},
			"AssignVolume": {
				"input": {
					"type": "structure",
					"required": [
						"VolumeId"
					],
					"members": {
						"VolumeId": {},
						"InstanceId": {}
					}
				}
			},
			"AssociateElasticIp": {
				"input": {
					"type": "structure",
					"required": [
						"ElasticIp"
					],
					"members": {
						"ElasticIp": {},
						"InstanceId": {}
					}
				}
			},
			"AttachElasticLoadBalancer": {
				"input": {
					"type": "structure",
					"required": [
						"ElasticLoadBalancerName",
						"LayerId"
					],
					"members": {
						"ElasticLoadBalancerName": {},
						"LayerId": {}
					}
				}
			},
			"CloneStack": {
				"input": {
					"type": "structure",
					"required": [
						"SourceStackId",
						"ServiceRoleArn"
					],
					"members": {
						"SourceStackId": {},
						"Name": {},
						"Region": {},
						"VpcId": {},
						"Attributes": {
							"shape": "S8"
						},
						"ServiceRoleArn": {},
						"DefaultInstanceProfileArn": {},
						"DefaultOs": {},
						"HostnameTheme": {},
						"DefaultAvailabilityZone": {},
						"DefaultSubnetId": {},
						"CustomJson": {},
						"ConfigurationManager": {
							"shape": "Sa"
						},
						"ChefConfiguration": {
							"shape": "Sb"
						},
						"UseCustomCookbooks": {
							"type": "boolean"
						},
						"UseOpsworksSecurityGroups": {
							"type": "boolean"
						},
						"CustomCookbooksSource": {
							"shape": "Sd"
						},
						"DefaultSshKeyName": {},
						"ClonePermissions": {
							"type": "boolean"
						},
						"CloneAppIds": {
							"shape": "S3"
						},
						"DefaultRootDeviceType": {},
						"AgentVersion": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"StackId": {}
					}
				}
			},
			"CreateApp": {
				"input": {
					"type": "structure",
					"required": [
						"StackId",
						"Name",
						"Type"
					],
					"members": {
						"StackId": {},
						"Shortname": {},
						"Name": {},
						"Description": {},
						"DataSources": {
							"shape": "Si"
						},
						"Type": {},
						"AppSource": {
							"shape": "Sd"
						},
						"Domains": {
							"shape": "S3"
						},
						"EnableSsl": {
							"type": "boolean"
						},
						"SslConfiguration": {
							"shape": "Sl"
						},
						"Attributes": {
							"shape": "Sm"
						},
						"Environment": {
							"shape": "So"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"AppId": {}
					}
				}
			},
			"CreateDeployment": {
				"input": {
					"type": "structure",
					"required": [
						"StackId",
						"Command"
					],
					"members": {
						"StackId": {},
						"AppId": {},
						"InstanceIds": {
							"shape": "S3"
						},
						"LayerIds": {
							"shape": "S3"
						},
						"Command": {
							"shape": "Ss"
						},
						"Comment": {},
						"CustomJson": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"DeploymentId": {}
					}
				}
			},
			"CreateInstance": {
				"input": {
					"type": "structure",
					"required": [
						"StackId",
						"LayerIds",
						"InstanceType"
					],
					"members": {
						"StackId": {},
						"LayerIds": {
							"shape": "S3"
						},
						"InstanceType": {},
						"AutoScalingType": {},
						"Hostname": {},
						"Os": {},
						"AmiId": {},
						"SshKeyName": {},
						"AvailabilityZone": {},
						"VirtualizationType": {},
						"SubnetId": {},
						"Architecture": {},
						"RootDeviceType": {},
						"BlockDeviceMappings": {
							"shape": "Sz"
						},
						"InstallUpdatesOnBoot": {
							"type": "boolean"
						},
						"EbsOptimized": {
							"type": "boolean"
						},
						"AgentVersion": {},
						"Tenancy": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"InstanceId": {}
					}
				}
			},
			"CreateLayer": {
				"input": {
					"type": "structure",
					"required": [
						"StackId",
						"Type",
						"Name",
						"Shortname"
					],
					"members": {
						"StackId": {},
						"Type": {},
						"Name": {},
						"Shortname": {},
						"Attributes": {
							"shape": "S17"
						},
						"CustomInstanceProfileArn": {},
						"CustomJson": {},
						"CustomSecurityGroupIds": {
							"shape": "S3"
						},
						"Packages": {
							"shape": "S3"
						},
						"VolumeConfigurations": {
							"shape": "S19"
						},
						"EnableAutoHealing": {
							"type": "boolean"
						},
						"AutoAssignElasticIps": {
							"type": "boolean"
						},
						"AutoAssignPublicIps": {
							"type": "boolean"
						},
						"CustomRecipes": {
							"shape": "S1b"
						},
						"InstallUpdatesOnBoot": {
							"type": "boolean"
						},
						"UseEbsOptimizedInstances": {
							"type": "boolean"
						},
						"LifecycleEventConfiguration": {
							"shape": "S1c"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"LayerId": {}
					}
				}
			},
			"CreateStack": {
				"input": {
					"type": "structure",
					"required": [
						"Name",
						"Region",
						"ServiceRoleArn",
						"DefaultInstanceProfileArn"
					],
					"members": {
						"Name": {},
						"Region": {},
						"VpcId": {},
						"Attributes": {
							"shape": "S8"
						},
						"ServiceRoleArn": {},
						"DefaultInstanceProfileArn": {},
						"DefaultOs": {},
						"HostnameTheme": {},
						"DefaultAvailabilityZone": {},
						"DefaultSubnetId": {},
						"CustomJson": {},
						"ConfigurationManager": {
							"shape": "Sa"
						},
						"ChefConfiguration": {
							"shape": "Sb"
						},
						"UseCustomCookbooks": {
							"type": "boolean"
						},
						"UseOpsworksSecurityGroups": {
							"type": "boolean"
						},
						"CustomCookbooksSource": {
							"shape": "Sd"
						},
						"DefaultSshKeyName": {},
						"DefaultRootDeviceType": {},
						"AgentVersion": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"StackId": {}
					}
				}
			},
			"CreateUserProfile": {
				"input": {
					"type": "structure",
					"required": [
						"IamUserArn"
					],
					"members": {
						"IamUserArn": {},
						"SshUsername": {},
						"SshPublicKey": {},
						"AllowSelfManagement": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"IamUserArn": {}
					}
				}
			},
			"DeleteApp": {
				"input": {
					"type": "structure",
					"required": [
						"AppId"
					],
					"members": {
						"AppId": {}
					}
				}
			},
			"DeleteInstance": {
				"input": {
					"type": "structure",
					"required": [
						"InstanceId"
					],
					"members": {
						"InstanceId": {},
						"DeleteElasticIp": {
							"type": "boolean"
						},
						"DeleteVolumes": {
							"type": "boolean"
						}
					}
				}
			},
			"DeleteLayer": {
				"input": {
					"type": "structure",
					"required": [
						"LayerId"
					],
					"members": {
						"LayerId": {}
					}
				}
			},
			"DeleteStack": {
				"input": {
					"type": "structure",
					"required": [
						"StackId"
					],
					"members": {
						"StackId": {}
					}
				}
			},
			"DeleteUserProfile": {
				"input": {
					"type": "structure",
					"required": [
						"IamUserArn"
					],
					"members": {
						"IamUserArn": {}
					}
				}
			},
			"DeregisterEcsCluster": {
				"input": {
					"type": "structure",
					"required": [
						"EcsClusterArn"
					],
					"members": {
						"EcsClusterArn": {}
					}
				}
			},
			"DeregisterElasticIp": {
				"input": {
					"type": "structure",
					"required": [
						"ElasticIp"
					],
					"members": {
						"ElasticIp": {}
					}
				}
			},
			"DeregisterInstance": {
				"input": {
					"type": "structure",
					"required": [
						"InstanceId"
					],
					"members": {
						"InstanceId": {}
					}
				}
			},
			"DeregisterRdsDbInstance": {
				"input": {
					"type": "structure",
					"required": [
						"RdsDbInstanceArn"
					],
					"members": {
						"RdsDbInstanceArn": {}
					}
				}
			},
			"DeregisterVolume": {
				"input": {
					"type": "structure",
					"required": [
						"VolumeId"
					],
					"members": {
						"VolumeId": {}
					}
				}
			},
			"DescribeAgentVersions": {
				"input": {
					"type": "structure",
					"members": {
						"StackId": {},
						"ConfigurationManager": {
							"shape": "Sa"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"AgentVersions": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"Version": {},
									"ConfigurationManager": {
										"shape": "Sa"
									}
								}
							}
						}
					}
				}
			},
			"DescribeApps": {
				"input": {
					"type": "structure",
					"members": {
						"StackId": {},
						"AppIds": {
							"shape": "S3"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Apps": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"AppId": {},
									"StackId": {},
									"Shortname": {},
									"Name": {},
									"Description": {},
									"DataSources": {
										"shape": "Si"
									},
									"Type": {},
									"AppSource": {
										"shape": "Sd"
									},
									"Domains": {
										"shape": "S3"
									},
									"EnableSsl": {
										"type": "boolean"
									},
									"SslConfiguration": {
										"shape": "Sl"
									},
									"Attributes": {
										"shape": "Sm"
									},
									"CreatedAt": {},
									"Environment": {
										"shape": "So"
									}
								}
							}
						}
					}
				}
			},
			"DescribeCommands": {
				"input": {
					"type": "structure",
					"members": {
						"DeploymentId": {},
						"InstanceId": {},
						"CommandIds": {
							"shape": "S3"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Commands": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"CommandId": {},
									"InstanceId": {},
									"DeploymentId": {},
									"CreatedAt": {},
									"AcknowledgedAt": {},
									"CompletedAt": {},
									"Status": {},
									"ExitCode": {
										"type": "integer"
									},
									"LogUrl": {},
									"Type": {}
								}
							}
						}
					}
				}
			},
			"DescribeDeployments": {
				"input": {
					"type": "structure",
					"members": {
						"StackId": {},
						"AppId": {},
						"DeploymentIds": {
							"shape": "S3"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Deployments": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"DeploymentId": {},
									"StackId": {},
									"AppId": {},
									"CreatedAt": {},
									"CompletedAt": {},
									"Duration": {
										"type": "integer"
									},
									"IamUserArn": {},
									"Comment": {},
									"Command": {
										"shape": "Ss"
									},
									"Status": {},
									"CustomJson": {},
									"InstanceIds": {
										"shape": "S3"
									}
								}
							}
						}
					}
				}
			},
			"DescribeEcsClusters": {
				"input": {
					"type": "structure",
					"members": {
						"EcsClusterArns": {
							"shape": "S3"
						},
						"StackId": {},
						"NextToken": {},
						"MaxResults": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"EcsClusters": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"EcsClusterArn": {},
									"EcsClusterName": {},
									"StackId": {},
									"RegisteredAt": {}
								}
							}
						},
						"NextToken": {}
					}
				}
			},
			"DescribeElasticIps": {
				"input": {
					"type": "structure",
					"members": {
						"InstanceId": {},
						"StackId": {},
						"Ips": {
							"shape": "S3"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ElasticIps": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"Ip": {},
									"Name": {},
									"Domain": {},
									"Region": {},
									"InstanceId": {}
								}
							}
						}
					}
				}
			},
			"DescribeElasticLoadBalancers": {
				"input": {
					"type": "structure",
					"members": {
						"StackId": {},
						"LayerIds": {
							"shape": "S3"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ElasticLoadBalancers": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"ElasticLoadBalancerName": {},
									"Region": {},
									"DnsName": {},
									"StackId": {},
									"LayerId": {},
									"VpcId": {},
									"AvailabilityZones": {
										"shape": "S3"
									},
									"SubnetIds": {
										"shape": "S3"
									},
									"Ec2InstanceIds": {
										"shape": "S3"
									}
								}
							}
						}
					}
				}
			},
			"DescribeInstances": {
				"input": {
					"type": "structure",
					"members": {
						"StackId": {},
						"LayerId": {},
						"InstanceIds": {
							"shape": "S3"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Instances": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"AgentVersion": {},
									"AmiId": {},
									"Architecture": {},
									"AutoScalingType": {},
									"AvailabilityZone": {},
									"BlockDeviceMappings": {
										"shape": "Sz"
									},
									"CreatedAt": {},
									"EbsOptimized": {
										"type": "boolean"
									},
									"Ec2InstanceId": {},
									"EcsClusterArn": {},
									"EcsContainerInstanceArn": {},
									"ElasticIp": {},
									"Hostname": {},
									"InfrastructureClass": {},
									"InstallUpdatesOnBoot": {
										"type": "boolean"
									},
									"InstanceId": {},
									"InstanceProfileArn": {},
									"InstanceType": {},
									"LastServiceErrorId": {},
									"LayerIds": {
										"shape": "S3"
									},
									"Os": {},
									"Platform": {},
									"PrivateDns": {},
									"PrivateIp": {},
									"PublicDns": {},
									"PublicIp": {},
									"RegisteredBy": {},
									"ReportedAgentVersion": {},
									"ReportedOs": {
										"type": "structure",
										"members": {
											"Family": {},
											"Name": {},
											"Version": {}
										}
									},
									"RootDeviceType": {},
									"RootDeviceVolumeId": {},
									"SecurityGroupIds": {
										"shape": "S3"
									},
									"SshHostDsaKeyFingerprint": {},
									"SshHostRsaKeyFingerprint": {},
									"SshKeyName": {},
									"StackId": {},
									"Status": {},
									"SubnetId": {},
									"Tenancy": {},
									"VirtualizationType": {}
								}
							}
						}
					}
				}
			},
			"DescribeLayers": {
				"input": {
					"type": "structure",
					"members": {
						"StackId": {},
						"LayerIds": {
							"shape": "S3"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Layers": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"StackId": {},
									"LayerId": {},
									"Type": {},
									"Name": {},
									"Shortname": {},
									"Attributes": {
										"shape": "S17"
									},
									"CustomInstanceProfileArn": {},
									"CustomJson": {},
									"CustomSecurityGroupIds": {
										"shape": "S3"
									},
									"DefaultSecurityGroupNames": {
										"shape": "S3"
									},
									"Packages": {
										"shape": "S3"
									},
									"VolumeConfigurations": {
										"shape": "S19"
									},
									"EnableAutoHealing": {
										"type": "boolean"
									},
									"AutoAssignElasticIps": {
										"type": "boolean"
									},
									"AutoAssignPublicIps": {
										"type": "boolean"
									},
									"DefaultRecipes": {
										"shape": "S1b"
									},
									"CustomRecipes": {
										"shape": "S1b"
									},
									"CreatedAt": {},
									"InstallUpdatesOnBoot": {
										"type": "boolean"
									},
									"UseEbsOptimizedInstances": {
										"type": "boolean"
									},
									"LifecycleEventConfiguration": {
										"shape": "S1c"
									}
								}
							}
						}
					}
				}
			},
			"DescribeLoadBasedAutoScaling": {
				"input": {
					"type": "structure",
					"required": [
						"LayerIds"
					],
					"members": {
						"LayerIds": {
							"shape": "S3"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"LoadBasedAutoScalingConfigurations": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"LayerId": {},
									"Enable": {
										"type": "boolean"
									},
									"UpScaling": {
										"shape": "S30"
									},
									"DownScaling": {
										"shape": "S30"
									}
								}
							}
						}
					}
				}
			},
			"DescribeMyUserProfile": {
				"output": {
					"type": "structure",
					"members": {
						"UserProfile": {
							"type": "structure",
							"members": {
								"IamUserArn": {},
								"Name": {},
								"SshUsername": {},
								"SshPublicKey": {}
							}
						}
					}
				}
			},
			"DescribePermissions": {
				"input": {
					"type": "structure",
					"members": {
						"IamUserArn": {},
						"StackId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Permissions": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"StackId": {},
									"IamUserArn": {},
									"AllowSsh": {
										"type": "boolean"
									},
									"AllowSudo": {
										"type": "boolean"
									},
									"Level": {}
								}
							}
						}
					}
				}
			},
			"DescribeRaidArrays": {
				"input": {
					"type": "structure",
					"members": {
						"InstanceId": {},
						"StackId": {},
						"RaidArrayIds": {
							"shape": "S3"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"RaidArrays": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"RaidArrayId": {},
									"InstanceId": {},
									"Name": {},
									"RaidLevel": {
										"type": "integer"
									},
									"NumberOfDisks": {
										"type": "integer"
									},
									"Size": {
										"type": "integer"
									},
									"Device": {},
									"MountPoint": {},
									"AvailabilityZone": {},
									"CreatedAt": {},
									"StackId": {},
									"VolumeType": {},
									"Iops": {
										"type": "integer"
									}
								}
							}
						}
					}
				}
			},
			"DescribeRdsDbInstances": {
				"input": {
					"type": "structure",
					"required": [
						"StackId"
					],
					"members": {
						"StackId": {},
						"RdsDbInstanceArns": {
							"shape": "S3"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"RdsDbInstances": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"RdsDbInstanceArn": {},
									"DbInstanceIdentifier": {},
									"DbUser": {},
									"DbPassword": {},
									"Region": {},
									"Address": {},
									"Engine": {},
									"StackId": {},
									"MissingOnRds": {
										"type": "boolean"
									}
								}
							}
						}
					}
				}
			},
			"DescribeServiceErrors": {
				"input": {
					"type": "structure",
					"members": {
						"StackId": {},
						"InstanceId": {},
						"ServiceErrorIds": {
							"shape": "S3"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ServiceErrors": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"ServiceErrorId": {},
									"StackId": {},
									"InstanceId": {},
									"Type": {},
									"Message": {},
									"CreatedAt": {}
								}
							}
						}
					}
				}
			},
			"DescribeStackProvisioningParameters": {
				"input": {
					"type": "structure",
					"required": [
						"StackId"
					],
					"members": {
						"StackId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"AgentInstallerUrl": {},
						"Parameters": {
							"type": "map",
							"key": {},
							"value": {}
						}
					}
				}
			},
			"DescribeStackSummary": {
				"input": {
					"type": "structure",
					"required": [
						"StackId"
					],
					"members": {
						"StackId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"StackSummary": {
							"type": "structure",
							"members": {
								"StackId": {},
								"Name": {},
								"Arn": {},
								"LayersCount": {
									"type": "integer"
								},
								"AppsCount": {
									"type": "integer"
								},
								"InstancesCount": {
									"type": "structure",
									"members": {
										"Assigning": {
											"type": "integer"
										},
										"Booting": {
											"type": "integer"
										},
										"ConnectionLost": {
											"type": "integer"
										},
										"Deregistering": {
											"type": "integer"
										},
										"Online": {
											"type": "integer"
										},
										"Pending": {
											"type": "integer"
										},
										"Rebooting": {
											"type": "integer"
										},
										"Registered": {
											"type": "integer"
										},
										"Registering": {
											"type": "integer"
										},
										"Requested": {
											"type": "integer"
										},
										"RunningSetup": {
											"type": "integer"
										},
										"SetupFailed": {
											"type": "integer"
										},
										"ShuttingDown": {
											"type": "integer"
										},
										"StartFailed": {
											"type": "integer"
										},
										"Stopped": {
											"type": "integer"
										},
										"Stopping": {
											"type": "integer"
										},
										"Terminated": {
											"type": "integer"
										},
										"Terminating": {
											"type": "integer"
										},
										"Unassigning": {
											"type": "integer"
										}
									}
								}
							}
						}
					}
				}
			},
			"DescribeStacks": {
				"input": {
					"type": "structure",
					"members": {
						"StackIds": {
							"shape": "S3"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Stacks": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"StackId": {},
									"Name": {},
									"Arn": {},
									"Region": {},
									"VpcId": {},
									"Attributes": {
										"shape": "S8"
									},
									"ServiceRoleArn": {},
									"DefaultInstanceProfileArn": {},
									"DefaultOs": {},
									"HostnameTheme": {},
									"DefaultAvailabilityZone": {},
									"DefaultSubnetId": {},
									"CustomJson": {},
									"ConfigurationManager": {
										"shape": "Sa"
									},
									"ChefConfiguration": {
										"shape": "Sb"
									},
									"UseCustomCookbooks": {
										"type": "boolean"
									},
									"UseOpsworksSecurityGroups": {
										"type": "boolean"
									},
									"CustomCookbooksSource": {
										"shape": "Sd"
									},
									"DefaultSshKeyName": {},
									"CreatedAt": {},
									"DefaultRootDeviceType": {},
									"AgentVersion": {}
								}
							}
						}
					}
				}
			},
			"DescribeTimeBasedAutoScaling": {
				"input": {
					"type": "structure",
					"required": [
						"InstanceIds"
					],
					"members": {
						"InstanceIds": {
							"shape": "S3"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"TimeBasedAutoScalingConfigurations": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"InstanceId": {},
									"AutoScalingSchedule": {
										"shape": "S40"
									}
								}
							}
						}
					}
				}
			},
			"DescribeUserProfiles": {
				"input": {
					"type": "structure",
					"members": {
						"IamUserArns": {
							"shape": "S3"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"UserProfiles": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"IamUserArn": {},
									"Name": {},
									"SshUsername": {},
									"SshPublicKey": {},
									"AllowSelfManagement": {
										"type": "boolean"
									}
								}
							}
						}
					}
				}
			},
			"DescribeVolumes": {
				"input": {
					"type": "structure",
					"members": {
						"InstanceId": {},
						"StackId": {},
						"RaidArrayId": {},
						"VolumeIds": {
							"shape": "S3"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Volumes": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"VolumeId": {},
									"Ec2VolumeId": {},
									"Name": {},
									"RaidArrayId": {},
									"InstanceId": {},
									"Status": {},
									"Size": {
										"type": "integer"
									},
									"Device": {},
									"MountPoint": {},
									"Region": {},
									"AvailabilityZone": {},
									"VolumeType": {},
									"Iops": {
										"type": "integer"
									}
								}
							}
						}
					}
				}
			},
			"DetachElasticLoadBalancer": {
				"input": {
					"type": "structure",
					"required": [
						"ElasticLoadBalancerName",
						"LayerId"
					],
					"members": {
						"ElasticLoadBalancerName": {},
						"LayerId": {}
					}
				}
			},
			"DisassociateElasticIp": {
				"input": {
					"type": "structure",
					"required": [
						"ElasticIp"
					],
					"members": {
						"ElasticIp": {}
					}
				}
			},
			"GetHostnameSuggestion": {
				"input": {
					"type": "structure",
					"required": [
						"LayerId"
					],
					"members": {
						"LayerId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"LayerId": {},
						"Hostname": {}
					}
				}
			},
			"GrantAccess": {
				"input": {
					"type": "structure",
					"required": [
						"InstanceId"
					],
					"members": {
						"InstanceId": {},
						"ValidForInMinutes": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"TemporaryCredential": {
							"type": "structure",
							"members": {
								"Username": {},
								"Password": {},
								"ValidForInMinutes": {
									"type": "integer"
								},
								"InstanceId": {}
							}
						}
					}
				}
			},
			"RebootInstance": {
				"input": {
					"type": "structure",
					"required": [
						"InstanceId"
					],
					"members": {
						"InstanceId": {}
					}
				}
			},
			"RegisterEcsCluster": {
				"input": {
					"type": "structure",
					"required": [
						"EcsClusterArn",
						"StackId"
					],
					"members": {
						"EcsClusterArn": {},
						"StackId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"EcsClusterArn": {}
					}
				}
			},
			"RegisterElasticIp": {
				"input": {
					"type": "structure",
					"required": [
						"ElasticIp",
						"StackId"
					],
					"members": {
						"ElasticIp": {},
						"StackId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ElasticIp": {}
					}
				}
			},
			"RegisterInstance": {
				"input": {
					"type": "structure",
					"required": [
						"StackId"
					],
					"members": {
						"StackId": {},
						"Hostname": {},
						"PublicIp": {},
						"PrivateIp": {},
						"RsaPublicKey": {},
						"RsaPublicKeyFingerprint": {},
						"InstanceIdentity": {
							"type": "structure",
							"members": {
								"Document": {},
								"Signature": {}
							}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"InstanceId": {}
					}
				}
			},
			"RegisterRdsDbInstance": {
				"input": {
					"type": "structure",
					"required": [
						"StackId",
						"RdsDbInstanceArn",
						"DbUser",
						"DbPassword"
					],
					"members": {
						"StackId": {},
						"RdsDbInstanceArn": {},
						"DbUser": {},
						"DbPassword": {}
					}
				}
			},
			"RegisterVolume": {
				"input": {
					"type": "structure",
					"required": [
						"StackId"
					],
					"members": {
						"Ec2VolumeId": {},
						"StackId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"VolumeId": {}
					}
				}
			},
			"SetLoadBasedAutoScaling": {
				"input": {
					"type": "structure",
					"required": [
						"LayerId"
					],
					"members": {
						"LayerId": {},
						"Enable": {
							"type": "boolean"
						},
						"UpScaling": {
							"shape": "S30"
						},
						"DownScaling": {
							"shape": "S30"
						}
					}
				}
			},
			"SetPermission": {
				"input": {
					"type": "structure",
					"required": [
						"StackId",
						"IamUserArn"
					],
					"members": {
						"StackId": {},
						"IamUserArn": {},
						"AllowSsh": {
							"type": "boolean"
						},
						"AllowSudo": {
							"type": "boolean"
						},
						"Level": {}
					}
				}
			},
			"SetTimeBasedAutoScaling": {
				"input": {
					"type": "structure",
					"required": [
						"InstanceId"
					],
					"members": {
						"InstanceId": {},
						"AutoScalingSchedule": {
							"shape": "S40"
						}
					}
				}
			},
			"StartInstance": {
				"input": {
					"type": "structure",
					"required": [
						"InstanceId"
					],
					"members": {
						"InstanceId": {}
					}
				}
			},
			"StartStack": {
				"input": {
					"type": "structure",
					"required": [
						"StackId"
					],
					"members": {
						"StackId": {}
					}
				}
			},
			"StopInstance": {
				"input": {
					"type": "structure",
					"required": [
						"InstanceId"
					],
					"members": {
						"InstanceId": {}
					}
				}
			},
			"StopStack": {
				"input": {
					"type": "structure",
					"required": [
						"StackId"
					],
					"members": {
						"StackId": {}
					}
				}
			},
			"UnassignInstance": {
				"input": {
					"type": "structure",
					"required": [
						"InstanceId"
					],
					"members": {
						"InstanceId": {}
					}
				}
			},
			"UnassignVolume": {
				"input": {
					"type": "structure",
					"required": [
						"VolumeId"
					],
					"members": {
						"VolumeId": {}
					}
				}
			},
			"UpdateApp": {
				"input": {
					"type": "structure",
					"required": [
						"AppId"
					],
					"members": {
						"AppId": {},
						"Name": {},
						"Description": {},
						"DataSources": {
							"shape": "Si"
						},
						"Type": {},
						"AppSource": {
							"shape": "Sd"
						},
						"Domains": {
							"shape": "S3"
						},
						"EnableSsl": {
							"type": "boolean"
						},
						"SslConfiguration": {
							"shape": "Sl"
						},
						"Attributes": {
							"shape": "Sm"
						},
						"Environment": {
							"shape": "So"
						}
					}
				}
			},
			"UpdateElasticIp": {
				"input": {
					"type": "structure",
					"required": [
						"ElasticIp"
					],
					"members": {
						"ElasticIp": {},
						"Name": {}
					}
				}
			},
			"UpdateInstance": {
				"input": {
					"type": "structure",
					"required": [
						"InstanceId"
					],
					"members": {
						"InstanceId": {},
						"LayerIds": {
							"shape": "S3"
						},
						"InstanceType": {},
						"AutoScalingType": {},
						"Hostname": {},
						"Os": {},
						"AmiId": {},
						"SshKeyName": {},
						"Architecture": {},
						"InstallUpdatesOnBoot": {
							"type": "boolean"
						},
						"EbsOptimized": {
							"type": "boolean"
						},
						"AgentVersion": {}
					}
				}
			},
			"UpdateLayer": {
				"input": {
					"type": "structure",
					"required": [
						"LayerId"
					],
					"members": {
						"LayerId": {},
						"Name": {},
						"Shortname": {},
						"Attributes": {
							"shape": "S17"
						},
						"CustomInstanceProfileArn": {},
						"CustomJson": {},
						"CustomSecurityGroupIds": {
							"shape": "S3"
						},
						"Packages": {
							"shape": "S3"
						},
						"VolumeConfigurations": {
							"shape": "S19"
						},
						"EnableAutoHealing": {
							"type": "boolean"
						},
						"AutoAssignElasticIps": {
							"type": "boolean"
						},
						"AutoAssignPublicIps": {
							"type": "boolean"
						},
						"CustomRecipes": {
							"shape": "S1b"
						},
						"InstallUpdatesOnBoot": {
							"type": "boolean"
						},
						"UseEbsOptimizedInstances": {
							"type": "boolean"
						},
						"LifecycleEventConfiguration": {
							"shape": "S1c"
						}
					}
				}
			},
			"UpdateMyUserProfile": {
				"input": {
					"type": "structure",
					"members": {
						"SshPublicKey": {}
					}
				}
			},
			"UpdateRdsDbInstance": {
				"input": {
					"type": "structure",
					"required": [
						"RdsDbInstanceArn"
					],
					"members": {
						"RdsDbInstanceArn": {},
						"DbUser": {},
						"DbPassword": {}
					}
				}
			},
			"UpdateStack": {
				"input": {
					"type": "structure",
					"required": [
						"StackId"
					],
					"members": {
						"StackId": {},
						"Name": {},
						"Attributes": {
							"shape": "S8"
						},
						"ServiceRoleArn": {},
						"DefaultInstanceProfileArn": {},
						"DefaultOs": {},
						"HostnameTheme": {},
						"DefaultAvailabilityZone": {},
						"DefaultSubnetId": {},
						"CustomJson": {},
						"ConfigurationManager": {
							"shape": "Sa"
						},
						"ChefConfiguration": {
							"shape": "Sb"
						},
						"UseCustomCookbooks": {
							"type": "boolean"
						},
						"CustomCookbooksSource": {
							"shape": "Sd"
						},
						"DefaultSshKeyName": {},
						"DefaultRootDeviceType": {},
						"UseOpsworksSecurityGroups": {
							"type": "boolean"
						},
						"AgentVersion": {}
					}
				}
			},
			"UpdateUserProfile": {
				"input": {
					"type": "structure",
					"required": [
						"IamUserArn"
					],
					"members": {
						"IamUserArn": {},
						"SshUsername": {},
						"SshPublicKey": {},
						"AllowSelfManagement": {
							"type": "boolean"
						}
					}
				}
			},
			"UpdateVolume": {
				"input": {
					"type": "structure",
					"required": [
						"VolumeId"
					],
					"members": {
						"VolumeId": {},
						"Name": {},
						"MountPoint": {}
					}
				}
			}
		},
		"shapes": {
			"S3": {
				"type": "list",
				"member": {}
			},
			"S8": {
				"type": "map",
				"key": {},
				"value": {}
			},
			"Sa": {
				"type": "structure",
				"members": {
					"Name": {},
					"Version": {}
				}
			},
			"Sb": {
				"type": "structure",
				"members": {
					"ManageBerkshelf": {
						"type": "boolean"
					},
					"BerkshelfVersion": {}
				}
			},
			"Sd": {
				"type": "structure",
				"members": {
					"Type": {},
					"Url": {},
					"Username": {},
					"Password": {},
					"SshKey": {},
					"Revision": {}
				}
			},
			"Si": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"Type": {},
						"Arn": {},
						"DatabaseName": {}
					}
				}
			},
			"Sl": {
				"type": "structure",
				"required": [
					"Certificate",
					"PrivateKey"
				],
				"members": {
					"Certificate": {},
					"PrivateKey": {},
					"Chain": {}
				}
			},
			"Sm": {
				"type": "map",
				"key": {},
				"value": {}
			},
			"So": {
				"type": "list",
				"member": {
					"type": "structure",
					"required": [
						"Key",
						"Value"
					],
					"members": {
						"Key": {},
						"Value": {},
						"Secure": {
							"type": "boolean"
						}
					}
				}
			},
			"Ss": {
				"type": "structure",
				"required": [
					"Name"
				],
				"members": {
					"Name": {},
					"Args": {
						"type": "map",
						"key": {},
						"value": {
							"shape": "S3"
						}
					}
				}
			},
			"Sz": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"DeviceName": {},
						"NoDevice": {},
						"VirtualName": {},
						"Ebs": {
							"type": "structure",
							"members": {
								"SnapshotId": {},
								"Iops": {
									"type": "integer"
								},
								"VolumeSize": {
									"type": "integer"
								},
								"VolumeType": {},
								"DeleteOnTermination": {
									"type": "boolean"
								}
							}
						}
					}
				}
			},
			"S17": {
				"type": "map",
				"key": {},
				"value": {}
			},
			"S19": {
				"type": "list",
				"member": {
					"type": "structure",
					"required": [
						"MountPoint",
						"NumberOfDisks",
						"Size"
					],
					"members": {
						"MountPoint": {},
						"RaidLevel": {
							"type": "integer"
						},
						"NumberOfDisks": {
							"type": "integer"
						},
						"Size": {
							"type": "integer"
						},
						"VolumeType": {},
						"Iops": {
							"type": "integer"
						}
					}
				}
			},
			"S1b": {
				"type": "structure",
				"members": {
					"Setup": {
						"shape": "S3"
					},
					"Configure": {
						"shape": "S3"
					},
					"Deploy": {
						"shape": "S3"
					},
					"Undeploy": {
						"shape": "S3"
					},
					"Shutdown": {
						"shape": "S3"
					}
				}
			},
			"S1c": {
				"type": "structure",
				"members": {
					"Shutdown": {
						"type": "structure",
						"members": {
							"ExecutionTimeout": {
								"type": "integer"
							},
							"DelayUntilElbConnectionsDrained": {
								"type": "boolean"
							}
						}
					}
				}
			},
			"S30": {
				"type": "structure",
				"members": {
					"InstanceCount": {
						"type": "integer"
					},
					"ThresholdsWaitTime": {
						"type": "integer"
					},
					"IgnoreMetricsTime": {
						"type": "integer"
					},
					"CpuThreshold": {
						"type": "double"
					},
					"MemoryThreshold": {
						"type": "double"
					},
					"LoadThreshold": {
						"type": "double"
					},
					"Alarms": {
						"shape": "S3"
					}
				}
			},
			"S40": {
				"type": "structure",
				"members": {
					"Monday": {
						"shape": "S41"
					},
					"Tuesday": {
						"shape": "S41"
					},
					"Wednesday": {
						"shape": "S41"
					},
					"Thursday": {
						"shape": "S41"
					},
					"Friday": {
						"shape": "S41"
					},
					"Saturday": {
						"shape": "S41"
					},
					"Sunday": {
						"shape": "S41"
					}
				}
			},
			"S41": {
				"type": "map",
				"key": {},
				"value": {}
			}
		}
	};

/***/ },
/* 415 */
/***/ function(module, exports) {

	module.exports = {
		"pagination": {
			"DescribeApps": {
				"result_key": "Apps"
			},
			"DescribeCommands": {
				"result_key": "Commands"
			},
			"DescribeDeployments": {
				"result_key": "Deployments"
			},
			"DescribeEcsClusters": {
				"input_token": "NextToken",
				"output_token": "NextToken",
				"limit_key": "MaxResults",
				"result_key": "EcsClusters"
			},
			"DescribeElasticIps": {
				"result_key": "ElasticIps"
			},
			"DescribeElasticLoadBalancers": {
				"result_key": "ElasticLoadBalancers"
			},
			"DescribeInstances": {
				"result_key": "Instances"
			},
			"DescribeLayers": {
				"result_key": "Layers"
			},
			"DescribeLoadBasedAutoScaling": {
				"result_key": "LoadBasedAutoScalingConfigurations"
			},
			"DescribePermissions": {
				"result_key": "Permissions"
			},
			"DescribeRaidArrays": {
				"result_key": "RaidArrays"
			},
			"DescribeServiceErrors": {
				"result_key": "ServiceErrors"
			},
			"DescribeStacks": {
				"result_key": "Stacks"
			},
			"DescribeTimeBasedAutoScaling": {
				"result_key": "TimeBasedAutoScalingConfigurations"
			},
			"DescribeUserProfiles": {
				"result_key": "UserProfiles"
			},
			"DescribeVolumes": {
				"result_key": "Volumes"
			}
		}
	};

/***/ },
/* 416 */
/***/ function(module, exports) {

	module.exports = {
		"version": 2,
		"waiters": {
			"AppExists": {
				"delay": 1,
				"operation": "DescribeApps",
				"maxAttempts": 40,
				"acceptors": [
					{
						"expected": 200,
						"matcher": "status",
						"state": "success"
					},
					{
						"matcher": "status",
						"expected": 400,
						"state": "failure"
					}
				]
			},
			"DeploymentSuccessful": {
				"delay": 15,
				"operation": "DescribeDeployments",
				"maxAttempts": 40,
				"description": "Wait until a deployment has completed successfully",
				"acceptors": [
					{
						"expected": "successful",
						"matcher": "pathAll",
						"state": "success",
						"argument": "Deployments[].Status"
					},
					{
						"expected": "failed",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "Deployments[].Status"
					}
				]
			},
			"InstanceOnline": {
				"delay": 15,
				"operation": "DescribeInstances",
				"maxAttempts": 40,
				"description": "Wait until OpsWorks instance is online.",
				"acceptors": [
					{
						"expected": "online",
						"matcher": "pathAll",
						"state": "success",
						"argument": "Instances[].Status"
					},
					{
						"expected": "setup_failed",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "Instances[].Status"
					},
					{
						"expected": "shutting_down",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "Instances[].Status"
					},
					{
						"expected": "start_failed",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "Instances[].Status"
					},
					{
						"expected": "stopped",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "Instances[].Status"
					},
					{
						"expected": "stopping",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "Instances[].Status"
					},
					{
						"expected": "terminating",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "Instances[].Status"
					},
					{
						"expected": "terminated",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "Instances[].Status"
					},
					{
						"expected": "stop_failed",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "Instances[].Status"
					}
				]
			},
			"InstanceRegistered": {
				"delay": 15,
				"operation": "DescribeInstances",
				"maxAttempts": 40,
				"description": "Wait until OpsWorks instance is registered.",
				"acceptors": [
					{
						"expected": "registered",
						"matcher": "pathAll",
						"state": "success",
						"argument": "Instances[].Status"
					},
					{
						"expected": "setup_failed",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "Instances[].Status"
					},
					{
						"expected": "shutting_down",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "Instances[].Status"
					},
					{
						"expected": "stopped",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "Instances[].Status"
					},
					{
						"expected": "stopping",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "Instances[].Status"
					},
					{
						"expected": "terminating",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "Instances[].Status"
					},
					{
						"expected": "terminated",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "Instances[].Status"
					},
					{
						"expected": "stop_failed",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "Instances[].Status"
					}
				]
			},
			"InstanceStopped": {
				"delay": 15,
				"operation": "DescribeInstances",
				"maxAttempts": 40,
				"description": "Wait until OpsWorks instance is stopped.",
				"acceptors": [
					{
						"expected": "stopped",
						"matcher": "pathAll",
						"state": "success",
						"argument": "Instances[].Status"
					},
					{
						"expected": "booting",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "Instances[].Status"
					},
					{
						"expected": "online",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "Instances[].Status"
					},
					{
						"expected": "pending",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "Instances[].Status"
					},
					{
						"expected": "rebooting",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "Instances[].Status"
					},
					{
						"expected": "requested",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "Instances[].Status"
					},
					{
						"expected": "running_setup",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "Instances[].Status"
					},
					{
						"expected": "setup_failed",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "Instances[].Status"
					},
					{
						"expected": "start_failed",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "Instances[].Status"
					},
					{
						"expected": "stop_failed",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "Instances[].Status"
					}
				]
			},
			"InstanceTerminated": {
				"delay": 15,
				"operation": "DescribeInstances",
				"maxAttempts": 40,
				"description": "Wait until OpsWorks instance is terminated.",
				"acceptors": [
					{
						"expected": "terminated",
						"matcher": "pathAll",
						"state": "success",
						"argument": "Instances[].Status"
					},
					{
						"expected": "ResourceNotFoundException",
						"matcher": "error",
						"state": "success"
					},
					{
						"expected": "booting",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "Instances[].Status"
					},
					{
						"expected": "online",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "Instances[].Status"
					},
					{
						"expected": "pending",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "Instances[].Status"
					},
					{
						"expected": "rebooting",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "Instances[].Status"
					},
					{
						"expected": "requested",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "Instances[].Status"
					},
					{
						"expected": "running_setup",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "Instances[].Status"
					},
					{
						"expected": "setup_failed",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "Instances[].Status"
					},
					{
						"expected": "start_failed",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "Instances[].Status"
					}
				]
			}
		}
	};

/***/ },
/* 417 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['rds'] = {};
	AWS.RDS = Service.defineService('rds', ['2013-01-10', '2013-02-12', '2013-09-09', '2014-09-01*', '2014-10-31']);
	Object.defineProperty(apiLoader.services['rds'], '2013-01-10', {
	  get: function get() {
	    var model = __webpack_require__(418);
	    model.paginators = __webpack_require__(419).pagination;
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});
	Object.defineProperty(apiLoader.services['rds'], '2013-02-12', {
	  get: function get() {
	    var model = __webpack_require__(420);
	    model.paginators = __webpack_require__(421).pagination;
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});
	Object.defineProperty(apiLoader.services['rds'], '2013-09-09', {
	  get: function get() {
	    var model = __webpack_require__(422);
	    model.paginators = __webpack_require__(423).pagination;
	    model.waiters = __webpack_require__(424).waiters;
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});
	Object.defineProperty(apiLoader.services['rds'], '2014-10-31', {
	  get: function get() {
	    var model = __webpack_require__(425);
	    model.paginators = __webpack_require__(426).pagination;
	    model.waiters = __webpack_require__(427).waiters;
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.RDS;


/***/ },
/* 418 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2013-01-10",
			"endpointPrefix": "rds",
			"protocol": "query",
			"serviceAbbreviation": "Amazon RDS",
			"serviceFullName": "Amazon Relational Database Service",
			"signatureVersion": "v4",
			"xmlNamespace": "http://rds.amazonaws.com/doc/2013-01-10/"
		},
		"operations": {
			"AddSourceIdentifierToSubscription": {
				"input": {
					"type": "structure",
					"required": [
						"SubscriptionName",
						"SourceIdentifier"
					],
					"members": {
						"SubscriptionName": {},
						"SourceIdentifier": {}
					}
				},
				"output": {
					"resultWrapper": "AddSourceIdentifierToSubscriptionResult",
					"type": "structure",
					"members": {
						"EventSubscription": {
							"shape": "S4"
						}
					}
				}
			},
			"AddTagsToResource": {
				"input": {
					"type": "structure",
					"required": [
						"ResourceName",
						"Tags"
					],
					"members": {
						"ResourceName": {},
						"Tags": {
							"shape": "S9"
						}
					}
				}
			},
			"AuthorizeDBSecurityGroupIngress": {
				"input": {
					"type": "structure",
					"required": [
						"DBSecurityGroupName"
					],
					"members": {
						"DBSecurityGroupName": {},
						"CIDRIP": {},
						"EC2SecurityGroupName": {},
						"EC2SecurityGroupId": {},
						"EC2SecurityGroupOwnerId": {}
					}
				},
				"output": {
					"resultWrapper": "AuthorizeDBSecurityGroupIngressResult",
					"type": "structure",
					"members": {
						"DBSecurityGroup": {
							"shape": "Sd"
						}
					}
				}
			},
			"CopyDBSnapshot": {
				"input": {
					"type": "structure",
					"required": [
						"SourceDBSnapshotIdentifier",
						"TargetDBSnapshotIdentifier"
					],
					"members": {
						"SourceDBSnapshotIdentifier": {},
						"TargetDBSnapshotIdentifier": {}
					}
				},
				"output": {
					"resultWrapper": "CopyDBSnapshotResult",
					"type": "structure",
					"members": {
						"DBSnapshot": {
							"shape": "Sk"
						}
					}
				}
			},
			"CreateDBInstance": {
				"input": {
					"type": "structure",
					"required": [
						"DBInstanceIdentifier",
						"AllocatedStorage",
						"DBInstanceClass",
						"Engine",
						"MasterUsername",
						"MasterUserPassword"
					],
					"members": {
						"DBName": {},
						"DBInstanceIdentifier": {},
						"AllocatedStorage": {
							"type": "integer"
						},
						"DBInstanceClass": {},
						"Engine": {},
						"MasterUsername": {},
						"MasterUserPassword": {},
						"DBSecurityGroups": {
							"shape": "Sp"
						},
						"VpcSecurityGroupIds": {
							"shape": "Sq"
						},
						"AvailabilityZone": {},
						"DBSubnetGroupName": {},
						"PreferredMaintenanceWindow": {},
						"DBParameterGroupName": {},
						"BackupRetentionPeriod": {
							"type": "integer"
						},
						"PreferredBackupWindow": {},
						"Port": {
							"type": "integer"
						},
						"MultiAZ": {
							"type": "boolean"
						},
						"EngineVersion": {},
						"AutoMinorVersionUpgrade": {
							"type": "boolean"
						},
						"LicenseModel": {},
						"Iops": {
							"type": "integer"
						},
						"OptionGroupName": {},
						"CharacterSetName": {},
						"PubliclyAccessible": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"resultWrapper": "CreateDBInstanceResult",
					"type": "structure",
					"members": {
						"DBInstance": {
							"shape": "St"
						}
					}
				}
			},
			"CreateDBInstanceReadReplica": {
				"input": {
					"type": "structure",
					"required": [
						"DBInstanceIdentifier",
						"SourceDBInstanceIdentifier"
					],
					"members": {
						"DBInstanceIdentifier": {},
						"SourceDBInstanceIdentifier": {},
						"DBInstanceClass": {},
						"AvailabilityZone": {},
						"Port": {
							"type": "integer"
						},
						"AutoMinorVersionUpgrade": {
							"type": "boolean"
						},
						"Iops": {
							"type": "integer"
						},
						"OptionGroupName": {},
						"PubliclyAccessible": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"resultWrapper": "CreateDBInstanceReadReplicaResult",
					"type": "structure",
					"members": {
						"DBInstance": {
							"shape": "St"
						}
					}
				}
			},
			"CreateDBParameterGroup": {
				"input": {
					"type": "structure",
					"required": [
						"DBParameterGroupName",
						"DBParameterGroupFamily",
						"Description"
					],
					"members": {
						"DBParameterGroupName": {},
						"DBParameterGroupFamily": {},
						"Description": {}
					}
				},
				"output": {
					"resultWrapper": "CreateDBParameterGroupResult",
					"type": "structure",
					"members": {
						"DBParameterGroup": {
							"shape": "S1c"
						}
					}
				}
			},
			"CreateDBSecurityGroup": {
				"input": {
					"type": "structure",
					"required": [
						"DBSecurityGroupName",
						"DBSecurityGroupDescription"
					],
					"members": {
						"DBSecurityGroupName": {},
						"DBSecurityGroupDescription": {}
					}
				},
				"output": {
					"resultWrapper": "CreateDBSecurityGroupResult",
					"type": "structure",
					"members": {
						"DBSecurityGroup": {
							"shape": "Sd"
						}
					}
				}
			},
			"CreateDBSnapshot": {
				"input": {
					"type": "structure",
					"required": [
						"DBSnapshotIdentifier",
						"DBInstanceIdentifier"
					],
					"members": {
						"DBSnapshotIdentifier": {},
						"DBInstanceIdentifier": {}
					}
				},
				"output": {
					"resultWrapper": "CreateDBSnapshotResult",
					"type": "structure",
					"members": {
						"DBSnapshot": {
							"shape": "Sk"
						}
					}
				}
			},
			"CreateDBSubnetGroup": {
				"input": {
					"type": "structure",
					"required": [
						"DBSubnetGroupName",
						"DBSubnetGroupDescription",
						"SubnetIds"
					],
					"members": {
						"DBSubnetGroupName": {},
						"DBSubnetGroupDescription": {},
						"SubnetIds": {
							"shape": "S1i"
						}
					}
				},
				"output": {
					"resultWrapper": "CreateDBSubnetGroupResult",
					"type": "structure",
					"members": {
						"DBSubnetGroup": {
							"shape": "S11"
						}
					}
				}
			},
			"CreateEventSubscription": {
				"input": {
					"type": "structure",
					"required": [
						"SubscriptionName",
						"SnsTopicArn"
					],
					"members": {
						"SubscriptionName": {},
						"SnsTopicArn": {},
						"SourceType": {},
						"EventCategories": {
							"shape": "S6"
						},
						"SourceIds": {
							"shape": "S5"
						},
						"Enabled": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"resultWrapper": "CreateEventSubscriptionResult",
					"type": "structure",
					"members": {
						"EventSubscription": {
							"shape": "S4"
						}
					}
				}
			},
			"CreateOptionGroup": {
				"input": {
					"type": "structure",
					"required": [
						"OptionGroupName",
						"EngineName",
						"MajorEngineVersion",
						"OptionGroupDescription"
					],
					"members": {
						"OptionGroupName": {},
						"EngineName": {},
						"MajorEngineVersion": {},
						"OptionGroupDescription": {}
					}
				},
				"output": {
					"resultWrapper": "CreateOptionGroupResult",
					"type": "structure",
					"members": {
						"OptionGroup": {
							"shape": "S1o"
						}
					}
				}
			},
			"DeleteDBInstance": {
				"input": {
					"type": "structure",
					"required": [
						"DBInstanceIdentifier"
					],
					"members": {
						"DBInstanceIdentifier": {},
						"SkipFinalSnapshot": {
							"type": "boolean"
						},
						"FinalDBSnapshotIdentifier": {}
					}
				},
				"output": {
					"resultWrapper": "DeleteDBInstanceResult",
					"type": "structure",
					"members": {
						"DBInstance": {
							"shape": "St"
						}
					}
				}
			},
			"DeleteDBParameterGroup": {
				"input": {
					"type": "structure",
					"required": [
						"DBParameterGroupName"
					],
					"members": {
						"DBParameterGroupName": {}
					}
				}
			},
			"DeleteDBSecurityGroup": {
				"input": {
					"type": "structure",
					"required": [
						"DBSecurityGroupName"
					],
					"members": {
						"DBSecurityGroupName": {}
					}
				}
			},
			"DeleteDBSnapshot": {
				"input": {
					"type": "structure",
					"required": [
						"DBSnapshotIdentifier"
					],
					"members": {
						"DBSnapshotIdentifier": {}
					}
				},
				"output": {
					"resultWrapper": "DeleteDBSnapshotResult",
					"type": "structure",
					"members": {
						"DBSnapshot": {
							"shape": "Sk"
						}
					}
				}
			},
			"DeleteDBSubnetGroup": {
				"input": {
					"type": "structure",
					"required": [
						"DBSubnetGroupName"
					],
					"members": {
						"DBSubnetGroupName": {}
					}
				}
			},
			"DeleteEventSubscription": {
				"input": {
					"type": "structure",
					"required": [
						"SubscriptionName"
					],
					"members": {
						"SubscriptionName": {}
					}
				},
				"output": {
					"resultWrapper": "DeleteEventSubscriptionResult",
					"type": "structure",
					"members": {
						"EventSubscription": {
							"shape": "S4"
						}
					}
				}
			},
			"DeleteOptionGroup": {
				"input": {
					"type": "structure",
					"required": [
						"OptionGroupName"
					],
					"members": {
						"OptionGroupName": {}
					}
				}
			},
			"DescribeDBEngineVersions": {
				"input": {
					"type": "structure",
					"members": {
						"Engine": {},
						"EngineVersion": {},
						"DBParameterGroupFamily": {},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {},
						"DefaultOnly": {
							"type": "boolean"
						},
						"ListSupportedCharacterSets": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"resultWrapper": "DescribeDBEngineVersionsResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"DBEngineVersions": {
							"type": "list",
							"member": {
								"locationName": "DBEngineVersion",
								"type": "structure",
								"members": {
									"Engine": {},
									"EngineVersion": {},
									"DBParameterGroupFamily": {},
									"DBEngineDescription": {},
									"DBEngineVersionDescription": {},
									"DefaultCharacterSet": {
										"shape": "S25"
									},
									"SupportedCharacterSets": {
										"type": "list",
										"member": {
											"shape": "S25",
											"locationName": "CharacterSet"
										}
									}
								}
							}
						}
					}
				}
			},
			"DescribeDBInstances": {
				"input": {
					"type": "structure",
					"members": {
						"DBInstanceIdentifier": {},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeDBInstancesResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"DBInstances": {
							"type": "list",
							"member": {
								"shape": "St",
								"locationName": "DBInstance"
							}
						}
					}
				}
			},
			"DescribeDBParameterGroups": {
				"input": {
					"type": "structure",
					"members": {
						"DBParameterGroupName": {},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeDBParameterGroupsResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"DBParameterGroups": {
							"type": "list",
							"member": {
								"shape": "S1c",
								"locationName": "DBParameterGroup"
							}
						}
					}
				}
			},
			"DescribeDBParameters": {
				"input": {
					"type": "structure",
					"required": [
						"DBParameterGroupName"
					],
					"members": {
						"DBParameterGroupName": {},
						"Source": {},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeDBParametersResult",
					"type": "structure",
					"members": {
						"Parameters": {
							"shape": "S2f"
						},
						"Marker": {}
					}
				}
			},
			"DescribeDBSecurityGroups": {
				"input": {
					"type": "structure",
					"members": {
						"DBSecurityGroupName": {},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeDBSecurityGroupsResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"DBSecurityGroups": {
							"type": "list",
							"member": {
								"shape": "Sd",
								"locationName": "DBSecurityGroup"
							}
						}
					}
				}
			},
			"DescribeDBSnapshots": {
				"input": {
					"type": "structure",
					"members": {
						"DBInstanceIdentifier": {},
						"DBSnapshotIdentifier": {},
						"SnapshotType": {},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeDBSnapshotsResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"DBSnapshots": {
							"type": "list",
							"member": {
								"shape": "Sk",
								"locationName": "DBSnapshot"
							}
						}
					}
				}
			},
			"DescribeDBSubnetGroups": {
				"input": {
					"type": "structure",
					"members": {
						"DBSubnetGroupName": {},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeDBSubnetGroupsResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"DBSubnetGroups": {
							"type": "list",
							"member": {
								"shape": "S11",
								"locationName": "DBSubnetGroup"
							}
						}
					}
				}
			},
			"DescribeEngineDefaultParameters": {
				"input": {
					"type": "structure",
					"required": [
						"DBParameterGroupFamily"
					],
					"members": {
						"DBParameterGroupFamily": {},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeEngineDefaultParametersResult",
					"type": "structure",
					"members": {
						"EngineDefaults": {
							"type": "structure",
							"members": {
								"DBParameterGroupFamily": {},
								"Marker": {},
								"Parameters": {
									"shape": "S2f"
								}
							},
							"wrapper": true
						}
					}
				}
			},
			"DescribeEventCategories": {
				"input": {
					"type": "structure",
					"members": {
						"SourceType": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeEventCategoriesResult",
					"type": "structure",
					"members": {
						"EventCategoriesMapList": {
							"type": "list",
							"member": {
								"locationName": "EventCategoriesMap",
								"type": "structure",
								"members": {
									"SourceType": {},
									"EventCategories": {
										"shape": "S6"
									}
								},
								"wrapper": true
							}
						}
					}
				}
			},
			"DescribeEventSubscriptions": {
				"input": {
					"type": "structure",
					"members": {
						"SubscriptionName": {},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeEventSubscriptionsResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"EventSubscriptionsList": {
							"type": "list",
							"member": {
								"shape": "S4",
								"locationName": "EventSubscription"
							}
						}
					}
				}
			},
			"DescribeEvents": {
				"input": {
					"type": "structure",
					"members": {
						"SourceIdentifier": {},
						"SourceType": {},
						"StartTime": {
							"type": "timestamp"
						},
						"EndTime": {
							"type": "timestamp"
						},
						"Duration": {
							"type": "integer"
						},
						"EventCategories": {
							"shape": "S6"
						},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeEventsResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"Events": {
							"type": "list",
							"member": {
								"locationName": "Event",
								"type": "structure",
								"members": {
									"SourceIdentifier": {},
									"SourceType": {},
									"Message": {},
									"EventCategories": {
										"shape": "S6"
									},
									"Date": {
										"type": "timestamp"
									}
								}
							}
						}
					}
				}
			},
			"DescribeOptionGroupOptions": {
				"input": {
					"type": "structure",
					"required": [
						"EngineName"
					],
					"members": {
						"EngineName": {},
						"MajorEngineVersion": {},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeOptionGroupOptionsResult",
					"type": "structure",
					"members": {
						"OptionGroupOptions": {
							"type": "list",
							"member": {
								"locationName": "OptionGroupOption",
								"type": "structure",
								"members": {
									"Name": {},
									"Description": {},
									"EngineName": {},
									"MajorEngineVersion": {},
									"MinimumRequiredMinorEngineVersion": {},
									"PortRequired": {
										"type": "boolean"
									},
									"DefaultPort": {
										"type": "integer"
									},
									"OptionsDependedOn": {
										"type": "list",
										"member": {
											"locationName": "OptionName"
										}
									}
								}
							}
						},
						"Marker": {}
					}
				}
			},
			"DescribeOptionGroups": {
				"input": {
					"type": "structure",
					"members": {
						"OptionGroupName": {},
						"Marker": {},
						"MaxRecords": {
							"type": "integer"
						},
						"EngineName": {},
						"MajorEngineVersion": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeOptionGroupsResult",
					"type": "structure",
					"members": {
						"OptionGroupsList": {
							"type": "list",
							"member": {
								"shape": "S1o",
								"locationName": "OptionGroup"
							}
						},
						"Marker": {}
					}
				}
			},
			"DescribeOrderableDBInstanceOptions": {
				"input": {
					"type": "structure",
					"required": [
						"Engine"
					],
					"members": {
						"Engine": {},
						"EngineVersion": {},
						"DBInstanceClass": {},
						"LicenseModel": {},
						"Vpc": {
							"type": "boolean"
						},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeOrderableDBInstanceOptionsResult",
					"type": "structure",
					"members": {
						"OrderableDBInstanceOptions": {
							"type": "list",
							"member": {
								"locationName": "OrderableDBInstanceOption",
								"type": "structure",
								"members": {
									"Engine": {},
									"EngineVersion": {},
									"DBInstanceClass": {},
									"LicenseModel": {},
									"AvailabilityZones": {
										"type": "list",
										"member": {
											"shape": "S14",
											"locationName": "AvailabilityZone"
										}
									},
									"MultiAZCapable": {
										"type": "boolean"
									},
									"ReadReplicaCapable": {
										"type": "boolean"
									},
									"Vpc": {
										"type": "boolean"
									}
								},
								"wrapper": true
							}
						},
						"Marker": {}
					}
				}
			},
			"DescribeReservedDBInstances": {
				"input": {
					"type": "structure",
					"members": {
						"ReservedDBInstanceId": {},
						"ReservedDBInstancesOfferingId": {},
						"DBInstanceClass": {},
						"Duration": {},
						"ProductDescription": {},
						"OfferingType": {},
						"MultiAZ": {
							"type": "boolean"
						},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeReservedDBInstancesResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"ReservedDBInstances": {
							"type": "list",
							"member": {
								"shape": "S3m",
								"locationName": "ReservedDBInstance"
							}
						}
					}
				}
			},
			"DescribeReservedDBInstancesOfferings": {
				"input": {
					"type": "structure",
					"members": {
						"ReservedDBInstancesOfferingId": {},
						"DBInstanceClass": {},
						"Duration": {},
						"ProductDescription": {},
						"OfferingType": {},
						"MultiAZ": {
							"type": "boolean"
						},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeReservedDBInstancesOfferingsResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"ReservedDBInstancesOfferings": {
							"type": "list",
							"member": {
								"locationName": "ReservedDBInstancesOffering",
								"type": "structure",
								"members": {
									"ReservedDBInstancesOfferingId": {},
									"DBInstanceClass": {},
									"Duration": {
										"type": "integer"
									},
									"FixedPrice": {
										"type": "double"
									},
									"UsagePrice": {
										"type": "double"
									},
									"CurrencyCode": {},
									"ProductDescription": {},
									"OfferingType": {},
									"MultiAZ": {
										"type": "boolean"
									},
									"RecurringCharges": {
										"shape": "S3o"
									}
								},
								"wrapper": true
							}
						}
					}
				}
			},
			"ListTagsForResource": {
				"input": {
					"type": "structure",
					"required": [
						"ResourceName"
					],
					"members": {
						"ResourceName": {}
					}
				},
				"output": {
					"resultWrapper": "ListTagsForResourceResult",
					"type": "structure",
					"members": {
						"TagList": {
							"shape": "S9"
						}
					}
				}
			},
			"ModifyDBInstance": {
				"input": {
					"type": "structure",
					"required": [
						"DBInstanceIdentifier"
					],
					"members": {
						"DBInstanceIdentifier": {},
						"AllocatedStorage": {
							"type": "integer"
						},
						"DBInstanceClass": {},
						"DBSecurityGroups": {
							"shape": "Sp"
						},
						"VpcSecurityGroupIds": {
							"shape": "Sq"
						},
						"ApplyImmediately": {
							"type": "boolean"
						},
						"MasterUserPassword": {},
						"DBParameterGroupName": {},
						"BackupRetentionPeriod": {
							"type": "integer"
						},
						"PreferredBackupWindow": {},
						"PreferredMaintenanceWindow": {},
						"MultiAZ": {
							"type": "boolean"
						},
						"EngineVersion": {},
						"AllowMajorVersionUpgrade": {
							"type": "boolean"
						},
						"AutoMinorVersionUpgrade": {
							"type": "boolean"
						},
						"Iops": {
							"type": "integer"
						},
						"OptionGroupName": {},
						"NewDBInstanceIdentifier": {}
					}
				},
				"output": {
					"resultWrapper": "ModifyDBInstanceResult",
					"type": "structure",
					"members": {
						"DBInstance": {
							"shape": "St"
						}
					}
				}
			},
			"ModifyDBParameterGroup": {
				"input": {
					"type": "structure",
					"required": [
						"DBParameterGroupName",
						"Parameters"
					],
					"members": {
						"DBParameterGroupName": {},
						"Parameters": {
							"shape": "S2f"
						}
					}
				},
				"output": {
					"shape": "S3z",
					"resultWrapper": "ModifyDBParameterGroupResult"
				}
			},
			"ModifyDBSubnetGroup": {
				"input": {
					"type": "structure",
					"required": [
						"DBSubnetGroupName",
						"SubnetIds"
					],
					"members": {
						"DBSubnetGroupName": {},
						"DBSubnetGroupDescription": {},
						"SubnetIds": {
							"shape": "S1i"
						}
					}
				},
				"output": {
					"resultWrapper": "ModifyDBSubnetGroupResult",
					"type": "structure",
					"members": {
						"DBSubnetGroup": {
							"shape": "S11"
						}
					}
				}
			},
			"ModifyEventSubscription": {
				"input": {
					"type": "structure",
					"required": [
						"SubscriptionName"
					],
					"members": {
						"SubscriptionName": {},
						"SnsTopicArn": {},
						"SourceType": {},
						"EventCategories": {
							"shape": "S6"
						},
						"Enabled": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"resultWrapper": "ModifyEventSubscriptionResult",
					"type": "structure",
					"members": {
						"EventSubscription": {
							"shape": "S4"
						}
					}
				}
			},
			"ModifyOptionGroup": {
				"input": {
					"type": "structure",
					"required": [
						"OptionGroupName"
					],
					"members": {
						"OptionGroupName": {},
						"OptionsToInclude": {
							"type": "list",
							"member": {
								"locationName": "OptionConfiguration",
								"type": "structure",
								"required": [
									"OptionName"
								],
								"members": {
									"OptionName": {},
									"Port": {
										"type": "integer"
									},
									"DBSecurityGroupMemberships": {
										"shape": "Sp"
									},
									"VpcSecurityGroupMemberships": {
										"shape": "Sq"
									}
								}
							}
						},
						"OptionsToRemove": {
							"type": "list",
							"member": {}
						},
						"ApplyImmediately": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"resultWrapper": "ModifyOptionGroupResult",
					"type": "structure",
					"members": {
						"OptionGroup": {
							"shape": "S1o"
						}
					}
				}
			},
			"PromoteReadReplica": {
				"input": {
					"type": "structure",
					"required": [
						"DBInstanceIdentifier"
					],
					"members": {
						"DBInstanceIdentifier": {},
						"BackupRetentionPeriod": {
							"type": "integer"
						},
						"PreferredBackupWindow": {}
					}
				},
				"output": {
					"resultWrapper": "PromoteReadReplicaResult",
					"type": "structure",
					"members": {
						"DBInstance": {
							"shape": "St"
						}
					}
				}
			},
			"PurchaseReservedDBInstancesOffering": {
				"input": {
					"type": "structure",
					"required": [
						"ReservedDBInstancesOfferingId"
					],
					"members": {
						"ReservedDBInstancesOfferingId": {},
						"ReservedDBInstanceId": {},
						"DBInstanceCount": {
							"type": "integer"
						}
					}
				},
				"output": {
					"resultWrapper": "PurchaseReservedDBInstancesOfferingResult",
					"type": "structure",
					"members": {
						"ReservedDBInstance": {
							"shape": "S3m"
						}
					}
				}
			},
			"RebootDBInstance": {
				"input": {
					"type": "structure",
					"required": [
						"DBInstanceIdentifier"
					],
					"members": {
						"DBInstanceIdentifier": {},
						"ForceFailover": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"resultWrapper": "RebootDBInstanceResult",
					"type": "structure",
					"members": {
						"DBInstance": {
							"shape": "St"
						}
					}
				}
			},
			"RemoveSourceIdentifierFromSubscription": {
				"input": {
					"type": "structure",
					"required": [
						"SubscriptionName",
						"SourceIdentifier"
					],
					"members": {
						"SubscriptionName": {},
						"SourceIdentifier": {}
					}
				},
				"output": {
					"resultWrapper": "RemoveSourceIdentifierFromSubscriptionResult",
					"type": "structure",
					"members": {
						"EventSubscription": {
							"shape": "S4"
						}
					}
				}
			},
			"RemoveTagsFromResource": {
				"input": {
					"type": "structure",
					"required": [
						"ResourceName",
						"TagKeys"
					],
					"members": {
						"ResourceName": {},
						"TagKeys": {
							"type": "list",
							"member": {}
						}
					}
				}
			},
			"ResetDBParameterGroup": {
				"input": {
					"type": "structure",
					"required": [
						"DBParameterGroupName"
					],
					"members": {
						"DBParameterGroupName": {},
						"ResetAllParameters": {
							"type": "boolean"
						},
						"Parameters": {
							"shape": "S2f"
						}
					}
				},
				"output": {
					"shape": "S3z",
					"resultWrapper": "ResetDBParameterGroupResult"
				}
			},
			"RestoreDBInstanceFromDBSnapshot": {
				"input": {
					"type": "structure",
					"required": [
						"DBInstanceIdentifier",
						"DBSnapshotIdentifier"
					],
					"members": {
						"DBInstanceIdentifier": {},
						"DBSnapshotIdentifier": {},
						"DBInstanceClass": {},
						"Port": {
							"type": "integer"
						},
						"AvailabilityZone": {},
						"DBSubnetGroupName": {},
						"MultiAZ": {
							"type": "boolean"
						},
						"PubliclyAccessible": {
							"type": "boolean"
						},
						"AutoMinorVersionUpgrade": {
							"type": "boolean"
						},
						"LicenseModel": {},
						"DBName": {},
						"Engine": {},
						"Iops": {
							"type": "integer"
						},
						"OptionGroupName": {}
					}
				},
				"output": {
					"resultWrapper": "RestoreDBInstanceFromDBSnapshotResult",
					"type": "structure",
					"members": {
						"DBInstance": {
							"shape": "St"
						}
					}
				}
			},
			"RestoreDBInstanceToPointInTime": {
				"input": {
					"type": "structure",
					"required": [
						"SourceDBInstanceIdentifier",
						"TargetDBInstanceIdentifier"
					],
					"members": {
						"SourceDBInstanceIdentifier": {},
						"TargetDBInstanceIdentifier": {},
						"RestoreTime": {
							"type": "timestamp"
						},
						"UseLatestRestorableTime": {
							"type": "boolean"
						},
						"DBInstanceClass": {},
						"Port": {
							"type": "integer"
						},
						"AvailabilityZone": {},
						"DBSubnetGroupName": {},
						"MultiAZ": {
							"type": "boolean"
						},
						"PubliclyAccessible": {
							"type": "boolean"
						},
						"AutoMinorVersionUpgrade": {
							"type": "boolean"
						},
						"LicenseModel": {},
						"DBName": {},
						"Engine": {},
						"Iops": {
							"type": "integer"
						},
						"OptionGroupName": {}
					}
				},
				"output": {
					"resultWrapper": "RestoreDBInstanceToPointInTimeResult",
					"type": "structure",
					"members": {
						"DBInstance": {
							"shape": "St"
						}
					}
				}
			},
			"RevokeDBSecurityGroupIngress": {
				"input": {
					"type": "structure",
					"required": [
						"DBSecurityGroupName"
					],
					"members": {
						"DBSecurityGroupName": {},
						"CIDRIP": {},
						"EC2SecurityGroupName": {},
						"EC2SecurityGroupId": {},
						"EC2SecurityGroupOwnerId": {}
					}
				},
				"output": {
					"resultWrapper": "RevokeDBSecurityGroupIngressResult",
					"type": "structure",
					"members": {
						"DBSecurityGroup": {
							"shape": "Sd"
						}
					}
				}
			}
		},
		"shapes": {
			"S4": {
				"type": "structure",
				"members": {
					"Id": {},
					"CustomerAwsId": {},
					"CustSubscriptionId": {},
					"SnsTopicArn": {},
					"Status": {},
					"SubscriptionCreationTime": {},
					"SourceType": {},
					"SourceIdsList": {
						"shape": "S5"
					},
					"EventCategoriesList": {
						"shape": "S6"
					},
					"Enabled": {
						"type": "boolean"
					}
				},
				"wrapper": true
			},
			"S5": {
				"type": "list",
				"member": {
					"locationName": "SourceId"
				}
			},
			"S6": {
				"type": "list",
				"member": {
					"locationName": "EventCategory"
				}
			},
			"S9": {
				"type": "list",
				"member": {
					"locationName": "Tag",
					"type": "structure",
					"members": {
						"Key": {},
						"Value": {}
					}
				}
			},
			"Sd": {
				"type": "structure",
				"members": {
					"OwnerId": {},
					"DBSecurityGroupName": {},
					"DBSecurityGroupDescription": {},
					"VpcId": {},
					"EC2SecurityGroups": {
						"type": "list",
						"member": {
							"locationName": "EC2SecurityGroup",
							"type": "structure",
							"members": {
								"Status": {},
								"EC2SecurityGroupName": {},
								"EC2SecurityGroupId": {},
								"EC2SecurityGroupOwnerId": {}
							}
						}
					},
					"IPRanges": {
						"type": "list",
						"member": {
							"locationName": "IPRange",
							"type": "structure",
							"members": {
								"Status": {},
								"CIDRIP": {}
							}
						}
					}
				},
				"wrapper": true
			},
			"Sk": {
				"type": "structure",
				"members": {
					"DBSnapshotIdentifier": {},
					"DBInstanceIdentifier": {},
					"SnapshotCreateTime": {
						"type": "timestamp"
					},
					"Engine": {},
					"AllocatedStorage": {
						"type": "integer"
					},
					"Status": {},
					"Port": {
						"type": "integer"
					},
					"AvailabilityZone": {},
					"VpcId": {},
					"InstanceCreateTime": {
						"type": "timestamp"
					},
					"MasterUsername": {},
					"EngineVersion": {},
					"LicenseModel": {},
					"SnapshotType": {},
					"Iops": {
						"type": "integer"
					}
				},
				"wrapper": true
			},
			"Sp": {
				"type": "list",
				"member": {
					"locationName": "DBSecurityGroupName"
				}
			},
			"Sq": {
				"type": "list",
				"member": {
					"locationName": "VpcSecurityGroupId"
				}
			},
			"St": {
				"type": "structure",
				"members": {
					"DBInstanceIdentifier": {},
					"DBInstanceClass": {},
					"Engine": {},
					"DBInstanceStatus": {},
					"MasterUsername": {},
					"DBName": {},
					"Endpoint": {
						"type": "structure",
						"members": {
							"Address": {},
							"Port": {
								"type": "integer"
							}
						}
					},
					"AllocatedStorage": {
						"type": "integer"
					},
					"InstanceCreateTime": {
						"type": "timestamp"
					},
					"PreferredBackupWindow": {},
					"BackupRetentionPeriod": {
						"type": "integer"
					},
					"DBSecurityGroups": {
						"shape": "Sv"
					},
					"VpcSecurityGroups": {
						"shape": "Sx"
					},
					"DBParameterGroups": {
						"type": "list",
						"member": {
							"locationName": "DBParameterGroup",
							"type": "structure",
							"members": {
								"DBParameterGroupName": {},
								"ParameterApplyStatus": {}
							}
						}
					},
					"AvailabilityZone": {},
					"DBSubnetGroup": {
						"shape": "S11"
					},
					"PreferredMaintenanceWindow": {},
					"PendingModifiedValues": {
						"type": "structure",
						"members": {
							"DBInstanceClass": {},
							"AllocatedStorage": {
								"type": "integer"
							},
							"MasterUserPassword": {},
							"Port": {
								"type": "integer"
							},
							"BackupRetentionPeriod": {
								"type": "integer"
							},
							"MultiAZ": {
								"type": "boolean"
							},
							"EngineVersion": {},
							"Iops": {
								"type": "integer"
							},
							"DBInstanceIdentifier": {}
						}
					},
					"LatestRestorableTime": {
						"type": "timestamp"
					},
					"MultiAZ": {
						"type": "boolean"
					},
					"EngineVersion": {},
					"AutoMinorVersionUpgrade": {
						"type": "boolean"
					},
					"ReadReplicaSourceDBInstanceIdentifier": {},
					"ReadReplicaDBInstanceIdentifiers": {
						"type": "list",
						"member": {
							"locationName": "ReadReplicaDBInstanceIdentifier"
						}
					},
					"LicenseModel": {},
					"Iops": {
						"type": "integer"
					},
					"OptionGroupMembership": {
						"type": "structure",
						"members": {
							"OptionGroupName": {},
							"Status": {}
						}
					},
					"CharacterSetName": {},
					"SecondaryAvailabilityZone": {},
					"PubliclyAccessible": {
						"type": "boolean"
					}
				},
				"wrapper": true
			},
			"Sv": {
				"type": "list",
				"member": {
					"locationName": "DBSecurityGroup",
					"type": "structure",
					"members": {
						"DBSecurityGroupName": {},
						"Status": {}
					}
				}
			},
			"Sx": {
				"type": "list",
				"member": {
					"locationName": "VpcSecurityGroupMembership",
					"type": "structure",
					"members": {
						"VpcSecurityGroupId": {},
						"Status": {}
					}
				}
			},
			"S11": {
				"type": "structure",
				"members": {
					"DBSubnetGroupName": {},
					"DBSubnetGroupDescription": {},
					"VpcId": {},
					"SubnetGroupStatus": {},
					"Subnets": {
						"type": "list",
						"member": {
							"locationName": "Subnet",
							"type": "structure",
							"members": {
								"SubnetIdentifier": {},
								"SubnetAvailabilityZone": {
									"shape": "S14"
								},
								"SubnetStatus": {}
							}
						}
					}
				},
				"wrapper": true
			},
			"S14": {
				"type": "structure",
				"members": {
					"Name": {},
					"ProvisionedIopsCapable": {
						"type": "boolean"
					}
				},
				"wrapper": true
			},
			"S1c": {
				"type": "structure",
				"members": {
					"DBParameterGroupName": {},
					"DBParameterGroupFamily": {},
					"Description": {}
				},
				"wrapper": true
			},
			"S1i": {
				"type": "list",
				"member": {
					"locationName": "SubnetIdentifier"
				}
			},
			"S1o": {
				"type": "structure",
				"members": {
					"OptionGroupName": {},
					"OptionGroupDescription": {},
					"EngineName": {},
					"MajorEngineVersion": {},
					"Options": {
						"type": "list",
						"member": {
							"locationName": "Option",
							"type": "structure",
							"members": {
								"OptionName": {},
								"OptionDescription": {},
								"Port": {
									"type": "integer"
								},
								"DBSecurityGroupMemberships": {
									"shape": "Sv"
								},
								"VpcSecurityGroupMemberships": {
									"shape": "Sx"
								}
							}
						}
					},
					"AllowsVpcAndNonVpcInstanceMemberships": {
						"type": "boolean"
					},
					"VpcId": {}
				},
				"wrapper": true
			},
			"S25": {
				"type": "structure",
				"members": {
					"CharacterSetName": {},
					"CharacterSetDescription": {}
				}
			},
			"S2f": {
				"type": "list",
				"member": {
					"locationName": "Parameter",
					"type": "structure",
					"members": {
						"ParameterName": {},
						"ParameterValue": {},
						"Description": {},
						"Source": {},
						"ApplyType": {},
						"DataType": {},
						"AllowedValues": {},
						"IsModifiable": {
							"type": "boolean"
						},
						"MinimumEngineVersion": {},
						"ApplyMethod": {}
					}
				}
			},
			"S3m": {
				"type": "structure",
				"members": {
					"ReservedDBInstanceId": {},
					"ReservedDBInstancesOfferingId": {},
					"DBInstanceClass": {},
					"StartTime": {
						"type": "timestamp"
					},
					"Duration": {
						"type": "integer"
					},
					"FixedPrice": {
						"type": "double"
					},
					"UsagePrice": {
						"type": "double"
					},
					"CurrencyCode": {},
					"DBInstanceCount": {
						"type": "integer"
					},
					"ProductDescription": {},
					"OfferingType": {},
					"MultiAZ": {
						"type": "boolean"
					},
					"State": {},
					"RecurringCharges": {
						"shape": "S3o"
					}
				},
				"wrapper": true
			},
			"S3o": {
				"type": "list",
				"member": {
					"locationName": "RecurringCharge",
					"type": "structure",
					"members": {
						"RecurringChargeAmount": {
							"type": "double"
						},
						"RecurringChargeFrequency": {}
					},
					"wrapper": true
				}
			},
			"S3z": {
				"type": "structure",
				"members": {
					"DBParameterGroupName": {}
				}
			}
		}
	};

/***/ },
/* 419 */
/***/ function(module, exports) {

	module.exports = {
		"pagination": {
			"DescribeDBEngineVersions": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "DBEngineVersions"
			},
			"DescribeDBInstances": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "DBInstances"
			},
			"DescribeDBParameterGroups": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "DBParameterGroups"
			},
			"DescribeDBParameters": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "Parameters"
			},
			"DescribeDBSecurityGroups": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "DBSecurityGroups"
			},
			"DescribeDBSnapshots": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "DBSnapshots"
			},
			"DescribeDBSubnetGroups": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "DBSubnetGroups"
			},
			"DescribeEngineDefaultParameters": {
				"input_token": "Marker",
				"output_token": "EngineDefaults.Marker",
				"limit_key": "MaxRecords",
				"result_key": "EngineDefaults.Parameters"
			},
			"DescribeEventSubscriptions": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "EventSubscriptionsList"
			},
			"DescribeEvents": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "Events"
			},
			"DescribeOptionGroupOptions": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "OptionGroupOptions"
			},
			"DescribeOptionGroups": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "OptionGroupsList"
			},
			"DescribeOrderableDBInstanceOptions": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "OrderableDBInstanceOptions"
			},
			"DescribeReservedDBInstances": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "ReservedDBInstances"
			},
			"DescribeReservedDBInstancesOfferings": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "ReservedDBInstancesOfferings"
			},
			"ListTagsForResource": {
				"result_key": "TagList"
			}
		}
	};

/***/ },
/* 420 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2013-02-12",
			"endpointPrefix": "rds",
			"protocol": "query",
			"serviceAbbreviation": "Amazon RDS",
			"serviceFullName": "Amazon Relational Database Service",
			"signatureVersion": "v4",
			"xmlNamespace": "http://rds.amazonaws.com/doc/2013-02-12/"
		},
		"operations": {
			"AddSourceIdentifierToSubscription": {
				"input": {
					"type": "structure",
					"required": [
						"SubscriptionName",
						"SourceIdentifier"
					],
					"members": {
						"SubscriptionName": {},
						"SourceIdentifier": {}
					}
				},
				"output": {
					"resultWrapper": "AddSourceIdentifierToSubscriptionResult",
					"type": "structure",
					"members": {
						"EventSubscription": {
							"shape": "S4"
						}
					}
				}
			},
			"AddTagsToResource": {
				"input": {
					"type": "structure",
					"required": [
						"ResourceName",
						"Tags"
					],
					"members": {
						"ResourceName": {},
						"Tags": {
							"shape": "S9"
						}
					}
				}
			},
			"AuthorizeDBSecurityGroupIngress": {
				"input": {
					"type": "structure",
					"required": [
						"DBSecurityGroupName"
					],
					"members": {
						"DBSecurityGroupName": {},
						"CIDRIP": {},
						"EC2SecurityGroupName": {},
						"EC2SecurityGroupId": {},
						"EC2SecurityGroupOwnerId": {}
					}
				},
				"output": {
					"resultWrapper": "AuthorizeDBSecurityGroupIngressResult",
					"type": "structure",
					"members": {
						"DBSecurityGroup": {
							"shape": "Sd"
						}
					}
				}
			},
			"CopyDBSnapshot": {
				"input": {
					"type": "structure",
					"required": [
						"SourceDBSnapshotIdentifier",
						"TargetDBSnapshotIdentifier"
					],
					"members": {
						"SourceDBSnapshotIdentifier": {},
						"TargetDBSnapshotIdentifier": {}
					}
				},
				"output": {
					"resultWrapper": "CopyDBSnapshotResult",
					"type": "structure",
					"members": {
						"DBSnapshot": {
							"shape": "Sk"
						}
					}
				}
			},
			"CreateDBInstance": {
				"input": {
					"type": "structure",
					"required": [
						"DBInstanceIdentifier",
						"AllocatedStorage",
						"DBInstanceClass",
						"Engine",
						"MasterUsername",
						"MasterUserPassword"
					],
					"members": {
						"DBName": {},
						"DBInstanceIdentifier": {},
						"AllocatedStorage": {
							"type": "integer"
						},
						"DBInstanceClass": {},
						"Engine": {},
						"MasterUsername": {},
						"MasterUserPassword": {},
						"DBSecurityGroups": {
							"shape": "Sp"
						},
						"VpcSecurityGroupIds": {
							"shape": "Sq"
						},
						"AvailabilityZone": {},
						"DBSubnetGroupName": {},
						"PreferredMaintenanceWindow": {},
						"DBParameterGroupName": {},
						"BackupRetentionPeriod": {
							"type": "integer"
						},
						"PreferredBackupWindow": {},
						"Port": {
							"type": "integer"
						},
						"MultiAZ": {
							"type": "boolean"
						},
						"EngineVersion": {},
						"AutoMinorVersionUpgrade": {
							"type": "boolean"
						},
						"LicenseModel": {},
						"Iops": {
							"type": "integer"
						},
						"OptionGroupName": {},
						"CharacterSetName": {},
						"PubliclyAccessible": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"resultWrapper": "CreateDBInstanceResult",
					"type": "structure",
					"members": {
						"DBInstance": {
							"shape": "St"
						}
					}
				}
			},
			"CreateDBInstanceReadReplica": {
				"input": {
					"type": "structure",
					"required": [
						"DBInstanceIdentifier",
						"SourceDBInstanceIdentifier"
					],
					"members": {
						"DBInstanceIdentifier": {},
						"SourceDBInstanceIdentifier": {},
						"DBInstanceClass": {},
						"AvailabilityZone": {},
						"Port": {
							"type": "integer"
						},
						"AutoMinorVersionUpgrade": {
							"type": "boolean"
						},
						"Iops": {
							"type": "integer"
						},
						"OptionGroupName": {},
						"PubliclyAccessible": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"resultWrapper": "CreateDBInstanceReadReplicaResult",
					"type": "structure",
					"members": {
						"DBInstance": {
							"shape": "St"
						}
					}
				}
			},
			"CreateDBParameterGroup": {
				"input": {
					"type": "structure",
					"required": [
						"DBParameterGroupName",
						"DBParameterGroupFamily",
						"Description"
					],
					"members": {
						"DBParameterGroupName": {},
						"DBParameterGroupFamily": {},
						"Description": {}
					}
				},
				"output": {
					"resultWrapper": "CreateDBParameterGroupResult",
					"type": "structure",
					"members": {
						"DBParameterGroup": {
							"shape": "S1d"
						}
					}
				}
			},
			"CreateDBSecurityGroup": {
				"input": {
					"type": "structure",
					"required": [
						"DBSecurityGroupName",
						"DBSecurityGroupDescription"
					],
					"members": {
						"DBSecurityGroupName": {},
						"DBSecurityGroupDescription": {}
					}
				},
				"output": {
					"resultWrapper": "CreateDBSecurityGroupResult",
					"type": "structure",
					"members": {
						"DBSecurityGroup": {
							"shape": "Sd"
						}
					}
				}
			},
			"CreateDBSnapshot": {
				"input": {
					"type": "structure",
					"required": [
						"DBSnapshotIdentifier",
						"DBInstanceIdentifier"
					],
					"members": {
						"DBSnapshotIdentifier": {},
						"DBInstanceIdentifier": {}
					}
				},
				"output": {
					"resultWrapper": "CreateDBSnapshotResult",
					"type": "structure",
					"members": {
						"DBSnapshot": {
							"shape": "Sk"
						}
					}
				}
			},
			"CreateDBSubnetGroup": {
				"input": {
					"type": "structure",
					"required": [
						"DBSubnetGroupName",
						"DBSubnetGroupDescription",
						"SubnetIds"
					],
					"members": {
						"DBSubnetGroupName": {},
						"DBSubnetGroupDescription": {},
						"SubnetIds": {
							"shape": "S1j"
						}
					}
				},
				"output": {
					"resultWrapper": "CreateDBSubnetGroupResult",
					"type": "structure",
					"members": {
						"DBSubnetGroup": {
							"shape": "S11"
						}
					}
				}
			},
			"CreateEventSubscription": {
				"input": {
					"type": "structure",
					"required": [
						"SubscriptionName",
						"SnsTopicArn"
					],
					"members": {
						"SubscriptionName": {},
						"SnsTopicArn": {},
						"SourceType": {},
						"EventCategories": {
							"shape": "S6"
						},
						"SourceIds": {
							"shape": "S5"
						},
						"Enabled": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"resultWrapper": "CreateEventSubscriptionResult",
					"type": "structure",
					"members": {
						"EventSubscription": {
							"shape": "S4"
						}
					}
				}
			},
			"CreateOptionGroup": {
				"input": {
					"type": "structure",
					"required": [
						"OptionGroupName",
						"EngineName",
						"MajorEngineVersion",
						"OptionGroupDescription"
					],
					"members": {
						"OptionGroupName": {},
						"EngineName": {},
						"MajorEngineVersion": {},
						"OptionGroupDescription": {}
					}
				},
				"output": {
					"resultWrapper": "CreateOptionGroupResult",
					"type": "structure",
					"members": {
						"OptionGroup": {
							"shape": "S1p"
						}
					}
				}
			},
			"DeleteDBInstance": {
				"input": {
					"type": "structure",
					"required": [
						"DBInstanceIdentifier"
					],
					"members": {
						"DBInstanceIdentifier": {},
						"SkipFinalSnapshot": {
							"type": "boolean"
						},
						"FinalDBSnapshotIdentifier": {}
					}
				},
				"output": {
					"resultWrapper": "DeleteDBInstanceResult",
					"type": "structure",
					"members": {
						"DBInstance": {
							"shape": "St"
						}
					}
				}
			},
			"DeleteDBParameterGroup": {
				"input": {
					"type": "structure",
					"required": [
						"DBParameterGroupName"
					],
					"members": {
						"DBParameterGroupName": {}
					}
				}
			},
			"DeleteDBSecurityGroup": {
				"input": {
					"type": "structure",
					"required": [
						"DBSecurityGroupName"
					],
					"members": {
						"DBSecurityGroupName": {}
					}
				}
			},
			"DeleteDBSnapshot": {
				"input": {
					"type": "structure",
					"required": [
						"DBSnapshotIdentifier"
					],
					"members": {
						"DBSnapshotIdentifier": {}
					}
				},
				"output": {
					"resultWrapper": "DeleteDBSnapshotResult",
					"type": "structure",
					"members": {
						"DBSnapshot": {
							"shape": "Sk"
						}
					}
				}
			},
			"DeleteDBSubnetGroup": {
				"input": {
					"type": "structure",
					"required": [
						"DBSubnetGroupName"
					],
					"members": {
						"DBSubnetGroupName": {}
					}
				}
			},
			"DeleteEventSubscription": {
				"input": {
					"type": "structure",
					"required": [
						"SubscriptionName"
					],
					"members": {
						"SubscriptionName": {}
					}
				},
				"output": {
					"resultWrapper": "DeleteEventSubscriptionResult",
					"type": "structure",
					"members": {
						"EventSubscription": {
							"shape": "S4"
						}
					}
				}
			},
			"DeleteOptionGroup": {
				"input": {
					"type": "structure",
					"required": [
						"OptionGroupName"
					],
					"members": {
						"OptionGroupName": {}
					}
				}
			},
			"DescribeDBEngineVersions": {
				"input": {
					"type": "structure",
					"members": {
						"Engine": {},
						"EngineVersion": {},
						"DBParameterGroupFamily": {},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {},
						"DefaultOnly": {
							"type": "boolean"
						},
						"ListSupportedCharacterSets": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"resultWrapper": "DescribeDBEngineVersionsResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"DBEngineVersions": {
							"type": "list",
							"member": {
								"locationName": "DBEngineVersion",
								"type": "structure",
								"members": {
									"Engine": {},
									"EngineVersion": {},
									"DBParameterGroupFamily": {},
									"DBEngineDescription": {},
									"DBEngineVersionDescription": {},
									"DefaultCharacterSet": {
										"shape": "S28"
									},
									"SupportedCharacterSets": {
										"type": "list",
										"member": {
											"shape": "S28",
											"locationName": "CharacterSet"
										}
									}
								}
							}
						}
					}
				}
			},
			"DescribeDBInstances": {
				"input": {
					"type": "structure",
					"members": {
						"DBInstanceIdentifier": {},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeDBInstancesResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"DBInstances": {
							"type": "list",
							"member": {
								"shape": "St",
								"locationName": "DBInstance"
							}
						}
					}
				}
			},
			"DescribeDBLogFiles": {
				"input": {
					"type": "structure",
					"required": [
						"DBInstanceIdentifier"
					],
					"members": {
						"DBInstanceIdentifier": {},
						"FilenameContains": {},
						"FileLastWritten": {
							"type": "long"
						},
						"FileSize": {
							"type": "long"
						},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeDBLogFilesResult",
					"type": "structure",
					"members": {
						"DescribeDBLogFiles": {
							"type": "list",
							"member": {
								"locationName": "DescribeDBLogFilesDetails",
								"type": "structure",
								"members": {
									"LogFileName": {},
									"LastWritten": {
										"type": "long"
									},
									"Size": {
										"type": "long"
									}
								}
							}
						},
						"Marker": {}
					}
				}
			},
			"DescribeDBParameterGroups": {
				"input": {
					"type": "structure",
					"members": {
						"DBParameterGroupName": {},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeDBParameterGroupsResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"DBParameterGroups": {
							"type": "list",
							"member": {
								"shape": "S1d",
								"locationName": "DBParameterGroup"
							}
						}
					}
				}
			},
			"DescribeDBParameters": {
				"input": {
					"type": "structure",
					"required": [
						"DBParameterGroupName"
					],
					"members": {
						"DBParameterGroupName": {},
						"Source": {},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeDBParametersResult",
					"type": "structure",
					"members": {
						"Parameters": {
							"shape": "S2n"
						},
						"Marker": {}
					}
				}
			},
			"DescribeDBSecurityGroups": {
				"input": {
					"type": "structure",
					"members": {
						"DBSecurityGroupName": {},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeDBSecurityGroupsResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"DBSecurityGroups": {
							"type": "list",
							"member": {
								"shape": "Sd",
								"locationName": "DBSecurityGroup"
							}
						}
					}
				}
			},
			"DescribeDBSnapshots": {
				"input": {
					"type": "structure",
					"members": {
						"DBInstanceIdentifier": {},
						"DBSnapshotIdentifier": {},
						"SnapshotType": {},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeDBSnapshotsResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"DBSnapshots": {
							"type": "list",
							"member": {
								"shape": "Sk",
								"locationName": "DBSnapshot"
							}
						}
					}
				}
			},
			"DescribeDBSubnetGroups": {
				"input": {
					"type": "structure",
					"members": {
						"DBSubnetGroupName": {},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeDBSubnetGroupsResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"DBSubnetGroups": {
							"type": "list",
							"member": {
								"shape": "S11",
								"locationName": "DBSubnetGroup"
							}
						}
					}
				}
			},
			"DescribeEngineDefaultParameters": {
				"input": {
					"type": "structure",
					"required": [
						"DBParameterGroupFamily"
					],
					"members": {
						"DBParameterGroupFamily": {},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeEngineDefaultParametersResult",
					"type": "structure",
					"members": {
						"EngineDefaults": {
							"type": "structure",
							"members": {
								"DBParameterGroupFamily": {},
								"Marker": {},
								"Parameters": {
									"shape": "S2n"
								}
							},
							"wrapper": true
						}
					}
				}
			},
			"DescribeEventCategories": {
				"input": {
					"type": "structure",
					"members": {
						"SourceType": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeEventCategoriesResult",
					"type": "structure",
					"members": {
						"EventCategoriesMapList": {
							"type": "list",
							"member": {
								"locationName": "EventCategoriesMap",
								"type": "structure",
								"members": {
									"SourceType": {},
									"EventCategories": {
										"shape": "S6"
									}
								},
								"wrapper": true
							}
						}
					}
				}
			},
			"DescribeEventSubscriptions": {
				"input": {
					"type": "structure",
					"members": {
						"SubscriptionName": {},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeEventSubscriptionsResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"EventSubscriptionsList": {
							"type": "list",
							"member": {
								"shape": "S4",
								"locationName": "EventSubscription"
							}
						}
					}
				}
			},
			"DescribeEvents": {
				"input": {
					"type": "structure",
					"members": {
						"SourceIdentifier": {},
						"SourceType": {},
						"StartTime": {
							"type": "timestamp"
						},
						"EndTime": {
							"type": "timestamp"
						},
						"Duration": {
							"type": "integer"
						},
						"EventCategories": {
							"shape": "S6"
						},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeEventsResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"Events": {
							"type": "list",
							"member": {
								"locationName": "Event",
								"type": "structure",
								"members": {
									"SourceIdentifier": {},
									"SourceType": {},
									"Message": {},
									"EventCategories": {
										"shape": "S6"
									},
									"Date": {
										"type": "timestamp"
									}
								}
							}
						}
					}
				}
			},
			"DescribeOptionGroupOptions": {
				"input": {
					"type": "structure",
					"required": [
						"EngineName"
					],
					"members": {
						"EngineName": {},
						"MajorEngineVersion": {},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeOptionGroupOptionsResult",
					"type": "structure",
					"members": {
						"OptionGroupOptions": {
							"type": "list",
							"member": {
								"locationName": "OptionGroupOption",
								"type": "structure",
								"members": {
									"Name": {},
									"Description": {},
									"EngineName": {},
									"MajorEngineVersion": {},
									"MinimumRequiredMinorEngineVersion": {},
									"PortRequired": {
										"type": "boolean"
									},
									"DefaultPort": {
										"type": "integer"
									},
									"OptionsDependedOn": {
										"type": "list",
										"member": {
											"locationName": "OptionName"
										}
									},
									"Persistent": {
										"type": "boolean"
									},
									"OptionGroupOptionSettings": {
										"type": "list",
										"member": {
											"locationName": "OptionGroupOptionSetting",
											"type": "structure",
											"members": {
												"SettingName": {},
												"SettingDescription": {},
												"DefaultValue": {},
												"ApplyType": {},
												"AllowedValues": {},
												"IsModifiable": {
													"type": "boolean"
												}
											}
										}
									}
								}
							}
						},
						"Marker": {}
					}
				}
			},
			"DescribeOptionGroups": {
				"input": {
					"type": "structure",
					"members": {
						"OptionGroupName": {},
						"Marker": {},
						"MaxRecords": {
							"type": "integer"
						},
						"EngineName": {},
						"MajorEngineVersion": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeOptionGroupsResult",
					"type": "structure",
					"members": {
						"OptionGroupsList": {
							"type": "list",
							"member": {
								"shape": "S1p",
								"locationName": "OptionGroup"
							}
						},
						"Marker": {}
					}
				}
			},
			"DescribeOrderableDBInstanceOptions": {
				"input": {
					"type": "structure",
					"required": [
						"Engine"
					],
					"members": {
						"Engine": {},
						"EngineVersion": {},
						"DBInstanceClass": {},
						"LicenseModel": {},
						"Vpc": {
							"type": "boolean"
						},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeOrderableDBInstanceOptionsResult",
					"type": "structure",
					"members": {
						"OrderableDBInstanceOptions": {
							"type": "list",
							"member": {
								"locationName": "OrderableDBInstanceOption",
								"type": "structure",
								"members": {
									"Engine": {},
									"EngineVersion": {},
									"DBInstanceClass": {},
									"LicenseModel": {},
									"AvailabilityZones": {
										"type": "list",
										"member": {
											"shape": "S14",
											"locationName": "AvailabilityZone"
										}
									},
									"MultiAZCapable": {
										"type": "boolean"
									},
									"ReadReplicaCapable": {
										"type": "boolean"
									},
									"Vpc": {
										"type": "boolean"
									}
								},
								"wrapper": true
							}
						},
						"Marker": {}
					}
				}
			},
			"DescribeReservedDBInstances": {
				"input": {
					"type": "structure",
					"members": {
						"ReservedDBInstanceId": {},
						"ReservedDBInstancesOfferingId": {},
						"DBInstanceClass": {},
						"Duration": {},
						"ProductDescription": {},
						"OfferingType": {},
						"MultiAZ": {
							"type": "boolean"
						},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeReservedDBInstancesResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"ReservedDBInstances": {
							"type": "list",
							"member": {
								"shape": "S3w",
								"locationName": "ReservedDBInstance"
							}
						}
					}
				}
			},
			"DescribeReservedDBInstancesOfferings": {
				"input": {
					"type": "structure",
					"members": {
						"ReservedDBInstancesOfferingId": {},
						"DBInstanceClass": {},
						"Duration": {},
						"ProductDescription": {},
						"OfferingType": {},
						"MultiAZ": {
							"type": "boolean"
						},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeReservedDBInstancesOfferingsResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"ReservedDBInstancesOfferings": {
							"type": "list",
							"member": {
								"locationName": "ReservedDBInstancesOffering",
								"type": "structure",
								"members": {
									"ReservedDBInstancesOfferingId": {},
									"DBInstanceClass": {},
									"Duration": {
										"type": "integer"
									},
									"FixedPrice": {
										"type": "double"
									},
									"UsagePrice": {
										"type": "double"
									},
									"CurrencyCode": {},
									"ProductDescription": {},
									"OfferingType": {},
									"MultiAZ": {
										"type": "boolean"
									},
									"RecurringCharges": {
										"shape": "S3y"
									}
								},
								"wrapper": true
							}
						}
					}
				}
			},
			"DownloadDBLogFilePortion": {
				"input": {
					"type": "structure",
					"required": [
						"DBInstanceIdentifier",
						"LogFileName"
					],
					"members": {
						"DBInstanceIdentifier": {},
						"LogFileName": {},
						"Marker": {},
						"NumberOfLines": {
							"type": "integer"
						}
					}
				},
				"output": {
					"resultWrapper": "DownloadDBLogFilePortionResult",
					"type": "structure",
					"members": {
						"LogFileData": {},
						"Marker": {},
						"AdditionalDataPending": {
							"type": "boolean"
						}
					}
				}
			},
			"ListTagsForResource": {
				"input": {
					"type": "structure",
					"required": [
						"ResourceName"
					],
					"members": {
						"ResourceName": {}
					}
				},
				"output": {
					"resultWrapper": "ListTagsForResourceResult",
					"type": "structure",
					"members": {
						"TagList": {
							"shape": "S9"
						}
					}
				}
			},
			"ModifyDBInstance": {
				"input": {
					"type": "structure",
					"required": [
						"DBInstanceIdentifier"
					],
					"members": {
						"DBInstanceIdentifier": {},
						"AllocatedStorage": {
							"type": "integer"
						},
						"DBInstanceClass": {},
						"DBSecurityGroups": {
							"shape": "Sp"
						},
						"VpcSecurityGroupIds": {
							"shape": "Sq"
						},
						"ApplyImmediately": {
							"type": "boolean"
						},
						"MasterUserPassword": {},
						"DBParameterGroupName": {},
						"BackupRetentionPeriod": {
							"type": "integer"
						},
						"PreferredBackupWindow": {},
						"PreferredMaintenanceWindow": {},
						"MultiAZ": {
							"type": "boolean"
						},
						"EngineVersion": {},
						"AllowMajorVersionUpgrade": {
							"type": "boolean"
						},
						"AutoMinorVersionUpgrade": {
							"type": "boolean"
						},
						"Iops": {
							"type": "integer"
						},
						"OptionGroupName": {},
						"NewDBInstanceIdentifier": {}
					}
				},
				"output": {
					"resultWrapper": "ModifyDBInstanceResult",
					"type": "structure",
					"members": {
						"DBInstance": {
							"shape": "St"
						}
					}
				}
			},
			"ModifyDBParameterGroup": {
				"input": {
					"type": "structure",
					"required": [
						"DBParameterGroupName",
						"Parameters"
					],
					"members": {
						"DBParameterGroupName": {},
						"Parameters": {
							"shape": "S2n"
						}
					}
				},
				"output": {
					"shape": "S4b",
					"resultWrapper": "ModifyDBParameterGroupResult"
				}
			},
			"ModifyDBSubnetGroup": {
				"input": {
					"type": "structure",
					"required": [
						"DBSubnetGroupName",
						"SubnetIds"
					],
					"members": {
						"DBSubnetGroupName": {},
						"DBSubnetGroupDescription": {},
						"SubnetIds": {
							"shape": "S1j"
						}
					}
				},
				"output": {
					"resultWrapper": "ModifyDBSubnetGroupResult",
					"type": "structure",
					"members": {
						"DBSubnetGroup": {
							"shape": "S11"
						}
					}
				}
			},
			"ModifyEventSubscription": {
				"input": {
					"type": "structure",
					"required": [
						"SubscriptionName"
					],
					"members": {
						"SubscriptionName": {},
						"SnsTopicArn": {},
						"SourceType": {},
						"EventCategories": {
							"shape": "S6"
						},
						"Enabled": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"resultWrapper": "ModifyEventSubscriptionResult",
					"type": "structure",
					"members": {
						"EventSubscription": {
							"shape": "S4"
						}
					}
				}
			},
			"ModifyOptionGroup": {
				"input": {
					"type": "structure",
					"required": [
						"OptionGroupName"
					],
					"members": {
						"OptionGroupName": {},
						"OptionsToInclude": {
							"type": "list",
							"member": {
								"locationName": "OptionConfiguration",
								"type": "structure",
								"required": [
									"OptionName"
								],
								"members": {
									"OptionName": {},
									"Port": {
										"type": "integer"
									},
									"DBSecurityGroupMemberships": {
										"shape": "Sp"
									},
									"VpcSecurityGroupMemberships": {
										"shape": "Sq"
									},
									"OptionSettings": {
										"type": "list",
										"member": {
											"shape": "S1t",
											"locationName": "OptionSetting"
										}
									}
								}
							}
						},
						"OptionsToRemove": {
							"type": "list",
							"member": {}
						},
						"ApplyImmediately": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"resultWrapper": "ModifyOptionGroupResult",
					"type": "structure",
					"members": {
						"OptionGroup": {
							"shape": "S1p"
						}
					}
				}
			},
			"PromoteReadReplica": {
				"input": {
					"type": "structure",
					"required": [
						"DBInstanceIdentifier"
					],
					"members": {
						"DBInstanceIdentifier": {},
						"BackupRetentionPeriod": {
							"type": "integer"
						},
						"PreferredBackupWindow": {}
					}
				},
				"output": {
					"resultWrapper": "PromoteReadReplicaResult",
					"type": "structure",
					"members": {
						"DBInstance": {
							"shape": "St"
						}
					}
				}
			},
			"PurchaseReservedDBInstancesOffering": {
				"input": {
					"type": "structure",
					"required": [
						"ReservedDBInstancesOfferingId"
					],
					"members": {
						"ReservedDBInstancesOfferingId": {},
						"ReservedDBInstanceId": {},
						"DBInstanceCount": {
							"type": "integer"
						}
					}
				},
				"output": {
					"resultWrapper": "PurchaseReservedDBInstancesOfferingResult",
					"type": "structure",
					"members": {
						"ReservedDBInstance": {
							"shape": "S3w"
						}
					}
				}
			},
			"RebootDBInstance": {
				"input": {
					"type": "structure",
					"required": [
						"DBInstanceIdentifier"
					],
					"members": {
						"DBInstanceIdentifier": {},
						"ForceFailover": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"resultWrapper": "RebootDBInstanceResult",
					"type": "structure",
					"members": {
						"DBInstance": {
							"shape": "St"
						}
					}
				}
			},
			"RemoveSourceIdentifierFromSubscription": {
				"input": {
					"type": "structure",
					"required": [
						"SubscriptionName",
						"SourceIdentifier"
					],
					"members": {
						"SubscriptionName": {},
						"SourceIdentifier": {}
					}
				},
				"output": {
					"resultWrapper": "RemoveSourceIdentifierFromSubscriptionResult",
					"type": "structure",
					"members": {
						"EventSubscription": {
							"shape": "S4"
						}
					}
				}
			},
			"RemoveTagsFromResource": {
				"input": {
					"type": "structure",
					"required": [
						"ResourceName",
						"TagKeys"
					],
					"members": {
						"ResourceName": {},
						"TagKeys": {
							"type": "list",
							"member": {}
						}
					}
				}
			},
			"ResetDBParameterGroup": {
				"input": {
					"type": "structure",
					"required": [
						"DBParameterGroupName"
					],
					"members": {
						"DBParameterGroupName": {},
						"ResetAllParameters": {
							"type": "boolean"
						},
						"Parameters": {
							"shape": "S2n"
						}
					}
				},
				"output": {
					"shape": "S4b",
					"resultWrapper": "ResetDBParameterGroupResult"
				}
			},
			"RestoreDBInstanceFromDBSnapshot": {
				"input": {
					"type": "structure",
					"required": [
						"DBInstanceIdentifier",
						"DBSnapshotIdentifier"
					],
					"members": {
						"DBInstanceIdentifier": {},
						"DBSnapshotIdentifier": {},
						"DBInstanceClass": {},
						"Port": {
							"type": "integer"
						},
						"AvailabilityZone": {},
						"DBSubnetGroupName": {},
						"MultiAZ": {
							"type": "boolean"
						},
						"PubliclyAccessible": {
							"type": "boolean"
						},
						"AutoMinorVersionUpgrade": {
							"type": "boolean"
						},
						"LicenseModel": {},
						"DBName": {},
						"Engine": {},
						"Iops": {
							"type": "integer"
						},
						"OptionGroupName": {}
					}
				},
				"output": {
					"resultWrapper": "RestoreDBInstanceFromDBSnapshotResult",
					"type": "structure",
					"members": {
						"DBInstance": {
							"shape": "St"
						}
					}
				}
			},
			"RestoreDBInstanceToPointInTime": {
				"input": {
					"type": "structure",
					"required": [
						"SourceDBInstanceIdentifier",
						"TargetDBInstanceIdentifier"
					],
					"members": {
						"SourceDBInstanceIdentifier": {},
						"TargetDBInstanceIdentifier": {},
						"RestoreTime": {
							"type": "timestamp"
						},
						"UseLatestRestorableTime": {
							"type": "boolean"
						},
						"DBInstanceClass": {},
						"Port": {
							"type": "integer"
						},
						"AvailabilityZone": {},
						"DBSubnetGroupName": {},
						"MultiAZ": {
							"type": "boolean"
						},
						"PubliclyAccessible": {
							"type": "boolean"
						},
						"AutoMinorVersionUpgrade": {
							"type": "boolean"
						},
						"LicenseModel": {},
						"DBName": {},
						"Engine": {},
						"Iops": {
							"type": "integer"
						},
						"OptionGroupName": {}
					}
				},
				"output": {
					"resultWrapper": "RestoreDBInstanceToPointInTimeResult",
					"type": "structure",
					"members": {
						"DBInstance": {
							"shape": "St"
						}
					}
				}
			},
			"RevokeDBSecurityGroupIngress": {
				"input": {
					"type": "structure",
					"required": [
						"DBSecurityGroupName"
					],
					"members": {
						"DBSecurityGroupName": {},
						"CIDRIP": {},
						"EC2SecurityGroupName": {},
						"EC2SecurityGroupId": {},
						"EC2SecurityGroupOwnerId": {}
					}
				},
				"output": {
					"resultWrapper": "RevokeDBSecurityGroupIngressResult",
					"type": "structure",
					"members": {
						"DBSecurityGroup": {
							"shape": "Sd"
						}
					}
				}
			}
		},
		"shapes": {
			"S4": {
				"type": "structure",
				"members": {
					"CustomerAwsId": {},
					"CustSubscriptionId": {},
					"SnsTopicArn": {},
					"Status": {},
					"SubscriptionCreationTime": {},
					"SourceType": {},
					"SourceIdsList": {
						"shape": "S5"
					},
					"EventCategoriesList": {
						"shape": "S6"
					},
					"Enabled": {
						"type": "boolean"
					}
				},
				"wrapper": true
			},
			"S5": {
				"type": "list",
				"member": {
					"locationName": "SourceId"
				}
			},
			"S6": {
				"type": "list",
				"member": {
					"locationName": "EventCategory"
				}
			},
			"S9": {
				"type": "list",
				"member": {
					"locationName": "Tag",
					"type": "structure",
					"members": {
						"Key": {},
						"Value": {}
					}
				}
			},
			"Sd": {
				"type": "structure",
				"members": {
					"OwnerId": {},
					"DBSecurityGroupName": {},
					"DBSecurityGroupDescription": {},
					"VpcId": {},
					"EC2SecurityGroups": {
						"type": "list",
						"member": {
							"locationName": "EC2SecurityGroup",
							"type": "structure",
							"members": {
								"Status": {},
								"EC2SecurityGroupName": {},
								"EC2SecurityGroupId": {},
								"EC2SecurityGroupOwnerId": {}
							}
						}
					},
					"IPRanges": {
						"type": "list",
						"member": {
							"locationName": "IPRange",
							"type": "structure",
							"members": {
								"Status": {},
								"CIDRIP": {}
							}
						}
					}
				},
				"wrapper": true
			},
			"Sk": {
				"type": "structure",
				"members": {
					"DBSnapshotIdentifier": {},
					"DBInstanceIdentifier": {},
					"SnapshotCreateTime": {
						"type": "timestamp"
					},
					"Engine": {},
					"AllocatedStorage": {
						"type": "integer"
					},
					"Status": {},
					"Port": {
						"type": "integer"
					},
					"AvailabilityZone": {},
					"VpcId": {},
					"InstanceCreateTime": {
						"type": "timestamp"
					},
					"MasterUsername": {},
					"EngineVersion": {},
					"LicenseModel": {},
					"SnapshotType": {},
					"Iops": {
						"type": "integer"
					},
					"OptionGroupName": {}
				},
				"wrapper": true
			},
			"Sp": {
				"type": "list",
				"member": {
					"locationName": "DBSecurityGroupName"
				}
			},
			"Sq": {
				"type": "list",
				"member": {
					"locationName": "VpcSecurityGroupId"
				}
			},
			"St": {
				"type": "structure",
				"members": {
					"DBInstanceIdentifier": {},
					"DBInstanceClass": {},
					"Engine": {},
					"DBInstanceStatus": {},
					"MasterUsername": {},
					"DBName": {},
					"Endpoint": {
						"type": "structure",
						"members": {
							"Address": {},
							"Port": {
								"type": "integer"
							}
						}
					},
					"AllocatedStorage": {
						"type": "integer"
					},
					"InstanceCreateTime": {
						"type": "timestamp"
					},
					"PreferredBackupWindow": {},
					"BackupRetentionPeriod": {
						"type": "integer"
					},
					"DBSecurityGroups": {
						"shape": "Sv"
					},
					"VpcSecurityGroups": {
						"shape": "Sx"
					},
					"DBParameterGroups": {
						"type": "list",
						"member": {
							"locationName": "DBParameterGroup",
							"type": "structure",
							"members": {
								"DBParameterGroupName": {},
								"ParameterApplyStatus": {}
							}
						}
					},
					"AvailabilityZone": {},
					"DBSubnetGroup": {
						"shape": "S11"
					},
					"PreferredMaintenanceWindow": {},
					"PendingModifiedValues": {
						"type": "structure",
						"members": {
							"DBInstanceClass": {},
							"AllocatedStorage": {
								"type": "integer"
							},
							"MasterUserPassword": {},
							"Port": {
								"type": "integer"
							},
							"BackupRetentionPeriod": {
								"type": "integer"
							},
							"MultiAZ": {
								"type": "boolean"
							},
							"EngineVersion": {},
							"Iops": {
								"type": "integer"
							},
							"DBInstanceIdentifier": {}
						}
					},
					"LatestRestorableTime": {
						"type": "timestamp"
					},
					"MultiAZ": {
						"type": "boolean"
					},
					"EngineVersion": {},
					"AutoMinorVersionUpgrade": {
						"type": "boolean"
					},
					"ReadReplicaSourceDBInstanceIdentifier": {},
					"ReadReplicaDBInstanceIdentifiers": {
						"type": "list",
						"member": {
							"locationName": "ReadReplicaDBInstanceIdentifier"
						}
					},
					"LicenseModel": {},
					"Iops": {
						"type": "integer"
					},
					"OptionGroupMemberships": {
						"type": "list",
						"member": {
							"locationName": "OptionGroupMembership",
							"type": "structure",
							"members": {
								"OptionGroupName": {},
								"Status": {}
							}
						}
					},
					"CharacterSetName": {},
					"SecondaryAvailabilityZone": {},
					"PubliclyAccessible": {
						"type": "boolean"
					}
				},
				"wrapper": true
			},
			"Sv": {
				"type": "list",
				"member": {
					"locationName": "DBSecurityGroup",
					"type": "structure",
					"members": {
						"DBSecurityGroupName": {},
						"Status": {}
					}
				}
			},
			"Sx": {
				"type": "list",
				"member": {
					"locationName": "VpcSecurityGroupMembership",
					"type": "structure",
					"members": {
						"VpcSecurityGroupId": {},
						"Status": {}
					}
				}
			},
			"S11": {
				"type": "structure",
				"members": {
					"DBSubnetGroupName": {},
					"DBSubnetGroupDescription": {},
					"VpcId": {},
					"SubnetGroupStatus": {},
					"Subnets": {
						"type": "list",
						"member": {
							"locationName": "Subnet",
							"type": "structure",
							"members": {
								"SubnetIdentifier": {},
								"SubnetAvailabilityZone": {
									"shape": "S14"
								},
								"SubnetStatus": {}
							}
						}
					}
				},
				"wrapper": true
			},
			"S14": {
				"type": "structure",
				"members": {
					"Name": {},
					"ProvisionedIopsCapable": {
						"type": "boolean"
					}
				},
				"wrapper": true
			},
			"S1d": {
				"type": "structure",
				"members": {
					"DBParameterGroupName": {},
					"DBParameterGroupFamily": {},
					"Description": {}
				},
				"wrapper": true
			},
			"S1j": {
				"type": "list",
				"member": {
					"locationName": "SubnetIdentifier"
				}
			},
			"S1p": {
				"type": "structure",
				"members": {
					"OptionGroupName": {},
					"OptionGroupDescription": {},
					"EngineName": {},
					"MajorEngineVersion": {},
					"Options": {
						"type": "list",
						"member": {
							"locationName": "Option",
							"type": "structure",
							"members": {
								"OptionName": {},
								"OptionDescription": {},
								"Persistent": {
									"type": "boolean"
								},
								"Port": {
									"type": "integer"
								},
								"OptionSettings": {
									"type": "list",
									"member": {
										"shape": "S1t",
										"locationName": "OptionSetting"
									}
								},
								"DBSecurityGroupMemberships": {
									"shape": "Sv"
								},
								"VpcSecurityGroupMemberships": {
									"shape": "Sx"
								}
							}
						}
					},
					"AllowsVpcAndNonVpcInstanceMemberships": {
						"type": "boolean"
					},
					"VpcId": {}
				},
				"wrapper": true
			},
			"S1t": {
				"type": "structure",
				"members": {
					"Name": {},
					"Value": {},
					"DefaultValue": {},
					"Description": {},
					"ApplyType": {},
					"DataType": {},
					"AllowedValues": {},
					"IsModifiable": {
						"type": "boolean"
					},
					"IsCollection": {
						"type": "boolean"
					}
				}
			},
			"S28": {
				"type": "structure",
				"members": {
					"CharacterSetName": {},
					"CharacterSetDescription": {}
				}
			},
			"S2n": {
				"type": "list",
				"member": {
					"locationName": "Parameter",
					"type": "structure",
					"members": {
						"ParameterName": {},
						"ParameterValue": {},
						"Description": {},
						"Source": {},
						"ApplyType": {},
						"DataType": {},
						"AllowedValues": {},
						"IsModifiable": {
							"type": "boolean"
						},
						"MinimumEngineVersion": {},
						"ApplyMethod": {}
					}
				}
			},
			"S3w": {
				"type": "structure",
				"members": {
					"ReservedDBInstanceId": {},
					"ReservedDBInstancesOfferingId": {},
					"DBInstanceClass": {},
					"StartTime": {
						"type": "timestamp"
					},
					"Duration": {
						"type": "integer"
					},
					"FixedPrice": {
						"type": "double"
					},
					"UsagePrice": {
						"type": "double"
					},
					"CurrencyCode": {},
					"DBInstanceCount": {
						"type": "integer"
					},
					"ProductDescription": {},
					"OfferingType": {},
					"MultiAZ": {
						"type": "boolean"
					},
					"State": {},
					"RecurringCharges": {
						"shape": "S3y"
					}
				},
				"wrapper": true
			},
			"S3y": {
				"type": "list",
				"member": {
					"locationName": "RecurringCharge",
					"type": "structure",
					"members": {
						"RecurringChargeAmount": {
							"type": "double"
						},
						"RecurringChargeFrequency": {}
					},
					"wrapper": true
				}
			},
			"S4b": {
				"type": "structure",
				"members": {
					"DBParameterGroupName": {}
				}
			}
		}
	};

/***/ },
/* 421 */
/***/ function(module, exports) {

	module.exports = {
		"pagination": {
			"DescribeDBEngineVersions": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "DBEngineVersions"
			},
			"DescribeDBInstances": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "DBInstances"
			},
			"DescribeDBLogFiles": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "DescribeDBLogFiles"
			},
			"DescribeDBParameterGroups": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "DBParameterGroups"
			},
			"DescribeDBParameters": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "Parameters"
			},
			"DescribeDBSecurityGroups": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "DBSecurityGroups"
			},
			"DescribeDBSnapshots": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "DBSnapshots"
			},
			"DescribeDBSubnetGroups": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "DBSubnetGroups"
			},
			"DescribeEngineDefaultParameters": {
				"input_token": "Marker",
				"output_token": "EngineDefaults.Marker",
				"limit_key": "MaxRecords",
				"result_key": "EngineDefaults.Parameters"
			},
			"DescribeEventSubscriptions": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "EventSubscriptionsList"
			},
			"DescribeEvents": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "Events"
			},
			"DescribeOptionGroupOptions": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "OptionGroupOptions"
			},
			"DescribeOptionGroups": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "OptionGroupsList"
			},
			"DescribeOrderableDBInstanceOptions": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "OrderableDBInstanceOptions"
			},
			"DescribeReservedDBInstances": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "ReservedDBInstances"
			},
			"DescribeReservedDBInstancesOfferings": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "ReservedDBInstancesOfferings"
			},
			"DownloadDBLogFilePortion": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "NumberOfLines",
				"more_results": "AdditionalDataPending",
				"result_key": "LogFileData"
			},
			"ListTagsForResource": {
				"result_key": "TagList"
			}
		}
	};

/***/ },
/* 422 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2013-09-09",
			"endpointPrefix": "rds",
			"protocol": "query",
			"serviceAbbreviation": "Amazon RDS",
			"serviceFullName": "Amazon Relational Database Service",
			"signatureVersion": "v4",
			"xmlNamespace": "http://rds.amazonaws.com/doc/2013-09-09/"
		},
		"operations": {
			"AddSourceIdentifierToSubscription": {
				"input": {
					"type": "structure",
					"required": [
						"SubscriptionName",
						"SourceIdentifier"
					],
					"members": {
						"SubscriptionName": {},
						"SourceIdentifier": {}
					}
				},
				"output": {
					"resultWrapper": "AddSourceIdentifierToSubscriptionResult",
					"type": "structure",
					"members": {
						"EventSubscription": {
							"shape": "S4"
						}
					}
				}
			},
			"AddTagsToResource": {
				"input": {
					"type": "structure",
					"required": [
						"ResourceName",
						"Tags"
					],
					"members": {
						"ResourceName": {},
						"Tags": {
							"shape": "S9"
						}
					}
				}
			},
			"AuthorizeDBSecurityGroupIngress": {
				"input": {
					"type": "structure",
					"required": [
						"DBSecurityGroupName"
					],
					"members": {
						"DBSecurityGroupName": {},
						"CIDRIP": {},
						"EC2SecurityGroupName": {},
						"EC2SecurityGroupId": {},
						"EC2SecurityGroupOwnerId": {}
					}
				},
				"output": {
					"resultWrapper": "AuthorizeDBSecurityGroupIngressResult",
					"type": "structure",
					"members": {
						"DBSecurityGroup": {
							"shape": "Sd"
						}
					}
				}
			},
			"CopyDBSnapshot": {
				"input": {
					"type": "structure",
					"required": [
						"SourceDBSnapshotIdentifier",
						"TargetDBSnapshotIdentifier"
					],
					"members": {
						"SourceDBSnapshotIdentifier": {},
						"TargetDBSnapshotIdentifier": {},
						"Tags": {
							"shape": "S9"
						}
					}
				},
				"output": {
					"resultWrapper": "CopyDBSnapshotResult",
					"type": "structure",
					"members": {
						"DBSnapshot": {
							"shape": "Sk"
						}
					}
				}
			},
			"CreateDBInstance": {
				"input": {
					"type": "structure",
					"required": [
						"DBInstanceIdentifier",
						"AllocatedStorage",
						"DBInstanceClass",
						"Engine",
						"MasterUsername",
						"MasterUserPassword"
					],
					"members": {
						"DBName": {},
						"DBInstanceIdentifier": {},
						"AllocatedStorage": {
							"type": "integer"
						},
						"DBInstanceClass": {},
						"Engine": {},
						"MasterUsername": {},
						"MasterUserPassword": {},
						"DBSecurityGroups": {
							"shape": "Sp"
						},
						"VpcSecurityGroupIds": {
							"shape": "Sq"
						},
						"AvailabilityZone": {},
						"DBSubnetGroupName": {},
						"PreferredMaintenanceWindow": {},
						"DBParameterGroupName": {},
						"BackupRetentionPeriod": {
							"type": "integer"
						},
						"PreferredBackupWindow": {},
						"Port": {
							"type": "integer"
						},
						"MultiAZ": {
							"type": "boolean"
						},
						"EngineVersion": {},
						"AutoMinorVersionUpgrade": {
							"type": "boolean"
						},
						"LicenseModel": {},
						"Iops": {
							"type": "integer"
						},
						"OptionGroupName": {},
						"CharacterSetName": {},
						"PubliclyAccessible": {
							"type": "boolean"
						},
						"Tags": {
							"shape": "S9"
						}
					}
				},
				"output": {
					"resultWrapper": "CreateDBInstanceResult",
					"type": "structure",
					"members": {
						"DBInstance": {
							"shape": "St"
						}
					}
				}
			},
			"CreateDBInstanceReadReplica": {
				"input": {
					"type": "structure",
					"required": [
						"DBInstanceIdentifier",
						"SourceDBInstanceIdentifier"
					],
					"members": {
						"DBInstanceIdentifier": {},
						"SourceDBInstanceIdentifier": {},
						"DBInstanceClass": {},
						"AvailabilityZone": {},
						"Port": {
							"type": "integer"
						},
						"AutoMinorVersionUpgrade": {
							"type": "boolean"
						},
						"Iops": {
							"type": "integer"
						},
						"OptionGroupName": {},
						"PubliclyAccessible": {
							"type": "boolean"
						},
						"Tags": {
							"shape": "S9"
						},
						"DBSubnetGroupName": {}
					}
				},
				"output": {
					"resultWrapper": "CreateDBInstanceReadReplicaResult",
					"type": "structure",
					"members": {
						"DBInstance": {
							"shape": "St"
						}
					}
				}
			},
			"CreateDBParameterGroup": {
				"input": {
					"type": "structure",
					"required": [
						"DBParameterGroupName",
						"DBParameterGroupFamily",
						"Description"
					],
					"members": {
						"DBParameterGroupName": {},
						"DBParameterGroupFamily": {},
						"Description": {},
						"Tags": {
							"shape": "S9"
						}
					}
				},
				"output": {
					"resultWrapper": "CreateDBParameterGroupResult",
					"type": "structure",
					"members": {
						"DBParameterGroup": {
							"shape": "S1f"
						}
					}
				}
			},
			"CreateDBSecurityGroup": {
				"input": {
					"type": "structure",
					"required": [
						"DBSecurityGroupName",
						"DBSecurityGroupDescription"
					],
					"members": {
						"DBSecurityGroupName": {},
						"DBSecurityGroupDescription": {},
						"Tags": {
							"shape": "S9"
						}
					}
				},
				"output": {
					"resultWrapper": "CreateDBSecurityGroupResult",
					"type": "structure",
					"members": {
						"DBSecurityGroup": {
							"shape": "Sd"
						}
					}
				}
			},
			"CreateDBSnapshot": {
				"input": {
					"type": "structure",
					"required": [
						"DBSnapshotIdentifier",
						"DBInstanceIdentifier"
					],
					"members": {
						"DBSnapshotIdentifier": {},
						"DBInstanceIdentifier": {},
						"Tags": {
							"shape": "S9"
						}
					}
				},
				"output": {
					"resultWrapper": "CreateDBSnapshotResult",
					"type": "structure",
					"members": {
						"DBSnapshot": {
							"shape": "Sk"
						}
					}
				}
			},
			"CreateDBSubnetGroup": {
				"input": {
					"type": "structure",
					"required": [
						"DBSubnetGroupName",
						"DBSubnetGroupDescription",
						"SubnetIds"
					],
					"members": {
						"DBSubnetGroupName": {},
						"DBSubnetGroupDescription": {},
						"SubnetIds": {
							"shape": "S1l"
						},
						"Tags": {
							"shape": "S9"
						}
					}
				},
				"output": {
					"resultWrapper": "CreateDBSubnetGroupResult",
					"type": "structure",
					"members": {
						"DBSubnetGroup": {
							"shape": "S11"
						}
					}
				}
			},
			"CreateEventSubscription": {
				"input": {
					"type": "structure",
					"required": [
						"SubscriptionName",
						"SnsTopicArn"
					],
					"members": {
						"SubscriptionName": {},
						"SnsTopicArn": {},
						"SourceType": {},
						"EventCategories": {
							"shape": "S6"
						},
						"SourceIds": {
							"shape": "S5"
						},
						"Enabled": {
							"type": "boolean"
						},
						"Tags": {
							"shape": "S9"
						}
					}
				},
				"output": {
					"resultWrapper": "CreateEventSubscriptionResult",
					"type": "structure",
					"members": {
						"EventSubscription": {
							"shape": "S4"
						}
					}
				}
			},
			"CreateOptionGroup": {
				"input": {
					"type": "structure",
					"required": [
						"OptionGroupName",
						"EngineName",
						"MajorEngineVersion",
						"OptionGroupDescription"
					],
					"members": {
						"OptionGroupName": {},
						"EngineName": {},
						"MajorEngineVersion": {},
						"OptionGroupDescription": {},
						"Tags": {
							"shape": "S9"
						}
					}
				},
				"output": {
					"resultWrapper": "CreateOptionGroupResult",
					"type": "structure",
					"members": {
						"OptionGroup": {
							"shape": "S1r"
						}
					}
				}
			},
			"DeleteDBInstance": {
				"input": {
					"type": "structure",
					"required": [
						"DBInstanceIdentifier"
					],
					"members": {
						"DBInstanceIdentifier": {},
						"SkipFinalSnapshot": {
							"type": "boolean"
						},
						"FinalDBSnapshotIdentifier": {}
					}
				},
				"output": {
					"resultWrapper": "DeleteDBInstanceResult",
					"type": "structure",
					"members": {
						"DBInstance": {
							"shape": "St"
						}
					}
				}
			},
			"DeleteDBParameterGroup": {
				"input": {
					"type": "structure",
					"required": [
						"DBParameterGroupName"
					],
					"members": {
						"DBParameterGroupName": {}
					}
				}
			},
			"DeleteDBSecurityGroup": {
				"input": {
					"type": "structure",
					"required": [
						"DBSecurityGroupName"
					],
					"members": {
						"DBSecurityGroupName": {}
					}
				}
			},
			"DeleteDBSnapshot": {
				"input": {
					"type": "structure",
					"required": [
						"DBSnapshotIdentifier"
					],
					"members": {
						"DBSnapshotIdentifier": {}
					}
				},
				"output": {
					"resultWrapper": "DeleteDBSnapshotResult",
					"type": "structure",
					"members": {
						"DBSnapshot": {
							"shape": "Sk"
						}
					}
				}
			},
			"DeleteDBSubnetGroup": {
				"input": {
					"type": "structure",
					"required": [
						"DBSubnetGroupName"
					],
					"members": {
						"DBSubnetGroupName": {}
					}
				}
			},
			"DeleteEventSubscription": {
				"input": {
					"type": "structure",
					"required": [
						"SubscriptionName"
					],
					"members": {
						"SubscriptionName": {}
					}
				},
				"output": {
					"resultWrapper": "DeleteEventSubscriptionResult",
					"type": "structure",
					"members": {
						"EventSubscription": {
							"shape": "S4"
						}
					}
				}
			},
			"DeleteOptionGroup": {
				"input": {
					"type": "structure",
					"required": [
						"OptionGroupName"
					],
					"members": {
						"OptionGroupName": {}
					}
				}
			},
			"DescribeDBEngineVersions": {
				"input": {
					"type": "structure",
					"members": {
						"Engine": {},
						"EngineVersion": {},
						"DBParameterGroupFamily": {},
						"Filters": {
							"shape": "S27"
						},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {},
						"DefaultOnly": {
							"type": "boolean"
						},
						"ListSupportedCharacterSets": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"resultWrapper": "DescribeDBEngineVersionsResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"DBEngineVersions": {
							"type": "list",
							"member": {
								"locationName": "DBEngineVersion",
								"type": "structure",
								"members": {
									"Engine": {},
									"EngineVersion": {},
									"DBParameterGroupFamily": {},
									"DBEngineDescription": {},
									"DBEngineVersionDescription": {},
									"DefaultCharacterSet": {
										"shape": "S2d"
									},
									"SupportedCharacterSets": {
										"type": "list",
										"member": {
											"shape": "S2d",
											"locationName": "CharacterSet"
										}
									}
								}
							}
						}
					}
				}
			},
			"DescribeDBInstances": {
				"input": {
					"type": "structure",
					"members": {
						"DBInstanceIdentifier": {},
						"Filters": {
							"shape": "S27"
						},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeDBInstancesResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"DBInstances": {
							"type": "list",
							"member": {
								"shape": "St",
								"locationName": "DBInstance"
							}
						}
					}
				}
			},
			"DescribeDBLogFiles": {
				"input": {
					"type": "structure",
					"required": [
						"DBInstanceIdentifier"
					],
					"members": {
						"DBInstanceIdentifier": {},
						"FilenameContains": {},
						"FileLastWritten": {
							"type": "long"
						},
						"FileSize": {
							"type": "long"
						},
						"Filters": {
							"shape": "S27"
						},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeDBLogFilesResult",
					"type": "structure",
					"members": {
						"DescribeDBLogFiles": {
							"type": "list",
							"member": {
								"locationName": "DescribeDBLogFilesDetails",
								"type": "structure",
								"members": {
									"LogFileName": {},
									"LastWritten": {
										"type": "long"
									},
									"Size": {
										"type": "long"
									}
								}
							}
						},
						"Marker": {}
					}
				}
			},
			"DescribeDBParameterGroups": {
				"input": {
					"type": "structure",
					"members": {
						"DBParameterGroupName": {},
						"Filters": {
							"shape": "S27"
						},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeDBParameterGroupsResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"DBParameterGroups": {
							"type": "list",
							"member": {
								"shape": "S1f",
								"locationName": "DBParameterGroup"
							}
						}
					}
				}
			},
			"DescribeDBParameters": {
				"input": {
					"type": "structure",
					"required": [
						"DBParameterGroupName"
					],
					"members": {
						"DBParameterGroupName": {},
						"Source": {},
						"Filters": {
							"shape": "S27"
						},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeDBParametersResult",
					"type": "structure",
					"members": {
						"Parameters": {
							"shape": "S2s"
						},
						"Marker": {}
					}
				}
			},
			"DescribeDBSecurityGroups": {
				"input": {
					"type": "structure",
					"members": {
						"DBSecurityGroupName": {},
						"Filters": {
							"shape": "S27"
						},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeDBSecurityGroupsResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"DBSecurityGroups": {
							"type": "list",
							"member": {
								"shape": "Sd",
								"locationName": "DBSecurityGroup"
							}
						}
					}
				}
			},
			"DescribeDBSnapshots": {
				"input": {
					"type": "structure",
					"members": {
						"DBInstanceIdentifier": {},
						"DBSnapshotIdentifier": {},
						"SnapshotType": {},
						"Filters": {
							"shape": "S27"
						},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeDBSnapshotsResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"DBSnapshots": {
							"type": "list",
							"member": {
								"shape": "Sk",
								"locationName": "DBSnapshot"
							}
						}
					}
				}
			},
			"DescribeDBSubnetGroups": {
				"input": {
					"type": "structure",
					"members": {
						"DBSubnetGroupName": {},
						"Filters": {
							"shape": "S27"
						},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeDBSubnetGroupsResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"DBSubnetGroups": {
							"type": "list",
							"member": {
								"shape": "S11",
								"locationName": "DBSubnetGroup"
							}
						}
					}
				}
			},
			"DescribeEngineDefaultParameters": {
				"input": {
					"type": "structure",
					"required": [
						"DBParameterGroupFamily"
					],
					"members": {
						"DBParameterGroupFamily": {},
						"Filters": {
							"shape": "S27"
						},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeEngineDefaultParametersResult",
					"type": "structure",
					"members": {
						"EngineDefaults": {
							"type": "structure",
							"members": {
								"DBParameterGroupFamily": {},
								"Marker": {},
								"Parameters": {
									"shape": "S2s"
								}
							},
							"wrapper": true
						}
					}
				}
			},
			"DescribeEventCategories": {
				"input": {
					"type": "structure",
					"members": {
						"SourceType": {},
						"Filters": {
							"shape": "S27"
						}
					}
				},
				"output": {
					"resultWrapper": "DescribeEventCategoriesResult",
					"type": "structure",
					"members": {
						"EventCategoriesMapList": {
							"type": "list",
							"member": {
								"locationName": "EventCategoriesMap",
								"type": "structure",
								"members": {
									"SourceType": {},
									"EventCategories": {
										"shape": "S6"
									}
								},
								"wrapper": true
							}
						}
					}
				}
			},
			"DescribeEventSubscriptions": {
				"input": {
					"type": "structure",
					"members": {
						"SubscriptionName": {},
						"Filters": {
							"shape": "S27"
						},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeEventSubscriptionsResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"EventSubscriptionsList": {
							"type": "list",
							"member": {
								"shape": "S4",
								"locationName": "EventSubscription"
							}
						}
					}
				}
			},
			"DescribeEvents": {
				"input": {
					"type": "structure",
					"members": {
						"SourceIdentifier": {},
						"SourceType": {},
						"StartTime": {
							"type": "timestamp"
						},
						"EndTime": {
							"type": "timestamp"
						},
						"Duration": {
							"type": "integer"
						},
						"EventCategories": {
							"shape": "S6"
						},
						"Filters": {
							"shape": "S27"
						},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeEventsResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"Events": {
							"type": "list",
							"member": {
								"locationName": "Event",
								"type": "structure",
								"members": {
									"SourceIdentifier": {},
									"SourceType": {},
									"Message": {},
									"EventCategories": {
										"shape": "S6"
									},
									"Date": {
										"type": "timestamp"
									}
								}
							}
						}
					}
				}
			},
			"DescribeOptionGroupOptions": {
				"input": {
					"type": "structure",
					"required": [
						"EngineName"
					],
					"members": {
						"EngineName": {},
						"MajorEngineVersion": {},
						"Filters": {
							"shape": "S27"
						},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeOptionGroupOptionsResult",
					"type": "structure",
					"members": {
						"OptionGroupOptions": {
							"type": "list",
							"member": {
								"locationName": "OptionGroupOption",
								"type": "structure",
								"members": {
									"Name": {},
									"Description": {},
									"EngineName": {},
									"MajorEngineVersion": {},
									"MinimumRequiredMinorEngineVersion": {},
									"PortRequired": {
										"type": "boolean"
									},
									"DefaultPort": {
										"type": "integer"
									},
									"OptionsDependedOn": {
										"type": "list",
										"member": {
											"locationName": "OptionName"
										}
									},
									"Persistent": {
										"type": "boolean"
									},
									"Permanent": {
										"type": "boolean"
									},
									"OptionGroupOptionSettings": {
										"type": "list",
										"member": {
											"locationName": "OptionGroupOptionSetting",
											"type": "structure",
											"members": {
												"SettingName": {},
												"SettingDescription": {},
												"DefaultValue": {},
												"ApplyType": {},
												"AllowedValues": {},
												"IsModifiable": {
													"type": "boolean"
												}
											}
										}
									}
								}
							}
						},
						"Marker": {}
					}
				}
			},
			"DescribeOptionGroups": {
				"input": {
					"type": "structure",
					"members": {
						"OptionGroupName": {},
						"Filters": {
							"shape": "S27"
						},
						"Marker": {},
						"MaxRecords": {
							"type": "integer"
						},
						"EngineName": {},
						"MajorEngineVersion": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeOptionGroupsResult",
					"type": "structure",
					"members": {
						"OptionGroupsList": {
							"type": "list",
							"member": {
								"shape": "S1r",
								"locationName": "OptionGroup"
							}
						},
						"Marker": {}
					}
				}
			},
			"DescribeOrderableDBInstanceOptions": {
				"input": {
					"type": "structure",
					"required": [
						"Engine"
					],
					"members": {
						"Engine": {},
						"EngineVersion": {},
						"DBInstanceClass": {},
						"LicenseModel": {},
						"Vpc": {
							"type": "boolean"
						},
						"Filters": {
							"shape": "S27"
						},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeOrderableDBInstanceOptionsResult",
					"type": "structure",
					"members": {
						"OrderableDBInstanceOptions": {
							"type": "list",
							"member": {
								"locationName": "OrderableDBInstanceOption",
								"type": "structure",
								"members": {
									"Engine": {},
									"EngineVersion": {},
									"DBInstanceClass": {},
									"LicenseModel": {},
									"AvailabilityZones": {
										"type": "list",
										"member": {
											"shape": "S14",
											"locationName": "AvailabilityZone"
										}
									},
									"MultiAZCapable": {
										"type": "boolean"
									},
									"ReadReplicaCapable": {
										"type": "boolean"
									},
									"Vpc": {
										"type": "boolean"
									}
								},
								"wrapper": true
							}
						},
						"Marker": {}
					}
				}
			},
			"DescribeReservedDBInstances": {
				"input": {
					"type": "structure",
					"members": {
						"ReservedDBInstanceId": {},
						"ReservedDBInstancesOfferingId": {},
						"DBInstanceClass": {},
						"Duration": {},
						"ProductDescription": {},
						"OfferingType": {},
						"MultiAZ": {
							"type": "boolean"
						},
						"Filters": {
							"shape": "S27"
						},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeReservedDBInstancesResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"ReservedDBInstances": {
							"type": "list",
							"member": {
								"shape": "S41",
								"locationName": "ReservedDBInstance"
							}
						}
					}
				}
			},
			"DescribeReservedDBInstancesOfferings": {
				"input": {
					"type": "structure",
					"members": {
						"ReservedDBInstancesOfferingId": {},
						"DBInstanceClass": {},
						"Duration": {},
						"ProductDescription": {},
						"OfferingType": {},
						"MultiAZ": {
							"type": "boolean"
						},
						"Filters": {
							"shape": "S27"
						},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeReservedDBInstancesOfferingsResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"ReservedDBInstancesOfferings": {
							"type": "list",
							"member": {
								"locationName": "ReservedDBInstancesOffering",
								"type": "structure",
								"members": {
									"ReservedDBInstancesOfferingId": {},
									"DBInstanceClass": {},
									"Duration": {
										"type": "integer"
									},
									"FixedPrice": {
										"type": "double"
									},
									"UsagePrice": {
										"type": "double"
									},
									"CurrencyCode": {},
									"ProductDescription": {},
									"OfferingType": {},
									"MultiAZ": {
										"type": "boolean"
									},
									"RecurringCharges": {
										"shape": "S43"
									}
								},
								"wrapper": true
							}
						}
					}
				}
			},
			"DownloadDBLogFilePortion": {
				"input": {
					"type": "structure",
					"required": [
						"DBInstanceIdentifier",
						"LogFileName"
					],
					"members": {
						"DBInstanceIdentifier": {},
						"LogFileName": {},
						"Marker": {},
						"NumberOfLines": {
							"type": "integer"
						}
					}
				},
				"output": {
					"resultWrapper": "DownloadDBLogFilePortionResult",
					"type": "structure",
					"members": {
						"LogFileData": {},
						"Marker": {},
						"AdditionalDataPending": {
							"type": "boolean"
						}
					}
				}
			},
			"ListTagsForResource": {
				"input": {
					"type": "structure",
					"required": [
						"ResourceName"
					],
					"members": {
						"ResourceName": {},
						"Filters": {
							"shape": "S27"
						}
					}
				},
				"output": {
					"resultWrapper": "ListTagsForResourceResult",
					"type": "structure",
					"members": {
						"TagList": {
							"shape": "S9"
						}
					}
				}
			},
			"ModifyDBInstance": {
				"input": {
					"type": "structure",
					"required": [
						"DBInstanceIdentifier"
					],
					"members": {
						"DBInstanceIdentifier": {},
						"AllocatedStorage": {
							"type": "integer"
						},
						"DBInstanceClass": {},
						"DBSecurityGroups": {
							"shape": "Sp"
						},
						"VpcSecurityGroupIds": {
							"shape": "Sq"
						},
						"ApplyImmediately": {
							"type": "boolean"
						},
						"MasterUserPassword": {},
						"DBParameterGroupName": {},
						"BackupRetentionPeriod": {
							"type": "integer"
						},
						"PreferredBackupWindow": {},
						"PreferredMaintenanceWindow": {},
						"MultiAZ": {
							"type": "boolean"
						},
						"EngineVersion": {},
						"AllowMajorVersionUpgrade": {
							"type": "boolean"
						},
						"AutoMinorVersionUpgrade": {
							"type": "boolean"
						},
						"Iops": {
							"type": "integer"
						},
						"OptionGroupName": {},
						"NewDBInstanceIdentifier": {}
					}
				},
				"output": {
					"resultWrapper": "ModifyDBInstanceResult",
					"type": "structure",
					"members": {
						"DBInstance": {
							"shape": "St"
						}
					}
				}
			},
			"ModifyDBParameterGroup": {
				"input": {
					"type": "structure",
					"required": [
						"DBParameterGroupName",
						"Parameters"
					],
					"members": {
						"DBParameterGroupName": {},
						"Parameters": {
							"shape": "S2s"
						}
					}
				},
				"output": {
					"shape": "S4g",
					"resultWrapper": "ModifyDBParameterGroupResult"
				}
			},
			"ModifyDBSubnetGroup": {
				"input": {
					"type": "structure",
					"required": [
						"DBSubnetGroupName",
						"SubnetIds"
					],
					"members": {
						"DBSubnetGroupName": {},
						"DBSubnetGroupDescription": {},
						"SubnetIds": {
							"shape": "S1l"
						}
					}
				},
				"output": {
					"resultWrapper": "ModifyDBSubnetGroupResult",
					"type": "structure",
					"members": {
						"DBSubnetGroup": {
							"shape": "S11"
						}
					}
				}
			},
			"ModifyEventSubscription": {
				"input": {
					"type": "structure",
					"required": [
						"SubscriptionName"
					],
					"members": {
						"SubscriptionName": {},
						"SnsTopicArn": {},
						"SourceType": {},
						"EventCategories": {
							"shape": "S6"
						},
						"Enabled": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"resultWrapper": "ModifyEventSubscriptionResult",
					"type": "structure",
					"members": {
						"EventSubscription": {
							"shape": "S4"
						}
					}
				}
			},
			"ModifyOptionGroup": {
				"input": {
					"type": "structure",
					"required": [
						"OptionGroupName"
					],
					"members": {
						"OptionGroupName": {},
						"OptionsToInclude": {
							"type": "list",
							"member": {
								"locationName": "OptionConfiguration",
								"type": "structure",
								"required": [
									"OptionName"
								],
								"members": {
									"OptionName": {},
									"Port": {
										"type": "integer"
									},
									"DBSecurityGroupMemberships": {
										"shape": "Sp"
									},
									"VpcSecurityGroupMemberships": {
										"shape": "Sq"
									},
									"OptionSettings": {
										"type": "list",
										"member": {
											"shape": "S1v",
											"locationName": "OptionSetting"
										}
									}
								}
							}
						},
						"OptionsToRemove": {
							"type": "list",
							"member": {}
						},
						"ApplyImmediately": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"resultWrapper": "ModifyOptionGroupResult",
					"type": "structure",
					"members": {
						"OptionGroup": {
							"shape": "S1r"
						}
					}
				}
			},
			"PromoteReadReplica": {
				"input": {
					"type": "structure",
					"required": [
						"DBInstanceIdentifier"
					],
					"members": {
						"DBInstanceIdentifier": {},
						"BackupRetentionPeriod": {
							"type": "integer"
						},
						"PreferredBackupWindow": {}
					}
				},
				"output": {
					"resultWrapper": "PromoteReadReplicaResult",
					"type": "structure",
					"members": {
						"DBInstance": {
							"shape": "St"
						}
					}
				}
			},
			"PurchaseReservedDBInstancesOffering": {
				"input": {
					"type": "structure",
					"required": [
						"ReservedDBInstancesOfferingId"
					],
					"members": {
						"ReservedDBInstancesOfferingId": {},
						"ReservedDBInstanceId": {},
						"DBInstanceCount": {
							"type": "integer"
						},
						"Tags": {
							"shape": "S9"
						}
					}
				},
				"output": {
					"resultWrapper": "PurchaseReservedDBInstancesOfferingResult",
					"type": "structure",
					"members": {
						"ReservedDBInstance": {
							"shape": "S41"
						}
					}
				}
			},
			"RebootDBInstance": {
				"input": {
					"type": "structure",
					"required": [
						"DBInstanceIdentifier"
					],
					"members": {
						"DBInstanceIdentifier": {},
						"ForceFailover": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"resultWrapper": "RebootDBInstanceResult",
					"type": "structure",
					"members": {
						"DBInstance": {
							"shape": "St"
						}
					}
				}
			},
			"RemoveSourceIdentifierFromSubscription": {
				"input": {
					"type": "structure",
					"required": [
						"SubscriptionName",
						"SourceIdentifier"
					],
					"members": {
						"SubscriptionName": {},
						"SourceIdentifier": {}
					}
				},
				"output": {
					"resultWrapper": "RemoveSourceIdentifierFromSubscriptionResult",
					"type": "structure",
					"members": {
						"EventSubscription": {
							"shape": "S4"
						}
					}
				}
			},
			"RemoveTagsFromResource": {
				"input": {
					"type": "structure",
					"required": [
						"ResourceName",
						"TagKeys"
					],
					"members": {
						"ResourceName": {},
						"TagKeys": {
							"type": "list",
							"member": {}
						}
					}
				}
			},
			"ResetDBParameterGroup": {
				"input": {
					"type": "structure",
					"required": [
						"DBParameterGroupName"
					],
					"members": {
						"DBParameterGroupName": {},
						"ResetAllParameters": {
							"type": "boolean"
						},
						"Parameters": {
							"shape": "S2s"
						}
					}
				},
				"output": {
					"shape": "S4g",
					"resultWrapper": "ResetDBParameterGroupResult"
				}
			},
			"RestoreDBInstanceFromDBSnapshot": {
				"input": {
					"type": "structure",
					"required": [
						"DBInstanceIdentifier",
						"DBSnapshotIdentifier"
					],
					"members": {
						"DBInstanceIdentifier": {},
						"DBSnapshotIdentifier": {},
						"DBInstanceClass": {},
						"Port": {
							"type": "integer"
						},
						"AvailabilityZone": {},
						"DBSubnetGroupName": {},
						"MultiAZ": {
							"type": "boolean"
						},
						"PubliclyAccessible": {
							"type": "boolean"
						},
						"AutoMinorVersionUpgrade": {
							"type": "boolean"
						},
						"LicenseModel": {},
						"DBName": {},
						"Engine": {},
						"Iops": {
							"type": "integer"
						},
						"OptionGroupName": {},
						"Tags": {
							"shape": "S9"
						}
					}
				},
				"output": {
					"resultWrapper": "RestoreDBInstanceFromDBSnapshotResult",
					"type": "structure",
					"members": {
						"DBInstance": {
							"shape": "St"
						}
					}
				}
			},
			"RestoreDBInstanceToPointInTime": {
				"input": {
					"type": "structure",
					"required": [
						"SourceDBInstanceIdentifier",
						"TargetDBInstanceIdentifier"
					],
					"members": {
						"SourceDBInstanceIdentifier": {},
						"TargetDBInstanceIdentifier": {},
						"RestoreTime": {
							"type": "timestamp"
						},
						"UseLatestRestorableTime": {
							"type": "boolean"
						},
						"DBInstanceClass": {},
						"Port": {
							"type": "integer"
						},
						"AvailabilityZone": {},
						"DBSubnetGroupName": {},
						"MultiAZ": {
							"type": "boolean"
						},
						"PubliclyAccessible": {
							"type": "boolean"
						},
						"AutoMinorVersionUpgrade": {
							"type": "boolean"
						},
						"LicenseModel": {},
						"DBName": {},
						"Engine": {},
						"Iops": {
							"type": "integer"
						},
						"OptionGroupName": {},
						"Tags": {
							"shape": "S9"
						}
					}
				},
				"output": {
					"resultWrapper": "RestoreDBInstanceToPointInTimeResult",
					"type": "structure",
					"members": {
						"DBInstance": {
							"shape": "St"
						}
					}
				}
			},
			"RevokeDBSecurityGroupIngress": {
				"input": {
					"type": "structure",
					"required": [
						"DBSecurityGroupName"
					],
					"members": {
						"DBSecurityGroupName": {},
						"CIDRIP": {},
						"EC2SecurityGroupName": {},
						"EC2SecurityGroupId": {},
						"EC2SecurityGroupOwnerId": {}
					}
				},
				"output": {
					"resultWrapper": "RevokeDBSecurityGroupIngressResult",
					"type": "structure",
					"members": {
						"DBSecurityGroup": {
							"shape": "Sd"
						}
					}
				}
			}
		},
		"shapes": {
			"S4": {
				"type": "structure",
				"members": {
					"CustomerAwsId": {},
					"CustSubscriptionId": {},
					"SnsTopicArn": {},
					"Status": {},
					"SubscriptionCreationTime": {},
					"SourceType": {},
					"SourceIdsList": {
						"shape": "S5"
					},
					"EventCategoriesList": {
						"shape": "S6"
					},
					"Enabled": {
						"type": "boolean"
					}
				},
				"wrapper": true
			},
			"S5": {
				"type": "list",
				"member": {
					"locationName": "SourceId"
				}
			},
			"S6": {
				"type": "list",
				"member": {
					"locationName": "EventCategory"
				}
			},
			"S9": {
				"type": "list",
				"member": {
					"locationName": "Tag",
					"type": "structure",
					"members": {
						"Key": {},
						"Value": {}
					}
				}
			},
			"Sd": {
				"type": "structure",
				"members": {
					"OwnerId": {},
					"DBSecurityGroupName": {},
					"DBSecurityGroupDescription": {},
					"VpcId": {},
					"EC2SecurityGroups": {
						"type": "list",
						"member": {
							"locationName": "EC2SecurityGroup",
							"type": "structure",
							"members": {
								"Status": {},
								"EC2SecurityGroupName": {},
								"EC2SecurityGroupId": {},
								"EC2SecurityGroupOwnerId": {}
							}
						}
					},
					"IPRanges": {
						"type": "list",
						"member": {
							"locationName": "IPRange",
							"type": "structure",
							"members": {
								"Status": {},
								"CIDRIP": {}
							}
						}
					}
				},
				"wrapper": true
			},
			"Sk": {
				"type": "structure",
				"members": {
					"DBSnapshotIdentifier": {},
					"DBInstanceIdentifier": {},
					"SnapshotCreateTime": {
						"type": "timestamp"
					},
					"Engine": {},
					"AllocatedStorage": {
						"type": "integer"
					},
					"Status": {},
					"Port": {
						"type": "integer"
					},
					"AvailabilityZone": {},
					"VpcId": {},
					"InstanceCreateTime": {
						"type": "timestamp"
					},
					"MasterUsername": {},
					"EngineVersion": {},
					"LicenseModel": {},
					"SnapshotType": {},
					"Iops": {
						"type": "integer"
					},
					"OptionGroupName": {},
					"PercentProgress": {
						"type": "integer"
					},
					"SourceRegion": {}
				},
				"wrapper": true
			},
			"Sp": {
				"type": "list",
				"member": {
					"locationName": "DBSecurityGroupName"
				}
			},
			"Sq": {
				"type": "list",
				"member": {
					"locationName": "VpcSecurityGroupId"
				}
			},
			"St": {
				"type": "structure",
				"members": {
					"DBInstanceIdentifier": {},
					"DBInstanceClass": {},
					"Engine": {},
					"DBInstanceStatus": {},
					"MasterUsername": {},
					"DBName": {},
					"Endpoint": {
						"type": "structure",
						"members": {
							"Address": {},
							"Port": {
								"type": "integer"
							}
						}
					},
					"AllocatedStorage": {
						"type": "integer"
					},
					"InstanceCreateTime": {
						"type": "timestamp"
					},
					"PreferredBackupWindow": {},
					"BackupRetentionPeriod": {
						"type": "integer"
					},
					"DBSecurityGroups": {
						"shape": "Sv"
					},
					"VpcSecurityGroups": {
						"shape": "Sx"
					},
					"DBParameterGroups": {
						"type": "list",
						"member": {
							"locationName": "DBParameterGroup",
							"type": "structure",
							"members": {
								"DBParameterGroupName": {},
								"ParameterApplyStatus": {}
							}
						}
					},
					"AvailabilityZone": {},
					"DBSubnetGroup": {
						"shape": "S11"
					},
					"PreferredMaintenanceWindow": {},
					"PendingModifiedValues": {
						"type": "structure",
						"members": {
							"DBInstanceClass": {},
							"AllocatedStorage": {
								"type": "integer"
							},
							"MasterUserPassword": {},
							"Port": {
								"type": "integer"
							},
							"BackupRetentionPeriod": {
								"type": "integer"
							},
							"MultiAZ": {
								"type": "boolean"
							},
							"EngineVersion": {},
							"Iops": {
								"type": "integer"
							},
							"DBInstanceIdentifier": {}
						}
					},
					"LatestRestorableTime": {
						"type": "timestamp"
					},
					"MultiAZ": {
						"type": "boolean"
					},
					"EngineVersion": {},
					"AutoMinorVersionUpgrade": {
						"type": "boolean"
					},
					"ReadReplicaSourceDBInstanceIdentifier": {},
					"ReadReplicaDBInstanceIdentifiers": {
						"type": "list",
						"member": {
							"locationName": "ReadReplicaDBInstanceIdentifier"
						}
					},
					"LicenseModel": {},
					"Iops": {
						"type": "integer"
					},
					"OptionGroupMemberships": {
						"type": "list",
						"member": {
							"locationName": "OptionGroupMembership",
							"type": "structure",
							"members": {
								"OptionGroupName": {},
								"Status": {}
							}
						}
					},
					"CharacterSetName": {},
					"SecondaryAvailabilityZone": {},
					"PubliclyAccessible": {
						"type": "boolean"
					},
					"StatusInfos": {
						"type": "list",
						"member": {
							"locationName": "DBInstanceStatusInfo",
							"type": "structure",
							"members": {
								"StatusType": {},
								"Normal": {
									"type": "boolean"
								},
								"Status": {},
								"Message": {}
							}
						}
					}
				},
				"wrapper": true
			},
			"Sv": {
				"type": "list",
				"member": {
					"locationName": "DBSecurityGroup",
					"type": "structure",
					"members": {
						"DBSecurityGroupName": {},
						"Status": {}
					}
				}
			},
			"Sx": {
				"type": "list",
				"member": {
					"locationName": "VpcSecurityGroupMembership",
					"type": "structure",
					"members": {
						"VpcSecurityGroupId": {},
						"Status": {}
					}
				}
			},
			"S11": {
				"type": "structure",
				"members": {
					"DBSubnetGroupName": {},
					"DBSubnetGroupDescription": {},
					"VpcId": {},
					"SubnetGroupStatus": {},
					"Subnets": {
						"type": "list",
						"member": {
							"locationName": "Subnet",
							"type": "structure",
							"members": {
								"SubnetIdentifier": {},
								"SubnetAvailabilityZone": {
									"shape": "S14"
								},
								"SubnetStatus": {}
							}
						}
					}
				},
				"wrapper": true
			},
			"S14": {
				"type": "structure",
				"members": {
					"Name": {},
					"ProvisionedIopsCapable": {
						"type": "boolean"
					}
				},
				"wrapper": true
			},
			"S1f": {
				"type": "structure",
				"members": {
					"DBParameterGroupName": {},
					"DBParameterGroupFamily": {},
					"Description": {}
				},
				"wrapper": true
			},
			"S1l": {
				"type": "list",
				"member": {
					"locationName": "SubnetIdentifier"
				}
			},
			"S1r": {
				"type": "structure",
				"members": {
					"OptionGroupName": {},
					"OptionGroupDescription": {},
					"EngineName": {},
					"MajorEngineVersion": {},
					"Options": {
						"type": "list",
						"member": {
							"locationName": "Option",
							"type": "structure",
							"members": {
								"OptionName": {},
								"OptionDescription": {},
								"Persistent": {
									"type": "boolean"
								},
								"Permanent": {
									"type": "boolean"
								},
								"Port": {
									"type": "integer"
								},
								"OptionSettings": {
									"type": "list",
									"member": {
										"shape": "S1v",
										"locationName": "OptionSetting"
									}
								},
								"DBSecurityGroupMemberships": {
									"shape": "Sv"
								},
								"VpcSecurityGroupMemberships": {
									"shape": "Sx"
								}
							}
						}
					},
					"AllowsVpcAndNonVpcInstanceMemberships": {
						"type": "boolean"
					},
					"VpcId": {}
				},
				"wrapper": true
			},
			"S1v": {
				"type": "structure",
				"members": {
					"Name": {},
					"Value": {},
					"DefaultValue": {},
					"Description": {},
					"ApplyType": {},
					"DataType": {},
					"AllowedValues": {},
					"IsModifiable": {
						"type": "boolean"
					},
					"IsCollection": {
						"type": "boolean"
					}
				}
			},
			"S27": {
				"type": "list",
				"member": {
					"locationName": "Filter",
					"type": "structure",
					"required": [
						"Name",
						"Values"
					],
					"members": {
						"Name": {},
						"Values": {
							"type": "list",
							"member": {
								"locationName": "Value"
							}
						}
					}
				}
			},
			"S2d": {
				"type": "structure",
				"members": {
					"CharacterSetName": {},
					"CharacterSetDescription": {}
				}
			},
			"S2s": {
				"type": "list",
				"member": {
					"locationName": "Parameter",
					"type": "structure",
					"members": {
						"ParameterName": {},
						"ParameterValue": {},
						"Description": {},
						"Source": {},
						"ApplyType": {},
						"DataType": {},
						"AllowedValues": {},
						"IsModifiable": {
							"type": "boolean"
						},
						"MinimumEngineVersion": {},
						"ApplyMethod": {}
					}
				}
			},
			"S41": {
				"type": "structure",
				"members": {
					"ReservedDBInstanceId": {},
					"ReservedDBInstancesOfferingId": {},
					"DBInstanceClass": {},
					"StartTime": {
						"type": "timestamp"
					},
					"Duration": {
						"type": "integer"
					},
					"FixedPrice": {
						"type": "double"
					},
					"UsagePrice": {
						"type": "double"
					},
					"CurrencyCode": {},
					"DBInstanceCount": {
						"type": "integer"
					},
					"ProductDescription": {},
					"OfferingType": {},
					"MultiAZ": {
						"type": "boolean"
					},
					"State": {},
					"RecurringCharges": {
						"shape": "S43"
					}
				},
				"wrapper": true
			},
			"S43": {
				"type": "list",
				"member": {
					"locationName": "RecurringCharge",
					"type": "structure",
					"members": {
						"RecurringChargeAmount": {
							"type": "double"
						},
						"RecurringChargeFrequency": {}
					},
					"wrapper": true
				}
			},
			"S4g": {
				"type": "structure",
				"members": {
					"DBParameterGroupName": {}
				}
			}
		}
	};

/***/ },
/* 423 */
/***/ function(module, exports) {

	module.exports = {
		"pagination": {
			"DescribeDBEngineVersions": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "DBEngineVersions"
			},
			"DescribeDBInstances": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "DBInstances"
			},
			"DescribeDBLogFiles": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "DescribeDBLogFiles"
			},
			"DescribeDBParameterGroups": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "DBParameterGroups"
			},
			"DescribeDBParameters": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "Parameters"
			},
			"DescribeDBSecurityGroups": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "DBSecurityGroups"
			},
			"DescribeDBSnapshots": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "DBSnapshots"
			},
			"DescribeDBSubnetGroups": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "DBSubnetGroups"
			},
			"DescribeEngineDefaultParameters": {
				"input_token": "Marker",
				"output_token": "EngineDefaults.Marker",
				"limit_key": "MaxRecords",
				"result_key": "EngineDefaults.Parameters"
			},
			"DescribeEventSubscriptions": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "EventSubscriptionsList"
			},
			"DescribeEvents": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "Events"
			},
			"DescribeOptionGroupOptions": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "OptionGroupOptions"
			},
			"DescribeOptionGroups": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "OptionGroupsList"
			},
			"DescribeOrderableDBInstanceOptions": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "OrderableDBInstanceOptions"
			},
			"DescribeReservedDBInstances": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "ReservedDBInstances"
			},
			"DescribeReservedDBInstancesOfferings": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "ReservedDBInstancesOfferings"
			},
			"DownloadDBLogFilePortion": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "NumberOfLines",
				"more_results": "AdditionalDataPending",
				"result_key": "LogFileData"
			},
			"ListTagsForResource": {
				"result_key": "TagList"
			}
		}
	};

/***/ },
/* 424 */
/***/ function(module, exports) {

	module.exports = {
		"version": 2,
		"waiters": {
			"DBInstanceAvailable": {
				"delay": 30,
				"operation": "DescribeDBInstances",
				"maxAttempts": 60,
				"acceptors": [
					{
						"expected": "available",
						"matcher": "pathAll",
						"state": "success",
						"argument": "DBInstances[].DBInstanceStatus"
					},
					{
						"expected": "deleted",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "DBInstances[].DBInstanceStatus"
					},
					{
						"expected": "deleting",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "DBInstances[].DBInstanceStatus"
					},
					{
						"expected": "failed",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "DBInstances[].DBInstanceStatus"
					},
					{
						"expected": "incompatible-restore",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "DBInstances[].DBInstanceStatus"
					},
					{
						"expected": "incompatible-parameters",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "DBInstances[].DBInstanceStatus"
					},
					{
						"expected": "incompatible-parameters",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "DBInstances[].DBInstanceStatus"
					},
					{
						"expected": "incompatible-restore",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "DBInstances[].DBInstanceStatus"
					}
				]
			},
			"DBInstanceDeleted": {
				"delay": 30,
				"operation": "DescribeDBInstances",
				"maxAttempts": 60,
				"acceptors": [
					{
						"expected": "deleted",
						"matcher": "pathAll",
						"state": "success",
						"argument": "DBInstances[].DBInstanceStatus"
					},
					{
						"expected": "creating",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "DBInstances[].DBInstanceStatus"
					},
					{
						"expected": "modifying",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "DBInstances[].DBInstanceStatus"
					},
					{
						"expected": "rebooting",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "DBInstances[].DBInstanceStatus"
					},
					{
						"expected": "resetting-master-credentials",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "DBInstances[].DBInstanceStatus"
					}
				]
			}
		}
	};

/***/ },
/* 425 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2014-10-31",
			"endpointPrefix": "rds",
			"protocol": "query",
			"serviceAbbreviation": "Amazon RDS",
			"serviceFullName": "Amazon Relational Database Service",
			"signatureVersion": "v4",
			"xmlNamespace": "http://rds.amazonaws.com/doc/2014-10-31/"
		},
		"operations": {
			"AddRoleToDBCluster": {
				"input": {
					"type": "structure",
					"required": [
						"DBClusterIdentifier",
						"RoleArn"
					],
					"members": {
						"DBClusterIdentifier": {},
						"RoleArn": {}
					}
				}
			},
			"AddSourceIdentifierToSubscription": {
				"input": {
					"type": "structure",
					"required": [
						"SubscriptionName",
						"SourceIdentifier"
					],
					"members": {
						"SubscriptionName": {},
						"SourceIdentifier": {}
					}
				},
				"output": {
					"resultWrapper": "AddSourceIdentifierToSubscriptionResult",
					"type": "structure",
					"members": {
						"EventSubscription": {
							"shape": "S5"
						}
					}
				}
			},
			"AddTagsToResource": {
				"input": {
					"type": "structure",
					"required": [
						"ResourceName",
						"Tags"
					],
					"members": {
						"ResourceName": {},
						"Tags": {
							"shape": "Sa"
						}
					}
				}
			},
			"ApplyPendingMaintenanceAction": {
				"input": {
					"type": "structure",
					"required": [
						"ResourceIdentifier",
						"ApplyAction",
						"OptInType"
					],
					"members": {
						"ResourceIdentifier": {},
						"ApplyAction": {},
						"OptInType": {}
					}
				},
				"output": {
					"resultWrapper": "ApplyPendingMaintenanceActionResult",
					"type": "structure",
					"members": {
						"ResourcePendingMaintenanceActions": {
							"shape": "Se"
						}
					}
				}
			},
			"AuthorizeDBSecurityGroupIngress": {
				"input": {
					"type": "structure",
					"required": [
						"DBSecurityGroupName"
					],
					"members": {
						"DBSecurityGroupName": {},
						"CIDRIP": {},
						"EC2SecurityGroupName": {},
						"EC2SecurityGroupId": {},
						"EC2SecurityGroupOwnerId": {}
					}
				},
				"output": {
					"resultWrapper": "AuthorizeDBSecurityGroupIngressResult",
					"type": "structure",
					"members": {
						"DBSecurityGroup": {
							"shape": "Sk"
						}
					}
				}
			},
			"CopyDBClusterParameterGroup": {
				"input": {
					"type": "structure",
					"required": [
						"SourceDBClusterParameterGroupIdentifier",
						"TargetDBClusterParameterGroupIdentifier",
						"TargetDBClusterParameterGroupDescription"
					],
					"members": {
						"SourceDBClusterParameterGroupIdentifier": {},
						"TargetDBClusterParameterGroupIdentifier": {},
						"TargetDBClusterParameterGroupDescription": {},
						"Tags": {
							"shape": "Sa"
						}
					}
				},
				"output": {
					"resultWrapper": "CopyDBClusterParameterGroupResult",
					"type": "structure",
					"members": {
						"DBClusterParameterGroup": {
							"shape": "Sr"
						}
					}
				}
			},
			"CopyDBClusterSnapshot": {
				"input": {
					"type": "structure",
					"required": [
						"SourceDBClusterSnapshotIdentifier",
						"TargetDBClusterSnapshotIdentifier"
					],
					"members": {
						"SourceDBClusterSnapshotIdentifier": {},
						"TargetDBClusterSnapshotIdentifier": {},
						"Tags": {
							"shape": "Sa"
						}
					}
				},
				"output": {
					"resultWrapper": "CopyDBClusterSnapshotResult",
					"type": "structure",
					"members": {
						"DBClusterSnapshot": {
							"shape": "Su"
						}
					}
				}
			},
			"CopyDBParameterGroup": {
				"input": {
					"type": "structure",
					"required": [
						"SourceDBParameterGroupIdentifier",
						"TargetDBParameterGroupIdentifier",
						"TargetDBParameterGroupDescription"
					],
					"members": {
						"SourceDBParameterGroupIdentifier": {},
						"TargetDBParameterGroupIdentifier": {},
						"TargetDBParameterGroupDescription": {},
						"Tags": {
							"shape": "Sa"
						}
					}
				},
				"output": {
					"resultWrapper": "CopyDBParameterGroupResult",
					"type": "structure",
					"members": {
						"DBParameterGroup": {
							"shape": "Sz"
						}
					}
				}
			},
			"CopyDBSnapshot": {
				"input": {
					"type": "structure",
					"required": [
						"SourceDBSnapshotIdentifier",
						"TargetDBSnapshotIdentifier"
					],
					"members": {
						"SourceDBSnapshotIdentifier": {},
						"TargetDBSnapshotIdentifier": {},
						"KmsKeyId": {},
						"Tags": {
							"shape": "Sa"
						},
						"CopyTags": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"resultWrapper": "CopyDBSnapshotResult",
					"type": "structure",
					"members": {
						"DBSnapshot": {
							"shape": "S13"
						}
					}
				}
			},
			"CopyOptionGroup": {
				"input": {
					"type": "structure",
					"required": [
						"SourceOptionGroupIdentifier",
						"TargetOptionGroupIdentifier",
						"TargetOptionGroupDescription"
					],
					"members": {
						"SourceOptionGroupIdentifier": {},
						"TargetOptionGroupIdentifier": {},
						"TargetOptionGroupDescription": {},
						"Tags": {
							"shape": "Sa"
						}
					}
				},
				"output": {
					"resultWrapper": "CopyOptionGroupResult",
					"type": "structure",
					"members": {
						"OptionGroup": {
							"shape": "S17"
						}
					}
				}
			},
			"CreateDBCluster": {
				"input": {
					"type": "structure",
					"required": [
						"DBClusterIdentifier",
						"Engine"
					],
					"members": {
						"AvailabilityZones": {
							"shape": "Sv"
						},
						"BackupRetentionPeriod": {
							"type": "integer"
						},
						"CharacterSetName": {},
						"DatabaseName": {},
						"DBClusterIdentifier": {},
						"DBClusterParameterGroupName": {},
						"VpcSecurityGroupIds": {
							"shape": "S1h"
						},
						"DBSubnetGroupName": {},
						"Engine": {},
						"EngineVersion": {},
						"Port": {
							"type": "integer"
						},
						"MasterUsername": {},
						"MasterUserPassword": {},
						"OptionGroupName": {},
						"PreferredBackupWindow": {},
						"PreferredMaintenanceWindow": {},
						"ReplicationSourceIdentifier": {},
						"Tags": {
							"shape": "Sa"
						},
						"StorageEncrypted": {
							"type": "boolean"
						},
						"KmsKeyId": {}
					}
				},
				"output": {
					"resultWrapper": "CreateDBClusterResult",
					"type": "structure",
					"members": {
						"DBCluster": {
							"shape": "S1j"
						}
					}
				}
			},
			"CreateDBClusterParameterGroup": {
				"input": {
					"type": "structure",
					"required": [
						"DBClusterParameterGroupName",
						"DBParameterGroupFamily",
						"Description"
					],
					"members": {
						"DBClusterParameterGroupName": {},
						"DBParameterGroupFamily": {},
						"Description": {},
						"Tags": {
							"shape": "Sa"
						}
					}
				},
				"output": {
					"resultWrapper": "CreateDBClusterParameterGroupResult",
					"type": "structure",
					"members": {
						"DBClusterParameterGroup": {
							"shape": "Sr"
						}
					}
				}
			},
			"CreateDBClusterSnapshot": {
				"input": {
					"type": "structure",
					"required": [
						"DBClusterSnapshotIdentifier",
						"DBClusterIdentifier"
					],
					"members": {
						"DBClusterSnapshotIdentifier": {},
						"DBClusterIdentifier": {},
						"Tags": {
							"shape": "Sa"
						}
					}
				},
				"output": {
					"resultWrapper": "CreateDBClusterSnapshotResult",
					"type": "structure",
					"members": {
						"DBClusterSnapshot": {
							"shape": "Su"
						}
					}
				}
			},
			"CreateDBInstance": {
				"input": {
					"type": "structure",
					"required": [
						"DBInstanceIdentifier",
						"DBInstanceClass",
						"Engine"
					],
					"members": {
						"DBName": {},
						"DBInstanceIdentifier": {},
						"AllocatedStorage": {
							"type": "integer"
						},
						"DBInstanceClass": {},
						"Engine": {},
						"MasterUsername": {},
						"MasterUserPassword": {},
						"DBSecurityGroups": {
							"shape": "S1w"
						},
						"VpcSecurityGroupIds": {
							"shape": "S1h"
						},
						"AvailabilityZone": {},
						"DBSubnetGroupName": {},
						"PreferredMaintenanceWindow": {},
						"DBParameterGroupName": {},
						"BackupRetentionPeriod": {
							"type": "integer"
						},
						"PreferredBackupWindow": {},
						"Port": {
							"type": "integer"
						},
						"MultiAZ": {
							"type": "boolean"
						},
						"EngineVersion": {},
						"AutoMinorVersionUpgrade": {
							"type": "boolean"
						},
						"LicenseModel": {},
						"Iops": {
							"type": "integer"
						},
						"OptionGroupName": {},
						"CharacterSetName": {},
						"PubliclyAccessible": {
							"type": "boolean"
						},
						"Tags": {
							"shape": "Sa"
						},
						"DBClusterIdentifier": {},
						"StorageType": {},
						"TdeCredentialArn": {},
						"TdeCredentialPassword": {},
						"StorageEncrypted": {
							"type": "boolean"
						},
						"KmsKeyId": {},
						"Domain": {},
						"CopyTagsToSnapshot": {
							"type": "boolean"
						},
						"MonitoringInterval": {
							"type": "integer"
						},
						"MonitoringRoleArn": {},
						"DomainIAMRoleName": {},
						"PromotionTier": {
							"type": "integer"
						},
						"Timezone": {}
					}
				},
				"output": {
					"resultWrapper": "CreateDBInstanceResult",
					"type": "structure",
					"members": {
						"DBInstance": {
							"shape": "S1y"
						}
					}
				}
			},
			"CreateDBInstanceReadReplica": {
				"input": {
					"type": "structure",
					"required": [
						"DBInstanceIdentifier",
						"SourceDBInstanceIdentifier"
					],
					"members": {
						"DBInstanceIdentifier": {},
						"SourceDBInstanceIdentifier": {},
						"DBInstanceClass": {},
						"AvailabilityZone": {},
						"Port": {
							"type": "integer"
						},
						"AutoMinorVersionUpgrade": {
							"type": "boolean"
						},
						"Iops": {
							"type": "integer"
						},
						"OptionGroupName": {},
						"PubliclyAccessible": {
							"type": "boolean"
						},
						"Tags": {
							"shape": "Sa"
						},
						"DBSubnetGroupName": {},
						"StorageType": {},
						"CopyTagsToSnapshot": {
							"type": "boolean"
						},
						"MonitoringInterval": {
							"type": "integer"
						},
						"MonitoringRoleArn": {}
					}
				},
				"output": {
					"resultWrapper": "CreateDBInstanceReadReplicaResult",
					"type": "structure",
					"members": {
						"DBInstance": {
							"shape": "S1y"
						}
					}
				}
			},
			"CreateDBParameterGroup": {
				"input": {
					"type": "structure",
					"required": [
						"DBParameterGroupName",
						"DBParameterGroupFamily",
						"Description"
					],
					"members": {
						"DBParameterGroupName": {},
						"DBParameterGroupFamily": {},
						"Description": {},
						"Tags": {
							"shape": "Sa"
						}
					}
				},
				"output": {
					"resultWrapper": "CreateDBParameterGroupResult",
					"type": "structure",
					"members": {
						"DBParameterGroup": {
							"shape": "Sz"
						}
					}
				}
			},
			"CreateDBSecurityGroup": {
				"input": {
					"type": "structure",
					"required": [
						"DBSecurityGroupName",
						"DBSecurityGroupDescription"
					],
					"members": {
						"DBSecurityGroupName": {},
						"DBSecurityGroupDescription": {},
						"Tags": {
							"shape": "Sa"
						}
					}
				},
				"output": {
					"resultWrapper": "CreateDBSecurityGroupResult",
					"type": "structure",
					"members": {
						"DBSecurityGroup": {
							"shape": "Sk"
						}
					}
				}
			},
			"CreateDBSnapshot": {
				"input": {
					"type": "structure",
					"required": [
						"DBSnapshotIdentifier",
						"DBInstanceIdentifier"
					],
					"members": {
						"DBSnapshotIdentifier": {},
						"DBInstanceIdentifier": {},
						"Tags": {
							"shape": "Sa"
						}
					}
				},
				"output": {
					"resultWrapper": "CreateDBSnapshotResult",
					"type": "structure",
					"members": {
						"DBSnapshot": {
							"shape": "S13"
						}
					}
				}
			},
			"CreateDBSubnetGroup": {
				"input": {
					"type": "structure",
					"required": [
						"DBSubnetGroupName",
						"DBSubnetGroupDescription",
						"SubnetIds"
					],
					"members": {
						"DBSubnetGroupName": {},
						"DBSubnetGroupDescription": {},
						"SubnetIds": {
							"shape": "S2n"
						},
						"Tags": {
							"shape": "Sa"
						}
					}
				},
				"output": {
					"resultWrapper": "CreateDBSubnetGroupResult",
					"type": "structure",
					"members": {
						"DBSubnetGroup": {
							"shape": "S22"
						}
					}
				}
			},
			"CreateEventSubscription": {
				"input": {
					"type": "structure",
					"required": [
						"SubscriptionName",
						"SnsTopicArn"
					],
					"members": {
						"SubscriptionName": {},
						"SnsTopicArn": {},
						"SourceType": {},
						"EventCategories": {
							"shape": "S7"
						},
						"SourceIds": {
							"shape": "S6"
						},
						"Enabled": {
							"type": "boolean"
						},
						"Tags": {
							"shape": "Sa"
						}
					}
				},
				"output": {
					"resultWrapper": "CreateEventSubscriptionResult",
					"type": "structure",
					"members": {
						"EventSubscription": {
							"shape": "S5"
						}
					}
				}
			},
			"CreateOptionGroup": {
				"input": {
					"type": "structure",
					"required": [
						"OptionGroupName",
						"EngineName",
						"MajorEngineVersion",
						"OptionGroupDescription"
					],
					"members": {
						"OptionGroupName": {},
						"EngineName": {},
						"MajorEngineVersion": {},
						"OptionGroupDescription": {},
						"Tags": {
							"shape": "Sa"
						}
					}
				},
				"output": {
					"resultWrapper": "CreateOptionGroupResult",
					"type": "structure",
					"members": {
						"OptionGroup": {
							"shape": "S17"
						}
					}
				}
			},
			"DeleteDBCluster": {
				"input": {
					"type": "structure",
					"required": [
						"DBClusterIdentifier"
					],
					"members": {
						"DBClusterIdentifier": {},
						"SkipFinalSnapshot": {
							"type": "boolean"
						},
						"FinalDBSnapshotIdentifier": {}
					}
				},
				"output": {
					"resultWrapper": "DeleteDBClusterResult",
					"type": "structure",
					"members": {
						"DBCluster": {
							"shape": "S1j"
						}
					}
				}
			},
			"DeleteDBClusterParameterGroup": {
				"input": {
					"type": "structure",
					"required": [
						"DBClusterParameterGroupName"
					],
					"members": {
						"DBClusterParameterGroupName": {}
					}
				}
			},
			"DeleteDBClusterSnapshot": {
				"input": {
					"type": "structure",
					"required": [
						"DBClusterSnapshotIdentifier"
					],
					"members": {
						"DBClusterSnapshotIdentifier": {}
					}
				},
				"output": {
					"resultWrapper": "DeleteDBClusterSnapshotResult",
					"type": "structure",
					"members": {
						"DBClusterSnapshot": {
							"shape": "Su"
						}
					}
				}
			},
			"DeleteDBInstance": {
				"input": {
					"type": "structure",
					"required": [
						"DBInstanceIdentifier"
					],
					"members": {
						"DBInstanceIdentifier": {},
						"SkipFinalSnapshot": {
							"type": "boolean"
						},
						"FinalDBSnapshotIdentifier": {}
					}
				},
				"output": {
					"resultWrapper": "DeleteDBInstanceResult",
					"type": "structure",
					"members": {
						"DBInstance": {
							"shape": "S1y"
						}
					}
				}
			},
			"DeleteDBParameterGroup": {
				"input": {
					"type": "structure",
					"required": [
						"DBParameterGroupName"
					],
					"members": {
						"DBParameterGroupName": {}
					}
				}
			},
			"DeleteDBSecurityGroup": {
				"input": {
					"type": "structure",
					"required": [
						"DBSecurityGroupName"
					],
					"members": {
						"DBSecurityGroupName": {}
					}
				}
			},
			"DeleteDBSnapshot": {
				"input": {
					"type": "structure",
					"required": [
						"DBSnapshotIdentifier"
					],
					"members": {
						"DBSnapshotIdentifier": {}
					}
				},
				"output": {
					"resultWrapper": "DeleteDBSnapshotResult",
					"type": "structure",
					"members": {
						"DBSnapshot": {
							"shape": "S13"
						}
					}
				}
			},
			"DeleteDBSubnetGroup": {
				"input": {
					"type": "structure",
					"required": [
						"DBSubnetGroupName"
					],
					"members": {
						"DBSubnetGroupName": {}
					}
				}
			},
			"DeleteEventSubscription": {
				"input": {
					"type": "structure",
					"required": [
						"SubscriptionName"
					],
					"members": {
						"SubscriptionName": {}
					}
				},
				"output": {
					"resultWrapper": "DeleteEventSubscriptionResult",
					"type": "structure",
					"members": {
						"EventSubscription": {
							"shape": "S5"
						}
					}
				}
			},
			"DeleteOptionGroup": {
				"input": {
					"type": "structure",
					"required": [
						"OptionGroupName"
					],
					"members": {
						"OptionGroupName": {}
					}
				}
			},
			"DescribeAccountAttributes": {
				"input": {
					"type": "structure",
					"members": {}
				},
				"output": {
					"resultWrapper": "DescribeAccountAttributesResult",
					"type": "structure",
					"members": {
						"AccountQuotas": {
							"type": "list",
							"member": {
								"locationName": "AccountQuota",
								"type": "structure",
								"members": {
									"AccountQuotaName": {},
									"Used": {
										"type": "long"
									},
									"Max": {
										"type": "long"
									}
								},
								"wrapper": true
							}
						}
					}
				}
			},
			"DescribeCertificates": {
				"input": {
					"type": "structure",
					"members": {
						"CertificateIdentifier": {},
						"Filters": {
							"shape": "S3e"
						},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeCertificatesResult",
					"type": "structure",
					"members": {
						"Certificates": {
							"type": "list",
							"member": {
								"locationName": "Certificate",
								"type": "structure",
								"members": {
									"CertificateIdentifier": {},
									"CertificateType": {},
									"Thumbprint": {},
									"ValidFrom": {
										"type": "timestamp"
									},
									"ValidTill": {
										"type": "timestamp"
									},
									"CertificateArn": {}
								},
								"wrapper": true
							}
						},
						"Marker": {}
					}
				}
			},
			"DescribeDBClusterParameterGroups": {
				"input": {
					"type": "structure",
					"members": {
						"DBClusterParameterGroupName": {},
						"Filters": {
							"shape": "S3e"
						},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeDBClusterParameterGroupsResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"DBClusterParameterGroups": {
							"type": "list",
							"member": {
								"shape": "Sr",
								"locationName": "DBClusterParameterGroup"
							}
						}
					}
				}
			},
			"DescribeDBClusterParameters": {
				"input": {
					"type": "structure",
					"required": [
						"DBClusterParameterGroupName"
					],
					"members": {
						"DBClusterParameterGroupName": {},
						"Source": {},
						"Filters": {
							"shape": "S3e"
						},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeDBClusterParametersResult",
					"type": "structure",
					"members": {
						"Parameters": {
							"shape": "S3p"
						},
						"Marker": {}
					}
				}
			},
			"DescribeDBClusterSnapshotAttributes": {
				"input": {
					"type": "structure",
					"required": [
						"DBClusterSnapshotIdentifier"
					],
					"members": {
						"DBClusterSnapshotIdentifier": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeDBClusterSnapshotAttributesResult",
					"type": "structure",
					"members": {
						"DBClusterSnapshotAttributesResult": {
							"shape": "S3u"
						}
					}
				}
			},
			"DescribeDBClusterSnapshots": {
				"input": {
					"type": "structure",
					"members": {
						"DBClusterIdentifier": {},
						"DBClusterSnapshotIdentifier": {},
						"SnapshotType": {},
						"Filters": {
							"shape": "S3e"
						},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {},
						"IncludeShared": {
							"type": "boolean"
						},
						"IncludePublic": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"resultWrapper": "DescribeDBClusterSnapshotsResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"DBClusterSnapshots": {
							"type": "list",
							"member": {
								"shape": "Su",
								"locationName": "DBClusterSnapshot"
							}
						}
					}
				}
			},
			"DescribeDBClusters": {
				"input": {
					"type": "structure",
					"members": {
						"DBClusterIdentifier": {},
						"Filters": {
							"shape": "S3e"
						},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeDBClustersResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"DBClusters": {
							"type": "list",
							"member": {
								"shape": "S1j",
								"locationName": "DBCluster"
							}
						}
					}
				}
			},
			"DescribeDBEngineVersions": {
				"input": {
					"type": "structure",
					"members": {
						"Engine": {},
						"EngineVersion": {},
						"DBParameterGroupFamily": {},
						"Filters": {
							"shape": "S3e"
						},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {},
						"DefaultOnly": {
							"type": "boolean"
						},
						"ListSupportedCharacterSets": {
							"type": "boolean"
						},
						"ListSupportedTimezones": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"resultWrapper": "DescribeDBEngineVersionsResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"DBEngineVersions": {
							"type": "list",
							"member": {
								"locationName": "DBEngineVersion",
								"type": "structure",
								"members": {
									"Engine": {},
									"EngineVersion": {},
									"DBParameterGroupFamily": {},
									"DBEngineDescription": {},
									"DBEngineVersionDescription": {},
									"DefaultCharacterSet": {
										"shape": "S48"
									},
									"SupportedCharacterSets": {
										"type": "list",
										"member": {
											"shape": "S48",
											"locationName": "CharacterSet"
										}
									},
									"ValidUpgradeTarget": {
										"type": "list",
										"member": {
											"locationName": "UpgradeTarget",
											"type": "structure",
											"members": {
												"Engine": {},
												"EngineVersion": {},
												"Description": {},
												"AutoUpgrade": {
													"type": "boolean"
												},
												"IsMajorVersionUpgrade": {
													"type": "boolean"
												}
											}
										}
									},
									"SupportedTimezones": {
										"type": "list",
										"member": {
											"locationName": "Timezone",
											"type": "structure",
											"members": {
												"TimezoneName": {}
											}
										}
									}
								}
							}
						}
					}
				}
			},
			"DescribeDBInstances": {
				"input": {
					"type": "structure",
					"members": {
						"DBInstanceIdentifier": {},
						"Filters": {
							"shape": "S3e"
						},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeDBInstancesResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"DBInstances": {
							"type": "list",
							"member": {
								"shape": "S1y",
								"locationName": "DBInstance"
							}
						}
					}
				}
			},
			"DescribeDBLogFiles": {
				"input": {
					"type": "structure",
					"required": [
						"DBInstanceIdentifier"
					],
					"members": {
						"DBInstanceIdentifier": {},
						"FilenameContains": {},
						"FileLastWritten": {
							"type": "long"
						},
						"FileSize": {
							"type": "long"
						},
						"Filters": {
							"shape": "S3e"
						},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeDBLogFilesResult",
					"type": "structure",
					"members": {
						"DescribeDBLogFiles": {
							"type": "list",
							"member": {
								"locationName": "DescribeDBLogFilesDetails",
								"type": "structure",
								"members": {
									"LogFileName": {},
									"LastWritten": {
										"type": "long"
									},
									"Size": {
										"type": "long"
									}
								}
							}
						},
						"Marker": {}
					}
				}
			},
			"DescribeDBParameterGroups": {
				"input": {
					"type": "structure",
					"members": {
						"DBParameterGroupName": {},
						"Filters": {
							"shape": "S3e"
						},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeDBParameterGroupsResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"DBParameterGroups": {
							"type": "list",
							"member": {
								"shape": "Sz",
								"locationName": "DBParameterGroup"
							}
						}
					}
				}
			},
			"DescribeDBParameters": {
				"input": {
					"type": "structure",
					"required": [
						"DBParameterGroupName"
					],
					"members": {
						"DBParameterGroupName": {},
						"Source": {},
						"Filters": {
							"shape": "S3e"
						},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeDBParametersResult",
					"type": "structure",
					"members": {
						"Parameters": {
							"shape": "S3p"
						},
						"Marker": {}
					}
				}
			},
			"DescribeDBSecurityGroups": {
				"input": {
					"type": "structure",
					"members": {
						"DBSecurityGroupName": {},
						"Filters": {
							"shape": "S3e"
						},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeDBSecurityGroupsResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"DBSecurityGroups": {
							"type": "list",
							"member": {
								"shape": "Sk",
								"locationName": "DBSecurityGroup"
							}
						}
					}
				}
			},
			"DescribeDBSnapshotAttributes": {
				"input": {
					"type": "structure",
					"required": [
						"DBSnapshotIdentifier"
					],
					"members": {
						"DBSnapshotIdentifier": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeDBSnapshotAttributesResult",
					"type": "structure",
					"members": {
						"DBSnapshotAttributesResult": {
							"shape": "S4v"
						}
					}
				}
			},
			"DescribeDBSnapshots": {
				"input": {
					"type": "structure",
					"members": {
						"DBInstanceIdentifier": {},
						"DBSnapshotIdentifier": {},
						"SnapshotType": {},
						"Filters": {
							"shape": "S3e"
						},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {},
						"IncludeShared": {
							"type": "boolean"
						},
						"IncludePublic": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"resultWrapper": "DescribeDBSnapshotsResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"DBSnapshots": {
							"type": "list",
							"member": {
								"shape": "S13",
								"locationName": "DBSnapshot"
							}
						}
					}
				}
			},
			"DescribeDBSubnetGroups": {
				"input": {
					"type": "structure",
					"members": {
						"DBSubnetGroupName": {},
						"Filters": {
							"shape": "S3e"
						},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeDBSubnetGroupsResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"DBSubnetGroups": {
							"type": "list",
							"member": {
								"shape": "S22",
								"locationName": "DBSubnetGroup"
							}
						}
					}
				}
			},
			"DescribeEngineDefaultClusterParameters": {
				"input": {
					"type": "structure",
					"required": [
						"DBParameterGroupFamily"
					],
					"members": {
						"DBParameterGroupFamily": {},
						"Filters": {
							"shape": "S3e"
						},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeEngineDefaultClusterParametersResult",
					"type": "structure",
					"members": {
						"EngineDefaults": {
							"shape": "S56"
						}
					}
				}
			},
			"DescribeEngineDefaultParameters": {
				"input": {
					"type": "structure",
					"required": [
						"DBParameterGroupFamily"
					],
					"members": {
						"DBParameterGroupFamily": {},
						"Filters": {
							"shape": "S3e"
						},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeEngineDefaultParametersResult",
					"type": "structure",
					"members": {
						"EngineDefaults": {
							"shape": "S56"
						}
					}
				}
			},
			"DescribeEventCategories": {
				"input": {
					"type": "structure",
					"members": {
						"SourceType": {},
						"Filters": {
							"shape": "S3e"
						}
					}
				},
				"output": {
					"resultWrapper": "DescribeEventCategoriesResult",
					"type": "structure",
					"members": {
						"EventCategoriesMapList": {
							"type": "list",
							"member": {
								"locationName": "EventCategoriesMap",
								"type": "structure",
								"members": {
									"SourceType": {},
									"EventCategories": {
										"shape": "S7"
									}
								},
								"wrapper": true
							}
						}
					}
				}
			},
			"DescribeEventSubscriptions": {
				"input": {
					"type": "structure",
					"members": {
						"SubscriptionName": {},
						"Filters": {
							"shape": "S3e"
						},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeEventSubscriptionsResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"EventSubscriptionsList": {
							"type": "list",
							"member": {
								"shape": "S5",
								"locationName": "EventSubscription"
							}
						}
					}
				}
			},
			"DescribeEvents": {
				"input": {
					"type": "structure",
					"members": {
						"SourceIdentifier": {},
						"SourceType": {},
						"StartTime": {
							"type": "timestamp"
						},
						"EndTime": {
							"type": "timestamp"
						},
						"Duration": {
							"type": "integer"
						},
						"EventCategories": {
							"shape": "S7"
						},
						"Filters": {
							"shape": "S3e"
						},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeEventsResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"Events": {
							"type": "list",
							"member": {
								"locationName": "Event",
								"type": "structure",
								"members": {
									"SourceIdentifier": {},
									"SourceType": {},
									"Message": {},
									"EventCategories": {
										"shape": "S7"
									},
									"Date": {
										"type": "timestamp"
									},
									"SourceArn": {}
								}
							}
						}
					}
				}
			},
			"DescribeOptionGroupOptions": {
				"input": {
					"type": "structure",
					"required": [
						"EngineName"
					],
					"members": {
						"EngineName": {},
						"MajorEngineVersion": {},
						"Filters": {
							"shape": "S3e"
						},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeOptionGroupOptionsResult",
					"type": "structure",
					"members": {
						"OptionGroupOptions": {
							"type": "list",
							"member": {
								"locationName": "OptionGroupOption",
								"type": "structure",
								"members": {
									"Name": {},
									"Description": {},
									"EngineName": {},
									"MajorEngineVersion": {},
									"MinimumRequiredMinorEngineVersion": {},
									"PortRequired": {
										"type": "boolean"
									},
									"DefaultPort": {
										"type": "integer"
									},
									"OptionsDependedOn": {
										"type": "list",
										"member": {
											"locationName": "OptionName"
										}
									},
									"OptionsConflictsWith": {
										"type": "list",
										"member": {
											"locationName": "OptionConflictName"
										}
									},
									"Persistent": {
										"type": "boolean"
									},
									"Permanent": {
										"type": "boolean"
									},
									"OptionGroupOptionSettings": {
										"type": "list",
										"member": {
											"locationName": "OptionGroupOptionSetting",
											"type": "structure",
											"members": {
												"SettingName": {},
												"SettingDescription": {},
												"DefaultValue": {},
												"ApplyType": {},
												"AllowedValues": {},
												"IsModifiable": {
													"type": "boolean"
												}
											}
										}
									},
									"OptionGroupOptionVersions": {
										"type": "list",
										"member": {
											"locationName": "OptionVersion",
											"type": "structure",
											"members": {
												"Version": {},
												"IsDefault": {
													"type": "boolean"
												}
											}
										}
									}
								}
							}
						},
						"Marker": {}
					}
				}
			},
			"DescribeOptionGroups": {
				"input": {
					"type": "structure",
					"members": {
						"OptionGroupName": {},
						"Filters": {
							"shape": "S3e"
						},
						"Marker": {},
						"MaxRecords": {
							"type": "integer"
						},
						"EngineName": {},
						"MajorEngineVersion": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeOptionGroupsResult",
					"type": "structure",
					"members": {
						"OptionGroupsList": {
							"type": "list",
							"member": {
								"shape": "S17",
								"locationName": "OptionGroup"
							}
						},
						"Marker": {}
					}
				}
			},
			"DescribeOrderableDBInstanceOptions": {
				"input": {
					"type": "structure",
					"required": [
						"Engine"
					],
					"members": {
						"Engine": {},
						"EngineVersion": {},
						"DBInstanceClass": {},
						"LicenseModel": {},
						"Vpc": {
							"type": "boolean"
						},
						"Filters": {
							"shape": "S3e"
						},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeOrderableDBInstanceOptionsResult",
					"type": "structure",
					"members": {
						"OrderableDBInstanceOptions": {
							"type": "list",
							"member": {
								"locationName": "OrderableDBInstanceOption",
								"type": "structure",
								"members": {
									"Engine": {},
									"EngineVersion": {},
									"DBInstanceClass": {},
									"LicenseModel": {},
									"AvailabilityZones": {
										"type": "list",
										"member": {
											"shape": "S25",
											"locationName": "AvailabilityZone"
										}
									},
									"MultiAZCapable": {
										"type": "boolean"
									},
									"ReadReplicaCapable": {
										"type": "boolean"
									},
									"Vpc": {
										"type": "boolean"
									},
									"SupportsStorageEncryption": {
										"type": "boolean"
									},
									"StorageType": {},
									"SupportsIops": {
										"type": "boolean"
									},
									"SupportsEnhancedMonitoring": {
										"type": "boolean"
									}
								},
								"wrapper": true
							}
						},
						"Marker": {}
					}
				}
			},
			"DescribePendingMaintenanceActions": {
				"input": {
					"type": "structure",
					"members": {
						"ResourceIdentifier": {},
						"Filters": {
							"shape": "S3e"
						},
						"Marker": {},
						"MaxRecords": {
							"type": "integer"
						}
					}
				},
				"output": {
					"resultWrapper": "DescribePendingMaintenanceActionsResult",
					"type": "structure",
					"members": {
						"PendingMaintenanceActions": {
							"type": "list",
							"member": {
								"shape": "Se",
								"locationName": "ResourcePendingMaintenanceActions"
							}
						},
						"Marker": {}
					}
				}
			},
			"DescribeReservedDBInstances": {
				"input": {
					"type": "structure",
					"members": {
						"ReservedDBInstanceId": {},
						"ReservedDBInstancesOfferingId": {},
						"DBInstanceClass": {},
						"Duration": {},
						"ProductDescription": {},
						"OfferingType": {},
						"MultiAZ": {
							"type": "boolean"
						},
						"Filters": {
							"shape": "S3e"
						},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeReservedDBInstancesResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"ReservedDBInstances": {
							"type": "list",
							"member": {
								"shape": "S69",
								"locationName": "ReservedDBInstance"
							}
						}
					}
				}
			},
			"DescribeReservedDBInstancesOfferings": {
				"input": {
					"type": "structure",
					"members": {
						"ReservedDBInstancesOfferingId": {},
						"DBInstanceClass": {},
						"Duration": {},
						"ProductDescription": {},
						"OfferingType": {},
						"MultiAZ": {
							"type": "boolean"
						},
						"Filters": {
							"shape": "S3e"
						},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeReservedDBInstancesOfferingsResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"ReservedDBInstancesOfferings": {
							"type": "list",
							"member": {
								"locationName": "ReservedDBInstancesOffering",
								"type": "structure",
								"members": {
									"ReservedDBInstancesOfferingId": {},
									"DBInstanceClass": {},
									"Duration": {
										"type": "integer"
									},
									"FixedPrice": {
										"type": "double"
									},
									"UsagePrice": {
										"type": "double"
									},
									"CurrencyCode": {},
									"ProductDescription": {},
									"OfferingType": {},
									"MultiAZ": {
										"type": "boolean"
									},
									"RecurringCharges": {
										"shape": "S6b"
									}
								},
								"wrapper": true
							}
						}
					}
				}
			},
			"DescribeSourceRegions": {
				"input": {
					"type": "structure",
					"members": {
						"RegionName": {},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {},
						"Filters": {
							"shape": "S3e"
						}
					}
				},
				"output": {
					"resultWrapper": "DescribeSourceRegionsResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"SourceRegions": {
							"type": "list",
							"member": {
								"locationName": "SourceRegion",
								"type": "structure",
								"members": {
									"RegionName": {},
									"Endpoint": {},
									"Status": {}
								}
							}
						}
					}
				}
			},
			"DownloadDBLogFilePortion": {
				"input": {
					"type": "structure",
					"required": [
						"DBInstanceIdentifier",
						"LogFileName"
					],
					"members": {
						"DBInstanceIdentifier": {},
						"LogFileName": {},
						"Marker": {},
						"NumberOfLines": {
							"type": "integer"
						}
					}
				},
				"output": {
					"resultWrapper": "DownloadDBLogFilePortionResult",
					"type": "structure",
					"members": {
						"LogFileData": {},
						"Marker": {},
						"AdditionalDataPending": {
							"type": "boolean"
						}
					}
				}
			},
			"FailoverDBCluster": {
				"input": {
					"type": "structure",
					"members": {
						"DBClusterIdentifier": {},
						"TargetDBInstanceIdentifier": {}
					}
				},
				"output": {
					"resultWrapper": "FailoverDBClusterResult",
					"type": "structure",
					"members": {
						"DBCluster": {
							"shape": "S1j"
						}
					}
				}
			},
			"ListTagsForResource": {
				"input": {
					"type": "structure",
					"required": [
						"ResourceName"
					],
					"members": {
						"ResourceName": {},
						"Filters": {
							"shape": "S3e"
						}
					}
				},
				"output": {
					"resultWrapper": "ListTagsForResourceResult",
					"type": "structure",
					"members": {
						"TagList": {
							"shape": "Sa"
						}
					}
				}
			},
			"ModifyDBCluster": {
				"input": {
					"type": "structure",
					"required": [
						"DBClusterIdentifier"
					],
					"members": {
						"DBClusterIdentifier": {},
						"NewDBClusterIdentifier": {},
						"ApplyImmediately": {
							"type": "boolean"
						},
						"BackupRetentionPeriod": {
							"type": "integer"
						},
						"DBClusterParameterGroupName": {},
						"VpcSecurityGroupIds": {
							"shape": "S1h"
						},
						"Port": {
							"type": "integer"
						},
						"MasterUserPassword": {},
						"OptionGroupName": {},
						"PreferredBackupWindow": {},
						"PreferredMaintenanceWindow": {}
					}
				},
				"output": {
					"resultWrapper": "ModifyDBClusterResult",
					"type": "structure",
					"members": {
						"DBCluster": {
							"shape": "S1j"
						}
					}
				}
			},
			"ModifyDBClusterParameterGroup": {
				"input": {
					"type": "structure",
					"required": [
						"DBClusterParameterGroupName",
						"Parameters"
					],
					"members": {
						"DBClusterParameterGroupName": {},
						"Parameters": {
							"shape": "S3p"
						}
					}
				},
				"output": {
					"shape": "S6u",
					"resultWrapper": "ModifyDBClusterParameterGroupResult"
				}
			},
			"ModifyDBClusterSnapshotAttribute": {
				"input": {
					"type": "structure",
					"required": [
						"DBClusterSnapshotIdentifier",
						"AttributeName"
					],
					"members": {
						"DBClusterSnapshotIdentifier": {},
						"AttributeName": {},
						"ValuesToAdd": {
							"shape": "S3x"
						},
						"ValuesToRemove": {
							"shape": "S3x"
						}
					}
				},
				"output": {
					"resultWrapper": "ModifyDBClusterSnapshotAttributeResult",
					"type": "structure",
					"members": {
						"DBClusterSnapshotAttributesResult": {
							"shape": "S3u"
						}
					}
				}
			},
			"ModifyDBInstance": {
				"input": {
					"type": "structure",
					"required": [
						"DBInstanceIdentifier"
					],
					"members": {
						"DBInstanceIdentifier": {},
						"AllocatedStorage": {
							"type": "integer"
						},
						"DBInstanceClass": {},
						"DBSubnetGroupName": {},
						"DBSecurityGroups": {
							"shape": "S1w"
						},
						"VpcSecurityGroupIds": {
							"shape": "S1h"
						},
						"ApplyImmediately": {
							"type": "boolean"
						},
						"MasterUserPassword": {},
						"DBParameterGroupName": {},
						"BackupRetentionPeriod": {
							"type": "integer"
						},
						"PreferredBackupWindow": {},
						"PreferredMaintenanceWindow": {},
						"MultiAZ": {
							"type": "boolean"
						},
						"EngineVersion": {},
						"AllowMajorVersionUpgrade": {
							"type": "boolean"
						},
						"AutoMinorVersionUpgrade": {
							"type": "boolean"
						},
						"LicenseModel": {},
						"Iops": {
							"type": "integer"
						},
						"OptionGroupName": {},
						"NewDBInstanceIdentifier": {},
						"StorageType": {},
						"TdeCredentialArn": {},
						"TdeCredentialPassword": {},
						"CACertificateIdentifier": {},
						"Domain": {},
						"CopyTagsToSnapshot": {
							"type": "boolean"
						},
						"MonitoringInterval": {
							"type": "integer"
						},
						"DBPortNumber": {
							"type": "integer"
						},
						"PubliclyAccessible": {
							"type": "boolean"
						},
						"MonitoringRoleArn": {},
						"DomainIAMRoleName": {},
						"PromotionTier": {
							"type": "integer"
						}
					}
				},
				"output": {
					"resultWrapper": "ModifyDBInstanceResult",
					"type": "structure",
					"members": {
						"DBInstance": {
							"shape": "S1y"
						}
					}
				}
			},
			"ModifyDBParameterGroup": {
				"input": {
					"type": "structure",
					"required": [
						"DBParameterGroupName",
						"Parameters"
					],
					"members": {
						"DBParameterGroupName": {},
						"Parameters": {
							"shape": "S3p"
						}
					}
				},
				"output": {
					"shape": "S70",
					"resultWrapper": "ModifyDBParameterGroupResult"
				}
			},
			"ModifyDBSnapshotAttribute": {
				"input": {
					"type": "structure",
					"required": [
						"DBSnapshotIdentifier",
						"AttributeName"
					],
					"members": {
						"DBSnapshotIdentifier": {},
						"AttributeName": {},
						"ValuesToAdd": {
							"shape": "S3x"
						},
						"ValuesToRemove": {
							"shape": "S3x"
						}
					}
				},
				"output": {
					"resultWrapper": "ModifyDBSnapshotAttributeResult",
					"type": "structure",
					"members": {
						"DBSnapshotAttributesResult": {
							"shape": "S4v"
						}
					}
				}
			},
			"ModifyDBSubnetGroup": {
				"input": {
					"type": "structure",
					"required": [
						"DBSubnetGroupName",
						"SubnetIds"
					],
					"members": {
						"DBSubnetGroupName": {},
						"DBSubnetGroupDescription": {},
						"SubnetIds": {
							"shape": "S2n"
						}
					}
				},
				"output": {
					"resultWrapper": "ModifyDBSubnetGroupResult",
					"type": "structure",
					"members": {
						"DBSubnetGroup": {
							"shape": "S22"
						}
					}
				}
			},
			"ModifyEventSubscription": {
				"input": {
					"type": "structure",
					"required": [
						"SubscriptionName"
					],
					"members": {
						"SubscriptionName": {},
						"SnsTopicArn": {},
						"SourceType": {},
						"EventCategories": {
							"shape": "S7"
						},
						"Enabled": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"resultWrapper": "ModifyEventSubscriptionResult",
					"type": "structure",
					"members": {
						"EventSubscription": {
							"shape": "S5"
						}
					}
				}
			},
			"ModifyOptionGroup": {
				"input": {
					"type": "structure",
					"required": [
						"OptionGroupName"
					],
					"members": {
						"OptionGroupName": {},
						"OptionsToInclude": {
							"type": "list",
							"member": {
								"locationName": "OptionConfiguration",
								"type": "structure",
								"required": [
									"OptionName"
								],
								"members": {
									"OptionName": {},
									"Port": {
										"type": "integer"
									},
									"OptionVersion": {},
									"DBSecurityGroupMemberships": {
										"shape": "S1w"
									},
									"VpcSecurityGroupMemberships": {
										"shape": "S1h"
									},
									"OptionSettings": {
										"type": "list",
										"member": {
											"shape": "S1b",
											"locationName": "OptionSetting"
										}
									}
								}
							}
						},
						"OptionsToRemove": {
							"type": "list",
							"member": {}
						},
						"ApplyImmediately": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"resultWrapper": "ModifyOptionGroupResult",
					"type": "structure",
					"members": {
						"OptionGroup": {
							"shape": "S17"
						}
					}
				}
			},
			"PromoteReadReplica": {
				"input": {
					"type": "structure",
					"required": [
						"DBInstanceIdentifier"
					],
					"members": {
						"DBInstanceIdentifier": {},
						"BackupRetentionPeriod": {
							"type": "integer"
						},
						"PreferredBackupWindow": {}
					}
				},
				"output": {
					"resultWrapper": "PromoteReadReplicaResult",
					"type": "structure",
					"members": {
						"DBInstance": {
							"shape": "S1y"
						}
					}
				}
			},
			"PromoteReadReplicaDBCluster": {
				"input": {
					"type": "structure",
					"required": [
						"DBClusterIdentifier"
					],
					"members": {
						"DBClusterIdentifier": {}
					}
				},
				"output": {
					"resultWrapper": "PromoteReadReplicaDBClusterResult",
					"type": "structure",
					"members": {
						"DBCluster": {
							"shape": "S1j"
						}
					}
				}
			},
			"PurchaseReservedDBInstancesOffering": {
				"input": {
					"type": "structure",
					"required": [
						"ReservedDBInstancesOfferingId"
					],
					"members": {
						"ReservedDBInstancesOfferingId": {},
						"ReservedDBInstanceId": {},
						"DBInstanceCount": {
							"type": "integer"
						},
						"Tags": {
							"shape": "Sa"
						}
					}
				},
				"output": {
					"resultWrapper": "PurchaseReservedDBInstancesOfferingResult",
					"type": "structure",
					"members": {
						"ReservedDBInstance": {
							"shape": "S69"
						}
					}
				}
			},
			"RebootDBInstance": {
				"input": {
					"type": "structure",
					"required": [
						"DBInstanceIdentifier"
					],
					"members": {
						"DBInstanceIdentifier": {},
						"ForceFailover": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"resultWrapper": "RebootDBInstanceResult",
					"type": "structure",
					"members": {
						"DBInstance": {
							"shape": "S1y"
						}
					}
				}
			},
			"RemoveRoleFromDBCluster": {
				"input": {
					"type": "structure",
					"required": [
						"DBClusterIdentifier",
						"RoleArn"
					],
					"members": {
						"DBClusterIdentifier": {},
						"RoleArn": {}
					}
				}
			},
			"RemoveSourceIdentifierFromSubscription": {
				"input": {
					"type": "structure",
					"required": [
						"SubscriptionName",
						"SourceIdentifier"
					],
					"members": {
						"SubscriptionName": {},
						"SourceIdentifier": {}
					}
				},
				"output": {
					"resultWrapper": "RemoveSourceIdentifierFromSubscriptionResult",
					"type": "structure",
					"members": {
						"EventSubscription": {
							"shape": "S5"
						}
					}
				}
			},
			"RemoveTagsFromResource": {
				"input": {
					"type": "structure",
					"required": [
						"ResourceName",
						"TagKeys"
					],
					"members": {
						"ResourceName": {},
						"TagKeys": {
							"type": "list",
							"member": {}
						}
					}
				}
			},
			"ResetDBClusterParameterGroup": {
				"input": {
					"type": "structure",
					"required": [
						"DBClusterParameterGroupName"
					],
					"members": {
						"DBClusterParameterGroupName": {},
						"ResetAllParameters": {
							"type": "boolean"
						},
						"Parameters": {
							"shape": "S3p"
						}
					}
				},
				"output": {
					"shape": "S6u",
					"resultWrapper": "ResetDBClusterParameterGroupResult"
				}
			},
			"ResetDBParameterGroup": {
				"input": {
					"type": "structure",
					"required": [
						"DBParameterGroupName"
					],
					"members": {
						"DBParameterGroupName": {},
						"ResetAllParameters": {
							"type": "boolean"
						},
						"Parameters": {
							"shape": "S3p"
						}
					}
				},
				"output": {
					"shape": "S70",
					"resultWrapper": "ResetDBParameterGroupResult"
				}
			},
			"RestoreDBClusterFromS3": {
				"input": {
					"type": "structure",
					"required": [
						"DBClusterIdentifier",
						"Engine",
						"MasterUsername",
						"MasterUserPassword",
						"SourceEngine",
						"SourceEngineVersion",
						"S3BucketName",
						"S3IngestionRoleArn"
					],
					"members": {
						"AvailabilityZones": {
							"shape": "Sv"
						},
						"BackupRetentionPeriod": {
							"type": "integer"
						},
						"CharacterSetName": {},
						"DatabaseName": {},
						"DBClusterIdentifier": {},
						"DBClusterParameterGroupName": {},
						"VpcSecurityGroupIds": {
							"shape": "S1h"
						},
						"DBSubnetGroupName": {},
						"Engine": {},
						"EngineVersion": {},
						"Port": {
							"type": "integer"
						},
						"MasterUsername": {},
						"MasterUserPassword": {},
						"OptionGroupName": {},
						"PreferredBackupWindow": {},
						"PreferredMaintenanceWindow": {},
						"Tags": {
							"shape": "Sa"
						},
						"StorageEncrypted": {
							"type": "boolean"
						},
						"KmsKeyId": {},
						"SourceEngine": {},
						"SourceEngineVersion": {},
						"S3BucketName": {},
						"S3Prefix": {},
						"S3IngestionRoleArn": {}
					}
				},
				"output": {
					"resultWrapper": "RestoreDBClusterFromS3Result",
					"type": "structure",
					"members": {
						"DBCluster": {
							"shape": "S1j"
						}
					}
				}
			},
			"RestoreDBClusterFromSnapshot": {
				"input": {
					"type": "structure",
					"required": [
						"DBClusterIdentifier",
						"SnapshotIdentifier",
						"Engine"
					],
					"members": {
						"AvailabilityZones": {
							"shape": "Sv"
						},
						"DBClusterIdentifier": {},
						"SnapshotIdentifier": {},
						"Engine": {},
						"EngineVersion": {},
						"Port": {
							"type": "integer"
						},
						"DBSubnetGroupName": {},
						"DatabaseName": {},
						"OptionGroupName": {},
						"VpcSecurityGroupIds": {
							"shape": "S1h"
						},
						"Tags": {
							"shape": "Sa"
						},
						"KmsKeyId": {}
					}
				},
				"output": {
					"resultWrapper": "RestoreDBClusterFromSnapshotResult",
					"type": "structure",
					"members": {
						"DBCluster": {
							"shape": "S1j"
						}
					}
				}
			},
			"RestoreDBClusterToPointInTime": {
				"input": {
					"type": "structure",
					"required": [
						"DBClusterIdentifier",
						"SourceDBClusterIdentifier"
					],
					"members": {
						"DBClusterIdentifier": {},
						"SourceDBClusterIdentifier": {},
						"RestoreToTime": {
							"type": "timestamp"
						},
						"UseLatestRestorableTime": {
							"type": "boolean"
						},
						"Port": {
							"type": "integer"
						},
						"DBSubnetGroupName": {},
						"OptionGroupName": {},
						"VpcSecurityGroupIds": {
							"shape": "S1h"
						},
						"Tags": {
							"shape": "Sa"
						},
						"KmsKeyId": {}
					}
				},
				"output": {
					"resultWrapper": "RestoreDBClusterToPointInTimeResult",
					"type": "structure",
					"members": {
						"DBCluster": {
							"shape": "S1j"
						}
					}
				}
			},
			"RestoreDBInstanceFromDBSnapshot": {
				"input": {
					"type": "structure",
					"required": [
						"DBInstanceIdentifier",
						"DBSnapshotIdentifier"
					],
					"members": {
						"DBInstanceIdentifier": {},
						"DBSnapshotIdentifier": {},
						"DBInstanceClass": {},
						"Port": {
							"type": "integer"
						},
						"AvailabilityZone": {},
						"DBSubnetGroupName": {},
						"MultiAZ": {
							"type": "boolean"
						},
						"PubliclyAccessible": {
							"type": "boolean"
						},
						"AutoMinorVersionUpgrade": {
							"type": "boolean"
						},
						"LicenseModel": {},
						"DBName": {},
						"Engine": {},
						"Iops": {
							"type": "integer"
						},
						"OptionGroupName": {},
						"Tags": {
							"shape": "Sa"
						},
						"StorageType": {},
						"TdeCredentialArn": {},
						"TdeCredentialPassword": {},
						"Domain": {},
						"CopyTagsToSnapshot": {
							"type": "boolean"
						},
						"DomainIAMRoleName": {}
					}
				},
				"output": {
					"resultWrapper": "RestoreDBInstanceFromDBSnapshotResult",
					"type": "structure",
					"members": {
						"DBInstance": {
							"shape": "S1y"
						}
					}
				}
			},
			"RestoreDBInstanceToPointInTime": {
				"input": {
					"type": "structure",
					"required": [
						"SourceDBInstanceIdentifier",
						"TargetDBInstanceIdentifier"
					],
					"members": {
						"SourceDBInstanceIdentifier": {},
						"TargetDBInstanceIdentifier": {},
						"RestoreTime": {
							"type": "timestamp"
						},
						"UseLatestRestorableTime": {
							"type": "boolean"
						},
						"DBInstanceClass": {},
						"Port": {
							"type": "integer"
						},
						"AvailabilityZone": {},
						"DBSubnetGroupName": {},
						"MultiAZ": {
							"type": "boolean"
						},
						"PubliclyAccessible": {
							"type": "boolean"
						},
						"AutoMinorVersionUpgrade": {
							"type": "boolean"
						},
						"LicenseModel": {},
						"DBName": {},
						"Engine": {},
						"Iops": {
							"type": "integer"
						},
						"OptionGroupName": {},
						"CopyTagsToSnapshot": {
							"type": "boolean"
						},
						"Tags": {
							"shape": "Sa"
						},
						"StorageType": {},
						"TdeCredentialArn": {},
						"TdeCredentialPassword": {},
						"Domain": {},
						"DomainIAMRoleName": {}
					}
				},
				"output": {
					"resultWrapper": "RestoreDBInstanceToPointInTimeResult",
					"type": "structure",
					"members": {
						"DBInstance": {
							"shape": "S1y"
						}
					}
				}
			},
			"RevokeDBSecurityGroupIngress": {
				"input": {
					"type": "structure",
					"required": [
						"DBSecurityGroupName"
					],
					"members": {
						"DBSecurityGroupName": {},
						"CIDRIP": {},
						"EC2SecurityGroupName": {},
						"EC2SecurityGroupId": {},
						"EC2SecurityGroupOwnerId": {}
					}
				},
				"output": {
					"resultWrapper": "RevokeDBSecurityGroupIngressResult",
					"type": "structure",
					"members": {
						"DBSecurityGroup": {
							"shape": "Sk"
						}
					}
				}
			}
		},
		"shapes": {
			"S5": {
				"type": "structure",
				"members": {
					"CustomerAwsId": {},
					"CustSubscriptionId": {},
					"SnsTopicArn": {},
					"Status": {},
					"SubscriptionCreationTime": {},
					"SourceType": {},
					"SourceIdsList": {
						"shape": "S6"
					},
					"EventCategoriesList": {
						"shape": "S7"
					},
					"Enabled": {
						"type": "boolean"
					},
					"EventSubscriptionArn": {}
				},
				"wrapper": true
			},
			"S6": {
				"type": "list",
				"member": {
					"locationName": "SourceId"
				}
			},
			"S7": {
				"type": "list",
				"member": {
					"locationName": "EventCategory"
				}
			},
			"Sa": {
				"type": "list",
				"member": {
					"locationName": "Tag",
					"type": "structure",
					"members": {
						"Key": {},
						"Value": {}
					}
				}
			},
			"Se": {
				"type": "structure",
				"members": {
					"ResourceIdentifier": {},
					"PendingMaintenanceActionDetails": {
						"type": "list",
						"member": {
							"locationName": "PendingMaintenanceAction",
							"type": "structure",
							"members": {
								"Action": {},
								"AutoAppliedAfterDate": {
									"type": "timestamp"
								},
								"ForcedApplyDate": {
									"type": "timestamp"
								},
								"OptInStatus": {},
								"CurrentApplyDate": {
									"type": "timestamp"
								},
								"Description": {}
							}
						}
					}
				},
				"wrapper": true
			},
			"Sk": {
				"type": "structure",
				"members": {
					"OwnerId": {},
					"DBSecurityGroupName": {},
					"DBSecurityGroupDescription": {},
					"VpcId": {},
					"EC2SecurityGroups": {
						"type": "list",
						"member": {
							"locationName": "EC2SecurityGroup",
							"type": "structure",
							"members": {
								"Status": {},
								"EC2SecurityGroupName": {},
								"EC2SecurityGroupId": {},
								"EC2SecurityGroupOwnerId": {}
							}
						}
					},
					"IPRanges": {
						"type": "list",
						"member": {
							"locationName": "IPRange",
							"type": "structure",
							"members": {
								"Status": {},
								"CIDRIP": {}
							}
						}
					},
					"DBSecurityGroupArn": {}
				},
				"wrapper": true
			},
			"Sr": {
				"type": "structure",
				"members": {
					"DBClusterParameterGroupName": {},
					"DBParameterGroupFamily": {},
					"Description": {},
					"DBClusterParameterGroupArn": {}
				},
				"wrapper": true
			},
			"Su": {
				"type": "structure",
				"members": {
					"AvailabilityZones": {
						"shape": "Sv"
					},
					"DBClusterSnapshotIdentifier": {},
					"DBClusterIdentifier": {},
					"SnapshotCreateTime": {
						"type": "timestamp"
					},
					"Engine": {},
					"AllocatedStorage": {
						"type": "integer"
					},
					"Status": {},
					"Port": {
						"type": "integer"
					},
					"VpcId": {},
					"ClusterCreateTime": {
						"type": "timestamp"
					},
					"MasterUsername": {},
					"EngineVersion": {},
					"LicenseModel": {},
					"SnapshotType": {},
					"PercentProgress": {
						"type": "integer"
					},
					"StorageEncrypted": {
						"type": "boolean"
					},
					"KmsKeyId": {},
					"DBClusterSnapshotArn": {}
				},
				"wrapper": true
			},
			"Sv": {
				"type": "list",
				"member": {
					"locationName": "AvailabilityZone"
				}
			},
			"Sz": {
				"type": "structure",
				"members": {
					"DBParameterGroupName": {},
					"DBParameterGroupFamily": {},
					"Description": {},
					"DBParameterGroupArn": {}
				},
				"wrapper": true
			},
			"S13": {
				"type": "structure",
				"members": {
					"DBSnapshotIdentifier": {},
					"DBInstanceIdentifier": {},
					"SnapshotCreateTime": {
						"type": "timestamp"
					},
					"Engine": {},
					"AllocatedStorage": {
						"type": "integer"
					},
					"Status": {},
					"Port": {
						"type": "integer"
					},
					"AvailabilityZone": {},
					"VpcId": {},
					"InstanceCreateTime": {
						"type": "timestamp"
					},
					"MasterUsername": {},
					"EngineVersion": {},
					"LicenseModel": {},
					"SnapshotType": {},
					"Iops": {
						"type": "integer"
					},
					"OptionGroupName": {},
					"PercentProgress": {
						"type": "integer"
					},
					"SourceRegion": {},
					"SourceDBSnapshotIdentifier": {},
					"StorageType": {},
					"TdeCredentialArn": {},
					"Encrypted": {
						"type": "boolean"
					},
					"KmsKeyId": {},
					"DBSnapshotArn": {},
					"Timezone": {}
				},
				"wrapper": true
			},
			"S17": {
				"type": "structure",
				"members": {
					"OptionGroupName": {},
					"OptionGroupDescription": {},
					"EngineName": {},
					"MajorEngineVersion": {},
					"Options": {
						"type": "list",
						"member": {
							"locationName": "Option",
							"type": "structure",
							"members": {
								"OptionName": {},
								"OptionDescription": {},
								"Persistent": {
									"type": "boolean"
								},
								"Permanent": {
									"type": "boolean"
								},
								"Port": {
									"type": "integer"
								},
								"OptionVersion": {},
								"OptionSettings": {
									"type": "list",
									"member": {
										"shape": "S1b",
										"locationName": "OptionSetting"
									}
								},
								"DBSecurityGroupMemberships": {
									"shape": "S1c"
								},
								"VpcSecurityGroupMemberships": {
									"shape": "S1e"
								}
							}
						}
					},
					"AllowsVpcAndNonVpcInstanceMemberships": {
						"type": "boolean"
					},
					"VpcId": {},
					"OptionGroupArn": {}
				},
				"wrapper": true
			},
			"S1b": {
				"type": "structure",
				"members": {
					"Name": {},
					"Value": {},
					"DefaultValue": {},
					"Description": {},
					"ApplyType": {},
					"DataType": {},
					"AllowedValues": {},
					"IsModifiable": {
						"type": "boolean"
					},
					"IsCollection": {
						"type": "boolean"
					}
				}
			},
			"S1c": {
				"type": "list",
				"member": {
					"locationName": "DBSecurityGroup",
					"type": "structure",
					"members": {
						"DBSecurityGroupName": {},
						"Status": {}
					}
				}
			},
			"S1e": {
				"type": "list",
				"member": {
					"locationName": "VpcSecurityGroupMembership",
					"type": "structure",
					"members": {
						"VpcSecurityGroupId": {},
						"Status": {}
					}
				}
			},
			"S1h": {
				"type": "list",
				"member": {
					"locationName": "VpcSecurityGroupId"
				}
			},
			"S1j": {
				"type": "structure",
				"members": {
					"AllocatedStorage": {
						"type": "integer"
					},
					"AvailabilityZones": {
						"shape": "Sv"
					},
					"BackupRetentionPeriod": {
						"type": "integer"
					},
					"CharacterSetName": {},
					"DatabaseName": {},
					"DBClusterIdentifier": {},
					"DBClusterParameterGroup": {},
					"DBSubnetGroup": {},
					"Status": {},
					"PercentProgress": {},
					"EarliestRestorableTime": {
						"type": "timestamp"
					},
					"Endpoint": {},
					"ReaderEndpoint": {},
					"Engine": {},
					"EngineVersion": {},
					"LatestRestorableTime": {
						"type": "timestamp"
					},
					"Port": {
						"type": "integer"
					},
					"MasterUsername": {},
					"DBClusterOptionGroupMemberships": {
						"type": "list",
						"member": {
							"locationName": "DBClusterOptionGroup",
							"type": "structure",
							"members": {
								"DBClusterOptionGroupName": {},
								"Status": {}
							}
						}
					},
					"PreferredBackupWindow": {},
					"PreferredMaintenanceWindow": {},
					"ReplicationSourceIdentifier": {},
					"ReadReplicaIdentifiers": {
						"type": "list",
						"member": {
							"locationName": "ReadReplicaIdentifier"
						}
					},
					"DBClusterMembers": {
						"type": "list",
						"member": {
							"locationName": "DBClusterMember",
							"type": "structure",
							"members": {
								"DBInstanceIdentifier": {},
								"IsClusterWriter": {
									"type": "boolean"
								},
								"DBClusterParameterGroupStatus": {},
								"PromotionTier": {
									"type": "integer"
								}
							},
							"wrapper": true
						}
					},
					"VpcSecurityGroups": {
						"shape": "S1e"
					},
					"HostedZoneId": {},
					"StorageEncrypted": {
						"type": "boolean"
					},
					"KmsKeyId": {},
					"DbClusterResourceId": {},
					"DBClusterArn": {},
					"AssociatedRoles": {
						"type": "list",
						"member": {
							"locationName": "DBClusterRole",
							"type": "structure",
							"members": {
								"RoleArn": {},
								"Status": {}
							}
						}
					}
				},
				"wrapper": true
			},
			"S1w": {
				"type": "list",
				"member": {
					"locationName": "DBSecurityGroupName"
				}
			},
			"S1y": {
				"type": "structure",
				"members": {
					"DBInstanceIdentifier": {},
					"DBInstanceClass": {},
					"Engine": {},
					"DBInstanceStatus": {},
					"MasterUsername": {},
					"DBName": {},
					"Endpoint": {
						"type": "structure",
						"members": {
							"Address": {},
							"Port": {
								"type": "integer"
							},
							"HostedZoneId": {}
						}
					},
					"AllocatedStorage": {
						"type": "integer"
					},
					"InstanceCreateTime": {
						"type": "timestamp"
					},
					"PreferredBackupWindow": {},
					"BackupRetentionPeriod": {
						"type": "integer"
					},
					"DBSecurityGroups": {
						"shape": "S1c"
					},
					"VpcSecurityGroups": {
						"shape": "S1e"
					},
					"DBParameterGroups": {
						"type": "list",
						"member": {
							"locationName": "DBParameterGroup",
							"type": "structure",
							"members": {
								"DBParameterGroupName": {},
								"ParameterApplyStatus": {}
							}
						}
					},
					"AvailabilityZone": {},
					"DBSubnetGroup": {
						"shape": "S22"
					},
					"PreferredMaintenanceWindow": {},
					"PendingModifiedValues": {
						"type": "structure",
						"members": {
							"DBInstanceClass": {},
							"AllocatedStorage": {
								"type": "integer"
							},
							"MasterUserPassword": {},
							"Port": {
								"type": "integer"
							},
							"BackupRetentionPeriod": {
								"type": "integer"
							},
							"MultiAZ": {
								"type": "boolean"
							},
							"EngineVersion": {},
							"LicenseModel": {},
							"Iops": {
								"type": "integer"
							},
							"DBInstanceIdentifier": {},
							"StorageType": {},
							"CACertificateIdentifier": {},
							"DBSubnetGroupName": {}
						}
					},
					"LatestRestorableTime": {
						"type": "timestamp"
					},
					"MultiAZ": {
						"type": "boolean"
					},
					"EngineVersion": {},
					"AutoMinorVersionUpgrade": {
						"type": "boolean"
					},
					"ReadReplicaSourceDBInstanceIdentifier": {},
					"ReadReplicaDBInstanceIdentifiers": {
						"type": "list",
						"member": {
							"locationName": "ReadReplicaDBInstanceIdentifier"
						}
					},
					"LicenseModel": {},
					"Iops": {
						"type": "integer"
					},
					"OptionGroupMemberships": {
						"type": "list",
						"member": {
							"locationName": "OptionGroupMembership",
							"type": "structure",
							"members": {
								"OptionGroupName": {},
								"Status": {}
							}
						}
					},
					"CharacterSetName": {},
					"SecondaryAvailabilityZone": {},
					"PubliclyAccessible": {
						"type": "boolean"
					},
					"StatusInfos": {
						"type": "list",
						"member": {
							"locationName": "DBInstanceStatusInfo",
							"type": "structure",
							"members": {
								"StatusType": {},
								"Normal": {
									"type": "boolean"
								},
								"Status": {},
								"Message": {}
							}
						}
					},
					"StorageType": {},
					"TdeCredentialArn": {},
					"DbInstancePort": {
						"type": "integer"
					},
					"DBClusterIdentifier": {},
					"StorageEncrypted": {
						"type": "boolean"
					},
					"KmsKeyId": {},
					"DbiResourceId": {},
					"CACertificateIdentifier": {},
					"DomainMemberships": {
						"type": "list",
						"member": {
							"locationName": "DomainMembership",
							"type": "structure",
							"members": {
								"Domain": {},
								"Status": {},
								"FQDN": {},
								"IAMRoleName": {}
							}
						}
					},
					"CopyTagsToSnapshot": {
						"type": "boolean"
					},
					"MonitoringInterval": {
						"type": "integer"
					},
					"EnhancedMonitoringResourceArn": {},
					"MonitoringRoleArn": {},
					"PromotionTier": {
						"type": "integer"
					},
					"DBInstanceArn": {},
					"Timezone": {}
				},
				"wrapper": true
			},
			"S22": {
				"type": "structure",
				"members": {
					"DBSubnetGroupName": {},
					"DBSubnetGroupDescription": {},
					"VpcId": {},
					"SubnetGroupStatus": {},
					"Subnets": {
						"type": "list",
						"member": {
							"locationName": "Subnet",
							"type": "structure",
							"members": {
								"SubnetIdentifier": {},
								"SubnetAvailabilityZone": {
									"shape": "S25"
								},
								"SubnetStatus": {}
							}
						}
					},
					"DBSubnetGroupArn": {}
				},
				"wrapper": true
			},
			"S25": {
				"type": "structure",
				"members": {
					"Name": {}
				},
				"wrapper": true
			},
			"S2n": {
				"type": "list",
				"member": {
					"locationName": "SubnetIdentifier"
				}
			},
			"S3e": {
				"type": "list",
				"member": {
					"locationName": "Filter",
					"type": "structure",
					"required": [
						"Name",
						"Values"
					],
					"members": {
						"Name": {},
						"Values": {
							"type": "list",
							"member": {
								"locationName": "Value"
							}
						}
					}
				}
			},
			"S3p": {
				"type": "list",
				"member": {
					"locationName": "Parameter",
					"type": "structure",
					"members": {
						"ParameterName": {},
						"ParameterValue": {},
						"Description": {},
						"Source": {},
						"ApplyType": {},
						"DataType": {},
						"AllowedValues": {},
						"IsModifiable": {
							"type": "boolean"
						},
						"MinimumEngineVersion": {},
						"ApplyMethod": {}
					}
				}
			},
			"S3u": {
				"type": "structure",
				"members": {
					"DBClusterSnapshotIdentifier": {},
					"DBClusterSnapshotAttributes": {
						"type": "list",
						"member": {
							"locationName": "DBClusterSnapshotAttribute",
							"type": "structure",
							"members": {
								"AttributeName": {},
								"AttributeValues": {
									"shape": "S3x"
								}
							}
						}
					}
				},
				"wrapper": true
			},
			"S3x": {
				"type": "list",
				"member": {
					"locationName": "AttributeValue"
				}
			},
			"S48": {
				"type": "structure",
				"members": {
					"CharacterSetName": {},
					"CharacterSetDescription": {}
				}
			},
			"S4v": {
				"type": "structure",
				"members": {
					"DBSnapshotIdentifier": {},
					"DBSnapshotAttributes": {
						"type": "list",
						"member": {
							"locationName": "DBSnapshotAttribute",
							"type": "structure",
							"members": {
								"AttributeName": {},
								"AttributeValues": {
									"shape": "S3x"
								}
							},
							"wrapper": true
						}
					}
				},
				"wrapper": true
			},
			"S56": {
				"type": "structure",
				"members": {
					"DBParameterGroupFamily": {},
					"Marker": {},
					"Parameters": {
						"shape": "S3p"
					}
				},
				"wrapper": true
			},
			"S69": {
				"type": "structure",
				"members": {
					"ReservedDBInstanceId": {},
					"ReservedDBInstancesOfferingId": {},
					"DBInstanceClass": {},
					"StartTime": {
						"type": "timestamp"
					},
					"Duration": {
						"type": "integer"
					},
					"FixedPrice": {
						"type": "double"
					},
					"UsagePrice": {
						"type": "double"
					},
					"CurrencyCode": {},
					"DBInstanceCount": {
						"type": "integer"
					},
					"ProductDescription": {},
					"OfferingType": {},
					"MultiAZ": {
						"type": "boolean"
					},
					"State": {},
					"RecurringCharges": {
						"shape": "S6b"
					},
					"ReservedDBInstanceArn": {}
				},
				"wrapper": true
			},
			"S6b": {
				"type": "list",
				"member": {
					"locationName": "RecurringCharge",
					"type": "structure",
					"members": {
						"RecurringChargeAmount": {
							"type": "double"
						},
						"RecurringChargeFrequency": {}
					},
					"wrapper": true
				}
			},
			"S6u": {
				"type": "structure",
				"members": {
					"DBClusterParameterGroupName": {}
				}
			},
			"S70": {
				"type": "structure",
				"members": {
					"DBParameterGroupName": {}
				}
			}
		}
	};

/***/ },
/* 426 */
/***/ function(module, exports) {

	module.exports = {
		"pagination": {
			"DescribeDBEngineVersions": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "DBEngineVersions"
			},
			"DescribeDBInstances": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "DBInstances"
			},
			"DescribeDBLogFiles": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "DescribeDBLogFiles"
			},
			"DescribeDBParameterGroups": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "DBParameterGroups"
			},
			"DescribeDBParameters": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "Parameters"
			},
			"DescribeDBSecurityGroups": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "DBSecurityGroups"
			},
			"DescribeDBSnapshots": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "DBSnapshots"
			},
			"DescribeDBSubnetGroups": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "DBSubnetGroups"
			},
			"DescribeEngineDefaultParameters": {
				"input_token": "Marker",
				"output_token": "EngineDefaults.Marker",
				"limit_key": "MaxRecords",
				"result_key": "EngineDefaults.Parameters"
			},
			"DescribeEventSubscriptions": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "EventSubscriptionsList"
			},
			"DescribeEvents": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "Events"
			},
			"DescribeOptionGroupOptions": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "OptionGroupOptions"
			},
			"DescribeOptionGroups": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "OptionGroupsList"
			},
			"DescribeOrderableDBInstanceOptions": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "OrderableDBInstanceOptions"
			},
			"DescribeReservedDBInstances": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "ReservedDBInstances"
			},
			"DescribeReservedDBInstancesOfferings": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "ReservedDBInstancesOfferings"
			},
			"DownloadDBLogFilePortion": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "NumberOfLines",
				"more_results": "AdditionalDataPending",
				"result_key": "LogFileData"
			},
			"ListTagsForResource": {
				"result_key": "TagList"
			}
		}
	};

/***/ },
/* 427 */
/***/ function(module, exports) {

	module.exports = {
		"version": 2,
		"waiters": {
			"DBInstanceAvailable": {
				"delay": 30,
				"operation": "DescribeDBInstances",
				"maxAttempts": 60,
				"acceptors": [
					{
						"expected": "available",
						"matcher": "pathAll",
						"state": "success",
						"argument": "DBInstances[].DBInstanceStatus"
					},
					{
						"expected": "deleted",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "DBInstances[].DBInstanceStatus"
					},
					{
						"expected": "deleting",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "DBInstances[].DBInstanceStatus"
					},
					{
						"expected": "failed",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "DBInstances[].DBInstanceStatus"
					},
					{
						"expected": "incompatible-restore",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "DBInstances[].DBInstanceStatus"
					},
					{
						"expected": "incompatible-parameters",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "DBInstances[].DBInstanceStatus"
					}
				]
			},
			"DBInstanceDeleted": {
				"delay": 30,
				"operation": "DescribeDBInstances",
				"maxAttempts": 60,
				"acceptors": [
					{
						"expected": "deleted",
						"matcher": "pathAll",
						"state": "success",
						"argument": "DBInstances[].DBInstanceStatus"
					},
					{
						"expected": "DBInstanceNotFound",
						"matcher": "error",
						"state": "success"
					},
					{
						"expected": "creating",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "DBInstances[].DBInstanceStatus"
					},
					{
						"expected": "modifying",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "DBInstances[].DBInstanceStatus"
					},
					{
						"expected": "rebooting",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "DBInstances[].DBInstanceStatus"
					},
					{
						"expected": "resetting-master-credentials",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "DBInstances[].DBInstanceStatus"
					}
				]
			}
		}
	};

/***/ },
/* 428 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['redshift'] = {};
	AWS.Redshift = Service.defineService('redshift', ['2012-12-01']);
	Object.defineProperty(apiLoader.services['redshift'], '2012-12-01', {
	  get: function get() {
	    var model = __webpack_require__(429);
	    model.paginators = __webpack_require__(430).pagination;
	    model.waiters = __webpack_require__(431).waiters;
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.Redshift;


/***/ },
/* 429 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2012-12-01",
			"endpointPrefix": "redshift",
			"protocol": "query",
			"serviceFullName": "Amazon Redshift",
			"signatureVersion": "v4",
			"xmlNamespace": "http://redshift.amazonaws.com/doc/2012-12-01/"
		},
		"operations": {
			"AuthorizeClusterSecurityGroupIngress": {
				"input": {
					"type": "structure",
					"required": [
						"ClusterSecurityGroupName"
					],
					"members": {
						"ClusterSecurityGroupName": {},
						"CIDRIP": {},
						"EC2SecurityGroupName": {},
						"EC2SecurityGroupOwnerId": {}
					}
				},
				"output": {
					"resultWrapper": "AuthorizeClusterSecurityGroupIngressResult",
					"type": "structure",
					"members": {
						"ClusterSecurityGroup": {
							"shape": "S4"
						}
					}
				}
			},
			"AuthorizeSnapshotAccess": {
				"input": {
					"type": "structure",
					"required": [
						"SnapshotIdentifier",
						"AccountWithRestoreAccess"
					],
					"members": {
						"SnapshotIdentifier": {},
						"SnapshotClusterIdentifier": {},
						"AccountWithRestoreAccess": {}
					}
				},
				"output": {
					"resultWrapper": "AuthorizeSnapshotAccessResult",
					"type": "structure",
					"members": {
						"Snapshot": {
							"shape": "Sd"
						}
					}
				}
			},
			"CopyClusterSnapshot": {
				"input": {
					"type": "structure",
					"required": [
						"SourceSnapshotIdentifier",
						"TargetSnapshotIdentifier"
					],
					"members": {
						"SourceSnapshotIdentifier": {},
						"SourceSnapshotClusterIdentifier": {},
						"TargetSnapshotIdentifier": {}
					}
				},
				"output": {
					"resultWrapper": "CopyClusterSnapshotResult",
					"type": "structure",
					"members": {
						"Snapshot": {
							"shape": "Sd"
						}
					}
				}
			},
			"CreateCluster": {
				"input": {
					"type": "structure",
					"required": [
						"ClusterIdentifier",
						"NodeType",
						"MasterUsername",
						"MasterUserPassword"
					],
					"members": {
						"DBName": {},
						"ClusterIdentifier": {},
						"ClusterType": {},
						"NodeType": {},
						"MasterUsername": {},
						"MasterUserPassword": {},
						"ClusterSecurityGroups": {
							"shape": "Sp"
						},
						"VpcSecurityGroupIds": {
							"shape": "Sq"
						},
						"ClusterSubnetGroupName": {},
						"AvailabilityZone": {},
						"PreferredMaintenanceWindow": {},
						"ClusterParameterGroupName": {},
						"AutomatedSnapshotRetentionPeriod": {
							"type": "integer"
						},
						"Port": {
							"type": "integer"
						},
						"ClusterVersion": {},
						"AllowVersionUpgrade": {
							"type": "boolean"
						},
						"NumberOfNodes": {
							"type": "integer"
						},
						"PubliclyAccessible": {
							"type": "boolean"
						},
						"Encrypted": {
							"type": "boolean"
						},
						"HsmClientCertificateIdentifier": {},
						"HsmConfigurationIdentifier": {},
						"ElasticIp": {},
						"Tags": {
							"shape": "S7"
						},
						"KmsKeyId": {},
						"EnhancedVpcRouting": {
							"type": "boolean"
						},
						"AdditionalInfo": {},
						"IamRoles": {
							"shape": "St"
						}
					}
				},
				"output": {
					"resultWrapper": "CreateClusterResult",
					"type": "structure",
					"members": {
						"Cluster": {
							"shape": "Sv"
						}
					}
				}
			},
			"CreateClusterParameterGroup": {
				"input": {
					"type": "structure",
					"required": [
						"ParameterGroupName",
						"ParameterGroupFamily",
						"Description"
					],
					"members": {
						"ParameterGroupName": {},
						"ParameterGroupFamily": {},
						"Description": {},
						"Tags": {
							"shape": "S7"
						}
					}
				},
				"output": {
					"resultWrapper": "CreateClusterParameterGroupResult",
					"type": "structure",
					"members": {
						"ClusterParameterGroup": {
							"shape": "S1g"
						}
					}
				}
			},
			"CreateClusterSecurityGroup": {
				"input": {
					"type": "structure",
					"required": [
						"ClusterSecurityGroupName",
						"Description"
					],
					"members": {
						"ClusterSecurityGroupName": {},
						"Description": {},
						"Tags": {
							"shape": "S7"
						}
					}
				},
				"output": {
					"resultWrapper": "CreateClusterSecurityGroupResult",
					"type": "structure",
					"members": {
						"ClusterSecurityGroup": {
							"shape": "S4"
						}
					}
				}
			},
			"CreateClusterSnapshot": {
				"input": {
					"type": "structure",
					"required": [
						"SnapshotIdentifier",
						"ClusterIdentifier"
					],
					"members": {
						"SnapshotIdentifier": {},
						"ClusterIdentifier": {},
						"Tags": {
							"shape": "S7"
						}
					}
				},
				"output": {
					"resultWrapper": "CreateClusterSnapshotResult",
					"type": "structure",
					"members": {
						"Snapshot": {
							"shape": "Sd"
						}
					}
				}
			},
			"CreateClusterSubnetGroup": {
				"input": {
					"type": "structure",
					"required": [
						"ClusterSubnetGroupName",
						"Description",
						"SubnetIds"
					],
					"members": {
						"ClusterSubnetGroupName": {},
						"Description": {},
						"SubnetIds": {
							"shape": "S1m"
						},
						"Tags": {
							"shape": "S7"
						}
					}
				},
				"output": {
					"resultWrapper": "CreateClusterSubnetGroupResult",
					"type": "structure",
					"members": {
						"ClusterSubnetGroup": {
							"shape": "S1o"
						}
					}
				}
			},
			"CreateEventSubscription": {
				"input": {
					"type": "structure",
					"required": [
						"SubscriptionName",
						"SnsTopicArn"
					],
					"members": {
						"SubscriptionName": {},
						"SnsTopicArn": {},
						"SourceType": {},
						"SourceIds": {
							"shape": "S1t"
						},
						"EventCategories": {
							"shape": "S1u"
						},
						"Severity": {},
						"Enabled": {
							"type": "boolean"
						},
						"Tags": {
							"shape": "S7"
						}
					}
				},
				"output": {
					"resultWrapper": "CreateEventSubscriptionResult",
					"type": "structure",
					"members": {
						"EventSubscription": {
							"shape": "S1w"
						}
					}
				}
			},
			"CreateHsmClientCertificate": {
				"input": {
					"type": "structure",
					"required": [
						"HsmClientCertificateIdentifier"
					],
					"members": {
						"HsmClientCertificateIdentifier": {},
						"Tags": {
							"shape": "S7"
						}
					}
				},
				"output": {
					"resultWrapper": "CreateHsmClientCertificateResult",
					"type": "structure",
					"members": {
						"HsmClientCertificate": {
							"shape": "S1z"
						}
					}
				}
			},
			"CreateHsmConfiguration": {
				"input": {
					"type": "structure",
					"required": [
						"HsmConfigurationIdentifier",
						"Description",
						"HsmIpAddress",
						"HsmPartitionName",
						"HsmPartitionPassword",
						"HsmServerPublicCertificate"
					],
					"members": {
						"HsmConfigurationIdentifier": {},
						"Description": {},
						"HsmIpAddress": {},
						"HsmPartitionName": {},
						"HsmPartitionPassword": {},
						"HsmServerPublicCertificate": {},
						"Tags": {
							"shape": "S7"
						}
					}
				},
				"output": {
					"resultWrapper": "CreateHsmConfigurationResult",
					"type": "structure",
					"members": {
						"HsmConfiguration": {
							"shape": "S22"
						}
					}
				}
			},
			"CreateSnapshotCopyGrant": {
				"input": {
					"type": "structure",
					"required": [
						"SnapshotCopyGrantName"
					],
					"members": {
						"SnapshotCopyGrantName": {},
						"KmsKeyId": {},
						"Tags": {
							"shape": "S7"
						}
					}
				},
				"output": {
					"resultWrapper": "CreateSnapshotCopyGrantResult",
					"type": "structure",
					"members": {
						"SnapshotCopyGrant": {
							"shape": "S25"
						}
					}
				}
			},
			"CreateTags": {
				"input": {
					"type": "structure",
					"required": [
						"ResourceName",
						"Tags"
					],
					"members": {
						"ResourceName": {},
						"Tags": {
							"shape": "S7"
						}
					}
				}
			},
			"DeleteCluster": {
				"input": {
					"type": "structure",
					"required": [
						"ClusterIdentifier"
					],
					"members": {
						"ClusterIdentifier": {},
						"SkipFinalClusterSnapshot": {
							"type": "boolean"
						},
						"FinalClusterSnapshotIdentifier": {}
					}
				},
				"output": {
					"resultWrapper": "DeleteClusterResult",
					"type": "structure",
					"members": {
						"Cluster": {
							"shape": "Sv"
						}
					}
				}
			},
			"DeleteClusterParameterGroup": {
				"input": {
					"type": "structure",
					"required": [
						"ParameterGroupName"
					],
					"members": {
						"ParameterGroupName": {}
					}
				}
			},
			"DeleteClusterSecurityGroup": {
				"input": {
					"type": "structure",
					"required": [
						"ClusterSecurityGroupName"
					],
					"members": {
						"ClusterSecurityGroupName": {}
					}
				}
			},
			"DeleteClusterSnapshot": {
				"input": {
					"type": "structure",
					"required": [
						"SnapshotIdentifier"
					],
					"members": {
						"SnapshotIdentifier": {},
						"SnapshotClusterIdentifier": {}
					}
				},
				"output": {
					"resultWrapper": "DeleteClusterSnapshotResult",
					"type": "structure",
					"members": {
						"Snapshot": {
							"shape": "Sd"
						}
					}
				}
			},
			"DeleteClusterSubnetGroup": {
				"input": {
					"type": "structure",
					"required": [
						"ClusterSubnetGroupName"
					],
					"members": {
						"ClusterSubnetGroupName": {}
					}
				}
			},
			"DeleteEventSubscription": {
				"input": {
					"type": "structure",
					"required": [
						"SubscriptionName"
					],
					"members": {
						"SubscriptionName": {}
					}
				}
			},
			"DeleteHsmClientCertificate": {
				"input": {
					"type": "structure",
					"required": [
						"HsmClientCertificateIdentifier"
					],
					"members": {
						"HsmClientCertificateIdentifier": {}
					}
				}
			},
			"DeleteHsmConfiguration": {
				"input": {
					"type": "structure",
					"required": [
						"HsmConfigurationIdentifier"
					],
					"members": {
						"HsmConfigurationIdentifier": {}
					}
				}
			},
			"DeleteSnapshotCopyGrant": {
				"input": {
					"type": "structure",
					"required": [
						"SnapshotCopyGrantName"
					],
					"members": {
						"SnapshotCopyGrantName": {}
					}
				}
			},
			"DeleteTags": {
				"input": {
					"type": "structure",
					"required": [
						"ResourceName",
						"TagKeys"
					],
					"members": {
						"ResourceName": {},
						"TagKeys": {
							"shape": "S2j"
						}
					}
				}
			},
			"DescribeClusterParameterGroups": {
				"input": {
					"type": "structure",
					"members": {
						"ParameterGroupName": {},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {},
						"TagKeys": {
							"shape": "S2j"
						},
						"TagValues": {
							"shape": "S2l"
						}
					}
				},
				"output": {
					"resultWrapper": "DescribeClusterParameterGroupsResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"ParameterGroups": {
							"type": "list",
							"member": {
								"shape": "S1g",
								"locationName": "ClusterParameterGroup"
							}
						}
					}
				}
			},
			"DescribeClusterParameters": {
				"input": {
					"type": "structure",
					"required": [
						"ParameterGroupName"
					],
					"members": {
						"ParameterGroupName": {},
						"Source": {},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeClusterParametersResult",
					"type": "structure",
					"members": {
						"Parameters": {
							"shape": "S2q"
						},
						"Marker": {}
					}
				}
			},
			"DescribeClusterSecurityGroups": {
				"input": {
					"type": "structure",
					"members": {
						"ClusterSecurityGroupName": {},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {},
						"TagKeys": {
							"shape": "S2j"
						},
						"TagValues": {
							"shape": "S2l"
						}
					}
				},
				"output": {
					"resultWrapper": "DescribeClusterSecurityGroupsResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"ClusterSecurityGroups": {
							"type": "list",
							"member": {
								"shape": "S4",
								"locationName": "ClusterSecurityGroup"
							}
						}
					}
				}
			},
			"DescribeClusterSnapshots": {
				"input": {
					"type": "structure",
					"members": {
						"ClusterIdentifier": {},
						"SnapshotIdentifier": {},
						"SnapshotType": {},
						"StartTime": {
							"type": "timestamp"
						},
						"EndTime": {
							"type": "timestamp"
						},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {},
						"OwnerAccount": {},
						"TagKeys": {
							"shape": "S2j"
						},
						"TagValues": {
							"shape": "S2l"
						}
					}
				},
				"output": {
					"resultWrapper": "DescribeClusterSnapshotsResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"Snapshots": {
							"type": "list",
							"member": {
								"shape": "Sd",
								"locationName": "Snapshot"
							}
						}
					}
				}
			},
			"DescribeClusterSubnetGroups": {
				"input": {
					"type": "structure",
					"members": {
						"ClusterSubnetGroupName": {},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {},
						"TagKeys": {
							"shape": "S2j"
						},
						"TagValues": {
							"shape": "S2l"
						}
					}
				},
				"output": {
					"resultWrapper": "DescribeClusterSubnetGroupsResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"ClusterSubnetGroups": {
							"type": "list",
							"member": {
								"shape": "S1o",
								"locationName": "ClusterSubnetGroup"
							}
						}
					}
				}
			},
			"DescribeClusterVersions": {
				"input": {
					"type": "structure",
					"members": {
						"ClusterVersion": {},
						"ClusterParameterGroupFamily": {},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeClusterVersionsResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"ClusterVersions": {
							"type": "list",
							"member": {
								"locationName": "ClusterVersion",
								"type": "structure",
								"members": {
									"ClusterVersion": {},
									"ClusterParameterGroupFamily": {},
									"Description": {}
								}
							}
						}
					}
				}
			},
			"DescribeClusters": {
				"input": {
					"type": "structure",
					"members": {
						"ClusterIdentifier": {},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {},
						"TagKeys": {
							"shape": "S2j"
						},
						"TagValues": {
							"shape": "S2l"
						}
					}
				},
				"output": {
					"resultWrapper": "DescribeClustersResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"Clusters": {
							"type": "list",
							"member": {
								"shape": "Sv",
								"locationName": "Cluster"
							}
						}
					}
				}
			},
			"DescribeDefaultClusterParameters": {
				"input": {
					"type": "structure",
					"required": [
						"ParameterGroupFamily"
					],
					"members": {
						"ParameterGroupFamily": {},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeDefaultClusterParametersResult",
					"type": "structure",
					"members": {
						"DefaultClusterParameters": {
							"type": "structure",
							"members": {
								"ParameterGroupFamily": {},
								"Marker": {},
								"Parameters": {
									"shape": "S2q"
								}
							},
							"wrapper": true
						}
					}
				}
			},
			"DescribeEventCategories": {
				"input": {
					"type": "structure",
					"members": {
						"SourceType": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeEventCategoriesResult",
					"type": "structure",
					"members": {
						"EventCategoriesMapList": {
							"type": "list",
							"member": {
								"locationName": "EventCategoriesMap",
								"type": "structure",
								"members": {
									"SourceType": {},
									"Events": {
										"type": "list",
										"member": {
											"locationName": "EventInfoMap",
											"type": "structure",
											"members": {
												"EventId": {},
												"EventCategories": {
													"shape": "S1u"
												},
												"EventDescription": {},
												"Severity": {}
											},
											"wrapper": true
										}
									}
								},
								"wrapper": true
							}
						}
					}
				}
			},
			"DescribeEventSubscriptions": {
				"input": {
					"type": "structure",
					"members": {
						"SubscriptionName": {},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeEventSubscriptionsResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"EventSubscriptionsList": {
							"type": "list",
							"member": {
								"shape": "S1w",
								"locationName": "EventSubscription"
							}
						}
					}
				}
			},
			"DescribeEvents": {
				"input": {
					"type": "structure",
					"members": {
						"SourceIdentifier": {},
						"SourceType": {},
						"StartTime": {
							"type": "timestamp"
						},
						"EndTime": {
							"type": "timestamp"
						},
						"Duration": {
							"type": "integer"
						},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeEventsResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"Events": {
							"type": "list",
							"member": {
								"locationName": "Event",
								"type": "structure",
								"members": {
									"SourceIdentifier": {},
									"SourceType": {},
									"Message": {},
									"EventCategories": {
										"shape": "S1u"
									},
									"Severity": {},
									"Date": {
										"type": "timestamp"
									},
									"EventId": {}
								}
							}
						}
					}
				}
			},
			"DescribeHsmClientCertificates": {
				"input": {
					"type": "structure",
					"members": {
						"HsmClientCertificateIdentifier": {},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {},
						"TagKeys": {
							"shape": "S2j"
						},
						"TagValues": {
							"shape": "S2l"
						}
					}
				},
				"output": {
					"resultWrapper": "DescribeHsmClientCertificatesResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"HsmClientCertificates": {
							"type": "list",
							"member": {
								"shape": "S1z",
								"locationName": "HsmClientCertificate"
							}
						}
					}
				}
			},
			"DescribeHsmConfigurations": {
				"input": {
					"type": "structure",
					"members": {
						"HsmConfigurationIdentifier": {},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {},
						"TagKeys": {
							"shape": "S2j"
						},
						"TagValues": {
							"shape": "S2l"
						}
					}
				},
				"output": {
					"resultWrapper": "DescribeHsmConfigurationsResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"HsmConfigurations": {
							"type": "list",
							"member": {
								"shape": "S22",
								"locationName": "HsmConfiguration"
							}
						}
					}
				}
			},
			"DescribeLoggingStatus": {
				"input": {
					"type": "structure",
					"required": [
						"ClusterIdentifier"
					],
					"members": {
						"ClusterIdentifier": {}
					}
				},
				"output": {
					"shape": "S3x",
					"resultWrapper": "DescribeLoggingStatusResult"
				}
			},
			"DescribeOrderableClusterOptions": {
				"input": {
					"type": "structure",
					"members": {
						"ClusterVersion": {},
						"NodeType": {},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeOrderableClusterOptionsResult",
					"type": "structure",
					"members": {
						"OrderableClusterOptions": {
							"type": "list",
							"member": {
								"locationName": "OrderableClusterOption",
								"type": "structure",
								"members": {
									"ClusterVersion": {},
									"ClusterType": {},
									"NodeType": {},
									"AvailabilityZones": {
										"type": "list",
										"member": {
											"shape": "S1r",
											"locationName": "AvailabilityZone"
										}
									}
								},
								"wrapper": true
							}
						},
						"Marker": {}
					}
				}
			},
			"DescribeReservedNodeOfferings": {
				"input": {
					"type": "structure",
					"members": {
						"ReservedNodeOfferingId": {},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeReservedNodeOfferingsResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"ReservedNodeOfferings": {
							"type": "list",
							"member": {
								"locationName": "ReservedNodeOffering",
								"type": "structure",
								"members": {
									"ReservedNodeOfferingId": {},
									"NodeType": {},
									"Duration": {
										"type": "integer"
									},
									"FixedPrice": {
										"type": "double"
									},
									"UsagePrice": {
										"type": "double"
									},
									"CurrencyCode": {},
									"OfferingType": {},
									"RecurringCharges": {
										"shape": "S47"
									}
								},
								"wrapper": true
							}
						}
					}
				}
			},
			"DescribeReservedNodes": {
				"input": {
					"type": "structure",
					"members": {
						"ReservedNodeId": {},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeReservedNodesResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"ReservedNodes": {
							"type": "list",
							"member": {
								"shape": "S4c",
								"locationName": "ReservedNode"
							}
						}
					}
				}
			},
			"DescribeResize": {
				"input": {
					"type": "structure",
					"required": [
						"ClusterIdentifier"
					],
					"members": {
						"ClusterIdentifier": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeResizeResult",
					"type": "structure",
					"members": {
						"TargetNodeType": {},
						"TargetNumberOfNodes": {
							"type": "integer"
						},
						"TargetClusterType": {},
						"Status": {},
						"ImportTablesCompleted": {
							"type": "list",
							"member": {}
						},
						"ImportTablesInProgress": {
							"type": "list",
							"member": {}
						},
						"ImportTablesNotStarted": {
							"type": "list",
							"member": {}
						},
						"AvgResizeRateInMegaBytesPerSecond": {
							"type": "double"
						},
						"TotalResizeDataInMegaBytes": {
							"type": "long"
						},
						"ProgressInMegaBytes": {
							"type": "long"
						},
						"ElapsedTimeInSeconds": {
							"type": "long"
						},
						"EstimatedTimeToCompletionInSeconds": {
							"type": "long"
						}
					}
				}
			},
			"DescribeSnapshotCopyGrants": {
				"input": {
					"type": "structure",
					"members": {
						"SnapshotCopyGrantName": {},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {},
						"TagKeys": {
							"shape": "S2j"
						},
						"TagValues": {
							"shape": "S2l"
						}
					}
				},
				"output": {
					"resultWrapper": "DescribeSnapshotCopyGrantsResult",
					"type": "structure",
					"members": {
						"Marker": {},
						"SnapshotCopyGrants": {
							"type": "list",
							"member": {
								"shape": "S25",
								"locationName": "SnapshotCopyGrant"
							}
						}
					}
				}
			},
			"DescribeTableRestoreStatus": {
				"input": {
					"type": "structure",
					"members": {
						"ClusterIdentifier": {},
						"TableRestoreRequestId": {},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeTableRestoreStatusResult",
					"type": "structure",
					"members": {
						"TableRestoreStatusDetails": {
							"type": "list",
							"member": {
								"shape": "S4q",
								"locationName": "TableRestoreStatus"
							}
						},
						"Marker": {}
					}
				}
			},
			"DescribeTags": {
				"input": {
					"type": "structure",
					"members": {
						"ResourceName": {},
						"ResourceType": {},
						"MaxRecords": {
							"type": "integer"
						},
						"Marker": {},
						"TagKeys": {
							"shape": "S2j"
						},
						"TagValues": {
							"shape": "S2l"
						}
					}
				},
				"output": {
					"resultWrapper": "DescribeTagsResult",
					"type": "structure",
					"members": {
						"TaggedResources": {
							"type": "list",
							"member": {
								"locationName": "TaggedResource",
								"type": "structure",
								"members": {
									"Tag": {
										"shape": "S8"
									},
									"ResourceName": {},
									"ResourceType": {}
								}
							}
						},
						"Marker": {}
					}
				}
			},
			"DisableLogging": {
				"input": {
					"type": "structure",
					"required": [
						"ClusterIdentifier"
					],
					"members": {
						"ClusterIdentifier": {}
					}
				},
				"output": {
					"shape": "S3x",
					"resultWrapper": "DisableLoggingResult"
				}
			},
			"DisableSnapshotCopy": {
				"input": {
					"type": "structure",
					"required": [
						"ClusterIdentifier"
					],
					"members": {
						"ClusterIdentifier": {}
					}
				},
				"output": {
					"resultWrapper": "DisableSnapshotCopyResult",
					"type": "structure",
					"members": {
						"Cluster": {
							"shape": "Sv"
						}
					}
				}
			},
			"EnableLogging": {
				"input": {
					"type": "structure",
					"required": [
						"ClusterIdentifier",
						"BucketName"
					],
					"members": {
						"ClusterIdentifier": {},
						"BucketName": {},
						"S3KeyPrefix": {}
					}
				},
				"output": {
					"shape": "S3x",
					"resultWrapper": "EnableLoggingResult"
				}
			},
			"EnableSnapshotCopy": {
				"input": {
					"type": "structure",
					"required": [
						"ClusterIdentifier",
						"DestinationRegion"
					],
					"members": {
						"ClusterIdentifier": {},
						"DestinationRegion": {},
						"RetentionPeriod": {
							"type": "integer"
						},
						"SnapshotCopyGrantName": {}
					}
				},
				"output": {
					"resultWrapper": "EnableSnapshotCopyResult",
					"type": "structure",
					"members": {
						"Cluster": {
							"shape": "Sv"
						}
					}
				}
			},
			"ModifyCluster": {
				"input": {
					"type": "structure",
					"required": [
						"ClusterIdentifier"
					],
					"members": {
						"ClusterIdentifier": {},
						"ClusterType": {},
						"NodeType": {},
						"NumberOfNodes": {
							"type": "integer"
						},
						"ClusterSecurityGroups": {
							"shape": "Sp"
						},
						"VpcSecurityGroupIds": {
							"shape": "Sq"
						},
						"MasterUserPassword": {},
						"ClusterParameterGroupName": {},
						"AutomatedSnapshotRetentionPeriod": {
							"type": "integer"
						},
						"PreferredMaintenanceWindow": {},
						"ClusterVersion": {},
						"AllowVersionUpgrade": {
							"type": "boolean"
						},
						"HsmClientCertificateIdentifier": {},
						"HsmConfigurationIdentifier": {},
						"NewClusterIdentifier": {},
						"PubliclyAccessible": {
							"type": "boolean"
						},
						"ElasticIp": {},
						"EnhancedVpcRouting": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"resultWrapper": "ModifyClusterResult",
					"type": "structure",
					"members": {
						"Cluster": {
							"shape": "Sv"
						}
					}
				}
			},
			"ModifyClusterIamRoles": {
				"input": {
					"type": "structure",
					"required": [
						"ClusterIdentifier"
					],
					"members": {
						"ClusterIdentifier": {},
						"AddIamRoles": {
							"shape": "St"
						},
						"RemoveIamRoles": {
							"shape": "St"
						}
					}
				},
				"output": {
					"resultWrapper": "ModifyClusterIamRolesResult",
					"type": "structure",
					"members": {
						"Cluster": {
							"shape": "Sv"
						}
					}
				}
			},
			"ModifyClusterParameterGroup": {
				"input": {
					"type": "structure",
					"required": [
						"ParameterGroupName",
						"Parameters"
					],
					"members": {
						"ParameterGroupName": {},
						"Parameters": {
							"shape": "S2q"
						}
					}
				},
				"output": {
					"shape": "S57",
					"resultWrapper": "ModifyClusterParameterGroupResult"
				}
			},
			"ModifyClusterSubnetGroup": {
				"input": {
					"type": "structure",
					"required": [
						"ClusterSubnetGroupName",
						"SubnetIds"
					],
					"members": {
						"ClusterSubnetGroupName": {},
						"Description": {},
						"SubnetIds": {
							"shape": "S1m"
						}
					}
				},
				"output": {
					"resultWrapper": "ModifyClusterSubnetGroupResult",
					"type": "structure",
					"members": {
						"ClusterSubnetGroup": {
							"shape": "S1o"
						}
					}
				}
			},
			"ModifyEventSubscription": {
				"input": {
					"type": "structure",
					"required": [
						"SubscriptionName"
					],
					"members": {
						"SubscriptionName": {},
						"SnsTopicArn": {},
						"SourceType": {},
						"SourceIds": {
							"shape": "S1t"
						},
						"EventCategories": {
							"shape": "S1u"
						},
						"Severity": {},
						"Enabled": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"resultWrapper": "ModifyEventSubscriptionResult",
					"type": "structure",
					"members": {
						"EventSubscription": {
							"shape": "S1w"
						}
					}
				}
			},
			"ModifySnapshotCopyRetentionPeriod": {
				"input": {
					"type": "structure",
					"required": [
						"ClusterIdentifier",
						"RetentionPeriod"
					],
					"members": {
						"ClusterIdentifier": {},
						"RetentionPeriod": {
							"type": "integer"
						}
					}
				},
				"output": {
					"resultWrapper": "ModifySnapshotCopyRetentionPeriodResult",
					"type": "structure",
					"members": {
						"Cluster": {
							"shape": "Sv"
						}
					}
				}
			},
			"PurchaseReservedNodeOffering": {
				"input": {
					"type": "structure",
					"required": [
						"ReservedNodeOfferingId"
					],
					"members": {
						"ReservedNodeOfferingId": {},
						"NodeCount": {
							"type": "integer"
						}
					}
				},
				"output": {
					"resultWrapper": "PurchaseReservedNodeOfferingResult",
					"type": "structure",
					"members": {
						"ReservedNode": {
							"shape": "S4c"
						}
					}
				}
			},
			"RebootCluster": {
				"input": {
					"type": "structure",
					"required": [
						"ClusterIdentifier"
					],
					"members": {
						"ClusterIdentifier": {}
					}
				},
				"output": {
					"resultWrapper": "RebootClusterResult",
					"type": "structure",
					"members": {
						"Cluster": {
							"shape": "Sv"
						}
					}
				}
			},
			"ResetClusterParameterGroup": {
				"input": {
					"type": "structure",
					"required": [
						"ParameterGroupName"
					],
					"members": {
						"ParameterGroupName": {},
						"ResetAllParameters": {
							"type": "boolean"
						},
						"Parameters": {
							"shape": "S2q"
						}
					}
				},
				"output": {
					"shape": "S57",
					"resultWrapper": "ResetClusterParameterGroupResult"
				}
			},
			"RestoreFromClusterSnapshot": {
				"input": {
					"type": "structure",
					"required": [
						"ClusterIdentifier",
						"SnapshotIdentifier"
					],
					"members": {
						"ClusterIdentifier": {},
						"SnapshotIdentifier": {},
						"SnapshotClusterIdentifier": {},
						"Port": {
							"type": "integer"
						},
						"AvailabilityZone": {},
						"AllowVersionUpgrade": {
							"type": "boolean"
						},
						"ClusterSubnetGroupName": {},
						"PubliclyAccessible": {
							"type": "boolean"
						},
						"OwnerAccount": {},
						"HsmClientCertificateIdentifier": {},
						"HsmConfigurationIdentifier": {},
						"ElasticIp": {},
						"ClusterParameterGroupName": {},
						"ClusterSecurityGroups": {
							"shape": "Sp"
						},
						"VpcSecurityGroupIds": {
							"shape": "Sq"
						},
						"PreferredMaintenanceWindow": {},
						"AutomatedSnapshotRetentionPeriod": {
							"type": "integer"
						},
						"KmsKeyId": {},
						"NodeType": {},
						"EnhancedVpcRouting": {
							"type": "boolean"
						},
						"AdditionalInfo": {},
						"IamRoles": {
							"shape": "St"
						}
					}
				},
				"output": {
					"resultWrapper": "RestoreFromClusterSnapshotResult",
					"type": "structure",
					"members": {
						"Cluster": {
							"shape": "Sv"
						}
					}
				}
			},
			"RestoreTableFromClusterSnapshot": {
				"input": {
					"type": "structure",
					"required": [
						"ClusterIdentifier",
						"SnapshotIdentifier",
						"SourceDatabaseName",
						"SourceTableName",
						"NewTableName"
					],
					"members": {
						"ClusterIdentifier": {},
						"SnapshotIdentifier": {},
						"SourceDatabaseName": {},
						"SourceSchemaName": {},
						"SourceTableName": {},
						"TargetDatabaseName": {},
						"TargetSchemaName": {},
						"NewTableName": {}
					}
				},
				"output": {
					"resultWrapper": "RestoreTableFromClusterSnapshotResult",
					"type": "structure",
					"members": {
						"TableRestoreStatus": {
							"shape": "S4q"
						}
					}
				}
			},
			"RevokeClusterSecurityGroupIngress": {
				"input": {
					"type": "structure",
					"required": [
						"ClusterSecurityGroupName"
					],
					"members": {
						"ClusterSecurityGroupName": {},
						"CIDRIP": {},
						"EC2SecurityGroupName": {},
						"EC2SecurityGroupOwnerId": {}
					}
				},
				"output": {
					"resultWrapper": "RevokeClusterSecurityGroupIngressResult",
					"type": "structure",
					"members": {
						"ClusterSecurityGroup": {
							"shape": "S4"
						}
					}
				}
			},
			"RevokeSnapshotAccess": {
				"input": {
					"type": "structure",
					"required": [
						"SnapshotIdentifier",
						"AccountWithRestoreAccess"
					],
					"members": {
						"SnapshotIdentifier": {},
						"SnapshotClusterIdentifier": {},
						"AccountWithRestoreAccess": {}
					}
				},
				"output": {
					"resultWrapper": "RevokeSnapshotAccessResult",
					"type": "structure",
					"members": {
						"Snapshot": {
							"shape": "Sd"
						}
					}
				}
			},
			"RotateEncryptionKey": {
				"input": {
					"type": "structure",
					"required": [
						"ClusterIdentifier"
					],
					"members": {
						"ClusterIdentifier": {}
					}
				},
				"output": {
					"resultWrapper": "RotateEncryptionKeyResult",
					"type": "structure",
					"members": {
						"Cluster": {
							"shape": "Sv"
						}
					}
				}
			}
		},
		"shapes": {
			"S4": {
				"type": "structure",
				"members": {
					"ClusterSecurityGroupName": {},
					"Description": {},
					"EC2SecurityGroups": {
						"type": "list",
						"member": {
							"locationName": "EC2SecurityGroup",
							"type": "structure",
							"members": {
								"Status": {},
								"EC2SecurityGroupName": {},
								"EC2SecurityGroupOwnerId": {},
								"Tags": {
									"shape": "S7"
								}
							}
						}
					},
					"IPRanges": {
						"type": "list",
						"member": {
							"locationName": "IPRange",
							"type": "structure",
							"members": {
								"Status": {},
								"CIDRIP": {},
								"Tags": {
									"shape": "S7"
								}
							}
						}
					},
					"Tags": {
						"shape": "S7"
					}
				},
				"wrapper": true
			},
			"S7": {
				"type": "list",
				"member": {
					"shape": "S8",
					"locationName": "Tag"
				}
			},
			"S8": {
				"type": "structure",
				"members": {
					"Key": {},
					"Value": {}
				}
			},
			"Sd": {
				"type": "structure",
				"members": {
					"SnapshotIdentifier": {},
					"ClusterIdentifier": {},
					"SnapshotCreateTime": {
						"type": "timestamp"
					},
					"Status": {},
					"Port": {
						"type": "integer"
					},
					"AvailabilityZone": {},
					"ClusterCreateTime": {
						"type": "timestamp"
					},
					"MasterUsername": {},
					"ClusterVersion": {},
					"SnapshotType": {},
					"NodeType": {},
					"NumberOfNodes": {
						"type": "integer"
					},
					"DBName": {},
					"VpcId": {},
					"Encrypted": {
						"type": "boolean"
					},
					"KmsKeyId": {},
					"EncryptedWithHSM": {
						"type": "boolean"
					},
					"AccountsWithRestoreAccess": {
						"type": "list",
						"member": {
							"locationName": "AccountWithRestoreAccess",
							"type": "structure",
							"members": {
								"AccountId": {}
							}
						}
					},
					"OwnerAccount": {},
					"TotalBackupSizeInMegaBytes": {
						"type": "double"
					},
					"ActualIncrementalBackupSizeInMegaBytes": {
						"type": "double"
					},
					"BackupProgressInMegaBytes": {
						"type": "double"
					},
					"CurrentBackupRateInMegaBytesPerSecond": {
						"type": "double"
					},
					"EstimatedSecondsToCompletion": {
						"type": "long"
					},
					"ElapsedTimeInSeconds": {
						"type": "long"
					},
					"SourceRegion": {},
					"Tags": {
						"shape": "S7"
					},
					"RestorableNodeTypes": {
						"type": "list",
						"member": {
							"locationName": "NodeType"
						}
					},
					"EnhancedVpcRouting": {
						"type": "boolean"
					}
				},
				"wrapper": true
			},
			"Sp": {
				"type": "list",
				"member": {
					"locationName": "ClusterSecurityGroupName"
				}
			},
			"Sq": {
				"type": "list",
				"member": {
					"locationName": "VpcSecurityGroupId"
				}
			},
			"St": {
				"type": "list",
				"member": {
					"locationName": "IamRoleArn"
				}
			},
			"Sv": {
				"type": "structure",
				"members": {
					"ClusterIdentifier": {},
					"NodeType": {},
					"ClusterStatus": {},
					"ModifyStatus": {},
					"MasterUsername": {},
					"DBName": {},
					"Endpoint": {
						"type": "structure",
						"members": {
							"Address": {},
							"Port": {
								"type": "integer"
							}
						}
					},
					"ClusterCreateTime": {
						"type": "timestamp"
					},
					"AutomatedSnapshotRetentionPeriod": {
						"type": "integer"
					},
					"ClusterSecurityGroups": {
						"type": "list",
						"member": {
							"locationName": "ClusterSecurityGroup",
							"type": "structure",
							"members": {
								"ClusterSecurityGroupName": {},
								"Status": {}
							}
						}
					},
					"VpcSecurityGroups": {
						"type": "list",
						"member": {
							"locationName": "VpcSecurityGroup",
							"type": "structure",
							"members": {
								"VpcSecurityGroupId": {},
								"Status": {}
							}
						}
					},
					"ClusterParameterGroups": {
						"type": "list",
						"member": {
							"locationName": "ClusterParameterGroup",
							"type": "structure",
							"members": {
								"ParameterGroupName": {},
								"ParameterApplyStatus": {},
								"ClusterParameterStatusList": {
									"type": "list",
									"member": {
										"type": "structure",
										"members": {
											"ParameterName": {},
											"ParameterApplyStatus": {},
											"ParameterApplyErrorDescription": {}
										}
									}
								}
							}
						}
					},
					"ClusterSubnetGroupName": {},
					"VpcId": {},
					"AvailabilityZone": {},
					"PreferredMaintenanceWindow": {},
					"PendingModifiedValues": {
						"type": "structure",
						"members": {
							"MasterUserPassword": {},
							"NodeType": {},
							"NumberOfNodes": {
								"type": "integer"
							},
							"ClusterType": {},
							"ClusterVersion": {},
							"AutomatedSnapshotRetentionPeriod": {
								"type": "integer"
							},
							"ClusterIdentifier": {},
							"PubliclyAccessible": {
								"type": "boolean"
							},
							"EnhancedVpcRouting": {
								"type": "boolean"
							}
						}
					},
					"ClusterVersion": {},
					"AllowVersionUpgrade": {
						"type": "boolean"
					},
					"NumberOfNodes": {
						"type": "integer"
					},
					"PubliclyAccessible": {
						"type": "boolean"
					},
					"Encrypted": {
						"type": "boolean"
					},
					"RestoreStatus": {
						"type": "structure",
						"members": {
							"Status": {},
							"CurrentRestoreRateInMegaBytesPerSecond": {
								"type": "double"
							},
							"SnapshotSizeInMegaBytes": {
								"type": "long"
							},
							"ProgressInMegaBytes": {
								"type": "long"
							},
							"ElapsedTimeInSeconds": {
								"type": "long"
							},
							"EstimatedTimeToCompletionInSeconds": {
								"type": "long"
							}
						}
					},
					"HsmStatus": {
						"type": "structure",
						"members": {
							"HsmClientCertificateIdentifier": {},
							"HsmConfigurationIdentifier": {},
							"Status": {}
						}
					},
					"ClusterSnapshotCopyStatus": {
						"type": "structure",
						"members": {
							"DestinationRegion": {},
							"RetentionPeriod": {
								"type": "long"
							},
							"SnapshotCopyGrantName": {}
						}
					},
					"ClusterPublicKey": {},
					"ClusterNodes": {
						"type": "list",
						"member": {
							"type": "structure",
							"members": {
								"NodeRole": {},
								"PrivateIPAddress": {},
								"PublicIPAddress": {}
							}
						}
					},
					"ElasticIpStatus": {
						"type": "structure",
						"members": {
							"ElasticIp": {},
							"Status": {}
						}
					},
					"ClusterRevisionNumber": {},
					"Tags": {
						"shape": "S7"
					},
					"KmsKeyId": {},
					"EnhancedVpcRouting": {
						"type": "boolean"
					},
					"IamRoles": {
						"type": "list",
						"member": {
							"locationName": "ClusterIamRole",
							"type": "structure",
							"members": {
								"IamRoleArn": {},
								"ApplyStatus": {}
							}
						}
					}
				},
				"wrapper": true
			},
			"S1g": {
				"type": "structure",
				"members": {
					"ParameterGroupName": {},
					"ParameterGroupFamily": {},
					"Description": {},
					"Tags": {
						"shape": "S7"
					}
				},
				"wrapper": true
			},
			"S1m": {
				"type": "list",
				"member": {
					"locationName": "SubnetIdentifier"
				}
			},
			"S1o": {
				"type": "structure",
				"members": {
					"ClusterSubnetGroupName": {},
					"Description": {},
					"VpcId": {},
					"SubnetGroupStatus": {},
					"Subnets": {
						"type": "list",
						"member": {
							"locationName": "Subnet",
							"type": "structure",
							"members": {
								"SubnetIdentifier": {},
								"SubnetAvailabilityZone": {
									"shape": "S1r"
								},
								"SubnetStatus": {}
							}
						}
					},
					"Tags": {
						"shape": "S7"
					}
				},
				"wrapper": true
			},
			"S1r": {
				"type": "structure",
				"members": {
					"Name": {}
				},
				"wrapper": true
			},
			"S1t": {
				"type": "list",
				"member": {
					"locationName": "SourceId"
				}
			},
			"S1u": {
				"type": "list",
				"member": {
					"locationName": "EventCategory"
				}
			},
			"S1w": {
				"type": "structure",
				"members": {
					"CustomerAwsId": {},
					"CustSubscriptionId": {},
					"SnsTopicArn": {},
					"Status": {},
					"SubscriptionCreationTime": {
						"type": "timestamp"
					},
					"SourceType": {},
					"SourceIdsList": {
						"shape": "S1t"
					},
					"EventCategoriesList": {
						"shape": "S1u"
					},
					"Severity": {},
					"Enabled": {
						"type": "boolean"
					},
					"Tags": {
						"shape": "S7"
					}
				},
				"wrapper": true
			},
			"S1z": {
				"type": "structure",
				"members": {
					"HsmClientCertificateIdentifier": {},
					"HsmClientCertificatePublicKey": {},
					"Tags": {
						"shape": "S7"
					}
				},
				"wrapper": true
			},
			"S22": {
				"type": "structure",
				"members": {
					"HsmConfigurationIdentifier": {},
					"Description": {},
					"HsmIpAddress": {},
					"HsmPartitionName": {},
					"Tags": {
						"shape": "S7"
					}
				},
				"wrapper": true
			},
			"S25": {
				"type": "structure",
				"members": {
					"SnapshotCopyGrantName": {},
					"KmsKeyId": {},
					"Tags": {
						"shape": "S7"
					}
				},
				"wrapper": true
			},
			"S2j": {
				"type": "list",
				"member": {
					"locationName": "TagKey"
				}
			},
			"S2l": {
				"type": "list",
				"member": {
					"locationName": "TagValue"
				}
			},
			"S2q": {
				"type": "list",
				"member": {
					"locationName": "Parameter",
					"type": "structure",
					"members": {
						"ParameterName": {},
						"ParameterValue": {},
						"Description": {},
						"Source": {},
						"DataType": {},
						"AllowedValues": {},
						"ApplyType": {},
						"IsModifiable": {
							"type": "boolean"
						},
						"MinimumEngineVersion": {}
					}
				}
			},
			"S3x": {
				"type": "structure",
				"members": {
					"LoggingEnabled": {
						"type": "boolean"
					},
					"BucketName": {},
					"S3KeyPrefix": {},
					"LastSuccessfulDeliveryTime": {
						"type": "timestamp"
					},
					"LastFailureTime": {
						"type": "timestamp"
					},
					"LastFailureMessage": {}
				}
			},
			"S47": {
				"type": "list",
				"member": {
					"locationName": "RecurringCharge",
					"type": "structure",
					"members": {
						"RecurringChargeAmount": {
							"type": "double"
						},
						"RecurringChargeFrequency": {}
					},
					"wrapper": true
				}
			},
			"S4c": {
				"type": "structure",
				"members": {
					"ReservedNodeId": {},
					"ReservedNodeOfferingId": {},
					"NodeType": {},
					"StartTime": {
						"type": "timestamp"
					},
					"Duration": {
						"type": "integer"
					},
					"FixedPrice": {
						"type": "double"
					},
					"UsagePrice": {
						"type": "double"
					},
					"CurrencyCode": {},
					"NodeCount": {
						"type": "integer"
					},
					"State": {},
					"OfferingType": {},
					"RecurringCharges": {
						"shape": "S47"
					}
				},
				"wrapper": true
			},
			"S4q": {
				"type": "structure",
				"members": {
					"TableRestoreRequestId": {},
					"Status": {},
					"Message": {},
					"RequestTime": {
						"type": "timestamp"
					},
					"ProgressInMegaBytes": {
						"type": "long"
					},
					"TotalDataInMegaBytes": {
						"type": "long"
					},
					"ClusterIdentifier": {},
					"SnapshotIdentifier": {},
					"SourceDatabaseName": {},
					"SourceSchemaName": {},
					"SourceTableName": {},
					"TargetDatabaseName": {},
					"TargetSchemaName": {},
					"NewTableName": {}
				},
				"wrapper": true
			},
			"S57": {
				"type": "structure",
				"members": {
					"ParameterGroupName": {},
					"ParameterGroupStatus": {}
				}
			}
		}
	};

/***/ },
/* 430 */
/***/ function(module, exports) {

	module.exports = {
		"pagination": {
			"DescribeClusterParameterGroups": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "ParameterGroups"
			},
			"DescribeClusterParameters": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "Parameters"
			},
			"DescribeClusterSecurityGroups": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "ClusterSecurityGroups"
			},
			"DescribeClusterSnapshots": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "Snapshots"
			},
			"DescribeClusterSubnetGroups": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "ClusterSubnetGroups"
			},
			"DescribeClusterVersions": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "ClusterVersions"
			},
			"DescribeClusters": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "Clusters"
			},
			"DescribeDefaultClusterParameters": {
				"input_token": "Marker",
				"output_token": "DefaultClusterParameters.Marker",
				"limit_key": "MaxRecords",
				"result_key": "DefaultClusterParameters.Parameters"
			},
			"DescribeEventSubscriptions": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "EventSubscriptionsList"
			},
			"DescribeEvents": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "Events"
			},
			"DescribeHsmClientCertificates": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "HsmClientCertificates"
			},
			"DescribeHsmConfigurations": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "HsmConfigurations"
			},
			"DescribeOrderableClusterOptions": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "OrderableClusterOptions"
			},
			"DescribeReservedNodeOfferings": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "ReservedNodeOfferings"
			},
			"DescribeReservedNodes": {
				"input_token": "Marker",
				"output_token": "Marker",
				"limit_key": "MaxRecords",
				"result_key": "ReservedNodes"
			}
		}
	};

/***/ },
/* 431 */
/***/ function(module, exports) {

	module.exports = {
		"version": 2,
		"waiters": {
			"ClusterAvailable": {
				"delay": 60,
				"operation": "DescribeClusters",
				"maxAttempts": 30,
				"acceptors": [
					{
						"expected": "available",
						"matcher": "pathAll",
						"state": "success",
						"argument": "Clusters[].ClusterStatus"
					},
					{
						"expected": "deleting",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "Clusters[].ClusterStatus"
					},
					{
						"expected": "ClusterNotFound",
						"matcher": "error",
						"state": "retry"
					}
				]
			},
			"ClusterDeleted": {
				"delay": 60,
				"operation": "DescribeClusters",
				"maxAttempts": 30,
				"acceptors": [
					{
						"expected": "ClusterNotFound",
						"matcher": "error",
						"state": "success"
					},
					{
						"expected": "creating",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "Clusters[].ClusterStatus"
					},
					{
						"expected": "modifying",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "Clusters[].ClusterStatus"
					}
				]
			},
			"ClusterRestored": {
				"operation": "DescribeClusters",
				"maxAttempts": 30,
				"delay": 60,
				"acceptors": [
					{
						"state": "success",
						"matcher": "pathAll",
						"argument": "Clusters[].RestoreStatus.Status",
						"expected": "completed"
					},
					{
						"state": "failure",
						"matcher": "pathAny",
						"argument": "Clusters[].ClusterStatus",
						"expected": "deleting"
					}
				]
			},
			"SnapshotAvailable": {
				"delay": 15,
				"operation": "DescribeClusterSnapshots",
				"maxAttempts": 20,
				"acceptors": [
					{
						"expected": "available",
						"matcher": "pathAll",
						"state": "success",
						"argument": "Snapshots[].Status"
					},
					{
						"expected": "failed",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "Snapshots[].Status"
					},
					{
						"expected": "deleted",
						"matcher": "pathAny",
						"state": "failure",
						"argument": "Snapshots[].Status"
					}
				]
			}
		}
	};

/***/ },
/* 432 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['route53'] = {};
	AWS.Route53 = Service.defineService('route53', ['2013-04-01']);
	__webpack_require__(433);
	Object.defineProperty(apiLoader.services['route53'], '2013-04-01', {
	  get: function get() {
	    var model = __webpack_require__(434);
	    model.paginators = __webpack_require__(435).pagination;
	    model.waiters = __webpack_require__(436).waiters;
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.Route53;


/***/ },
/* 433 */
/***/ function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(93);

	AWS.util.update(AWS.Route53.prototype, {
	  /**
	   * @api private
	   */
	  setupRequestListeners: function setupRequestListeners(request) {
	    request.on('build', this.sanitizeUrl);
	  },

	  /**
	   * @api private
	   */
	  sanitizeUrl: function sanitizeUrl(request) {
	    var path = request.httpRequest.path;
	    request.httpRequest.path = path.replace(/\/%2F\w+%2F/, '/');
	  },

	  /**
	   * @return [Boolean] whether the error can be retried
	   * @api private
	   */
	  retryableError: function retryableError(error) {
	    if (error.code === 'PriorRequestNotComplete' &&
	        error.statusCode === 400) {
	      return true;
	    } else {
	      var _super = AWS.Service.prototype.retryableError;
	      return _super.call(this, error);
	    }
	  }
	});


/***/ },
/* 434 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2013-04-01",
			"endpointPrefix": "route53",
			"globalEndpoint": "route53.amazonaws.com",
			"protocol": "rest-xml",
			"serviceAbbreviation": "Route 53",
			"serviceFullName": "Amazon Route 53",
			"signatureVersion": "v4"
		},
		"operations": {
			"AssociateVPCWithHostedZone": {
				"http": {
					"requestUri": "/2013-04-01/hostedzone/{Id}/associatevpc"
				},
				"input": {
					"locationName": "AssociateVPCWithHostedZoneRequest",
					"xmlNamespace": {
						"uri": "https://route53.amazonaws.com/doc/2013-04-01/"
					},
					"type": "structure",
					"required": [
						"HostedZoneId",
						"VPC"
					],
					"members": {
						"HostedZoneId": {
							"location": "uri",
							"locationName": "Id"
						},
						"VPC": {
							"shape": "S3"
						},
						"Comment": {}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"ChangeInfo"
					],
					"members": {
						"ChangeInfo": {
							"shape": "S8"
						}
					}
				}
			},
			"ChangeResourceRecordSets": {
				"http": {
					"requestUri": "/2013-04-01/hostedzone/{Id}/rrset/"
				},
				"input": {
					"locationName": "ChangeResourceRecordSetsRequest",
					"xmlNamespace": {
						"uri": "https://route53.amazonaws.com/doc/2013-04-01/"
					},
					"type": "structure",
					"required": [
						"HostedZoneId",
						"ChangeBatch"
					],
					"members": {
						"HostedZoneId": {
							"location": "uri",
							"locationName": "Id"
						},
						"ChangeBatch": {
							"type": "structure",
							"required": [
								"Changes"
							],
							"members": {
								"Comment": {},
								"Changes": {
									"shape": "Se"
								}
							}
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"ChangeInfo"
					],
					"members": {
						"ChangeInfo": {
							"shape": "S8"
						}
					}
				}
			},
			"ChangeTagsForResource": {
				"http": {
					"requestUri": "/2013-04-01/tags/{ResourceType}/{ResourceId}"
				},
				"input": {
					"locationName": "ChangeTagsForResourceRequest",
					"xmlNamespace": {
						"uri": "https://route53.amazonaws.com/doc/2013-04-01/"
					},
					"type": "structure",
					"required": [
						"ResourceType",
						"ResourceId"
					],
					"members": {
						"ResourceType": {
							"location": "uri",
							"locationName": "ResourceType"
						},
						"ResourceId": {
							"location": "uri",
							"locationName": "ResourceId"
						},
						"AddTags": {
							"shape": "S14"
						},
						"RemoveTagKeys": {
							"type": "list",
							"member": {
								"locationName": "Key"
							}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"CreateHealthCheck": {
				"http": {
					"requestUri": "/2013-04-01/healthcheck",
					"responseCode": 201
				},
				"input": {
					"locationName": "CreateHealthCheckRequest",
					"xmlNamespace": {
						"uri": "https://route53.amazonaws.com/doc/2013-04-01/"
					},
					"type": "structure",
					"required": [
						"CallerReference",
						"HealthCheckConfig"
					],
					"members": {
						"CallerReference": {},
						"HealthCheckConfig": {
							"shape": "S1c"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"HealthCheck",
						"Location"
					],
					"members": {
						"HealthCheck": {
							"shape": "S1x"
						},
						"Location": {
							"location": "header",
							"locationName": "Location"
						}
					}
				}
			},
			"CreateHostedZone": {
				"http": {
					"requestUri": "/2013-04-01/hostedzone",
					"responseCode": 201
				},
				"input": {
					"locationName": "CreateHostedZoneRequest",
					"xmlNamespace": {
						"uri": "https://route53.amazonaws.com/doc/2013-04-01/"
					},
					"type": "structure",
					"required": [
						"Name",
						"CallerReference"
					],
					"members": {
						"Name": {},
						"VPC": {
							"shape": "S3"
						},
						"CallerReference": {},
						"HostedZoneConfig": {
							"shape": "S2d"
						},
						"DelegationSetId": {}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"HostedZone",
						"ChangeInfo",
						"DelegationSet",
						"Location"
					],
					"members": {
						"HostedZone": {
							"shape": "S2g"
						},
						"ChangeInfo": {
							"shape": "S8"
						},
						"DelegationSet": {
							"shape": "S2i"
						},
						"VPC": {
							"shape": "S3"
						},
						"Location": {
							"location": "header",
							"locationName": "Location"
						}
					}
				}
			},
			"CreateReusableDelegationSet": {
				"http": {
					"requestUri": "/2013-04-01/delegationset",
					"responseCode": 201
				},
				"input": {
					"locationName": "CreateReusableDelegationSetRequest",
					"xmlNamespace": {
						"uri": "https://route53.amazonaws.com/doc/2013-04-01/"
					},
					"type": "structure",
					"required": [
						"CallerReference"
					],
					"members": {
						"CallerReference": {},
						"HostedZoneId": {}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"DelegationSet",
						"Location"
					],
					"members": {
						"DelegationSet": {
							"shape": "S2i"
						},
						"Location": {
							"location": "header",
							"locationName": "Location"
						}
					}
				}
			},
			"CreateTrafficPolicy": {
				"http": {
					"requestUri": "/2013-04-01/trafficpolicy",
					"responseCode": 201
				},
				"input": {
					"locationName": "CreateTrafficPolicyRequest",
					"xmlNamespace": {
						"uri": "https://route53.amazonaws.com/doc/2013-04-01/"
					},
					"type": "structure",
					"required": [
						"Name",
						"Document"
					],
					"members": {
						"Name": {},
						"Document": {},
						"Comment": {}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"TrafficPolicy",
						"Location"
					],
					"members": {
						"TrafficPolicy": {
							"shape": "S2r"
						},
						"Location": {
							"location": "header",
							"locationName": "Location"
						}
					}
				}
			},
			"CreateTrafficPolicyInstance": {
				"http": {
					"requestUri": "/2013-04-01/trafficpolicyinstance",
					"responseCode": 201
				},
				"input": {
					"locationName": "CreateTrafficPolicyInstanceRequest",
					"xmlNamespace": {
						"uri": "https://route53.amazonaws.com/doc/2013-04-01/"
					},
					"type": "structure",
					"required": [
						"HostedZoneId",
						"Name",
						"TTL",
						"TrafficPolicyId",
						"TrafficPolicyVersion"
					],
					"members": {
						"HostedZoneId": {},
						"Name": {},
						"TTL": {
							"type": "long"
						},
						"TrafficPolicyId": {},
						"TrafficPolicyVersion": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"TrafficPolicyInstance",
						"Location"
					],
					"members": {
						"TrafficPolicyInstance": {
							"shape": "S2w"
						},
						"Location": {
							"location": "header",
							"locationName": "Location"
						}
					}
				}
			},
			"CreateTrafficPolicyVersion": {
				"http": {
					"requestUri": "/2013-04-01/trafficpolicy/{Id}",
					"responseCode": 201
				},
				"input": {
					"locationName": "CreateTrafficPolicyVersionRequest",
					"xmlNamespace": {
						"uri": "https://route53.amazonaws.com/doc/2013-04-01/"
					},
					"type": "structure",
					"required": [
						"Id",
						"Document"
					],
					"members": {
						"Id": {
							"location": "uri",
							"locationName": "Id"
						},
						"Document": {},
						"Comment": {}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"TrafficPolicy",
						"Location"
					],
					"members": {
						"TrafficPolicy": {
							"shape": "S2r"
						},
						"Location": {
							"location": "header",
							"locationName": "Location"
						}
					}
				}
			},
			"DeleteHealthCheck": {
				"http": {
					"method": "DELETE",
					"requestUri": "/2013-04-01/healthcheck/{HealthCheckId}"
				},
				"input": {
					"type": "structure",
					"required": [
						"HealthCheckId"
					],
					"members": {
						"HealthCheckId": {
							"location": "uri",
							"locationName": "HealthCheckId"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"DeleteHostedZone": {
				"http": {
					"method": "DELETE",
					"requestUri": "/2013-04-01/hostedzone/{Id}"
				},
				"input": {
					"type": "structure",
					"required": [
						"Id"
					],
					"members": {
						"Id": {
							"location": "uri",
							"locationName": "Id"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"ChangeInfo"
					],
					"members": {
						"ChangeInfo": {
							"shape": "S8"
						}
					}
				}
			},
			"DeleteReusableDelegationSet": {
				"http": {
					"method": "DELETE",
					"requestUri": "/2013-04-01/delegationset/{Id}"
				},
				"input": {
					"type": "structure",
					"required": [
						"Id"
					],
					"members": {
						"Id": {
							"location": "uri",
							"locationName": "Id"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"DeleteTrafficPolicy": {
				"http": {
					"method": "DELETE",
					"requestUri": "/2013-04-01/trafficpolicy/{Id}/{Version}"
				},
				"input": {
					"type": "structure",
					"required": [
						"Id",
						"Version"
					],
					"members": {
						"Id": {
							"location": "uri",
							"locationName": "Id"
						},
						"Version": {
							"location": "uri",
							"locationName": "Version",
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"DeleteTrafficPolicyInstance": {
				"http": {
					"method": "DELETE",
					"requestUri": "/2013-04-01/trafficpolicyinstance/{Id}"
				},
				"input": {
					"type": "structure",
					"required": [
						"Id"
					],
					"members": {
						"Id": {
							"location": "uri",
							"locationName": "Id"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"DisassociateVPCFromHostedZone": {
				"http": {
					"requestUri": "/2013-04-01/hostedzone/{Id}/disassociatevpc"
				},
				"input": {
					"locationName": "DisassociateVPCFromHostedZoneRequest",
					"xmlNamespace": {
						"uri": "https://route53.amazonaws.com/doc/2013-04-01/"
					},
					"type": "structure",
					"required": [
						"HostedZoneId",
						"VPC"
					],
					"members": {
						"HostedZoneId": {
							"location": "uri",
							"locationName": "Id"
						},
						"VPC": {
							"shape": "S3"
						},
						"Comment": {}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"ChangeInfo"
					],
					"members": {
						"ChangeInfo": {
							"shape": "S8"
						}
					}
				}
			},
			"GetChange": {
				"http": {
					"method": "GET",
					"requestUri": "/2013-04-01/change/{Id}"
				},
				"input": {
					"type": "structure",
					"required": [
						"Id"
					],
					"members": {
						"Id": {
							"location": "uri",
							"locationName": "Id"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"ChangeInfo"
					],
					"members": {
						"ChangeInfo": {
							"shape": "S8"
						}
					}
				}
			},
			"GetChangeDetails": {
				"http": {
					"method": "GET",
					"requestUri": "/2013-04-01/changedetails/{Id}"
				},
				"input": {
					"type": "structure",
					"required": [
						"Id"
					],
					"members": {
						"Id": {
							"location": "uri",
							"locationName": "Id"
						}
					},
					"deprecated": true
				},
				"output": {
					"type": "structure",
					"required": [
						"ChangeBatchRecord"
					],
					"members": {
						"ChangeBatchRecord": {
							"shape": "S3i"
						}
					},
					"deprecated": true
				},
				"deprecated": true
			},
			"GetCheckerIpRanges": {
				"http": {
					"method": "GET",
					"requestUri": "/2013-04-01/checkeripranges"
				},
				"input": {
					"type": "structure",
					"members": {}
				},
				"output": {
					"type": "structure",
					"required": [
						"CheckerIpRanges"
					],
					"members": {
						"CheckerIpRanges": {
							"type": "list",
							"member": {}
						}
					}
				}
			},
			"GetGeoLocation": {
				"http": {
					"method": "GET",
					"requestUri": "/2013-04-01/geolocation"
				},
				"input": {
					"type": "structure",
					"members": {
						"ContinentCode": {
							"location": "querystring",
							"locationName": "continentcode"
						},
						"CountryCode": {
							"location": "querystring",
							"locationName": "countrycode"
						},
						"SubdivisionCode": {
							"location": "querystring",
							"locationName": "subdivisioncode"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"GeoLocationDetails"
					],
					"members": {
						"GeoLocationDetails": {
							"shape": "S3q"
						}
					}
				}
			},
			"GetHealthCheck": {
				"http": {
					"method": "GET",
					"requestUri": "/2013-04-01/healthcheck/{HealthCheckId}"
				},
				"input": {
					"type": "structure",
					"required": [
						"HealthCheckId"
					],
					"members": {
						"HealthCheckId": {
							"location": "uri",
							"locationName": "HealthCheckId"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"HealthCheck"
					],
					"members": {
						"HealthCheck": {
							"shape": "S1x"
						}
					}
				}
			},
			"GetHealthCheckCount": {
				"http": {
					"method": "GET",
					"requestUri": "/2013-04-01/healthcheckcount"
				},
				"input": {
					"type": "structure",
					"members": {}
				},
				"output": {
					"type": "structure",
					"required": [
						"HealthCheckCount"
					],
					"members": {
						"HealthCheckCount": {
							"type": "long"
						}
					}
				}
			},
			"GetHealthCheckLastFailureReason": {
				"http": {
					"method": "GET",
					"requestUri": "/2013-04-01/healthcheck/{HealthCheckId}/lastfailurereason"
				},
				"input": {
					"type": "structure",
					"required": [
						"HealthCheckId"
					],
					"members": {
						"HealthCheckId": {
							"location": "uri",
							"locationName": "HealthCheckId"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"HealthCheckObservations"
					],
					"members": {
						"HealthCheckObservations": {
							"shape": "S41"
						}
					}
				}
			},
			"GetHealthCheckStatus": {
				"http": {
					"method": "GET",
					"requestUri": "/2013-04-01/healthcheck/{HealthCheckId}/status"
				},
				"input": {
					"type": "structure",
					"required": [
						"HealthCheckId"
					],
					"members": {
						"HealthCheckId": {
							"location": "uri",
							"locationName": "HealthCheckId"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"HealthCheckObservations"
					],
					"members": {
						"HealthCheckObservations": {
							"shape": "S41"
						}
					}
				}
			},
			"GetHostedZone": {
				"http": {
					"method": "GET",
					"requestUri": "/2013-04-01/hostedzone/{Id}"
				},
				"input": {
					"type": "structure",
					"required": [
						"Id"
					],
					"members": {
						"Id": {
							"location": "uri",
							"locationName": "Id"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"HostedZone"
					],
					"members": {
						"HostedZone": {
							"shape": "S2g"
						},
						"DelegationSet": {
							"shape": "S2i"
						},
						"VPCs": {
							"type": "list",
							"member": {
								"shape": "S3",
								"locationName": "VPC"
							}
						}
					}
				}
			},
			"GetHostedZoneCount": {
				"http": {
					"method": "GET",
					"requestUri": "/2013-04-01/hostedzonecount"
				},
				"input": {
					"type": "structure",
					"members": {}
				},
				"output": {
					"type": "structure",
					"required": [
						"HostedZoneCount"
					],
					"members": {
						"HostedZoneCount": {
							"type": "long"
						}
					}
				}
			},
			"GetReusableDelegationSet": {
				"http": {
					"method": "GET",
					"requestUri": "/2013-04-01/delegationset/{Id}"
				},
				"input": {
					"type": "structure",
					"required": [
						"Id"
					],
					"members": {
						"Id": {
							"location": "uri",
							"locationName": "Id"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"DelegationSet"
					],
					"members": {
						"DelegationSet": {
							"shape": "S2i"
						}
					}
				}
			},
			"GetTrafficPolicy": {
				"http": {
					"method": "GET",
					"requestUri": "/2013-04-01/trafficpolicy/{Id}/{Version}"
				},
				"input": {
					"type": "structure",
					"required": [
						"Id",
						"Version"
					],
					"members": {
						"Id": {
							"location": "uri",
							"locationName": "Id"
						},
						"Version": {
							"location": "uri",
							"locationName": "Version",
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"TrafficPolicy"
					],
					"members": {
						"TrafficPolicy": {
							"shape": "S2r"
						}
					}
				}
			},
			"GetTrafficPolicyInstance": {
				"http": {
					"method": "GET",
					"requestUri": "/2013-04-01/trafficpolicyinstance/{Id}"
				},
				"input": {
					"type": "structure",
					"required": [
						"Id"
					],
					"members": {
						"Id": {
							"location": "uri",
							"locationName": "Id"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"TrafficPolicyInstance"
					],
					"members": {
						"TrafficPolicyInstance": {
							"shape": "S2w"
						}
					}
				}
			},
			"GetTrafficPolicyInstanceCount": {
				"http": {
					"method": "GET",
					"requestUri": "/2013-04-01/trafficpolicyinstancecount"
				},
				"input": {
					"type": "structure",
					"members": {}
				},
				"output": {
					"type": "structure",
					"required": [
						"TrafficPolicyInstanceCount"
					],
					"members": {
						"TrafficPolicyInstanceCount": {
							"type": "integer"
						}
					}
				}
			},
			"ListChangeBatchesByHostedZone": {
				"http": {
					"method": "GET",
					"requestUri": "/2013-04-01/hostedzone/{Id}/changes"
				},
				"input": {
					"type": "structure",
					"required": [
						"HostedZoneId",
						"StartDate",
						"EndDate"
					],
					"members": {
						"HostedZoneId": {
							"location": "uri",
							"locationName": "Id"
						},
						"StartDate": {
							"shape": "S4n",
							"location": "querystring",
							"locationName": "startDate"
						},
						"EndDate": {
							"shape": "S4n",
							"location": "querystring",
							"locationName": "endDate"
						},
						"MaxItems": {
							"location": "querystring",
							"locationName": "maxItems"
						},
						"Marker": {
							"location": "querystring",
							"locationName": "marker"
						}
					},
					"deprecated": true
				},
				"output": {
					"type": "structure",
					"required": [
						"MaxItems",
						"Marker",
						"ChangeBatchRecords"
					],
					"members": {
						"MaxItems": {},
						"Marker": {},
						"IsTruncated": {
							"type": "boolean"
						},
						"ChangeBatchRecords": {
							"shape": "S4s"
						},
						"NextMarker": {}
					},
					"deprecated": true
				},
				"deprecated": true
			},
			"ListChangeBatchesByRRSet": {
				"http": {
					"method": "GET",
					"requestUri": "/2013-04-01/hostedzone/{Id}/rrsChanges"
				},
				"input": {
					"type": "structure",
					"required": [
						"HostedZoneId",
						"Name",
						"Type",
						"StartDate",
						"EndDate"
					],
					"members": {
						"HostedZoneId": {
							"location": "uri",
							"locationName": "Id"
						},
						"Name": {
							"location": "querystring",
							"locationName": "rrSet_name"
						},
						"Type": {
							"location": "querystring",
							"locationName": "type"
						},
						"SetIdentifier": {
							"location": "querystring",
							"locationName": "identifier"
						},
						"StartDate": {
							"shape": "S4n",
							"location": "querystring",
							"locationName": "startDate"
						},
						"EndDate": {
							"shape": "S4n",
							"location": "querystring",
							"locationName": "endDate"
						},
						"MaxItems": {
							"location": "querystring",
							"locationName": "maxItems"
						},
						"Marker": {
							"location": "querystring",
							"locationName": "marker"
						}
					},
					"deprecated": true
				},
				"output": {
					"type": "structure",
					"required": [
						"MaxItems",
						"Marker",
						"ChangeBatchRecords"
					],
					"members": {
						"MaxItems": {},
						"Marker": {},
						"IsTruncated": {
							"type": "boolean"
						},
						"ChangeBatchRecords": {
							"shape": "S4s"
						},
						"NextMarker": {}
					},
					"deprecated": true
				},
				"deprecated": true
			},
			"ListGeoLocations": {
				"http": {
					"method": "GET",
					"requestUri": "/2013-04-01/geolocations"
				},
				"input": {
					"type": "structure",
					"members": {
						"StartContinentCode": {
							"location": "querystring",
							"locationName": "startcontinentcode"
						},
						"StartCountryCode": {
							"location": "querystring",
							"locationName": "startcountrycode"
						},
						"StartSubdivisionCode": {
							"location": "querystring",
							"locationName": "startsubdivisioncode"
						},
						"MaxItems": {
							"location": "querystring",
							"locationName": "maxitems"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"GeoLocationDetailsList",
						"IsTruncated",
						"MaxItems"
					],
					"members": {
						"GeoLocationDetailsList": {
							"type": "list",
							"member": {
								"shape": "S3q",
								"locationName": "GeoLocationDetails"
							}
						},
						"IsTruncated": {
							"type": "boolean"
						},
						"NextContinentCode": {},
						"NextCountryCode": {},
						"NextSubdivisionCode": {},
						"MaxItems": {}
					}
				}
			},
			"ListHealthChecks": {
				"http": {
					"method": "GET",
					"requestUri": "/2013-04-01/healthcheck"
				},
				"input": {
					"type": "structure",
					"members": {
						"Marker": {
							"location": "querystring",
							"locationName": "marker"
						},
						"MaxItems": {
							"location": "querystring",
							"locationName": "maxitems"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"HealthChecks",
						"Marker",
						"IsTruncated",
						"MaxItems"
					],
					"members": {
						"HealthChecks": {
							"type": "list",
							"member": {
								"shape": "S1x",
								"locationName": "HealthCheck"
							}
						},
						"Marker": {},
						"IsTruncated": {
							"type": "boolean"
						},
						"NextMarker": {},
						"MaxItems": {}
					}
				}
			},
			"ListHostedZones": {
				"http": {
					"method": "GET",
					"requestUri": "/2013-04-01/hostedzone"
				},
				"input": {
					"type": "structure",
					"members": {
						"Marker": {
							"location": "querystring",
							"locationName": "marker"
						},
						"MaxItems": {
							"location": "querystring",
							"locationName": "maxitems"
						},
						"DelegationSetId": {
							"location": "querystring",
							"locationName": "delegationsetid"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"HostedZones",
						"Marker",
						"IsTruncated",
						"MaxItems"
					],
					"members": {
						"HostedZones": {
							"shape": "S53"
						},
						"Marker": {},
						"IsTruncated": {
							"type": "boolean"
						},
						"NextMarker": {},
						"MaxItems": {}
					}
				}
			},
			"ListHostedZonesByName": {
				"http": {
					"method": "GET",
					"requestUri": "/2013-04-01/hostedzonesbyname"
				},
				"input": {
					"type": "structure",
					"members": {
						"DNSName": {
							"location": "querystring",
							"locationName": "dnsname"
						},
						"HostedZoneId": {
							"location": "querystring",
							"locationName": "hostedzoneid"
						},
						"MaxItems": {
							"location": "querystring",
							"locationName": "maxitems"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"HostedZones",
						"IsTruncated",
						"MaxItems"
					],
					"members": {
						"HostedZones": {
							"shape": "S53"
						},
						"DNSName": {},
						"HostedZoneId": {},
						"IsTruncated": {
							"type": "boolean"
						},
						"NextDNSName": {},
						"NextHostedZoneId": {},
						"MaxItems": {}
					}
				}
			},
			"ListResourceRecordSets": {
				"http": {
					"method": "GET",
					"requestUri": "/2013-04-01/hostedzone/{Id}/rrset"
				},
				"input": {
					"type": "structure",
					"required": [
						"HostedZoneId"
					],
					"members": {
						"HostedZoneId": {
							"location": "uri",
							"locationName": "Id"
						},
						"StartRecordName": {
							"location": "querystring",
							"locationName": "name"
						},
						"StartRecordType": {
							"location": "querystring",
							"locationName": "type"
						},
						"StartRecordIdentifier": {
							"location": "querystring",
							"locationName": "identifier"
						},
						"MaxItems": {
							"location": "querystring",
							"locationName": "maxitems"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"ResourceRecordSets",
						"IsTruncated",
						"MaxItems"
					],
					"members": {
						"ResourceRecordSets": {
							"type": "list",
							"member": {
								"shape": "Sh",
								"locationName": "ResourceRecordSet"
							}
						},
						"IsTruncated": {
							"type": "boolean"
						},
						"NextRecordName": {},
						"NextRecordType": {},
						"NextRecordIdentifier": {},
						"MaxItems": {}
					}
				}
			},
			"ListReusableDelegationSets": {
				"http": {
					"method": "GET",
					"requestUri": "/2013-04-01/delegationset"
				},
				"input": {
					"type": "structure",
					"members": {
						"Marker": {
							"location": "querystring",
							"locationName": "marker"
						},
						"MaxItems": {
							"location": "querystring",
							"locationName": "maxitems"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"DelegationSets",
						"Marker",
						"IsTruncated",
						"MaxItems"
					],
					"members": {
						"DelegationSets": {
							"type": "list",
							"member": {
								"shape": "S2i",
								"locationName": "DelegationSet"
							}
						},
						"Marker": {},
						"IsTruncated": {
							"type": "boolean"
						},
						"NextMarker": {},
						"MaxItems": {}
					}
				}
			},
			"ListTagsForResource": {
				"http": {
					"method": "GET",
					"requestUri": "/2013-04-01/tags/{ResourceType}/{ResourceId}"
				},
				"input": {
					"type": "structure",
					"required": [
						"ResourceType",
						"ResourceId"
					],
					"members": {
						"ResourceType": {
							"location": "uri",
							"locationName": "ResourceType"
						},
						"ResourceId": {
							"location": "uri",
							"locationName": "ResourceId"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"ResourceTagSet"
					],
					"members": {
						"ResourceTagSet": {
							"shape": "S5e"
						}
					}
				}
			},
			"ListTagsForResources": {
				"http": {
					"requestUri": "/2013-04-01/tags/{ResourceType}"
				},
				"input": {
					"locationName": "ListTagsForResourcesRequest",
					"xmlNamespace": {
						"uri": "https://route53.amazonaws.com/doc/2013-04-01/"
					},
					"type": "structure",
					"required": [
						"ResourceType",
						"ResourceIds"
					],
					"members": {
						"ResourceType": {
							"location": "uri",
							"locationName": "ResourceType"
						},
						"ResourceIds": {
							"type": "list",
							"member": {
								"locationName": "ResourceId"
							}
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"ResourceTagSets"
					],
					"members": {
						"ResourceTagSets": {
							"type": "list",
							"member": {
								"shape": "S5e",
								"locationName": "ResourceTagSet"
							}
						}
					}
				}
			},
			"ListTrafficPolicies": {
				"http": {
					"method": "GET",
					"requestUri": "/2013-04-01/trafficpolicies"
				},
				"input": {
					"type": "structure",
					"members": {
						"TrafficPolicyIdMarker": {
							"location": "querystring",
							"locationName": "trafficpolicyid"
						},
						"MaxItems": {
							"location": "querystring",
							"locationName": "maxitems"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"TrafficPolicySummaries",
						"IsTruncated",
						"TrafficPolicyIdMarker",
						"MaxItems"
					],
					"members": {
						"TrafficPolicySummaries": {
							"type": "list",
							"member": {
								"locationName": "TrafficPolicySummary",
								"type": "structure",
								"required": [
									"Id",
									"Name",
									"Type",
									"LatestVersion",
									"TrafficPolicyCount"
								],
								"members": {
									"Id": {},
									"Name": {},
									"Type": {},
									"LatestVersion": {
										"type": "integer"
									},
									"TrafficPolicyCount": {
										"type": "integer"
									}
								}
							}
						},
						"IsTruncated": {
							"type": "boolean"
						},
						"TrafficPolicyIdMarker": {},
						"MaxItems": {}
					}
				}
			},
			"ListTrafficPolicyInstances": {
				"http": {
					"method": "GET",
					"requestUri": "/2013-04-01/trafficpolicyinstances"
				},
				"input": {
					"type": "structure",
					"members": {
						"HostedZoneIdMarker": {
							"location": "querystring",
							"locationName": "hostedzoneid"
						},
						"TrafficPolicyInstanceNameMarker": {
							"location": "querystring",
							"locationName": "trafficpolicyinstancename"
						},
						"TrafficPolicyInstanceTypeMarker": {
							"location": "querystring",
							"locationName": "trafficpolicyinstancetype"
						},
						"MaxItems": {
							"location": "querystring",
							"locationName": "maxitems"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"TrafficPolicyInstances",
						"IsTruncated",
						"MaxItems"
					],
					"members": {
						"TrafficPolicyInstances": {
							"shape": "S5p"
						},
						"HostedZoneIdMarker": {},
						"TrafficPolicyInstanceNameMarker": {},
						"TrafficPolicyInstanceTypeMarker": {},
						"IsTruncated": {
							"type": "boolean"
						},
						"MaxItems": {}
					}
				}
			},
			"ListTrafficPolicyInstancesByHostedZone": {
				"http": {
					"method": "GET",
					"requestUri": "/2013-04-01/trafficpolicyinstances/hostedzone"
				},
				"input": {
					"type": "structure",
					"required": [
						"HostedZoneId"
					],
					"members": {
						"HostedZoneId": {
							"location": "querystring",
							"locationName": "id"
						},
						"TrafficPolicyInstanceNameMarker": {
							"location": "querystring",
							"locationName": "trafficpolicyinstancename"
						},
						"TrafficPolicyInstanceTypeMarker": {
							"location": "querystring",
							"locationName": "trafficpolicyinstancetype"
						},
						"MaxItems": {
							"location": "querystring",
							"locationName": "maxitems"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"TrafficPolicyInstances",
						"IsTruncated",
						"MaxItems"
					],
					"members": {
						"TrafficPolicyInstances": {
							"shape": "S5p"
						},
						"TrafficPolicyInstanceNameMarker": {},
						"TrafficPolicyInstanceTypeMarker": {},
						"IsTruncated": {
							"type": "boolean"
						},
						"MaxItems": {}
					}
				}
			},
			"ListTrafficPolicyInstancesByPolicy": {
				"http": {
					"method": "GET",
					"requestUri": "/2013-04-01/trafficpolicyinstances/trafficpolicy"
				},
				"input": {
					"type": "structure",
					"required": [
						"TrafficPolicyId",
						"TrafficPolicyVersion"
					],
					"members": {
						"TrafficPolicyId": {
							"location": "querystring",
							"locationName": "id"
						},
						"TrafficPolicyVersion": {
							"location": "querystring",
							"locationName": "version",
							"type": "integer"
						},
						"HostedZoneIdMarker": {
							"location": "querystring",
							"locationName": "hostedzoneid"
						},
						"TrafficPolicyInstanceNameMarker": {
							"location": "querystring",
							"locationName": "trafficpolicyinstancename"
						},
						"TrafficPolicyInstanceTypeMarker": {
							"location": "querystring",
							"locationName": "trafficpolicyinstancetype"
						},
						"MaxItems": {
							"location": "querystring",
							"locationName": "maxitems"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"TrafficPolicyInstances",
						"IsTruncated",
						"MaxItems"
					],
					"members": {
						"TrafficPolicyInstances": {
							"shape": "S5p"
						},
						"HostedZoneIdMarker": {},
						"TrafficPolicyInstanceNameMarker": {},
						"TrafficPolicyInstanceTypeMarker": {},
						"IsTruncated": {
							"type": "boolean"
						},
						"MaxItems": {}
					}
				}
			},
			"ListTrafficPolicyVersions": {
				"http": {
					"method": "GET",
					"requestUri": "/2013-04-01/trafficpolicies/{Id}/versions"
				},
				"input": {
					"type": "structure",
					"required": [
						"Id"
					],
					"members": {
						"Id": {
							"location": "uri",
							"locationName": "Id"
						},
						"TrafficPolicyVersionMarker": {
							"location": "querystring",
							"locationName": "trafficpolicyversion"
						},
						"MaxItems": {
							"location": "querystring",
							"locationName": "maxitems"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"TrafficPolicies",
						"IsTruncated",
						"TrafficPolicyVersionMarker",
						"MaxItems"
					],
					"members": {
						"TrafficPolicies": {
							"type": "list",
							"member": {
								"shape": "S2r",
								"locationName": "TrafficPolicy"
							}
						},
						"IsTruncated": {
							"type": "boolean"
						},
						"TrafficPolicyVersionMarker": {},
						"MaxItems": {}
					}
				}
			},
			"TestDNSAnswer": {
				"http": {
					"method": "GET",
					"requestUri": "/2013-04-01/testdnsanswer"
				},
				"input": {
					"type": "structure",
					"required": [
						"HostedZoneId",
						"RecordName",
						"RecordType"
					],
					"members": {
						"HostedZoneId": {
							"location": "querystring",
							"locationName": "hostedzoneid"
						},
						"RecordName": {
							"location": "querystring",
							"locationName": "recordname"
						},
						"RecordType": {
							"location": "querystring",
							"locationName": "recordtype"
						},
						"ResolverIP": {
							"location": "querystring",
							"locationName": "resolverip"
						},
						"EDNS0ClientSubnetIP": {
							"location": "querystring",
							"locationName": "edns0clientsubnetip"
						},
						"EDNS0ClientSubnetMask": {
							"location": "querystring",
							"locationName": "edns0clientsubnetmask"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"Nameserver",
						"RecordName",
						"RecordType",
						"RecordData",
						"ResponseCode",
						"Protocol"
					],
					"members": {
						"Nameserver": {},
						"RecordName": {},
						"RecordType": {},
						"RecordData": {
							"type": "list",
							"member": {
								"locationName": "RecordDataEntry"
							}
						},
						"ResponseCode": {},
						"Protocol": {}
					}
				}
			},
			"UpdateHealthCheck": {
				"http": {
					"requestUri": "/2013-04-01/healthcheck/{HealthCheckId}"
				},
				"input": {
					"locationName": "UpdateHealthCheckRequest",
					"xmlNamespace": {
						"uri": "https://route53.amazonaws.com/doc/2013-04-01/"
					},
					"type": "structure",
					"required": [
						"HealthCheckId"
					],
					"members": {
						"HealthCheckId": {
							"location": "uri",
							"locationName": "HealthCheckId"
						},
						"HealthCheckVersion": {
							"type": "long"
						},
						"IPAddress": {},
						"Port": {
							"type": "integer"
						},
						"ResourcePath": {},
						"FullyQualifiedDomainName": {},
						"SearchString": {},
						"FailureThreshold": {
							"type": "integer"
						},
						"Inverted": {
							"type": "boolean"
						},
						"HealthThreshold": {
							"type": "integer"
						},
						"ChildHealthChecks": {
							"shape": "S1o"
						},
						"EnableSNI": {
							"type": "boolean"
						},
						"Regions": {
							"shape": "S1q"
						},
						"AlarmIdentifier": {
							"shape": "S1s"
						},
						"InsufficientDataHealthStatus": {}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"HealthCheck"
					],
					"members": {
						"HealthCheck": {
							"shape": "S1x"
						}
					}
				}
			},
			"UpdateHostedZoneComment": {
				"http": {
					"requestUri": "/2013-04-01/hostedzone/{Id}"
				},
				"input": {
					"locationName": "UpdateHostedZoneCommentRequest",
					"xmlNamespace": {
						"uri": "https://route53.amazonaws.com/doc/2013-04-01/"
					},
					"type": "structure",
					"required": [
						"Id"
					],
					"members": {
						"Id": {
							"location": "uri",
							"locationName": "Id"
						},
						"Comment": {}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"HostedZone"
					],
					"members": {
						"HostedZone": {
							"shape": "S2g"
						}
					}
				}
			},
			"UpdateTrafficPolicyComment": {
				"http": {
					"requestUri": "/2013-04-01/trafficpolicy/{Id}/{Version}"
				},
				"input": {
					"locationName": "UpdateTrafficPolicyCommentRequest",
					"xmlNamespace": {
						"uri": "https://route53.amazonaws.com/doc/2013-04-01/"
					},
					"type": "structure",
					"required": [
						"Id",
						"Version",
						"Comment"
					],
					"members": {
						"Id": {
							"location": "uri",
							"locationName": "Id"
						},
						"Version": {
							"location": "uri",
							"locationName": "Version",
							"type": "integer"
						},
						"Comment": {}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"TrafficPolicy"
					],
					"members": {
						"TrafficPolicy": {
							"shape": "S2r"
						}
					}
				}
			},
			"UpdateTrafficPolicyInstance": {
				"http": {
					"requestUri": "/2013-04-01/trafficpolicyinstance/{Id}"
				},
				"input": {
					"locationName": "UpdateTrafficPolicyInstanceRequest",
					"xmlNamespace": {
						"uri": "https://route53.amazonaws.com/doc/2013-04-01/"
					},
					"type": "structure",
					"required": [
						"Id",
						"TTL",
						"TrafficPolicyId",
						"TrafficPolicyVersion"
					],
					"members": {
						"Id": {
							"location": "uri",
							"locationName": "Id"
						},
						"TTL": {
							"type": "long"
						},
						"TrafficPolicyId": {},
						"TrafficPolicyVersion": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"TrafficPolicyInstance"
					],
					"members": {
						"TrafficPolicyInstance": {
							"shape": "S2w"
						}
					}
				}
			}
		},
		"shapes": {
			"S3": {
				"type": "structure",
				"members": {
					"VPCRegion": {},
					"VPCId": {}
				}
			},
			"S8": {
				"type": "structure",
				"required": [
					"Id",
					"Status",
					"SubmittedAt"
				],
				"members": {
					"Id": {},
					"Status": {},
					"SubmittedAt": {
						"type": "timestamp"
					},
					"Comment": {}
				}
			},
			"Se": {
				"type": "list",
				"member": {
					"locationName": "Change",
					"type": "structure",
					"required": [
						"Action",
						"ResourceRecordSet"
					],
					"members": {
						"Action": {},
						"ResourceRecordSet": {
							"shape": "Sh"
						}
					}
				}
			},
			"Sh": {
				"type": "structure",
				"required": [
					"Name",
					"Type"
				],
				"members": {
					"Name": {},
					"Type": {},
					"SetIdentifier": {},
					"Weight": {
						"type": "long"
					},
					"Region": {},
					"GeoLocation": {
						"type": "structure",
						"members": {
							"ContinentCode": {},
							"CountryCode": {},
							"SubdivisionCode": {}
						}
					},
					"Failover": {},
					"TTL": {
						"type": "long"
					},
					"ResourceRecords": {
						"type": "list",
						"member": {
							"locationName": "ResourceRecord",
							"type": "structure",
							"required": [
								"Value"
							],
							"members": {
								"Value": {}
							}
						}
					},
					"AliasTarget": {
						"type": "structure",
						"required": [
							"HostedZoneId",
							"DNSName",
							"EvaluateTargetHealth"
						],
						"members": {
							"HostedZoneId": {},
							"DNSName": {},
							"EvaluateTargetHealth": {
								"type": "boolean"
							}
						}
					},
					"HealthCheckId": {},
					"TrafficPolicyInstanceId": {}
				}
			},
			"S14": {
				"type": "list",
				"member": {
					"locationName": "Tag",
					"type": "structure",
					"members": {
						"Key": {},
						"Value": {}
					}
				}
			},
			"S1c": {
				"type": "structure",
				"required": [
					"Type"
				],
				"members": {
					"IPAddress": {},
					"Port": {
						"type": "integer"
					},
					"Type": {},
					"ResourcePath": {},
					"FullyQualifiedDomainName": {},
					"SearchString": {},
					"RequestInterval": {
						"type": "integer"
					},
					"FailureThreshold": {
						"type": "integer"
					},
					"MeasureLatency": {
						"type": "boolean"
					},
					"Inverted": {
						"type": "boolean"
					},
					"HealthThreshold": {
						"type": "integer"
					},
					"ChildHealthChecks": {
						"shape": "S1o"
					},
					"EnableSNI": {
						"type": "boolean"
					},
					"Regions": {
						"shape": "S1q"
					},
					"AlarmIdentifier": {
						"shape": "S1s"
					},
					"InsufficientDataHealthStatus": {}
				}
			},
			"S1o": {
				"type": "list",
				"member": {
					"locationName": "ChildHealthCheck"
				}
			},
			"S1q": {
				"type": "list",
				"member": {
					"locationName": "Region"
				}
			},
			"S1s": {
				"type": "structure",
				"required": [
					"Region",
					"Name"
				],
				"members": {
					"Region": {},
					"Name": {}
				}
			},
			"S1x": {
				"type": "structure",
				"required": [
					"Id",
					"CallerReference",
					"HealthCheckConfig",
					"HealthCheckVersion"
				],
				"members": {
					"Id": {},
					"CallerReference": {},
					"HealthCheckConfig": {
						"shape": "S1c"
					},
					"HealthCheckVersion": {
						"type": "long"
					},
					"CloudWatchAlarmConfiguration": {
						"type": "structure",
						"required": [
							"EvaluationPeriods",
							"Threshold",
							"ComparisonOperator",
							"Period",
							"MetricName",
							"Namespace",
							"Statistic"
						],
						"members": {
							"EvaluationPeriods": {
								"type": "integer"
							},
							"Threshold": {
								"type": "double"
							},
							"ComparisonOperator": {},
							"Period": {
								"type": "integer"
							},
							"MetricName": {},
							"Namespace": {},
							"Statistic": {},
							"Dimensions": {
								"type": "list",
								"member": {
									"locationName": "Dimension",
									"type": "structure",
									"required": [
										"Name",
										"Value"
									],
									"members": {
										"Name": {},
										"Value": {}
									}
								}
							}
						}
					}
				}
			},
			"S2d": {
				"type": "structure",
				"members": {
					"Comment": {},
					"PrivateZone": {
						"type": "boolean"
					}
				}
			},
			"S2g": {
				"type": "structure",
				"required": [
					"Id",
					"Name",
					"CallerReference"
				],
				"members": {
					"Id": {},
					"Name": {},
					"CallerReference": {},
					"Config": {
						"shape": "S2d"
					},
					"ResourceRecordSetCount": {
						"type": "long"
					}
				}
			},
			"S2i": {
				"type": "structure",
				"required": [
					"NameServers"
				],
				"members": {
					"Id": {},
					"CallerReference": {},
					"NameServers": {
						"type": "list",
						"member": {
							"locationName": "NameServer"
						}
					}
				}
			},
			"S2r": {
				"type": "structure",
				"required": [
					"Id",
					"Version",
					"Name",
					"Type",
					"Document"
				],
				"members": {
					"Id": {},
					"Version": {
						"type": "integer"
					},
					"Name": {},
					"Type": {},
					"Document": {},
					"Comment": {}
				}
			},
			"S2w": {
				"type": "structure",
				"required": [
					"Id",
					"HostedZoneId",
					"Name",
					"TTL",
					"State",
					"Message",
					"TrafficPolicyId",
					"TrafficPolicyVersion",
					"TrafficPolicyType"
				],
				"members": {
					"Id": {},
					"HostedZoneId": {},
					"Name": {},
					"TTL": {
						"type": "long"
					},
					"State": {},
					"Message": {},
					"TrafficPolicyId": {},
					"TrafficPolicyVersion": {
						"type": "integer"
					},
					"TrafficPolicyType": {}
				}
			},
			"S3i": {
				"type": "structure",
				"required": [
					"Id",
					"Status"
				],
				"members": {
					"Id": {},
					"SubmittedAt": {
						"type": "timestamp"
					},
					"Status": {},
					"Comment": {},
					"Submitter": {},
					"Changes": {
						"shape": "Se"
					}
				},
				"deprecated": true
			},
			"S3q": {
				"type": "structure",
				"members": {
					"ContinentCode": {},
					"ContinentName": {},
					"CountryCode": {},
					"CountryName": {},
					"SubdivisionCode": {},
					"SubdivisionName": {}
				}
			},
			"S41": {
				"type": "list",
				"member": {
					"locationName": "HealthCheckObservation",
					"type": "structure",
					"members": {
						"Region": {},
						"IPAddress": {},
						"StatusReport": {
							"type": "structure",
							"members": {
								"Status": {},
								"CheckedTime": {
									"type": "timestamp"
								}
							}
						}
					}
				}
			},
			"S4n": {
				"type": "string",
				"deprecated": true
			},
			"S4s": {
				"type": "list",
				"member": {
					"shape": "S3i",
					"locationName": "ChangeBatchRecord"
				},
				"deprecated": true
			},
			"S53": {
				"type": "list",
				"member": {
					"shape": "S2g",
					"locationName": "HostedZone"
				}
			},
			"S5e": {
				"type": "structure",
				"members": {
					"ResourceType": {},
					"ResourceId": {},
					"Tags": {
						"shape": "S14"
					}
				}
			},
			"S5p": {
				"type": "list",
				"member": {
					"shape": "S2w",
					"locationName": "TrafficPolicyInstance"
				}
			}
		}
	};

/***/ },
/* 435 */
/***/ function(module, exports) {

	module.exports = {
		"pagination": {
			"ListHealthChecks": {
				"input_token": "Marker",
				"output_token": "NextMarker",
				"more_results": "IsTruncated",
				"limit_key": "MaxItems",
				"result_key": "HealthChecks"
			},
			"ListHostedZones": {
				"input_token": "Marker",
				"output_token": "NextMarker",
				"more_results": "IsTruncated",
				"limit_key": "MaxItems",
				"result_key": "HostedZones"
			},
			"ListResourceRecordSets": {
				"more_results": "IsTruncated",
				"limit_key": "MaxItems",
				"result_key": "ResourceRecordSets",
				"input_token": [
					"StartRecordName",
					"StartRecordType",
					"StartRecordIdentifier"
				],
				"output_token": [
					"NextRecordName",
					"NextRecordType",
					"NextRecordIdentifier"
				]
			}
		}
	};

/***/ },
/* 436 */
/***/ function(module, exports) {

	module.exports = {
		"version": 2,
		"waiters": {
			"ResourceRecordSetsChanged": {
				"delay": 30,
				"maxAttempts": 60,
				"operation": "GetChange",
				"acceptors": [
					{
						"matcher": "path",
						"expected": "INSYNC",
						"argument": "ChangeInfo.Status",
						"state": "success"
					}
				]
			}
		}
	};

/***/ },
/* 437 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['route53domains'] = {};
	AWS.Route53Domains = Service.defineService('route53domains', ['2014-05-15']);
	Object.defineProperty(apiLoader.services['route53domains'], '2014-05-15', {
	  get: function get() {
	    var model = __webpack_require__(438);
	    model.paginators = __webpack_require__(439).pagination;
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.Route53Domains;


/***/ },
/* 438 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2014-05-15",
			"endpointPrefix": "route53domains",
			"jsonVersion": "1.1",
			"protocol": "json",
			"serviceFullName": "Amazon Route 53 Domains",
			"signatureVersion": "v4",
			"targetPrefix": "Route53Domains_v20140515"
		},
		"operations": {
			"CheckDomainAvailability": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName"
					],
					"members": {
						"DomainName": {},
						"IdnLangCode": {}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"Availability"
					],
					"members": {
						"Availability": {}
					}
				}
			},
			"DeleteTagsForDomain": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName",
						"TagsToDelete"
					],
					"members": {
						"DomainName": {},
						"TagsToDelete": {
							"type": "list",
							"member": {}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"DisableDomainAutoRenew": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName"
					],
					"members": {
						"DomainName": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"DisableDomainTransferLock": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName"
					],
					"members": {
						"DomainName": {}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"OperationId"
					],
					"members": {
						"OperationId": {}
					}
				}
			},
			"EnableDomainAutoRenew": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName"
					],
					"members": {
						"DomainName": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"EnableDomainTransferLock": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName"
					],
					"members": {
						"DomainName": {}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"OperationId"
					],
					"members": {
						"OperationId": {}
					}
				}
			},
			"GetContactReachabilityStatus": {
				"input": {
					"type": "structure",
					"members": {
						"domainName": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"domainName": {},
						"status": {}
					}
				}
			},
			"GetDomainDetail": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName"
					],
					"members": {
						"DomainName": {}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"DomainName",
						"Nameservers",
						"AdminContact",
						"RegistrantContact",
						"TechContact"
					],
					"members": {
						"DomainName": {},
						"Nameservers": {
							"shape": "So"
						},
						"AutoRenew": {
							"type": "boolean"
						},
						"AdminContact": {
							"shape": "Su"
						},
						"RegistrantContact": {
							"shape": "Su"
						},
						"TechContact": {
							"shape": "Su"
						},
						"AdminPrivacy": {
							"type": "boolean"
						},
						"RegistrantPrivacy": {
							"type": "boolean"
						},
						"TechPrivacy": {
							"type": "boolean"
						},
						"RegistrarName": {},
						"WhoIsServer": {},
						"RegistrarUrl": {},
						"AbuseContactEmail": {},
						"AbuseContactPhone": {},
						"RegistryDomainId": {},
						"CreationDate": {
							"type": "timestamp"
						},
						"UpdatedDate": {
							"type": "timestamp"
						},
						"ExpirationDate": {
							"type": "timestamp"
						},
						"Reseller": {},
						"DnsSec": {},
						"StatusList": {
							"type": "list",
							"member": {}
						}
					}
				}
			},
			"GetDomainSuggestions": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName",
						"SuggestionCount",
						"OnlyAvailable"
					],
					"members": {
						"DomainName": {},
						"SuggestionCount": {
							"type": "integer"
						},
						"OnlyAvailable": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"SuggestionsList": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"DomainName": {},
									"Availability": {}
								}
							}
						}
					}
				}
			},
			"GetOperationDetail": {
				"input": {
					"type": "structure",
					"required": [
						"OperationId"
					],
					"members": {
						"OperationId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"OperationId": {},
						"Status": {},
						"Message": {},
						"DomainName": {},
						"Type": {},
						"SubmittedDate": {
							"type": "timestamp"
						}
					}
				}
			},
			"ListDomains": {
				"input": {
					"type": "structure",
					"members": {
						"Marker": {},
						"MaxItems": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"Domains"
					],
					"members": {
						"Domains": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"DomainName"
								],
								"members": {
									"DomainName": {},
									"AutoRenew": {
										"type": "boolean"
									},
									"TransferLock": {
										"type": "boolean"
									},
									"Expiry": {
										"type": "timestamp"
									}
								}
							}
						},
						"NextPageMarker": {}
					}
				}
			},
			"ListOperations": {
				"input": {
					"type": "structure",
					"members": {
						"Marker": {},
						"MaxItems": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"Operations"
					],
					"members": {
						"Operations": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"OperationId",
									"Status",
									"Type",
									"SubmittedDate"
								],
								"members": {
									"OperationId": {},
									"Status": {},
									"Type": {},
									"SubmittedDate": {
										"type": "timestamp"
									}
								}
							}
						},
						"NextPageMarker": {}
					}
				}
			},
			"ListTagsForDomain": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName"
					],
					"members": {
						"DomainName": {}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"TagList"
					],
					"members": {
						"TagList": {
							"shape": "S24"
						}
					}
				}
			},
			"RegisterDomain": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName",
						"DurationInYears",
						"AdminContact",
						"RegistrantContact",
						"TechContact"
					],
					"members": {
						"DomainName": {},
						"IdnLangCode": {},
						"DurationInYears": {
							"type": "integer"
						},
						"AutoRenew": {
							"type": "boolean"
						},
						"AdminContact": {
							"shape": "Su"
						},
						"RegistrantContact": {
							"shape": "Su"
						},
						"TechContact": {
							"shape": "Su"
						},
						"PrivacyProtectAdminContact": {
							"type": "boolean"
						},
						"PrivacyProtectRegistrantContact": {
							"type": "boolean"
						},
						"PrivacyProtectTechContact": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"OperationId"
					],
					"members": {
						"OperationId": {}
					}
				}
			},
			"RenewDomain": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName",
						"CurrentExpiryYear"
					],
					"members": {
						"DomainName": {},
						"DurationInYears": {
							"type": "integer"
						},
						"CurrentExpiryYear": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"OperationId"
					],
					"members": {
						"OperationId": {}
					}
				}
			},
			"ResendContactReachabilityEmail": {
				"input": {
					"type": "structure",
					"members": {
						"domainName": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"domainName": {},
						"emailAddress": {},
						"isAlreadyVerified": {
							"type": "boolean"
						}
					}
				}
			},
			"RetrieveDomainAuthCode": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName"
					],
					"members": {
						"DomainName": {}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"AuthCode"
					],
					"members": {
						"AuthCode": {
							"shape": "S2h"
						}
					}
				}
			},
			"TransferDomain": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName",
						"DurationInYears",
						"AdminContact",
						"RegistrantContact",
						"TechContact"
					],
					"members": {
						"DomainName": {},
						"IdnLangCode": {},
						"DurationInYears": {
							"type": "integer"
						},
						"Nameservers": {
							"shape": "So"
						},
						"AuthCode": {
							"shape": "S2h"
						},
						"AutoRenew": {
							"type": "boolean"
						},
						"AdminContact": {
							"shape": "Su"
						},
						"RegistrantContact": {
							"shape": "Su"
						},
						"TechContact": {
							"shape": "Su"
						},
						"PrivacyProtectAdminContact": {
							"type": "boolean"
						},
						"PrivacyProtectRegistrantContact": {
							"type": "boolean"
						},
						"PrivacyProtectTechContact": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"OperationId"
					],
					"members": {
						"OperationId": {}
					}
				}
			},
			"UpdateDomainContact": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName"
					],
					"members": {
						"DomainName": {},
						"AdminContact": {
							"shape": "Su"
						},
						"RegistrantContact": {
							"shape": "Su"
						},
						"TechContact": {
							"shape": "Su"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"OperationId"
					],
					"members": {
						"OperationId": {}
					}
				}
			},
			"UpdateDomainContactPrivacy": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName"
					],
					"members": {
						"DomainName": {},
						"AdminPrivacy": {
							"type": "boolean"
						},
						"RegistrantPrivacy": {
							"type": "boolean"
						},
						"TechPrivacy": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"OperationId"
					],
					"members": {
						"OperationId": {}
					}
				}
			},
			"UpdateDomainNameservers": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName",
						"Nameservers"
					],
					"members": {
						"DomainName": {},
						"FIAuthKey": {},
						"Nameservers": {
							"shape": "So"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"OperationId"
					],
					"members": {
						"OperationId": {}
					}
				}
			},
			"UpdateTagsForDomain": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName"
					],
					"members": {
						"DomainName": {},
						"TagsToUpdate": {
							"shape": "S24"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"ViewBilling": {
				"input": {
					"type": "structure",
					"members": {
						"Start": {
							"type": "timestamp"
						},
						"End": {
							"type": "timestamp"
						},
						"Marker": {},
						"MaxItems": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"NextPageMarker": {},
						"BillingRecords": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"DomainName": {},
									"Operation": {},
									"InvoiceId": {},
									"BillDate": {
										"type": "timestamp"
									},
									"Price": {
										"type": "double"
									}
								}
							}
						}
					}
				}
			}
		},
		"shapes": {
			"So": {
				"type": "list",
				"member": {
					"type": "structure",
					"required": [
						"Name"
					],
					"members": {
						"Name": {},
						"GlueIps": {
							"type": "list",
							"member": {}
						}
					}
				}
			},
			"Su": {
				"type": "structure",
				"members": {
					"FirstName": {},
					"LastName": {},
					"ContactType": {},
					"OrganizationName": {},
					"AddressLine1": {},
					"AddressLine2": {},
					"City": {},
					"State": {},
					"CountryCode": {},
					"ZipCode": {},
					"PhoneNumber": {},
					"Email": {},
					"Fax": {},
					"ExtraParams": {
						"type": "list",
						"member": {
							"type": "structure",
							"required": [
								"Name",
								"Value"
							],
							"members": {
								"Name": {},
								"Value": {}
							}
						}
					}
				},
				"sensitive": true
			},
			"S24": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"Key": {},
						"Value": {}
					}
				}
			},
			"S2h": {
				"type": "string",
				"sensitive": true
			}
		}
	};

/***/ },
/* 439 */
/***/ function(module, exports) {

	module.exports = {
		"version": "1.0",
		"pagination": {
			"ListDomains": {
				"limit_key": "MaxItems",
				"input_token": "Marker",
				"output_token": "NextPageMarker",
				"result_key": "Domains"
			},
			"ListOperations": {
				"limit_key": "MaxItems",
				"input_token": "Marker",
				"output_token": "NextPageMarker",
				"result_key": "Operations"
			}
		}
	};

/***/ },
/* 440 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['s3'] = {};
	AWS.S3 = Service.defineService('s3', ['2006-03-01']);
	__webpack_require__(441);
	Object.defineProperty(apiLoader.services['s3'], '2006-03-01', {
	  get: function get() {
	    var model = __webpack_require__(443);
	    model.paginators = __webpack_require__(444).pagination;
	    model.waiters = __webpack_require__(445).waiters;
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.S3;


/***/ },
/* 441 */
/***/ function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(93);

	// Pull in managed upload extension
	__webpack_require__(442);

	/**
	 * @api private
	 */
	var operationsWith200StatusCodeError = {
	  'completeMultipartUpload': true,
	  'copyObject': true,
	  'uploadPartCopy': true
	};

	/**
	 * @api private
	 */
	 var regionRedirectErrorCodes = [
	  'AuthorizationHeaderMalformed', // non-head operations on virtual-hosted global bucket endpoints
	  'BadRequest', // head operations on virtual-hosted global bucket endpoints
	  'PermanentRedirect', // non-head operations on path-style or regional endpoints
	  301 // head operations on path-style or regional endpoints
	 ];

	AWS.util.update(AWS.S3.prototype, {
	  /**
	   * @api private
	   */
	  getSignerClass: function getSignerClass(request) {
	    var defaultApiVersion = this.api.signatureVersion;
	    var userDefinedVersion = this._originalConfig ? this._originalConfig.signatureVersion : null;
	    var regionDefinedVersion = this.config.signatureVersion;
	    var isPresigned = request ? request.isPresigned() : false;
	    /*
	      1) User defined version specified:
	        a) always return user defined version
	      2) No user defined version specified:
	        a) default to lowest version the region supports
	    */
	    if (userDefinedVersion) {
	      userDefinedVersion = userDefinedVersion === 'v2' ? 's3' : userDefinedVersion;
	      return AWS.Signers.RequestSigner.getVersion(userDefinedVersion);
	    }
	    if (regionDefinedVersion) {
	      defaultApiVersion = regionDefinedVersion;
	    }

	    return AWS.Signers.RequestSigner.getVersion(defaultApiVersion);
	  },

	  /**
	   * @api private
	   */
	  validateService: function validateService() {
	    var msg;
	    var messages = [];

	    // default to us-east-1 when no region is provided
	    if (!this.config.region) this.config.region = 'us-east-1';

	    if (!this.config.endpoint && this.config.s3BucketEndpoint) {
	      messages.push('An endpoint must be provided when configuring ' +
	                    '`s3BucketEndpoint` to true.');
	    }
	    if (messages.length === 1) {
	      msg = messages[0];
	    } else if (messages.length > 1) {
	      msg = 'Multiple configuration errors:\n' + messages.join('\n');
	    }
	    if (msg) {
	      throw AWS.util.error(new Error(),
	        {name: 'InvalidEndpoint', message: msg});
	    }
	  },

	  /**
	   * @api private
	   */
	  shouldDisableBodySigning: function shouldDisableBodySigning(request) {
	    var signerClass = this.getSignerClass();
	    if (this.config.s3DisableBodySigning === true && signerClass === AWS.Signers.V4
	        && request.httpRequest.endpoint.protocol === 'https:') {
	      return true;
	    }
	    return false;
	  },

	  /**
	   * @api private
	   */
	  setupRequestListeners: function setupRequestListeners(request) {
	    request.addListener('validate', this.validateScheme);
	    request.addListener('validate', this.validateBucketEndpoint);
	    request.addListener('validate', this.correctBucketRegionFromCache);
	    request.addListener('build', this.addContentType);
	    request.addListener('build', this.populateURI);
	    request.addListener('build', this.computeContentMd5);
	    request.addListener('build', this.computeSseCustomerKeyMd5);
	    request.addListener('afterBuild', this.addExpect100Continue);
	    request.removeListener('validate',
	      AWS.EventListeners.Core.VALIDATE_REGION);
	    request.addListener('extractError', this.extractError);
	    request.onAsync('extractError', this.requestBucketRegion);
	    request.addListener('extractData', this.extractData);
	    request.addListener('extractData', AWS.util.hoistPayloadMember);
	    request.addListener('beforePresign', this.prepareSignedUrl);
	    if (AWS.util.isBrowser()) {
	      request.onAsync('retry', this.reqRegionForNetworkingError);
	    }
	    if (this.shouldDisableBodySigning(request))  {
	      request.removeListener('afterBuild', AWS.EventListeners.Core.COMPUTE_SHA256);
	      request.addListener('afterBuild', this.disableBodySigning);
	    }
	  },

	  /**
	   * @api private
	   */
	  validateScheme: function(req) {
	    var params = req.params,
	        scheme = req.httpRequest.endpoint.protocol,
	        sensitive = params.SSECustomerKey || params.CopySourceSSECustomerKey;
	    if (sensitive && scheme !== 'https:') {
	      var msg = 'Cannot send SSE keys over HTTP. Set \'sslEnabled\'' +
	        'to \'true\' in your configuration';
	      throw AWS.util.error(new Error(),
	        { code: 'ConfigError', message: msg });
	    }
	  },

	  /**
	   * @api private
	   */
	  validateBucketEndpoint: function(req) {
	    if (!req.params.Bucket && req.service.config.s3BucketEndpoint) {
	      var msg = 'Cannot send requests to root API with `s3BucketEndpoint` set.';
	      throw AWS.util.error(new Error(),
	        { code: 'ConfigError', message: msg });
	    }
	  },

	  /**
	   * @api private
	   */
	  isValidAccelerateOperation: function isValidAccelerateOperation(operation) {
	    var invalidOperations = [
	      'createBucket',
	      'deleteBucket',
	      'listBuckets'
	    ];
	    return invalidOperations.indexOf(operation) === -1;
	  },


	  /**
	   * S3 prefers dns-compatible bucket names to be moved from the uri path
	   * to the hostname as a sub-domain.  This is not possible, even for dns-compat
	   * buckets when using SSL and the bucket name contains a dot ('.').  The
	   * ssl wildcard certificate is only 1-level deep.
	   *
	   * @api private
	   */
	  populateURI: function populateURI(req) {
	    var httpRequest = req.httpRequest;
	    var b = req.params.Bucket;
	    var service = req.service;
	    var endpoint = httpRequest.endpoint;

	    if (b) {
	      if (!service.pathStyleBucketName(b)) {
	        if (service.config.useAccelerateEndpoint && service.isValidAccelerateOperation(req.operation)) {
	          if (service.config.useDualstack) {
	            endpoint.hostname = b + '.s3-accelerate.dualstack.amazonaws.com';
	          } else {
	            endpoint.hostname = b + '.s3-accelerate.amazonaws.com';
	          }
	        } else if (!service.config.s3BucketEndpoint) {
	          endpoint.hostname =
	            b + '.' + endpoint.hostname;
	        }

	        var port = endpoint.port;
	        if (port !== 80 && port !== 443) {
	          endpoint.host = endpoint.hostname + ':' +
	            endpoint.port;
	        } else {
	          endpoint.host = endpoint.hostname;
	        }

	        httpRequest.virtualHostedBucket = b; // needed for signing the request
	        service.removeVirtualHostedBucketFromPath(req);
	      }
	    }
	  },

	  /**
	   * Takes the bucket name out of the path if bucket is virtual-hosted
	   *
	   * @api private
	   */
	  removeVirtualHostedBucketFromPath: function removeVirtualHostedBucketFromPath(req) {
	    var httpRequest = req.httpRequest;
	    var bucket = httpRequest.virtualHostedBucket;
	    if (bucket && httpRequest.path) {
	      httpRequest.path = httpRequest.path.replace(new RegExp('/' + bucket), '');
	      if (httpRequest.path[0] !== '/') {
	        httpRequest.path = '/' + httpRequest.path;
	      }
	    }
	  },

	  /**
	   * Adds Expect: 100-continue header if payload is greater-or-equal 1MB
	   * @api private
	   */
	  addExpect100Continue: function addExpect100Continue(req) {
	    var len = req.httpRequest.headers['Content-Length'];
	    if (AWS.util.isNode() && len >= 1024 * 1024) {
	      req.httpRequest.headers['Expect'] = '100-continue';
	    }
	  },

	  /**
	   * Adds a default content type if none is supplied.
	   *
	   * @api private
	   */
	  addContentType: function addContentType(req) {
	    var httpRequest = req.httpRequest;
	    if (httpRequest.method === 'GET' || httpRequest.method === 'HEAD') {
	      // Content-Type is not set in GET/HEAD requests
	      delete httpRequest.headers['Content-Type'];
	      return;
	    }

	    if (!httpRequest.headers['Content-Type']) { // always have a Content-Type
	      httpRequest.headers['Content-Type'] = 'application/octet-stream';
	    }

	    var contentType = httpRequest.headers['Content-Type'];
	    if (AWS.util.isBrowser()) {
	      if (typeof httpRequest.body === 'string' && !contentType.match(/;\s*charset=/)) {
	        var charset = '; charset=UTF-8';
	        httpRequest.headers['Content-Type'] += charset;
	      } else {
	        var replaceFn = function(_, prefix, charsetName) {
	          return prefix + charsetName.toUpperCase();
	        };

	        httpRequest.headers['Content-Type'] =
	          contentType.replace(/(;\s*charset=)(.+)$/, replaceFn);
	      }
	    }
	  },

	  /**
	   * @api private
	   */
	  computableChecksumOperations: {
	    putBucketCors: true,
	    putBucketLifecycle: true,
	    putBucketLifecycleConfiguration: true,
	    putBucketTagging: true,
	    deleteObjects: true,
	    putBucketReplication: true
	  },

	  /**
	   * Checks whether checksums should be computed for the request.
	   * If the request requires checksums to be computed, this will always
	   * return true, otherwise it depends on whether {AWS.Config.computeChecksums}
	   * is set.
	   *
	   * @param req [AWS.Request] the request to check against
	   * @return [Boolean] whether to compute checksums for a request.
	   * @api private
	   */
	  willComputeChecksums: function willComputeChecksums(req) {
	    if (this.computableChecksumOperations[req.operation]) return true;
	    if (!this.config.computeChecksums) return false;

	    // TODO: compute checksums for Stream objects
	    if (!AWS.util.Buffer.isBuffer(req.httpRequest.body) &&
	        typeof req.httpRequest.body !== 'string') {
	      return false;
	    }

	    var rules = req.service.api.operations[req.operation].input.members;

	    // Sha256 signing disabled, and not a presigned url
	    if (req.service.shouldDisableBodySigning(req) && !Object.prototype.hasOwnProperty.call(req.httpRequest.headers, 'presigned-expires')) {
	      if (rules.ContentMD5 && !req.params.ContentMD5) {
	        return true;
	      }
	    }

	    // V4 signer uses SHA256 signatures so only compute MD5 if it is required
	    if (req.service.getSignerClass(req) === AWS.Signers.V4) {
	      if (rules.ContentMD5 && !rules.ContentMD5.required) return false;
	    }

	    if (rules.ContentMD5 && !req.params.ContentMD5) return true;
	  },

	  /**
	   * A listener that computes the Content-MD5 and sets it in the header.
	   * @see AWS.S3.willComputeChecksums
	   * @api private
	   */
	  computeContentMd5: function computeContentMd5(req) {
	    if (req.service.willComputeChecksums(req)) {
	      var md5 = AWS.util.crypto.md5(req.httpRequest.body, 'base64');
	      req.httpRequest.headers['Content-MD5'] = md5;
	    }
	  },

	  /**
	   * @api private
	   */
	  computeSseCustomerKeyMd5: function computeSseCustomerKeyMd5(req) {
	    var keys = {
	      SSECustomerKey: 'x-amz-server-side-encryption-customer-key-MD5',
	      CopySourceSSECustomerKey: 'x-amz-copy-source-server-side-encryption-customer-key-MD5'
	    };
	    AWS.util.each(keys, function(key, header) {
	      if (req.params[key]) {
	        var value = AWS.util.crypto.md5(req.params[key], 'base64');
	        req.httpRequest.headers[header] = value;
	      }
	    });
	  },

	  /**
	   * Returns true if the bucket name should be left in the URI path for
	   * a request to S3.  This function takes into account the current
	   * endpoint protocol (e.g. http or https).
	   *
	   * @api private
	   */
	  pathStyleBucketName: function pathStyleBucketName(bucketName) {
	    // user can force path style requests via the configuration
	    if (this.config.s3ForcePathStyle) return true;
	    if (this.config.s3BucketEndpoint) return false;

	    if (this.dnsCompatibleBucketName(bucketName)) {
	      return (this.config.sslEnabled && bucketName.match(/\./)) ? true : false;
	    } else {
	      return true; // not dns compatible names must always use path style
	    }
	  },

	  /**
	   * Returns true if the bucket name is DNS compatible.  Buckets created
	   * outside of the classic region MUST be DNS compatible.
	   *
	   * @api private
	   */
	  dnsCompatibleBucketName: function dnsCompatibleBucketName(bucketName) {
	    var b = bucketName;
	    var domain = new RegExp(/^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/);
	    var ipAddress = new RegExp(/(\d+\.){3}\d+/);
	    var dots = new RegExp(/\.\./);
	    return (b.match(domain) && !b.match(ipAddress) && !b.match(dots)) ? true : false;
	  },

	  /**
	   * @return [Boolean] whether response contains an error
	   * @api private
	   */
	  successfulResponse: function successfulResponse(resp) {
	    var req = resp.request;
	    var httpResponse = resp.httpResponse;
	    if (operationsWith200StatusCodeError[req.operation] &&
	        httpResponse.body.toString().match('<Error>')) {
	      return false;
	    } else {
	      return httpResponse.statusCode < 300;
	    }
	  },

	  /**
	   * @return [Boolean] whether the error can be retried
	   * @api private
	   */
	  retryableError: function retryableError(error, request) {
	    if (operationsWith200StatusCodeError[request.operation] &&
	        error.statusCode === 200) {
	      return true;
	    } else if (request._requestRegionForBucket &&
	        request.service.bucketRegionCache[request._requestRegionForBucket]) {
	      return false;
	    } else if (error && error.code === 'RequestTimeout') {
	      return true;
	    } else if (error &&
	        regionRedirectErrorCodes.indexOf(error.code) != -1 &&
	        error.region && error.region != request.httpRequest.region) {
	      request.httpRequest.region = error.region;
	      if (error.statusCode === 301) {
	        request.service.updateReqBucketRegion(request);
	      }
	      return true;
	    } else {
	      var _super = AWS.Service.prototype.retryableError;
	      return _super.call(this, error, request);
	    }
	  },

	  /**
	   * Updates httpRequest with region. If region is not provided, then
	   * the httpRequest will be updated based on httpRequest.region
	   *
	   * @api private
	   */
	  updateReqBucketRegion: function updateReqBucketRegion(request, region) {
	    var httpRequest = request.httpRequest;
	    if (typeof region === 'string' && region.length) {
	      httpRequest.region = region;
	    }
	    if (!httpRequest.endpoint.host.match(/s3(?!-accelerate).*\.amazonaws\.com$/)) {
	      return;
	    }
	    var service = request.service;
	    var s3Config = service.config;
	    var s3BucketEndpoint = s3Config.s3BucketEndpoint;
	    if (s3BucketEndpoint) {
	      delete s3Config.s3BucketEndpoint;
	    }
	    var newConfig = AWS.util.copy(s3Config);
	    delete newConfig.endpoint;
	    newConfig.region = httpRequest.region;

	    httpRequest.endpoint = (new AWS.S3(newConfig)).endpoint;
	    service.populateURI(request);
	    s3Config.s3BucketEndpoint = s3BucketEndpoint;
	    httpRequest.headers.Host = httpRequest.endpoint.host;

	    if (request._asm.currentState === 'validate') {
	      request.removeListener('build', service.populateURI);
	      request.addListener('build', service.removeVirtualHostedBucketFromPath);
	    }
	  },

	  /**
	   * Provides a specialized parser for getBucketLocation -- all other
	   * operations are parsed by the super class.
	   *
	   * @api private
	   */
	  extractData: function extractData(resp) {
	    var req = resp.request;
	    if (req.operation === 'getBucketLocation') {
	      var match = resp.httpResponse.body.toString().match(/>(.+)<\/Location/);
	      delete resp.data['_'];
	      if (match) {
	        resp.data.LocationConstraint = match[1];
	      } else {
	        resp.data.LocationConstraint = '';
	      }
	    }
	    var bucket = req.params.Bucket || null;
	    if (req.operation === 'deleteBucket' && typeof bucket === 'string' && !resp.error) {
	      req.service.clearBucketRegionCache(bucket);
	    } else {
	      var headers = resp.httpResponse.headers || {};
	      var region = headers['x-amz-bucket-region'] || null;
	      if (!region && req.operation === 'createBucket' && !resp.error) {
	        var createBucketConfiguration = req.params.CreateBucketConfiguration;
	        if (!createBucketConfiguration) {
	          region = 'us-east-1';
	        } else if (createBucketConfiguration.LocationConstraint === 'EU') {
	          region = 'eu-west-1';
	        } else {
	          region = createBucketConfiguration.LocationConstraint;
	        }
	      }
	      if (region) {
	          if (bucket && region !== req.service.bucketRegionCache[bucket]) {
	            req.service.bucketRegionCache[bucket] = region;
	          }
	      }
	    }
	    req.service.extractRequestIds(resp);
	  },

	  /**
	   * Extracts an error object from the http response.
	   *
	   * @api private
	   */
	  extractError: function extractError(resp) {
	    var codes = {
	      304: 'NotModified',
	      403: 'Forbidden',
	      400: 'BadRequest',
	      404: 'NotFound'
	    };

	    var req = resp.request;
	    var code = resp.httpResponse.statusCode;
	    var body = resp.httpResponse.body || '';

	    var headers = resp.httpResponse.headers || {};
	    var region = headers['x-amz-bucket-region'] || null;
	    var bucket = req.params.Bucket || null;
	    var bucketRegionCache = req.service.bucketRegionCache;
	    if (region && bucket && region !== bucketRegionCache[bucket]) {
	      bucketRegionCache[bucket] = region;
	    }

	    var cachedRegion;
	    if (codes[code] && body.length === 0) {
	      if (bucket && !region) {
	        cachedRegion = bucketRegionCache[bucket] || null;
	        if (cachedRegion !== req.httpRequest.region) {
	          region = cachedRegion;
	        }
	      }
	      resp.error = AWS.util.error(new Error(), {
	        code: codes[code],
	        message: null,
	        region: region
	      });
	    } else {
	      var data = new AWS.XML.Parser().parse(body.toString());

	      if (data.Region && !region) {
	        region = data.Region;
	        if (bucket && region !== bucketRegionCache[bucket]) {
	          bucketRegionCache[bucket] = region;
	        }
	      } else if (bucket && !region && !data.Region) {
	        cachedRegion = bucketRegionCache[bucket] || null;
	        if (cachedRegion !== req.httpRequest.region) {
	          region = cachedRegion;
	        }
	      }

	      resp.error = AWS.util.error(new Error(), {
	        code: data.Code || code,
	        message: data.Message || null,
	        region: region
	      });
	    }
	    req.service.extractRequestIds(resp);
	  },

	  /**
	   * If region was not obtained synchronously, then send async request
	   * to get bucket region for errors resulting from wrong region.
	   *
	   * @api private
	   */
	  requestBucketRegion: function requestBucketRegion(resp, done) {
	    var error = resp.error;
	    var req = resp.request;
	    var bucket = req.params.Bucket || null;

	    if (!error || !bucket || error.region || req.operation === 'listObjects' ||
	        (AWS.util.isNode() && req.operation === 'headBucket') ||
	        (error.statusCode === 400 && req.operation !== 'headObject') ||
	        regionRedirectErrorCodes.indexOf(error.code) === -1) {
	      return done();
	    }
	    var reqOperation = AWS.util.isNode() ? 'headBucket' : 'listObjects';
	    var reqParams = {Bucket: bucket};
	    if (reqOperation === 'listObjects') reqParams.MaxKeys = 0;
	    var regionReq = req.service[reqOperation](reqParams);
	    regionReq._requestRegionForBucket = bucket;
	    regionReq.send(function() {
	      var region = req.service.bucketRegionCache[bucket] || null;
	      error.region = region;
	      done();
	    });
	  },

	   /**
	   * For browser only. If NetworkingError received, will attempt to obtain
	   * the bucket region.
	   *
	   * @api private
	   */
	   reqRegionForNetworkingError: function reqRegionForNetworkingError(resp, done) {
	    if (!AWS.util.isBrowser()) {
	      return done();
	    }
	    var error = resp.error;
	    var request = resp.request;
	    var bucket = request.params.Bucket;
	    if (!error || error.code !== 'NetworkingError' || !bucket ||
	        request.httpRequest.region === 'us-east-1') {
	      return done();
	    }
	    var service = request.service;
	    var bucketRegionCache = service.bucketRegionCache;
	    var cachedRegion = bucketRegionCache[bucket] || null;

	    if (cachedRegion && cachedRegion !== request.httpRequest.region) {
	      service.updateReqBucketRegion(request, cachedRegion);
	      done();
	    } else if (!service.dnsCompatibleBucketName(bucket)) {
	      service.updateReqBucketRegion(request, 'us-east-1');
	      if (bucketRegionCache[bucket] !== 'us-east-1') {
	        bucketRegionCache[bucket] = 'us-east-1';
	      }
	      done();
	    } else if (request.httpRequest.virtualHostedBucket) {
	      var getRegionReq = service.listObjects({Bucket: bucket, MaxKeys: 0});
	      service.updateReqBucketRegion(getRegionReq, 'us-east-1');
	      getRegionReq._requestRegionForBucket = bucket;

	      getRegionReq.send(function() {
	        var region = service.bucketRegionCache[bucket] || null;
	        if (region && region !== request.httpRequest.region) {
	          service.updateReqBucketRegion(request, region);
	        }
	        done();
	      });
	    } else {
	      // DNS-compatible path-style
	      // (s3ForcePathStyle or bucket name with dot over https)
	      // Cannot obtain region information for this case
	      done();
	    }
	   },

	  /**
	   * Cache for bucket region.
	   *
	   * @api private
	   */
	   bucketRegionCache: {},

	  /**
	   * Clears bucket region cache.
	   *
	   * @api private
	   */
	   clearBucketRegionCache: function(buckets) {
	    var bucketRegionCache = this.bucketRegionCache;
	    if (!buckets) {
	      buckets = Object.keys(bucketRegionCache);
	    } else if (typeof buckets === 'string') {
	      buckets = [buckets];
	    }
	    for (var i = 0; i < buckets.length; i++) {
	      delete bucketRegionCache[buckets[i]];
	    }
	    return bucketRegionCache;
	   },

	   /**
	    * Corrects request region if bucket's cached region is different
	    *
	    * @api private
	    */
	  correctBucketRegionFromCache: function correctBucketRegionFromCache(req) {
	    var bucket = req.params.Bucket || null;
	    if (bucket) {
	      var service = req.service;
	      var requestRegion = req.httpRequest.region;
	      var cachedRegion = service.bucketRegionCache[bucket];
	      if (cachedRegion && cachedRegion !== requestRegion) {
	        service.updateReqBucketRegion(req, cachedRegion);
	      }
	    }
	  },

	  /**
	   * Extracts S3 specific request ids from the http response.
	   *
	   * @api private
	   */
	  extractRequestIds: function extractRequestIds(resp) {
	    var extendedRequestId = resp.httpResponse.headers ? resp.httpResponse.headers['x-amz-id-2'] : null;
	    var cfId = resp.httpResponse.headers ? resp.httpResponse.headers['x-amz-cf-id'] : null;
	    resp.extendedRequestId = extendedRequestId;
	    resp.cfId = cfId;

	    if (resp.error) {
	      resp.error.requestId = resp.requestId || null;
	      resp.error.extendedRequestId = extendedRequestId;
	      resp.error.cfId = cfId;
	    }
	  },

	  /**
	   * Get a pre-signed URL for a given operation name.
	   *
	   * @note You must ensure that you have static or previously resolved
	   *   credentials if you call this method synchronously (with no callback),
	   *   otherwise it may not properly sign the request. If you cannot guarantee
	   *   this (you are using an asynchronous credential provider, i.e., EC2
	   *   IAM roles), you should always call this method with an asynchronous
	   *   callback.
	   * @param operation [String] the name of the operation to call
	   * @param params [map] parameters to pass to the operation. See the given
	   *   operation for the expected operation parameters. In addition, you can
	   *   also pass the "Expires" parameter to inform S3 how long the URL should
	   *   work for.
	   * @option params Expires [Integer] (900) the number of seconds to expire
	   *   the pre-signed URL operation in. Defaults to 15 minutes.
	   * @param callback [Function] if a callback is provided, this function will
	   *   pass the URL as the second parameter (after the error parameter) to
	   *   the callback function.
	   * @return [String] if called synchronously (with no callback), returns the
	   *   signed URL.
	   * @return [null] nothing is returned if a callback is provided.
	   * @example Pre-signing a getObject operation (synchronously)
	   *   var params = {Bucket: 'bucket', Key: 'key'};
	   *   var url = s3.getSignedUrl('getObject', params);
	   *   console.log('The URL is', url);
	   * @example Pre-signing a putObject (asynchronously)
	   *   var params = {Bucket: 'bucket', Key: 'key'};
	   *   s3.getSignedUrl('putObject', params, function (err, url) {
	   *     console.log('The URL is', url);
	   *   });
	   * @example Pre-signing a putObject operation with a specific payload
	   *   var params = {Bucket: 'bucket', Key: 'key', Body: 'body'};
	   *   var url = s3.getSignedUrl('putObject', params);
	   *   console.log('The URL is', url);
	   * @example Passing in a 1-minute expiry time for a pre-signed URL
	   *   var params = {Bucket: 'bucket', Key: 'key', Expires: 60};
	   *   var url = s3.getSignedUrl('getObject', params);
	   *   console.log('The URL is', url); // expires in 60 seconds
	   */
	  getSignedUrl: function getSignedUrl(operation, params, callback) {
	    params = AWS.util.copy(params || {});
	    var expires = params.Expires || 900;
	    delete params.Expires; // we can't validate this
	    var request = this.makeRequest(operation, params);
	    return request.presign(expires, callback);
	  },

	  /**
	   * @api private
	   */
	  prepareSignedUrl: function prepareSignedUrl(request) {
	    request.addListener('validate', request.service.noPresignedContentLength);
	    request.removeListener('build', request.service.addContentType);
	    if (!request.params.Body) {
	      // no Content-MD5/SHA-256 if body is not provided
	      request.removeListener('build', request.service.computeContentMd5);
	    } else {
	      request.addListener('afterBuild', AWS.EventListeners.Core.COMPUTE_SHA256);
	    }
	  },

	  /**
	   * @api private
	   * @param request
	   */
	  disableBodySigning: function disableBodySigning(request) {
	    var headers = request.httpRequest.headers;
	    // Add the header to anything that isn't a presigned url, unless that presigned url had a body defined
	    if (!Object.prototype.hasOwnProperty.call(headers, 'presigned-expires')) {
	      headers['X-Amz-Content-Sha256'] = 'UNSIGNED-PAYLOAD';
	    }
	  },

	  /**
	   * @api private
	   */
	  noPresignedContentLength: function noPresignedContentLength(request) {
	    if (request.params.ContentLength !== undefined) {
	      throw AWS.util.error(new Error(), {code: 'UnexpectedParameter',
	        message: 'ContentLength is not supported in pre-signed URLs.'});
	    }
	  },

	  createBucket: function createBucket(params, callback) {
	    // When creating a bucket *outside* the classic region, the location
	    // constraint must be set for the bucket and it must match the endpoint.
	    // This chunk of code will set the location constraint param based
	    // on the region (when possible), but it will not override a passed-in
	    // location constraint.
	    if (typeof params === 'function' || !params) {
	      callback = callback || params;
	      params = {};
	    }
	    var hostname = this.endpoint.hostname;
	    if (hostname !== this.api.globalEndpoint && !params.CreateBucketConfiguration) {
	      params.CreateBucketConfiguration = { LocationConstraint: this.config.region };
	    }
	    return this.makeRequest('createBucket', params, callback);
	  },

	  /**
	   * @overload upload(params = {}, [options], [callback])
	   *   Uploads an arbitrarily sized buffer, blob, or stream, using intelligent
	   *   concurrent handling of parts if the payload is large enough. You can
	   *   configure the concurrent queue size by setting `options`. Note that this
	   *   is the only operation for which the SDK can retry requests with stream
	   *   bodies.
	   *
	   *   @param (see AWS.S3.putObject)
	   *   @option (see AWS.S3.ManagedUpload.constructor)
	   *   @return [AWS.S3.ManagedUpload] the managed upload object that can call
	   *     `send()` or track progress.
	   *   @example Uploading a stream object
	   *     var params = {Bucket: 'bucket', Key: 'key', Body: stream};
	   *     s3.upload(params, function(err, data) {
	   *       console.log(err, data);
	   *     });
	   *   @example Uploading a stream with concurrency of 1 and partSize of 10mb
	   *     var params = {Bucket: 'bucket', Key: 'key', Body: stream};
	   *     var options = {partSize: 10 * 1024 * 1024, queueSize: 1};
	   *     s3.upload(params, options, function(err, data) {
	   *       console.log(err, data);
	   *     });
	   * @callback callback function(err, data)
	   *   @param err [Error] an error or null if no error occurred.
	   *   @param data [map] The response data from the successful upload:
	   *     * `Location` (String) the URL of the uploaded object
	   *     * `ETag` (String) the ETag of the uploaded object
	   *     * `Bucket` (String) the bucket to which the object was uploaded
	   *     * `Key` (String) the key to which the object was uploaded
	   *   @see AWS.S3.ManagedUpload
	   */
	  upload: function upload(params, options, callback) {
	    if (typeof options === 'function' && callback === undefined) {
	      callback = options;
	      options = null;
	    }

	    options = options || {};
	    options = AWS.util.merge(options || {}, {service: this, params: params});

	    var uploader = new AWS.S3.ManagedUpload(options);
	    if (typeof callback === 'function') uploader.send(callback);
	    return uploader;
	  }
	});


/***/ },
/* 442 */
/***/ function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(93);
	var byteLength = AWS.util.string.byteLength;
	var Buffer = AWS.util.Buffer;

	/**
	 * The managed uploader allows for easy and efficient uploading of buffers,
	 * blobs, or streams, using a configurable amount of concurrency to perform
	 * multipart uploads where possible. This abstraction also enables uploading
	 * streams of unknown size due to the use of multipart uploads.
	 *
	 * To construct a managed upload object, see the {constructor} function.
	 *
	 * ## Tracking upload progress
	 *
	 * The managed upload object can also track progress by attaching an
	 * 'httpUploadProgress' listener to the upload manager. This event is similar
	 * to {AWS.Request~httpUploadProgress} but groups all concurrent upload progress
	 * into a single event. See {AWS.S3.ManagedUpload~httpUploadProgress} for more
	 * information.
	 *
	 * ## Handling Multipart Cleanup
	 *
	 * By default, this class will automatically clean up any multipart uploads
	 * when an individual part upload fails. This behavior can be disabled in order
	 * to manually handle failures by setting the `leavePartsOnError` configuration
	 * option to `true` when initializing the upload object.
	 *
	 * @!event httpUploadProgress(progress)
	 *   Triggered when the uploader has uploaded more data.
	 *   @note The `total` property may not be set if the stream being uploaded has
	 *     not yet finished chunking. In this case the `total` will be undefined
	 *     until the total stream size is known.
	 *   @note This event will not be emitted in Node.js 0.8.x.
	 *   @param progress [map] An object containing the `loaded` and `total` bytes
	 *     of the request and the `key` of the S3 object. Note that `total` may be undefined until the payload
	 *     size is known.
	 *   @context (see AWS.Request~send)
	 */
	AWS.S3.ManagedUpload = AWS.util.inherit({
	  /**
	   * Creates a managed upload object with a set of configuration options.
	   *
	   * @note A "Body" parameter is required to be set prior to calling {send}.
	   * @option options params [map] a map of parameters to pass to the upload
	   *   requests. The "Body" parameter is required to be specified either on
	   *   the service or in the params option.
	   * @note ContentMD5 should not be provided when using the managed upload object.
	   *   Instead, setting "computeChecksums" to true will enable automatic ContentMD5 generation
	   *   by the managed upload object.
	   * @option options queueSize [Number] (4) the size of the concurrent queue
	   *   manager to upload parts in parallel. Set to 1 for synchronous uploading
	   *   of parts. Note that the uploader will buffer at most queueSize * partSize
	   *   bytes into memory at any given time.
	   * @option options partSize [Number] (5mb) the size in bytes for each
	   *   individual part to be uploaded. Adjust the part size to ensure the number
	   *   of parts does not exceed {maxTotalParts}. See {minPartSize} for the
	   *   minimum allowed part size.
	   * @option options leavePartsOnError [Boolean] (false) whether to abort the
	   *   multipart upload if an error occurs. Set to true if you want to handle
	   *   failures manually.
	   * @option options service [AWS.S3] an optional S3 service object to use for
	   *   requests. This object might have bound parameters used by the uploader.
	   * @example Creating a default uploader for a stream object
	   *   var upload = new AWS.S3.ManagedUpload({
	   *     params: {Bucket: 'bucket', Key: 'key', Body: stream}
	   *   });
	   * @example Creating an uploader with concurrency of 1 and partSize of 10mb
	   *   var upload = new AWS.S3.ManagedUpload({
	   *     partSize: 10 * 1024 * 1024, queueSize: 1,
	   *     params: {Bucket: 'bucket', Key: 'key', Body: stream}
	   *   });
	   * @see send
	   */
	  constructor: function ManagedUpload(options) {
	    var self = this;
	    AWS.SequentialExecutor.call(self);
	    self.body = null;
	    self.sliceFn = null;
	    self.callback = null;
	    self.parts = {};
	    self.completeInfo = [];
	    self.fillQueue = function() {
	      self.callback(new Error('Unsupported body payload ' + typeof self.body));
	    };

	    self.configure(options);
	  },

	  /**
	   * @api private
	   */
	  configure: function configure(options) {
	    options = options || {};
	    this.partSize = this.minPartSize;

	    if (options.queueSize) this.queueSize = options.queueSize;
	    if (options.partSize) this.partSize = options.partSize;
	    if (options.leavePartsOnError) this.leavePartsOnError = true;

	    if (this.partSize < this.minPartSize) {
	      throw new Error('partSize must be greater than ' +
	                      this.minPartSize);
	    }

	    this.service = options.service;
	    this.bindServiceObject(options.params);
	    this.validateBody();
	    this.adjustTotalBytes();
	  },

	  /**
	   * @api private
	   */
	  leavePartsOnError: false,

	  /**
	   * @api private
	   */
	  queueSize: 4,

	  /**
	   * @api private
	   */
	  partSize: null,

	  /**
	   * @readonly
	   * @return [Number] the minimum number of bytes for an individual part
	   *   upload.
	   */
	  minPartSize: 1024 * 1024 * 5,

	  /**
	   * @readonly
	   * @return [Number] the maximum allowed number of parts in a multipart upload.
	   */
	  maxTotalParts: 10000,

	  /**
	   * Initiates the managed upload for the payload.
	   *
	   * @callback callback function(err, data)
	   *   @param err [Error] an error or null if no error occurred.
	   *   @param data [map] The response data from the successful upload:
	   *     * `Location` (String) the URL of the uploaded object
	   *     * `ETag` (String) the ETag of the uploaded object
	   *     * `Bucket` (String) the bucket to which the object was uploaded
	   *     * `Key` (String) the key to which the object was uploaded
	   * @example Sending a managed upload object
	   *   var params = {Bucket: 'bucket', Key: 'key', Body: stream};
	   *   var upload = new AWS.S3.ManagedUpload({params: params});
	   *   upload.send(function(err, data) {
	   *     console.log(err, data);
	   *   });
	   */
	  send: function(callback) {
	    var self = this;
	    self.failed = false;
	    self.callback = callback || function(err) { if (err) throw err; };

	    var runFill = true;
	    if (self.sliceFn) {
	      self.fillQueue = self.fillBuffer;
	    } else if (AWS.util.isNode()) {
	      var Stream = AWS.util.stream.Stream;
	      if (self.body instanceof Stream) {
	        runFill = false;
	        self.fillQueue = self.fillStream;
	        self.partBuffers = [];
	        self.body.
	          on('error', function(err) { self.cleanup(err); }).
	          on('readable', function() { self.fillQueue(); }).
	          on('end', function() {
	            self.isDoneChunking = true;
	            self.numParts = self.totalPartNumbers;
	            self.fillQueue.call(self);
	          });
	      }
	    }

	    if (runFill) self.fillQueue.call(self);
	  },

	  /**
	   * @!method  promise()
	   *   Returns a 'thenable' promise.
	   *
	   *   Two callbacks can be provided to the `then` method on the returned promise.
	   *   The first callback will be called if the promise is fulfilled, and the second
	   *   callback will be called if the promise is rejected.
	   *   @callback fulfilledCallback function(data)
	   *     Called if the promise is fulfilled.
	   *     @param data [map] The response data from the successful upload:
	   *       `Location` (String) the URL of the uploaded object
	   *       `ETag` (String) the ETag of the uploaded object
	   *       `Bucket` (String) the bucket to which the object was uploaded
	   *       `Key` (String) the key to which the object was uploaded
	   *   @callback rejectedCallback function(err)
	   *     Called if the promise is rejected.
	   *     @param err [Error] an error or null if no error occurred.
	   *   @return [Promise] A promise that represents the state of the upload request.
	   *   @example Sending an upload request using promises.
	   *     var upload = s3.upload({Bucket: 'bucket', Key: 'key', Body: stream});
	   *     var promise = upload.promise();
	   *     promise.then(function(data) { ... }, function(err) { ... });
	   */

	  /**
	   * Aborts a managed upload, including all concurrent upload requests.
	   * @note By default, calling this function will cleanup a multipart upload
	   *   if one was created. To leave the multipart upload around after aborting
	   *   a request, configure `leavePartsOnError` to `true` in the {constructor}.
	   * @note Calling {abort} in the browser environment will not abort any requests
	   *   that are already in flight. If a multipart upload was created, any parts
	   *   not yet uploaded will not be sent, and the multipart upload will be cleaned up.
	   * @example Aborting an upload
	   *   var params = {
	   *     Bucket: 'bucket', Key: 'key',
	   *     Body: new Buffer(1024 * 1024 * 25) // 25MB payload
	   *   };
	   *   var upload = s3.upload(params);
	   *   upload.send(function (err, data) {
	   *     if (err) console.log("Error:", err.code, err.message);
	   *     else console.log(data);
	   *   });
	   *
	   *   // abort request in 1 second
	   *   setTimeout(upload.abort.bind(upload), 1000);
	   */
	  abort: function() {
	    this.cleanup(AWS.util.error(new Error('Request aborted by user'), {
	      code: 'RequestAbortedError', retryable: false
	    }));
	  },

	  /**
	   * @api private
	   */
	  validateBody: function validateBody() {
	    var self = this;
	    self.body = self.service.config.params.Body;
	    if (!self.body) throw new Error('params.Body is required');
	    if (typeof self.body === 'string') {
	      self.body = new AWS.util.Buffer(self.body);
	    }
	    self.sliceFn = AWS.util.arraySliceFn(self.body);
	  },

	  /**
	   * @api private
	   */
	  bindServiceObject: function bindServiceObject(params) {
	    params = params || {};
	    var self = this;

	    // bind parameters to new service object
	    if (!self.service) {
	      self.service = new AWS.S3({params: params});
	    } else {
	      var config = AWS.util.copy(self.service.config);
	      self.service = new self.service.constructor.__super__(config);
	      self.service.config.params =
	        AWS.util.merge(self.service.config.params || {}, params);
	    }
	  },

	  /**
	   * @api private
	   */
	  adjustTotalBytes: function adjustTotalBytes() {
	    var self = this;
	    try { // try to get totalBytes
	      self.totalBytes = byteLength(self.body);
	    } catch (e) { }

	    // try to adjust partSize if we know payload length
	    if (self.totalBytes) {
	      var newPartSize = Math.ceil(self.totalBytes / self.maxTotalParts);
	      if (newPartSize > self.partSize) self.partSize = newPartSize;
	    } else {
	      self.totalBytes = undefined;
	    }
	  },

	  /**
	   * @api private
	   */
	  isDoneChunking: false,

	  /**
	   * @api private
	   */
	  partPos: 0,

	  /**
	   * @api private
	   */
	  totalChunkedBytes: 0,

	  /**
	   * @api private
	   */
	  totalUploadedBytes: 0,

	  /**
	   * @api private
	   */
	  totalBytes: undefined,

	  /**
	   * @api private
	   */
	  numParts: 0,

	  /**
	   * @api private
	   */
	  totalPartNumbers: 0,

	  /**
	   * @api private
	   */
	  activeParts: 0,

	  /**
	   * @api private
	   */
	  doneParts: 0,

	  /**
	   * @api private
	   */
	  parts: null,

	  /**
	   * @api private
	   */
	  completeInfo: null,

	  /**
	   * @api private
	   */
	  failed: false,

	  /**
	   * @api private
	   */
	  multipartReq: null,

	  /**
	   * @api private
	   */
	  partBuffers: null,

	  /**
	   * @api private
	   */
	  partBufferLength: 0,

	  /**
	   * @api private
	   */
	  fillBuffer: function fillBuffer() {
	    var self = this;
	    var bodyLen = byteLength(self.body);

	    if (bodyLen === 0) {
	      self.isDoneChunking = true;
	      self.numParts = 1;
	      self.nextChunk(self.body);
	      return;
	    }

	    while (self.activeParts < self.queueSize && self.partPos < bodyLen) {
	      var endPos = Math.min(self.partPos + self.partSize, bodyLen);
	      var buf = self.sliceFn.call(self.body, self.partPos, endPos);
	      self.partPos += self.partSize;

	      if (byteLength(buf) < self.partSize || self.partPos === bodyLen) {
	        self.isDoneChunking = true;
	        self.numParts = self.totalPartNumbers + 1;
	      }
	      self.nextChunk(buf);
	    }
	  },

	  /**
	   * @api private
	   */
	  fillStream: function fillStream() {
	    var self = this;
	    if (self.activeParts >= self.queueSize) return;

	    var buf = self.body.read(self.partSize - self.partBufferLength) ||
	              self.body.read();
	    if (buf) {
	      self.partBuffers.push(buf);
	      self.partBufferLength += buf.length;
	      self.totalChunkedBytes += buf.length;
	    }

	    if (self.partBufferLength >= self.partSize) {
	      // if we have single buffer we avoid copyfull concat
	      var pbuf = self.partBuffers.length === 1 ?
	        self.partBuffers[0] : Buffer.concat(self.partBuffers);
	      self.partBuffers = [];
	      self.partBufferLength = 0;

	      // if we have more than partSize, push the rest back on the queue
	      if (pbuf.length > self.partSize) {
	        var rest = pbuf.slice(self.partSize);
	        self.partBuffers.push(rest);
	        self.partBufferLength += rest.length;
	        pbuf = pbuf.slice(0, self.partSize);
	      }

	      self.nextChunk(pbuf);
	    }

	    if (self.isDoneChunking && !self.isDoneSending) {
	      // if we have single buffer we avoid copyfull concat
	      pbuf = self.partBuffers.length === 1 ?
	          self.partBuffers[0] : Buffer.concat(self.partBuffers);
	      self.partBuffers = [];
	      self.partBufferLength = 0;
	      self.totalBytes = self.totalChunkedBytes;
	      self.isDoneSending = true;

	      if (self.numParts === 0 || pbuf.length > 0) {
	        self.numParts++;
	        self.nextChunk(pbuf);
	      }
	    }

	    self.body.read(0);
	  },

	  /**
	   * @api private
	   */
	  nextChunk: function nextChunk(chunk) {
	    var self = this;
	    if (self.failed) return null;

	    var partNumber = ++self.totalPartNumbers;
	    if (self.isDoneChunking && partNumber === 1) {
	      var req = self.service.putObject({Body: chunk});
	      req._managedUpload = self;
	      req.on('httpUploadProgress', self.progress).send(self.finishSinglePart);
	      return null;
	    } else if (self.service.config.params.ContentMD5) {
	      var err = AWS.util.error(new Error('The Content-MD5 you specified is invalid for multi-part uploads.'), {
	        code: 'InvalidDigest', retryable: false
	      });

	      self.cleanup(err);
	      return null;
	    }

	    if (self.completeInfo[partNumber] && self.completeInfo[partNumber].ETag !== null) {
	      return null; // Already uploaded this part.
	    }

	    self.activeParts++;
	    if (!self.service.config.params.UploadId) {

	      if (!self.multipartReq) { // create multipart
	        self.multipartReq = self.service.createMultipartUpload();
	        self.multipartReq.on('success', function(resp) {
	          self.service.config.params.UploadId = resp.data.UploadId;
	          self.multipartReq = null;
	        });
	        self.queueChunks(chunk, partNumber);
	        self.multipartReq.on('error', function(err) {
	          self.cleanup(err);
	        });
	        self.multipartReq.send();
	      } else {
	        self.queueChunks(chunk, partNumber);
	      }
	    } else { // multipart is created, just send
	      self.uploadPart(chunk, partNumber);
	    }
	  },

	  /**
	   * @api private
	   */
	  uploadPart: function uploadPart(chunk, partNumber) {
	    var self = this;

	    var partParams = {
	      Body: chunk,
	      ContentLength: AWS.util.string.byteLength(chunk),
	      PartNumber: partNumber
	    };

	    var partInfo = {ETag: null, PartNumber: partNumber};
	    self.completeInfo[partNumber] = partInfo;

	    var req = self.service.uploadPart(partParams);
	    self.parts[partNumber] = req;
	    req._lastUploadedBytes = 0;
	    req._managedUpload = self;
	    req.on('httpUploadProgress', self.progress);
	    req.send(function(err, data) {
	      delete self.parts[partParams.PartNumber];
	      self.activeParts--;

	      if (!err && (!data || !data.ETag)) {
	        var message = 'No access to ETag property on response.';
	        if (AWS.util.isBrowser()) {
	          message += ' Check CORS configuration to expose ETag header.';
	        }

	        err = AWS.util.error(new Error(message), {
	          code: 'ETagMissing', retryable: false
	        });
	      }
	      if (err) return self.cleanup(err);

	      partInfo.ETag = data.ETag;
	      self.doneParts++;
	      if (self.isDoneChunking && self.doneParts === self.numParts) {
	        self.finishMultiPart();
	      } else {
	        self.fillQueue.call(self);
	      }
	    });
	  },

	  /**
	   * @api private
	   */
	  queueChunks: function queueChunks(chunk, partNumber) {
	    var self = this;
	    self.multipartReq.on('success', function() {
	      self.uploadPart(chunk, partNumber);
	    });
	  },

	  /**
	   * @api private
	   */
	  cleanup: function cleanup(err) {
	    var self = this;
	    if (self.failed) return;

	    // clean up stream
	    if (typeof self.body.removeAllListeners === 'function' &&
	        typeof self.body.resume === 'function') {
	      self.body.removeAllListeners('readable');
	      self.body.removeAllListeners('end');
	      self.body.resume();
	    }

	    if (self.service.config.params.UploadId && !self.leavePartsOnError) {
	      self.service.abortMultipartUpload().send();
	    }

	    AWS.util.each(self.parts, function(partNumber, part) {
	      part.removeAllListeners('complete');
	      part.abort();
	    });

	    self.activeParts = 0;
	    self.partPos = 0;
	    self.numParts = 0;
	    self.totalPartNumbers = 0;
	    self.parts = {};
	    self.failed = true;
	    self.callback(err);
	  },

	  /**
	   * @api private
	   */
	  finishMultiPart: function finishMultiPart() {
	    var self = this;
	    var completeParams = { MultipartUpload: { Parts: self.completeInfo.slice(1) } };
	    self.service.completeMultipartUpload(completeParams, function(err, data) {
	      if (err) return self.cleanup(err);
	      else self.callback(err, data);
	    });
	  },

	  /**
	   * @api private
	   */
	  finishSinglePart: function finishSinglePart(err, data) {
	    var upload = this.request._managedUpload;
	    var httpReq = this.request.httpRequest;
	    var endpoint = httpReq.endpoint;
	    if (err) return upload.callback(err);
	    data.Location =
	      [endpoint.protocol, '//', endpoint.host, httpReq.path].join('');
	    data.key = this.request.params.Key; // will stay undocumented
	    data.Key = this.request.params.Key;
	    data.Bucket = this.request.params.Bucket;
	    upload.callback(err, data);
	  },

	  /**
	   * @api private
	   */
	  progress: function progress(info) {
	    var upload = this._managedUpload;
	    if (this.operation === 'putObject') {
	      info.part = 1;
	      info.key = this.params.Key;
	    } else {
	      upload.totalUploadedBytes += info.loaded - this._lastUploadedBytes;
	      this._lastUploadedBytes = info.loaded;
	      info = {
	        loaded: upload.totalUploadedBytes,
	        total: upload.totalBytes,
	        part: this.params.PartNumber,
	        key: this.params.Key
	      };
	    }
	    upload.emit('httpUploadProgress', [info]);
	  }
	});

	AWS.util.mixin(AWS.S3.ManagedUpload, AWS.SequentialExecutor);

	/**
	 * @api private
	 */
	AWS.S3.ManagedUpload.addPromisesToClass = function addPromisesToClass(PromiseDependency) {
	  this.prototype.promise = AWS.util.promisifyMethod('send', PromiseDependency);
	};

	/**
	 * @api private
	 */
	AWS.S3.ManagedUpload.deletePromisesFromClass = function deletePromisesFromClass() {
	  delete this.prototype.promise;
	};

	AWS.util.addPromises(AWS.S3.ManagedUpload);

	module.exports = AWS.S3.ManagedUpload;


/***/ },
/* 443 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2006-03-01",
			"checksumFormat": "md5",
			"endpointPrefix": "s3",
			"globalEndpoint": "s3.amazonaws.com",
			"protocol": "rest-xml",
			"serviceAbbreviation": "Amazon S3",
			"serviceFullName": "Amazon Simple Storage Service",
			"signatureVersion": "s3",
			"timestampFormat": "rfc822"
		},
		"operations": {
			"AbortMultipartUpload": {
				"http": {
					"method": "DELETE",
					"requestUri": "/{Bucket}/{Key+}"
				},
				"input": {
					"type": "structure",
					"required": [
						"Bucket",
						"Key",
						"UploadId"
					],
					"members": {
						"Bucket": {
							"location": "uri",
							"locationName": "Bucket"
						},
						"Key": {
							"location": "uri",
							"locationName": "Key"
						},
						"UploadId": {
							"location": "querystring",
							"locationName": "uploadId"
						},
						"RequestPayer": {
							"location": "header",
							"locationName": "x-amz-request-payer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"RequestCharged": {
							"location": "header",
							"locationName": "x-amz-request-charged"
						}
					}
				}
			},
			"CompleteMultipartUpload": {
				"http": {
					"requestUri": "/{Bucket}/{Key+}"
				},
				"input": {
					"type": "structure",
					"required": [
						"Bucket",
						"Key",
						"UploadId"
					],
					"members": {
						"Bucket": {
							"location": "uri",
							"locationName": "Bucket"
						},
						"Key": {
							"location": "uri",
							"locationName": "Key"
						},
						"MultipartUpload": {
							"locationName": "CompleteMultipartUpload",
							"xmlNamespace": {
								"uri": "http://s3.amazonaws.com/doc/2006-03-01/"
							},
							"type": "structure",
							"members": {
								"Parts": {
									"locationName": "Part",
									"type": "list",
									"member": {
										"type": "structure",
										"members": {
											"ETag": {},
											"PartNumber": {
												"type": "integer"
											}
										}
									},
									"flattened": true
								}
							}
						},
						"UploadId": {
							"location": "querystring",
							"locationName": "uploadId"
						},
						"RequestPayer": {
							"location": "header",
							"locationName": "x-amz-request-payer"
						}
					},
					"payload": "MultipartUpload"
				},
				"output": {
					"type": "structure",
					"members": {
						"Location": {},
						"Bucket": {},
						"Key": {},
						"Expiration": {
							"location": "header",
							"locationName": "x-amz-expiration"
						},
						"ETag": {},
						"ServerSideEncryption": {
							"location": "header",
							"locationName": "x-amz-server-side-encryption"
						},
						"VersionId": {
							"location": "header",
							"locationName": "x-amz-version-id"
						},
						"SSEKMSKeyId": {
							"shape": "Sj",
							"location": "header",
							"locationName": "x-amz-server-side-encryption-aws-kms-key-id"
						},
						"RequestCharged": {
							"location": "header",
							"locationName": "x-amz-request-charged"
						}
					}
				}
			},
			"CopyObject": {
				"http": {
					"method": "PUT",
					"requestUri": "/{Bucket}/{Key+}"
				},
				"input": {
					"type": "structure",
					"required": [
						"Bucket",
						"CopySource",
						"Key"
					],
					"members": {
						"ACL": {
							"location": "header",
							"locationName": "x-amz-acl"
						},
						"Bucket": {
							"location": "uri",
							"locationName": "Bucket"
						},
						"CacheControl": {
							"location": "header",
							"locationName": "Cache-Control"
						},
						"ContentDisposition": {
							"location": "header",
							"locationName": "Content-Disposition"
						},
						"ContentEncoding": {
							"location": "header",
							"locationName": "Content-Encoding"
						},
						"ContentLanguage": {
							"location": "header",
							"locationName": "Content-Language"
						},
						"ContentType": {
							"location": "header",
							"locationName": "Content-Type"
						},
						"CopySource": {
							"location": "header",
							"locationName": "x-amz-copy-source"
						},
						"CopySourceIfMatch": {
							"location": "header",
							"locationName": "x-amz-copy-source-if-match"
						},
						"CopySourceIfModifiedSince": {
							"location": "header",
							"locationName": "x-amz-copy-source-if-modified-since",
							"type": "timestamp"
						},
						"CopySourceIfNoneMatch": {
							"location": "header",
							"locationName": "x-amz-copy-source-if-none-match"
						},
						"CopySourceIfUnmodifiedSince": {
							"location": "header",
							"locationName": "x-amz-copy-source-if-unmodified-since",
							"type": "timestamp"
						},
						"Expires": {
							"location": "header",
							"locationName": "Expires",
							"type": "timestamp"
						},
						"GrantFullControl": {
							"location": "header",
							"locationName": "x-amz-grant-full-control"
						},
						"GrantRead": {
							"location": "header",
							"locationName": "x-amz-grant-read"
						},
						"GrantReadACP": {
							"location": "header",
							"locationName": "x-amz-grant-read-acp"
						},
						"GrantWriteACP": {
							"location": "header",
							"locationName": "x-amz-grant-write-acp"
						},
						"Key": {
							"location": "uri",
							"locationName": "Key"
						},
						"Metadata": {
							"shape": "S11",
							"location": "headers",
							"locationName": "x-amz-meta-"
						},
						"MetadataDirective": {
							"location": "header",
							"locationName": "x-amz-metadata-directive"
						},
						"ServerSideEncryption": {
							"location": "header",
							"locationName": "x-amz-server-side-encryption"
						},
						"StorageClass": {
							"location": "header",
							"locationName": "x-amz-storage-class"
						},
						"WebsiteRedirectLocation": {
							"location": "header",
							"locationName": "x-amz-website-redirect-location"
						},
						"SSECustomerAlgorithm": {
							"location": "header",
							"locationName": "x-amz-server-side-encryption-customer-algorithm"
						},
						"SSECustomerKey": {
							"shape": "S18",
							"location": "header",
							"locationName": "x-amz-server-side-encryption-customer-key"
						},
						"SSECustomerKeyMD5": {
							"location": "header",
							"locationName": "x-amz-server-side-encryption-customer-key-MD5"
						},
						"SSEKMSKeyId": {
							"shape": "Sj",
							"location": "header",
							"locationName": "x-amz-server-side-encryption-aws-kms-key-id"
						},
						"CopySourceSSECustomerAlgorithm": {
							"location": "header",
							"locationName": "x-amz-copy-source-server-side-encryption-customer-algorithm"
						},
						"CopySourceSSECustomerKey": {
							"shape": "S1b",
							"location": "header",
							"locationName": "x-amz-copy-source-server-side-encryption-customer-key"
						},
						"CopySourceSSECustomerKeyMD5": {
							"location": "header",
							"locationName": "x-amz-copy-source-server-side-encryption-customer-key-MD5"
						},
						"RequestPayer": {
							"location": "header",
							"locationName": "x-amz-request-payer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"CopyObjectResult": {
							"type": "structure",
							"members": {
								"ETag": {},
								"LastModified": {
									"type": "timestamp"
								}
							}
						},
						"Expiration": {
							"location": "header",
							"locationName": "x-amz-expiration"
						},
						"CopySourceVersionId": {
							"location": "header",
							"locationName": "x-amz-copy-source-version-id"
						},
						"VersionId": {
							"location": "header",
							"locationName": "x-amz-version-id"
						},
						"ServerSideEncryption": {
							"location": "header",
							"locationName": "x-amz-server-side-encryption"
						},
						"SSECustomerAlgorithm": {
							"location": "header",
							"locationName": "x-amz-server-side-encryption-customer-algorithm"
						},
						"SSECustomerKeyMD5": {
							"location": "header",
							"locationName": "x-amz-server-side-encryption-customer-key-MD5"
						},
						"SSEKMSKeyId": {
							"shape": "Sj",
							"location": "header",
							"locationName": "x-amz-server-side-encryption-aws-kms-key-id"
						},
						"RequestCharged": {
							"location": "header",
							"locationName": "x-amz-request-charged"
						}
					},
					"payload": "CopyObjectResult"
				},
				"alias": "PutObjectCopy"
			},
			"CreateBucket": {
				"http": {
					"method": "PUT",
					"requestUri": "/{Bucket}"
				},
				"input": {
					"type": "structure",
					"required": [
						"Bucket"
					],
					"members": {
						"ACL": {
							"location": "header",
							"locationName": "x-amz-acl"
						},
						"Bucket": {
							"location": "uri",
							"locationName": "Bucket"
						},
						"CreateBucketConfiguration": {
							"locationName": "CreateBucketConfiguration",
							"xmlNamespace": {
								"uri": "http://s3.amazonaws.com/doc/2006-03-01/"
							},
							"type": "structure",
							"members": {
								"LocationConstraint": {}
							}
						},
						"GrantFullControl": {
							"location": "header",
							"locationName": "x-amz-grant-full-control"
						},
						"GrantRead": {
							"location": "header",
							"locationName": "x-amz-grant-read"
						},
						"GrantReadACP": {
							"location": "header",
							"locationName": "x-amz-grant-read-acp"
						},
						"GrantWrite": {
							"location": "header",
							"locationName": "x-amz-grant-write"
						},
						"GrantWriteACP": {
							"location": "header",
							"locationName": "x-amz-grant-write-acp"
						}
					},
					"payload": "CreateBucketConfiguration"
				},
				"output": {
					"type": "structure",
					"members": {
						"Location": {
							"location": "header",
							"locationName": "Location"
						}
					}
				},
				"alias": "PutBucket"
			},
			"CreateMultipartUpload": {
				"http": {
					"requestUri": "/{Bucket}/{Key+}?uploads"
				},
				"input": {
					"type": "structure",
					"required": [
						"Bucket",
						"Key"
					],
					"members": {
						"ACL": {
							"location": "header",
							"locationName": "x-amz-acl"
						},
						"Bucket": {
							"location": "uri",
							"locationName": "Bucket"
						},
						"CacheControl": {
							"location": "header",
							"locationName": "Cache-Control"
						},
						"ContentDisposition": {
							"location": "header",
							"locationName": "Content-Disposition"
						},
						"ContentEncoding": {
							"location": "header",
							"locationName": "Content-Encoding"
						},
						"ContentLanguage": {
							"location": "header",
							"locationName": "Content-Language"
						},
						"ContentType": {
							"location": "header",
							"locationName": "Content-Type"
						},
						"Expires": {
							"location": "header",
							"locationName": "Expires",
							"type": "timestamp"
						},
						"GrantFullControl": {
							"location": "header",
							"locationName": "x-amz-grant-full-control"
						},
						"GrantRead": {
							"location": "header",
							"locationName": "x-amz-grant-read"
						},
						"GrantReadACP": {
							"location": "header",
							"locationName": "x-amz-grant-read-acp"
						},
						"GrantWriteACP": {
							"location": "header",
							"locationName": "x-amz-grant-write-acp"
						},
						"Key": {
							"location": "uri",
							"locationName": "Key"
						},
						"Metadata": {
							"shape": "S11",
							"location": "headers",
							"locationName": "x-amz-meta-"
						},
						"ServerSideEncryption": {
							"location": "header",
							"locationName": "x-amz-server-side-encryption"
						},
						"StorageClass": {
							"location": "header",
							"locationName": "x-amz-storage-class"
						},
						"WebsiteRedirectLocation": {
							"location": "header",
							"locationName": "x-amz-website-redirect-location"
						},
						"SSECustomerAlgorithm": {
							"location": "header",
							"locationName": "x-amz-server-side-encryption-customer-algorithm"
						},
						"SSECustomerKey": {
							"shape": "S18",
							"location": "header",
							"locationName": "x-amz-server-side-encryption-customer-key"
						},
						"SSECustomerKeyMD5": {
							"location": "header",
							"locationName": "x-amz-server-side-encryption-customer-key-MD5"
						},
						"SSEKMSKeyId": {
							"shape": "Sj",
							"location": "header",
							"locationName": "x-amz-server-side-encryption-aws-kms-key-id"
						},
						"RequestPayer": {
							"location": "header",
							"locationName": "x-amz-request-payer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"AbortDate": {
							"location": "header",
							"locationName": "x-amz-abort-date",
							"type": "timestamp"
						},
						"AbortRuleId": {
							"location": "header",
							"locationName": "x-amz-abort-rule-id"
						},
						"Bucket": {
							"locationName": "Bucket"
						},
						"Key": {},
						"UploadId": {},
						"ServerSideEncryption": {
							"location": "header",
							"locationName": "x-amz-server-side-encryption"
						},
						"SSECustomerAlgorithm": {
							"location": "header",
							"locationName": "x-amz-server-side-encryption-customer-algorithm"
						},
						"SSECustomerKeyMD5": {
							"location": "header",
							"locationName": "x-amz-server-side-encryption-customer-key-MD5"
						},
						"SSEKMSKeyId": {
							"shape": "Sj",
							"location": "header",
							"locationName": "x-amz-server-side-encryption-aws-kms-key-id"
						},
						"RequestCharged": {
							"location": "header",
							"locationName": "x-amz-request-charged"
						}
					}
				},
				"alias": "InitiateMultipartUpload"
			},
			"DeleteBucket": {
				"http": {
					"method": "DELETE",
					"requestUri": "/{Bucket}"
				},
				"input": {
					"type": "structure",
					"required": [
						"Bucket"
					],
					"members": {
						"Bucket": {
							"location": "uri",
							"locationName": "Bucket"
						}
					}
				}
			},
			"DeleteBucketCors": {
				"http": {
					"method": "DELETE",
					"requestUri": "/{Bucket}?cors"
				},
				"input": {
					"type": "structure",
					"required": [
						"Bucket"
					],
					"members": {
						"Bucket": {
							"location": "uri",
							"locationName": "Bucket"
						}
					}
				}
			},
			"DeleteBucketLifecycle": {
				"http": {
					"method": "DELETE",
					"requestUri": "/{Bucket}?lifecycle"
				},
				"input": {
					"type": "structure",
					"required": [
						"Bucket"
					],
					"members": {
						"Bucket": {
							"location": "uri",
							"locationName": "Bucket"
						}
					}
				}
			},
			"DeleteBucketPolicy": {
				"http": {
					"method": "DELETE",
					"requestUri": "/{Bucket}?policy"
				},
				"input": {
					"type": "structure",
					"required": [
						"Bucket"
					],
					"members": {
						"Bucket": {
							"location": "uri",
							"locationName": "Bucket"
						}
					}
				}
			},
			"DeleteBucketReplication": {
				"http": {
					"method": "DELETE",
					"requestUri": "/{Bucket}?replication"
				},
				"input": {
					"type": "structure",
					"required": [
						"Bucket"
					],
					"members": {
						"Bucket": {
							"location": "uri",
							"locationName": "Bucket"
						}
					}
				}
			},
			"DeleteBucketTagging": {
				"http": {
					"method": "DELETE",
					"requestUri": "/{Bucket}?tagging"
				},
				"input": {
					"type": "structure",
					"required": [
						"Bucket"
					],
					"members": {
						"Bucket": {
							"location": "uri",
							"locationName": "Bucket"
						}
					}
				}
			},
			"DeleteBucketWebsite": {
				"http": {
					"method": "DELETE",
					"requestUri": "/{Bucket}?website"
				},
				"input": {
					"type": "structure",
					"required": [
						"Bucket"
					],
					"members": {
						"Bucket": {
							"location": "uri",
							"locationName": "Bucket"
						}
					}
				}
			},
			"DeleteObject": {
				"http": {
					"method": "DELETE",
					"requestUri": "/{Bucket}/{Key+}"
				},
				"input": {
					"type": "structure",
					"required": [
						"Bucket",
						"Key"
					],
					"members": {
						"Bucket": {
							"location": "uri",
							"locationName": "Bucket"
						},
						"Key": {
							"location": "uri",
							"locationName": "Key"
						},
						"MFA": {
							"location": "header",
							"locationName": "x-amz-mfa"
						},
						"VersionId": {
							"location": "querystring",
							"locationName": "versionId"
						},
						"RequestPayer": {
							"location": "header",
							"locationName": "x-amz-request-payer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"DeleteMarker": {
							"location": "header",
							"locationName": "x-amz-delete-marker",
							"type": "boolean"
						},
						"VersionId": {
							"location": "header",
							"locationName": "x-amz-version-id"
						},
						"RequestCharged": {
							"location": "header",
							"locationName": "x-amz-request-charged"
						}
					}
				}
			},
			"DeleteObjects": {
				"http": {
					"requestUri": "/{Bucket}?delete"
				},
				"input": {
					"type": "structure",
					"required": [
						"Bucket",
						"Delete"
					],
					"members": {
						"Bucket": {
							"location": "uri",
							"locationName": "Bucket"
						},
						"Delete": {
							"locationName": "Delete",
							"xmlNamespace": {
								"uri": "http://s3.amazonaws.com/doc/2006-03-01/"
							},
							"type": "structure",
							"required": [
								"Objects"
							],
							"members": {
								"Objects": {
									"locationName": "Object",
									"type": "list",
									"member": {
										"type": "structure",
										"required": [
											"Key"
										],
										"members": {
											"Key": {},
											"VersionId": {}
										}
									},
									"flattened": true
								},
								"Quiet": {
									"type": "boolean"
								}
							}
						},
						"MFA": {
							"location": "header",
							"locationName": "x-amz-mfa"
						},
						"RequestPayer": {
							"location": "header",
							"locationName": "x-amz-request-payer"
						}
					},
					"payload": "Delete"
				},
				"output": {
					"type": "structure",
					"members": {
						"Deleted": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"Key": {},
									"VersionId": {},
									"DeleteMarker": {
										"type": "boolean"
									},
									"DeleteMarkerVersionId": {}
								}
							},
							"flattened": true
						},
						"RequestCharged": {
							"location": "header",
							"locationName": "x-amz-request-charged"
						},
						"Errors": {
							"locationName": "Error",
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"Key": {},
									"VersionId": {},
									"Code": {},
									"Message": {}
								}
							},
							"flattened": true
						}
					}
				},
				"alias": "DeleteMultipleObjects"
			},
			"GetBucketAccelerateConfiguration": {
				"http": {
					"method": "GET",
					"requestUri": "/{Bucket}?accelerate"
				},
				"input": {
					"type": "structure",
					"required": [
						"Bucket"
					],
					"members": {
						"Bucket": {
							"location": "uri",
							"locationName": "Bucket"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Status": {}
					}
				}
			},
			"GetBucketAcl": {
				"http": {
					"method": "GET",
					"requestUri": "/{Bucket}?acl"
				},
				"input": {
					"type": "structure",
					"required": [
						"Bucket"
					],
					"members": {
						"Bucket": {
							"location": "uri",
							"locationName": "Bucket"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Owner": {
							"shape": "S2k"
						},
						"Grants": {
							"shape": "S2n",
							"locationName": "AccessControlList"
						}
					}
				}
			},
			"GetBucketCors": {
				"http": {
					"method": "GET",
					"requestUri": "/{Bucket}?cors"
				},
				"input": {
					"type": "structure",
					"required": [
						"Bucket"
					],
					"members": {
						"Bucket": {
							"location": "uri",
							"locationName": "Bucket"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"CORSRules": {
							"shape": "S2w",
							"locationName": "CORSRule"
						}
					}
				}
			},
			"GetBucketLifecycle": {
				"http": {
					"method": "GET",
					"requestUri": "/{Bucket}?lifecycle"
				},
				"input": {
					"type": "structure",
					"required": [
						"Bucket"
					],
					"members": {
						"Bucket": {
							"location": "uri",
							"locationName": "Bucket"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Rules": {
							"shape": "S39",
							"locationName": "Rule"
						}
					}
				},
				"deprecated": true
			},
			"GetBucketLifecycleConfiguration": {
				"http": {
					"method": "GET",
					"requestUri": "/{Bucket}?lifecycle"
				},
				"input": {
					"type": "structure",
					"required": [
						"Bucket"
					],
					"members": {
						"Bucket": {
							"location": "uri",
							"locationName": "Bucket"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Rules": {
							"shape": "S3p",
							"locationName": "Rule"
						}
					}
				}
			},
			"GetBucketLocation": {
				"http": {
					"method": "GET",
					"requestUri": "/{Bucket}?location"
				},
				"input": {
					"type": "structure",
					"required": [
						"Bucket"
					],
					"members": {
						"Bucket": {
							"location": "uri",
							"locationName": "Bucket"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"LocationConstraint": {}
					}
				}
			},
			"GetBucketLogging": {
				"http": {
					"method": "GET",
					"requestUri": "/{Bucket}?logging"
				},
				"input": {
					"type": "structure",
					"required": [
						"Bucket"
					],
					"members": {
						"Bucket": {
							"location": "uri",
							"locationName": "Bucket"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"LoggingEnabled": {
							"shape": "S3x"
						}
					}
				}
			},
			"GetBucketNotification": {
				"http": {
					"method": "GET",
					"requestUri": "/{Bucket}?notification"
				},
				"input": {
					"shape": "S43"
				},
				"output": {
					"shape": "S44"
				},
				"deprecated": true
			},
			"GetBucketNotificationConfiguration": {
				"http": {
					"method": "GET",
					"requestUri": "/{Bucket}?notification"
				},
				"input": {
					"shape": "S43"
				},
				"output": {
					"shape": "S4f"
				}
			},
			"GetBucketPolicy": {
				"http": {
					"method": "GET",
					"requestUri": "/{Bucket}?policy"
				},
				"input": {
					"type": "structure",
					"required": [
						"Bucket"
					],
					"members": {
						"Bucket": {
							"location": "uri",
							"locationName": "Bucket"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Policy": {}
					},
					"payload": "Policy"
				}
			},
			"GetBucketReplication": {
				"http": {
					"method": "GET",
					"requestUri": "/{Bucket}?replication"
				},
				"input": {
					"type": "structure",
					"required": [
						"Bucket"
					],
					"members": {
						"Bucket": {
							"location": "uri",
							"locationName": "Bucket"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ReplicationConfiguration": {
							"shape": "S4y"
						}
					},
					"payload": "ReplicationConfiguration"
				}
			},
			"GetBucketRequestPayment": {
				"http": {
					"method": "GET",
					"requestUri": "/{Bucket}?requestPayment"
				},
				"input": {
					"type": "structure",
					"required": [
						"Bucket"
					],
					"members": {
						"Bucket": {
							"location": "uri",
							"locationName": "Bucket"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Payer": {}
					}
				}
			},
			"GetBucketTagging": {
				"http": {
					"method": "GET",
					"requestUri": "/{Bucket}?tagging"
				},
				"input": {
					"type": "structure",
					"required": [
						"Bucket"
					],
					"members": {
						"Bucket": {
							"location": "uri",
							"locationName": "Bucket"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"TagSet"
					],
					"members": {
						"TagSet": {
							"shape": "S59"
						}
					}
				}
			},
			"GetBucketVersioning": {
				"http": {
					"method": "GET",
					"requestUri": "/{Bucket}?versioning"
				},
				"input": {
					"type": "structure",
					"required": [
						"Bucket"
					],
					"members": {
						"Bucket": {
							"location": "uri",
							"locationName": "Bucket"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Status": {},
						"MFADelete": {
							"locationName": "MfaDelete"
						}
					}
				}
			},
			"GetBucketWebsite": {
				"http": {
					"method": "GET",
					"requestUri": "/{Bucket}?website"
				},
				"input": {
					"type": "structure",
					"required": [
						"Bucket"
					],
					"members": {
						"Bucket": {
							"location": "uri",
							"locationName": "Bucket"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"RedirectAllRequestsTo": {
							"shape": "S5i"
						},
						"IndexDocument": {
							"shape": "S5l"
						},
						"ErrorDocument": {
							"shape": "S5n"
						},
						"RoutingRules": {
							"shape": "S5o"
						}
					}
				}
			},
			"GetObject": {
				"http": {
					"method": "GET",
					"requestUri": "/{Bucket}/{Key+}"
				},
				"input": {
					"type": "structure",
					"required": [
						"Bucket",
						"Key"
					],
					"members": {
						"Bucket": {
							"location": "uri",
							"locationName": "Bucket"
						},
						"IfMatch": {
							"location": "header",
							"locationName": "If-Match"
						},
						"IfModifiedSince": {
							"location": "header",
							"locationName": "If-Modified-Since",
							"type": "timestamp"
						},
						"IfNoneMatch": {
							"location": "header",
							"locationName": "If-None-Match"
						},
						"IfUnmodifiedSince": {
							"location": "header",
							"locationName": "If-Unmodified-Since",
							"type": "timestamp"
						},
						"Key": {
							"location": "uri",
							"locationName": "Key"
						},
						"Range": {
							"location": "header",
							"locationName": "Range"
						},
						"ResponseCacheControl": {
							"location": "querystring",
							"locationName": "response-cache-control"
						},
						"ResponseContentDisposition": {
							"location": "querystring",
							"locationName": "response-content-disposition"
						},
						"ResponseContentEncoding": {
							"location": "querystring",
							"locationName": "response-content-encoding"
						},
						"ResponseContentLanguage": {
							"location": "querystring",
							"locationName": "response-content-language"
						},
						"ResponseContentType": {
							"location": "querystring",
							"locationName": "response-content-type"
						},
						"ResponseExpires": {
							"location": "querystring",
							"locationName": "response-expires",
							"type": "timestamp"
						},
						"VersionId": {
							"location": "querystring",
							"locationName": "versionId"
						},
						"SSECustomerAlgorithm": {
							"location": "header",
							"locationName": "x-amz-server-side-encryption-customer-algorithm"
						},
						"SSECustomerKey": {
							"shape": "S18",
							"location": "header",
							"locationName": "x-amz-server-side-encryption-customer-key"
						},
						"SSECustomerKeyMD5": {
							"location": "header",
							"locationName": "x-amz-server-side-encryption-customer-key-MD5"
						},
						"RequestPayer": {
							"location": "header",
							"locationName": "x-amz-request-payer"
						},
						"PartNumber": {
							"location": "querystring",
							"locationName": "partNumber",
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Body": {
							"streaming": true,
							"type": "blob"
						},
						"DeleteMarker": {
							"location": "header",
							"locationName": "x-amz-delete-marker",
							"type": "boolean"
						},
						"AcceptRanges": {
							"location": "header",
							"locationName": "accept-ranges"
						},
						"Expiration": {
							"location": "header",
							"locationName": "x-amz-expiration"
						},
						"Restore": {
							"location": "header",
							"locationName": "x-amz-restore"
						},
						"LastModified": {
							"location": "header",
							"locationName": "Last-Modified",
							"type": "timestamp"
						},
						"ContentLength": {
							"location": "header",
							"locationName": "Content-Length",
							"type": "long"
						},
						"ETag": {
							"location": "header",
							"locationName": "ETag"
						},
						"MissingMeta": {
							"location": "header",
							"locationName": "x-amz-missing-meta",
							"type": "integer"
						},
						"VersionId": {
							"location": "header",
							"locationName": "x-amz-version-id"
						},
						"CacheControl": {
							"location": "header",
							"locationName": "Cache-Control"
						},
						"ContentDisposition": {
							"location": "header",
							"locationName": "Content-Disposition"
						},
						"ContentEncoding": {
							"location": "header",
							"locationName": "Content-Encoding"
						},
						"ContentLanguage": {
							"location": "header",
							"locationName": "Content-Language"
						},
						"ContentRange": {
							"location": "header",
							"locationName": "Content-Range"
						},
						"ContentType": {
							"location": "header",
							"locationName": "Content-Type"
						},
						"Expires": {
							"location": "header",
							"locationName": "Expires",
							"type": "timestamp"
						},
						"WebsiteRedirectLocation": {
							"location": "header",
							"locationName": "x-amz-website-redirect-location"
						},
						"ServerSideEncryption": {
							"location": "header",
							"locationName": "x-amz-server-side-encryption"
						},
						"Metadata": {
							"shape": "S11",
							"location": "headers",
							"locationName": "x-amz-meta-"
						},
						"SSECustomerAlgorithm": {
							"location": "header",
							"locationName": "x-amz-server-side-encryption-customer-algorithm"
						},
						"SSECustomerKeyMD5": {
							"location": "header",
							"locationName": "x-amz-server-side-encryption-customer-key-MD5"
						},
						"SSEKMSKeyId": {
							"shape": "Sj",
							"location": "header",
							"locationName": "x-amz-server-side-encryption-aws-kms-key-id"
						},
						"StorageClass": {
							"location": "header",
							"locationName": "x-amz-storage-class"
						},
						"RequestCharged": {
							"location": "header",
							"locationName": "x-amz-request-charged"
						},
						"ReplicationStatus": {
							"location": "header",
							"locationName": "x-amz-replication-status"
						},
						"PartsCount": {
							"location": "header",
							"locationName": "x-amz-mp-parts-count",
							"type": "integer"
						}
					},
					"payload": "Body"
				}
			},
			"GetObjectAcl": {
				"http": {
					"method": "GET",
					"requestUri": "/{Bucket}/{Key+}?acl"
				},
				"input": {
					"type": "structure",
					"required": [
						"Bucket",
						"Key"
					],
					"members": {
						"Bucket": {
							"location": "uri",
							"locationName": "Bucket"
						},
						"Key": {
							"location": "uri",
							"locationName": "Key"
						},
						"VersionId": {
							"location": "querystring",
							"locationName": "versionId"
						},
						"RequestPayer": {
							"location": "header",
							"locationName": "x-amz-request-payer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Owner": {
							"shape": "S2k"
						},
						"Grants": {
							"shape": "S2n",
							"locationName": "AccessControlList"
						},
						"RequestCharged": {
							"location": "header",
							"locationName": "x-amz-request-charged"
						}
					}
				}
			},
			"GetObjectTorrent": {
				"http": {
					"method": "GET",
					"requestUri": "/{Bucket}/{Key+}?torrent"
				},
				"input": {
					"type": "structure",
					"required": [
						"Bucket",
						"Key"
					],
					"members": {
						"Bucket": {
							"location": "uri",
							"locationName": "Bucket"
						},
						"Key": {
							"location": "uri",
							"locationName": "Key"
						},
						"RequestPayer": {
							"location": "header",
							"locationName": "x-amz-request-payer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Body": {
							"streaming": true,
							"type": "blob"
						},
						"RequestCharged": {
							"location": "header",
							"locationName": "x-amz-request-charged"
						}
					},
					"payload": "Body"
				}
			},
			"HeadBucket": {
				"http": {
					"method": "HEAD",
					"requestUri": "/{Bucket}"
				},
				"input": {
					"type": "structure",
					"required": [
						"Bucket"
					],
					"members": {
						"Bucket": {
							"location": "uri",
							"locationName": "Bucket"
						}
					}
				}
			},
			"HeadObject": {
				"http": {
					"method": "HEAD",
					"requestUri": "/{Bucket}/{Key+}"
				},
				"input": {
					"type": "structure",
					"required": [
						"Bucket",
						"Key"
					],
					"members": {
						"Bucket": {
							"location": "uri",
							"locationName": "Bucket"
						},
						"IfMatch": {
							"location": "header",
							"locationName": "If-Match"
						},
						"IfModifiedSince": {
							"location": "header",
							"locationName": "If-Modified-Since",
							"type": "timestamp"
						},
						"IfNoneMatch": {
							"location": "header",
							"locationName": "If-None-Match"
						},
						"IfUnmodifiedSince": {
							"location": "header",
							"locationName": "If-Unmodified-Since",
							"type": "timestamp"
						},
						"Key": {
							"location": "uri",
							"locationName": "Key"
						},
						"Range": {
							"location": "header",
							"locationName": "Range"
						},
						"VersionId": {
							"location": "querystring",
							"locationName": "versionId"
						},
						"SSECustomerAlgorithm": {
							"location": "header",
							"locationName": "x-amz-server-side-encryption-customer-algorithm"
						},
						"SSECustomerKey": {
							"shape": "S18",
							"location": "header",
							"locationName": "x-amz-server-side-encryption-customer-key"
						},
						"SSECustomerKeyMD5": {
							"location": "header",
							"locationName": "x-amz-server-side-encryption-customer-key-MD5"
						},
						"RequestPayer": {
							"location": "header",
							"locationName": "x-amz-request-payer"
						},
						"PartNumber": {
							"location": "querystring",
							"locationName": "partNumber",
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"DeleteMarker": {
							"location": "header",
							"locationName": "x-amz-delete-marker",
							"type": "boolean"
						},
						"AcceptRanges": {
							"location": "header",
							"locationName": "accept-ranges"
						},
						"Expiration": {
							"location": "header",
							"locationName": "x-amz-expiration"
						},
						"Restore": {
							"location": "header",
							"locationName": "x-amz-restore"
						},
						"LastModified": {
							"location": "header",
							"locationName": "Last-Modified",
							"type": "timestamp"
						},
						"ContentLength": {
							"location": "header",
							"locationName": "Content-Length",
							"type": "long"
						},
						"ETag": {
							"location": "header",
							"locationName": "ETag"
						},
						"MissingMeta": {
							"location": "header",
							"locationName": "x-amz-missing-meta",
							"type": "integer"
						},
						"VersionId": {
							"location": "header",
							"locationName": "x-amz-version-id"
						},
						"CacheControl": {
							"location": "header",
							"locationName": "Cache-Control"
						},
						"ContentDisposition": {
							"location": "header",
							"locationName": "Content-Disposition"
						},
						"ContentEncoding": {
							"location": "header",
							"locationName": "Content-Encoding"
						},
						"ContentLanguage": {
							"location": "header",
							"locationName": "Content-Language"
						},
						"ContentType": {
							"location": "header",
							"locationName": "Content-Type"
						},
						"Expires": {
							"location": "header",
							"locationName": "Expires",
							"type": "timestamp"
						},
						"WebsiteRedirectLocation": {
							"location": "header",
							"locationName": "x-amz-website-redirect-location"
						},
						"ServerSideEncryption": {
							"location": "header",
							"locationName": "x-amz-server-side-encryption"
						},
						"Metadata": {
							"shape": "S11",
							"location": "headers",
							"locationName": "x-amz-meta-"
						},
						"SSECustomerAlgorithm": {
							"location": "header",
							"locationName": "x-amz-server-side-encryption-customer-algorithm"
						},
						"SSECustomerKeyMD5": {
							"location": "header",
							"locationName": "x-amz-server-side-encryption-customer-key-MD5"
						},
						"SSEKMSKeyId": {
							"shape": "Sj",
							"location": "header",
							"locationName": "x-amz-server-side-encryption-aws-kms-key-id"
						},
						"StorageClass": {
							"location": "header",
							"locationName": "x-amz-storage-class"
						},
						"RequestCharged": {
							"location": "header",
							"locationName": "x-amz-request-charged"
						},
						"ReplicationStatus": {
							"location": "header",
							"locationName": "x-amz-replication-status"
						},
						"PartsCount": {
							"location": "header",
							"locationName": "x-amz-mp-parts-count",
							"type": "integer"
						}
					}
				}
			},
			"ListBuckets": {
				"http": {
					"method": "GET"
				},
				"output": {
					"type": "structure",
					"members": {
						"Buckets": {
							"type": "list",
							"member": {
								"locationName": "Bucket",
								"type": "structure",
								"members": {
									"Name": {},
									"CreationDate": {
										"type": "timestamp"
									}
								}
							}
						},
						"Owner": {
							"shape": "S2k"
						}
					}
				},
				"alias": "GetService"
			},
			"ListMultipartUploads": {
				"http": {
					"method": "GET",
					"requestUri": "/{Bucket}?uploads"
				},
				"input": {
					"type": "structure",
					"required": [
						"Bucket"
					],
					"members": {
						"Bucket": {
							"location": "uri",
							"locationName": "Bucket"
						},
						"Delimiter": {
							"location": "querystring",
							"locationName": "delimiter"
						},
						"EncodingType": {
							"location": "querystring",
							"locationName": "encoding-type"
						},
						"KeyMarker": {
							"location": "querystring",
							"locationName": "key-marker"
						},
						"MaxUploads": {
							"location": "querystring",
							"locationName": "max-uploads",
							"type": "integer"
						},
						"Prefix": {
							"location": "querystring",
							"locationName": "prefix"
						},
						"UploadIdMarker": {
							"location": "querystring",
							"locationName": "upload-id-marker"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Bucket": {},
						"KeyMarker": {},
						"UploadIdMarker": {},
						"NextKeyMarker": {},
						"Prefix": {},
						"Delimiter": {},
						"NextUploadIdMarker": {},
						"MaxUploads": {
							"type": "integer"
						},
						"IsTruncated": {
							"type": "boolean"
						},
						"Uploads": {
							"locationName": "Upload",
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"UploadId": {},
									"Key": {},
									"Initiated": {
										"type": "timestamp"
									},
									"StorageClass": {},
									"Owner": {
										"shape": "S2k"
									},
									"Initiator": {
										"shape": "S76"
									}
								}
							},
							"flattened": true
						},
						"CommonPrefixes": {
							"shape": "S77"
						},
						"EncodingType": {}
					}
				}
			},
			"ListObjectVersions": {
				"http": {
					"method": "GET",
					"requestUri": "/{Bucket}?versions"
				},
				"input": {
					"type": "structure",
					"required": [
						"Bucket"
					],
					"members": {
						"Bucket": {
							"location": "uri",
							"locationName": "Bucket"
						},
						"Delimiter": {
							"location": "querystring",
							"locationName": "delimiter"
						},
						"EncodingType": {
							"location": "querystring",
							"locationName": "encoding-type"
						},
						"KeyMarker": {
							"location": "querystring",
							"locationName": "key-marker"
						},
						"MaxKeys": {
							"location": "querystring",
							"locationName": "max-keys",
							"type": "integer"
						},
						"Prefix": {
							"location": "querystring",
							"locationName": "prefix"
						},
						"VersionIdMarker": {
							"location": "querystring",
							"locationName": "version-id-marker"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"IsTruncated": {
							"type": "boolean"
						},
						"KeyMarker": {},
						"VersionIdMarker": {},
						"NextKeyMarker": {},
						"NextVersionIdMarker": {},
						"Versions": {
							"locationName": "Version",
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"ETag": {},
									"Size": {
										"type": "integer"
									},
									"StorageClass": {},
									"Key": {},
									"VersionId": {},
									"IsLatest": {
										"type": "boolean"
									},
									"LastModified": {
										"type": "timestamp"
									},
									"Owner": {
										"shape": "S2k"
									}
								}
							},
							"flattened": true
						},
						"DeleteMarkers": {
							"locationName": "DeleteMarker",
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"Owner": {
										"shape": "S2k"
									},
									"Key": {},
									"VersionId": {},
									"IsLatest": {
										"type": "boolean"
									},
									"LastModified": {
										"type": "timestamp"
									}
								}
							},
							"flattened": true
						},
						"Name": {},
						"Prefix": {},
						"Delimiter": {},
						"MaxKeys": {
							"type": "integer"
						},
						"CommonPrefixes": {
							"shape": "S77"
						},
						"EncodingType": {}
					}
				},
				"alias": "GetBucketObjectVersions"
			},
			"ListObjects": {
				"http": {
					"method": "GET",
					"requestUri": "/{Bucket}"
				},
				"input": {
					"type": "structure",
					"required": [
						"Bucket"
					],
					"members": {
						"Bucket": {
							"location": "uri",
							"locationName": "Bucket"
						},
						"Delimiter": {
							"location": "querystring",
							"locationName": "delimiter"
						},
						"EncodingType": {
							"location": "querystring",
							"locationName": "encoding-type"
						},
						"Marker": {
							"location": "querystring",
							"locationName": "marker"
						},
						"MaxKeys": {
							"location": "querystring",
							"locationName": "max-keys",
							"type": "integer"
						},
						"Prefix": {
							"location": "querystring",
							"locationName": "prefix"
						},
						"RequestPayer": {
							"location": "header",
							"locationName": "x-amz-request-payer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"IsTruncated": {
							"type": "boolean"
						},
						"Marker": {},
						"NextMarker": {},
						"Contents": {
							"shape": "S7p"
						},
						"Name": {},
						"Prefix": {},
						"Delimiter": {},
						"MaxKeys": {
							"type": "integer"
						},
						"CommonPrefixes": {
							"shape": "S77"
						},
						"EncodingType": {}
					}
				},
				"alias": "GetBucket"
			},
			"ListObjectsV2": {
				"http": {
					"method": "GET",
					"requestUri": "/{Bucket}?list-type=2"
				},
				"input": {
					"type": "structure",
					"required": [
						"Bucket"
					],
					"members": {
						"Bucket": {
							"location": "uri",
							"locationName": "Bucket"
						},
						"Delimiter": {
							"location": "querystring",
							"locationName": "delimiter"
						},
						"EncodingType": {
							"location": "querystring",
							"locationName": "encoding-type"
						},
						"MaxKeys": {
							"location": "querystring",
							"locationName": "max-keys",
							"type": "integer"
						},
						"Prefix": {
							"location": "querystring",
							"locationName": "prefix"
						},
						"ContinuationToken": {
							"location": "querystring",
							"locationName": "continuation-token"
						},
						"FetchOwner": {
							"location": "querystring",
							"locationName": "fetch-owner",
							"type": "boolean"
						},
						"StartAfter": {
							"location": "querystring",
							"locationName": "start-after"
						},
						"RequestPayer": {
							"location": "header",
							"locationName": "x-amz-request-payer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"IsTruncated": {
							"type": "boolean"
						},
						"Contents": {
							"shape": "S7p"
						},
						"Name": {},
						"Prefix": {},
						"Delimiter": {},
						"MaxKeys": {
							"type": "integer"
						},
						"CommonPrefixes": {
							"shape": "S77"
						},
						"EncodingType": {},
						"KeyCount": {
							"type": "integer"
						},
						"ContinuationToken": {},
						"NextContinuationToken": {},
						"StartAfter": {}
					}
				}
			},
			"ListParts": {
				"http": {
					"method": "GET",
					"requestUri": "/{Bucket}/{Key+}"
				},
				"input": {
					"type": "structure",
					"required": [
						"Bucket",
						"Key",
						"UploadId"
					],
					"members": {
						"Bucket": {
							"location": "uri",
							"locationName": "Bucket"
						},
						"Key": {
							"location": "uri",
							"locationName": "Key"
						},
						"MaxParts": {
							"location": "querystring",
							"locationName": "max-parts",
							"type": "integer"
						},
						"PartNumberMarker": {
							"location": "querystring",
							"locationName": "part-number-marker",
							"type": "integer"
						},
						"UploadId": {
							"location": "querystring",
							"locationName": "uploadId"
						},
						"RequestPayer": {
							"location": "header",
							"locationName": "x-amz-request-payer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"AbortDate": {
							"location": "header",
							"locationName": "x-amz-abort-date",
							"type": "timestamp"
						},
						"AbortRuleId": {
							"location": "header",
							"locationName": "x-amz-abort-rule-id"
						},
						"Bucket": {},
						"Key": {},
						"UploadId": {},
						"PartNumberMarker": {
							"type": "integer"
						},
						"NextPartNumberMarker": {
							"type": "integer"
						},
						"MaxParts": {
							"type": "integer"
						},
						"IsTruncated": {
							"type": "boolean"
						},
						"Parts": {
							"locationName": "Part",
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"PartNumber": {
										"type": "integer"
									},
									"LastModified": {
										"type": "timestamp"
									},
									"ETag": {},
									"Size": {
										"type": "integer"
									}
								}
							},
							"flattened": true
						},
						"Initiator": {
							"shape": "S76"
						},
						"Owner": {
							"shape": "S2k"
						},
						"StorageClass": {},
						"RequestCharged": {
							"location": "header",
							"locationName": "x-amz-request-charged"
						}
					}
				}
			},
			"PutBucketAccelerateConfiguration": {
				"http": {
					"method": "PUT",
					"requestUri": "/{Bucket}?accelerate"
				},
				"input": {
					"type": "structure",
					"required": [
						"Bucket",
						"AccelerateConfiguration"
					],
					"members": {
						"Bucket": {
							"location": "uri",
							"locationName": "Bucket"
						},
						"AccelerateConfiguration": {
							"locationName": "AccelerateConfiguration",
							"xmlNamespace": {
								"uri": "http://s3.amazonaws.com/doc/2006-03-01/"
							},
							"type": "structure",
							"members": {
								"Status": {}
							}
						}
					},
					"payload": "AccelerateConfiguration"
				}
			},
			"PutBucketAcl": {
				"http": {
					"method": "PUT",
					"requestUri": "/{Bucket}?acl"
				},
				"input": {
					"type": "structure",
					"required": [
						"Bucket"
					],
					"members": {
						"ACL": {
							"location": "header",
							"locationName": "x-amz-acl"
						},
						"AccessControlPolicy": {
							"shape": "S89",
							"locationName": "AccessControlPolicy",
							"xmlNamespace": {
								"uri": "http://s3.amazonaws.com/doc/2006-03-01/"
							}
						},
						"Bucket": {
							"location": "uri",
							"locationName": "Bucket"
						},
						"ContentMD5": {
							"location": "header",
							"locationName": "Content-MD5"
						},
						"GrantFullControl": {
							"location": "header",
							"locationName": "x-amz-grant-full-control"
						},
						"GrantRead": {
							"location": "header",
							"locationName": "x-amz-grant-read"
						},
						"GrantReadACP": {
							"location": "header",
							"locationName": "x-amz-grant-read-acp"
						},
						"GrantWrite": {
							"location": "header",
							"locationName": "x-amz-grant-write"
						},
						"GrantWriteACP": {
							"location": "header",
							"locationName": "x-amz-grant-write-acp"
						}
					},
					"payload": "AccessControlPolicy"
				}
			},
			"PutBucketCors": {
				"http": {
					"method": "PUT",
					"requestUri": "/{Bucket}?cors"
				},
				"input": {
					"type": "structure",
					"required": [
						"Bucket",
						"CORSConfiguration"
					],
					"members": {
						"Bucket": {
							"location": "uri",
							"locationName": "Bucket"
						},
						"CORSConfiguration": {
							"locationName": "CORSConfiguration",
							"xmlNamespace": {
								"uri": "http://s3.amazonaws.com/doc/2006-03-01/"
							},
							"type": "structure",
							"required": [
								"CORSRules"
							],
							"members": {
								"CORSRules": {
									"shape": "S2w",
									"locationName": "CORSRule"
								}
							}
						},
						"ContentMD5": {
							"location": "header",
							"locationName": "Content-MD5"
						}
					},
					"payload": "CORSConfiguration"
				}
			},
			"PutBucketLifecycle": {
				"http": {
					"method": "PUT",
					"requestUri": "/{Bucket}?lifecycle"
				},
				"input": {
					"type": "structure",
					"required": [
						"Bucket"
					],
					"members": {
						"Bucket": {
							"location": "uri",
							"locationName": "Bucket"
						},
						"ContentMD5": {
							"location": "header",
							"locationName": "Content-MD5"
						},
						"LifecycleConfiguration": {
							"locationName": "LifecycleConfiguration",
							"xmlNamespace": {
								"uri": "http://s3.amazonaws.com/doc/2006-03-01/"
							},
							"type": "structure",
							"required": [
								"Rules"
							],
							"members": {
								"Rules": {
									"shape": "S39",
									"locationName": "Rule"
								}
							}
						}
					},
					"payload": "LifecycleConfiguration"
				},
				"deprecated": true
			},
			"PutBucketLifecycleConfiguration": {
				"http": {
					"method": "PUT",
					"requestUri": "/{Bucket}?lifecycle"
				},
				"input": {
					"type": "structure",
					"required": [
						"Bucket"
					],
					"members": {
						"Bucket": {
							"location": "uri",
							"locationName": "Bucket"
						},
						"LifecycleConfiguration": {
							"locationName": "LifecycleConfiguration",
							"xmlNamespace": {
								"uri": "http://s3.amazonaws.com/doc/2006-03-01/"
							},
							"type": "structure",
							"required": [
								"Rules"
							],
							"members": {
								"Rules": {
									"shape": "S3p",
									"locationName": "Rule"
								}
							}
						}
					},
					"payload": "LifecycleConfiguration"
				}
			},
			"PutBucketLogging": {
				"http": {
					"method": "PUT",
					"requestUri": "/{Bucket}?logging"
				},
				"input": {
					"type": "structure",
					"required": [
						"Bucket",
						"BucketLoggingStatus"
					],
					"members": {
						"Bucket": {
							"location": "uri",
							"locationName": "Bucket"
						},
						"BucketLoggingStatus": {
							"locationName": "BucketLoggingStatus",
							"xmlNamespace": {
								"uri": "http://s3.amazonaws.com/doc/2006-03-01/"
							},
							"type": "structure",
							"members": {
								"LoggingEnabled": {
									"shape": "S3x"
								}
							}
						},
						"ContentMD5": {
							"location": "header",
							"locationName": "Content-MD5"
						}
					},
					"payload": "BucketLoggingStatus"
				}
			},
			"PutBucketNotification": {
				"http": {
					"method": "PUT",
					"requestUri": "/{Bucket}?notification"
				},
				"input": {
					"type": "structure",
					"required": [
						"Bucket",
						"NotificationConfiguration"
					],
					"members": {
						"Bucket": {
							"location": "uri",
							"locationName": "Bucket"
						},
						"ContentMD5": {
							"location": "header",
							"locationName": "Content-MD5"
						},
						"NotificationConfiguration": {
							"shape": "S44",
							"locationName": "NotificationConfiguration",
							"xmlNamespace": {
								"uri": "http://s3.amazonaws.com/doc/2006-03-01/"
							}
						}
					},
					"payload": "NotificationConfiguration"
				},
				"deprecated": true
			},
			"PutBucketNotificationConfiguration": {
				"http": {
					"method": "PUT",
					"requestUri": "/{Bucket}?notification"
				},
				"input": {
					"type": "structure",
					"required": [
						"Bucket",
						"NotificationConfiguration"
					],
					"members": {
						"Bucket": {
							"location": "uri",
							"locationName": "Bucket"
						},
						"NotificationConfiguration": {
							"shape": "S4f",
							"locationName": "NotificationConfiguration",
							"xmlNamespace": {
								"uri": "http://s3.amazonaws.com/doc/2006-03-01/"
							}
						}
					},
					"payload": "NotificationConfiguration"
				}
			},
			"PutBucketPolicy": {
				"http": {
					"method": "PUT",
					"requestUri": "/{Bucket}?policy"
				},
				"input": {
					"type": "structure",
					"required": [
						"Bucket",
						"Policy"
					],
					"members": {
						"Bucket": {
							"location": "uri",
							"locationName": "Bucket"
						},
						"ContentMD5": {
							"location": "header",
							"locationName": "Content-MD5"
						},
						"Policy": {}
					},
					"payload": "Policy"
				}
			},
			"PutBucketReplication": {
				"http": {
					"method": "PUT",
					"requestUri": "/{Bucket}?replication"
				},
				"input": {
					"type": "structure",
					"required": [
						"Bucket",
						"ReplicationConfiguration"
					],
					"members": {
						"Bucket": {
							"location": "uri",
							"locationName": "Bucket"
						},
						"ContentMD5": {
							"location": "header",
							"locationName": "Content-MD5"
						},
						"ReplicationConfiguration": {
							"shape": "S4y",
							"locationName": "ReplicationConfiguration",
							"xmlNamespace": {
								"uri": "http://s3.amazonaws.com/doc/2006-03-01/"
							}
						}
					},
					"payload": "ReplicationConfiguration"
				}
			},
			"PutBucketRequestPayment": {
				"http": {
					"method": "PUT",
					"requestUri": "/{Bucket}?requestPayment"
				},
				"input": {
					"type": "structure",
					"required": [
						"Bucket",
						"RequestPaymentConfiguration"
					],
					"members": {
						"Bucket": {
							"location": "uri",
							"locationName": "Bucket"
						},
						"ContentMD5": {
							"location": "header",
							"locationName": "Content-MD5"
						},
						"RequestPaymentConfiguration": {
							"locationName": "RequestPaymentConfiguration",
							"xmlNamespace": {
								"uri": "http://s3.amazonaws.com/doc/2006-03-01/"
							},
							"type": "structure",
							"required": [
								"Payer"
							],
							"members": {
								"Payer": {}
							}
						}
					},
					"payload": "RequestPaymentConfiguration"
				}
			},
			"PutBucketTagging": {
				"http": {
					"method": "PUT",
					"requestUri": "/{Bucket}?tagging"
				},
				"input": {
					"type": "structure",
					"required": [
						"Bucket",
						"Tagging"
					],
					"members": {
						"Bucket": {
							"location": "uri",
							"locationName": "Bucket"
						},
						"ContentMD5": {
							"location": "header",
							"locationName": "Content-MD5"
						},
						"Tagging": {
							"locationName": "Tagging",
							"xmlNamespace": {
								"uri": "http://s3.amazonaws.com/doc/2006-03-01/"
							},
							"type": "structure",
							"required": [
								"TagSet"
							],
							"members": {
								"TagSet": {
									"shape": "S59"
								}
							}
						}
					},
					"payload": "Tagging"
				}
			},
			"PutBucketVersioning": {
				"http": {
					"method": "PUT",
					"requestUri": "/{Bucket}?versioning"
				},
				"input": {
					"type": "structure",
					"required": [
						"Bucket",
						"VersioningConfiguration"
					],
					"members": {
						"Bucket": {
							"location": "uri",
							"locationName": "Bucket"
						},
						"ContentMD5": {
							"location": "header",
							"locationName": "Content-MD5"
						},
						"MFA": {
							"location": "header",
							"locationName": "x-amz-mfa"
						},
						"VersioningConfiguration": {
							"locationName": "VersioningConfiguration",
							"xmlNamespace": {
								"uri": "http://s3.amazonaws.com/doc/2006-03-01/"
							},
							"type": "structure",
							"members": {
								"MFADelete": {
									"locationName": "MfaDelete"
								},
								"Status": {}
							}
						}
					},
					"payload": "VersioningConfiguration"
				}
			},
			"PutBucketWebsite": {
				"http": {
					"method": "PUT",
					"requestUri": "/{Bucket}?website"
				},
				"input": {
					"type": "structure",
					"required": [
						"Bucket",
						"WebsiteConfiguration"
					],
					"members": {
						"Bucket": {
							"location": "uri",
							"locationName": "Bucket"
						},
						"ContentMD5": {
							"location": "header",
							"locationName": "Content-MD5"
						},
						"WebsiteConfiguration": {
							"locationName": "WebsiteConfiguration",
							"xmlNamespace": {
								"uri": "http://s3.amazonaws.com/doc/2006-03-01/"
							},
							"type": "structure",
							"members": {
								"ErrorDocument": {
									"shape": "S5n"
								},
								"IndexDocument": {
									"shape": "S5l"
								},
								"RedirectAllRequestsTo": {
									"shape": "S5i"
								},
								"RoutingRules": {
									"shape": "S5o"
								}
							}
						}
					},
					"payload": "WebsiteConfiguration"
				}
			},
			"PutObject": {
				"http": {
					"method": "PUT",
					"requestUri": "/{Bucket}/{Key+}"
				},
				"input": {
					"type": "structure",
					"required": [
						"Bucket",
						"Key"
					],
					"members": {
						"ACL": {
							"location": "header",
							"locationName": "x-amz-acl"
						},
						"Body": {
							"streaming": true,
							"type": "blob"
						},
						"Bucket": {
							"location": "uri",
							"locationName": "Bucket"
						},
						"CacheControl": {
							"location": "header",
							"locationName": "Cache-Control"
						},
						"ContentDisposition": {
							"location": "header",
							"locationName": "Content-Disposition"
						},
						"ContentEncoding": {
							"location": "header",
							"locationName": "Content-Encoding"
						},
						"ContentLanguage": {
							"location": "header",
							"locationName": "Content-Language"
						},
						"ContentLength": {
							"location": "header",
							"locationName": "Content-Length",
							"type": "long"
						},
						"ContentMD5": {
							"location": "header",
							"locationName": "Content-MD5"
						},
						"ContentType": {
							"location": "header",
							"locationName": "Content-Type"
						},
						"Expires": {
							"location": "header",
							"locationName": "Expires",
							"type": "timestamp"
						},
						"GrantFullControl": {
							"location": "header",
							"locationName": "x-amz-grant-full-control"
						},
						"GrantRead": {
							"location": "header",
							"locationName": "x-amz-grant-read"
						},
						"GrantReadACP": {
							"location": "header",
							"locationName": "x-amz-grant-read-acp"
						},
						"GrantWriteACP": {
							"location": "header",
							"locationName": "x-amz-grant-write-acp"
						},
						"Key": {
							"location": "uri",
							"locationName": "Key"
						},
						"Metadata": {
							"shape": "S11",
							"location": "headers",
							"locationName": "x-amz-meta-"
						},
						"ServerSideEncryption": {
							"location": "header",
							"locationName": "x-amz-server-side-encryption"
						},
						"StorageClass": {
							"location": "header",
							"locationName": "x-amz-storage-class"
						},
						"WebsiteRedirectLocation": {
							"location": "header",
							"locationName": "x-amz-website-redirect-location"
						},
						"SSECustomerAlgorithm": {
							"location": "header",
							"locationName": "x-amz-server-side-encryption-customer-algorithm"
						},
						"SSECustomerKey": {
							"shape": "S18",
							"location": "header",
							"locationName": "x-amz-server-side-encryption-customer-key"
						},
						"SSECustomerKeyMD5": {
							"location": "header",
							"locationName": "x-amz-server-side-encryption-customer-key-MD5"
						},
						"SSEKMSKeyId": {
							"shape": "Sj",
							"location": "header",
							"locationName": "x-amz-server-side-encryption-aws-kms-key-id"
						},
						"RequestPayer": {
							"location": "header",
							"locationName": "x-amz-request-payer"
						}
					},
					"payload": "Body"
				},
				"output": {
					"type": "structure",
					"members": {
						"Expiration": {
							"location": "header",
							"locationName": "x-amz-expiration"
						},
						"ETag": {
							"location": "header",
							"locationName": "ETag"
						},
						"ServerSideEncryption": {
							"location": "header",
							"locationName": "x-amz-server-side-encryption"
						},
						"VersionId": {
							"location": "header",
							"locationName": "x-amz-version-id"
						},
						"SSECustomerAlgorithm": {
							"location": "header",
							"locationName": "x-amz-server-side-encryption-customer-algorithm"
						},
						"SSECustomerKeyMD5": {
							"location": "header",
							"locationName": "x-amz-server-side-encryption-customer-key-MD5"
						},
						"SSEKMSKeyId": {
							"shape": "Sj",
							"location": "header",
							"locationName": "x-amz-server-side-encryption-aws-kms-key-id"
						},
						"RequestCharged": {
							"location": "header",
							"locationName": "x-amz-request-charged"
						}
					}
				}
			},
			"PutObjectAcl": {
				"http": {
					"method": "PUT",
					"requestUri": "/{Bucket}/{Key+}?acl"
				},
				"input": {
					"type": "structure",
					"required": [
						"Bucket",
						"Key"
					],
					"members": {
						"ACL": {
							"location": "header",
							"locationName": "x-amz-acl"
						},
						"AccessControlPolicy": {
							"shape": "S89",
							"locationName": "AccessControlPolicy",
							"xmlNamespace": {
								"uri": "http://s3.amazonaws.com/doc/2006-03-01/"
							}
						},
						"Bucket": {
							"location": "uri",
							"locationName": "Bucket"
						},
						"ContentMD5": {
							"location": "header",
							"locationName": "Content-MD5"
						},
						"GrantFullControl": {
							"location": "header",
							"locationName": "x-amz-grant-full-control"
						},
						"GrantRead": {
							"location": "header",
							"locationName": "x-amz-grant-read"
						},
						"GrantReadACP": {
							"location": "header",
							"locationName": "x-amz-grant-read-acp"
						},
						"GrantWrite": {
							"location": "header",
							"locationName": "x-amz-grant-write"
						},
						"GrantWriteACP": {
							"location": "header",
							"locationName": "x-amz-grant-write-acp"
						},
						"Key": {
							"location": "uri",
							"locationName": "Key"
						},
						"RequestPayer": {
							"location": "header",
							"locationName": "x-amz-request-payer"
						},
						"VersionId": {
							"location": "querystring",
							"locationName": "versionId"
						}
					},
					"payload": "AccessControlPolicy"
				},
				"output": {
					"type": "structure",
					"members": {
						"RequestCharged": {
							"location": "header",
							"locationName": "x-amz-request-charged"
						}
					}
				}
			},
			"RestoreObject": {
				"http": {
					"requestUri": "/{Bucket}/{Key+}?restore"
				},
				"input": {
					"type": "structure",
					"required": [
						"Bucket",
						"Key"
					],
					"members": {
						"Bucket": {
							"location": "uri",
							"locationName": "Bucket"
						},
						"Key": {
							"location": "uri",
							"locationName": "Key"
						},
						"VersionId": {
							"location": "querystring",
							"locationName": "versionId"
						},
						"RestoreRequest": {
							"locationName": "RestoreRequest",
							"xmlNamespace": {
								"uri": "http://s3.amazonaws.com/doc/2006-03-01/"
							},
							"type": "structure",
							"required": [
								"Days"
							],
							"members": {
								"Days": {
									"type": "integer"
								}
							}
						},
						"RequestPayer": {
							"location": "header",
							"locationName": "x-amz-request-payer"
						}
					},
					"payload": "RestoreRequest"
				},
				"output": {
					"type": "structure",
					"members": {
						"RequestCharged": {
							"location": "header",
							"locationName": "x-amz-request-charged"
						}
					}
				},
				"alias": "PostObjectRestore"
			},
			"UploadPart": {
				"http": {
					"method": "PUT",
					"requestUri": "/{Bucket}/{Key+}"
				},
				"input": {
					"type": "structure",
					"required": [
						"Bucket",
						"Key",
						"PartNumber",
						"UploadId"
					],
					"members": {
						"Body": {
							"streaming": true,
							"type": "blob"
						},
						"Bucket": {
							"location": "uri",
							"locationName": "Bucket"
						},
						"ContentLength": {
							"location": "header",
							"locationName": "Content-Length",
							"type": "long"
						},
						"ContentMD5": {
							"location": "header",
							"locationName": "Content-MD5"
						},
						"Key": {
							"location": "uri",
							"locationName": "Key"
						},
						"PartNumber": {
							"location": "querystring",
							"locationName": "partNumber",
							"type": "integer"
						},
						"UploadId": {
							"location": "querystring",
							"locationName": "uploadId"
						},
						"SSECustomerAlgorithm": {
							"location": "header",
							"locationName": "x-amz-server-side-encryption-customer-algorithm"
						},
						"SSECustomerKey": {
							"shape": "S18",
							"location": "header",
							"locationName": "x-amz-server-side-encryption-customer-key"
						},
						"SSECustomerKeyMD5": {
							"location": "header",
							"locationName": "x-amz-server-side-encryption-customer-key-MD5"
						},
						"RequestPayer": {
							"location": "header",
							"locationName": "x-amz-request-payer"
						}
					},
					"payload": "Body"
				},
				"output": {
					"type": "structure",
					"members": {
						"ServerSideEncryption": {
							"location": "header",
							"locationName": "x-amz-server-side-encryption"
						},
						"ETag": {
							"location": "header",
							"locationName": "ETag"
						},
						"SSECustomerAlgorithm": {
							"location": "header",
							"locationName": "x-amz-server-side-encryption-customer-algorithm"
						},
						"SSECustomerKeyMD5": {
							"location": "header",
							"locationName": "x-amz-server-side-encryption-customer-key-MD5"
						},
						"SSEKMSKeyId": {
							"shape": "Sj",
							"location": "header",
							"locationName": "x-amz-server-side-encryption-aws-kms-key-id"
						},
						"RequestCharged": {
							"location": "header",
							"locationName": "x-amz-request-charged"
						}
					}
				}
			},
			"UploadPartCopy": {
				"http": {
					"method": "PUT",
					"requestUri": "/{Bucket}/{Key+}"
				},
				"input": {
					"type": "structure",
					"required": [
						"Bucket",
						"CopySource",
						"Key",
						"PartNumber",
						"UploadId"
					],
					"members": {
						"Bucket": {
							"location": "uri",
							"locationName": "Bucket"
						},
						"CopySource": {
							"location": "header",
							"locationName": "x-amz-copy-source"
						},
						"CopySourceIfMatch": {
							"location": "header",
							"locationName": "x-amz-copy-source-if-match"
						},
						"CopySourceIfModifiedSince": {
							"location": "header",
							"locationName": "x-amz-copy-source-if-modified-since",
							"type": "timestamp"
						},
						"CopySourceIfNoneMatch": {
							"location": "header",
							"locationName": "x-amz-copy-source-if-none-match"
						},
						"CopySourceIfUnmodifiedSince": {
							"location": "header",
							"locationName": "x-amz-copy-source-if-unmodified-since",
							"type": "timestamp"
						},
						"CopySourceRange": {
							"location": "header",
							"locationName": "x-amz-copy-source-range"
						},
						"Key": {
							"location": "uri",
							"locationName": "Key"
						},
						"PartNumber": {
							"location": "querystring",
							"locationName": "partNumber",
							"type": "integer"
						},
						"UploadId": {
							"location": "querystring",
							"locationName": "uploadId"
						},
						"SSECustomerAlgorithm": {
							"location": "header",
							"locationName": "x-amz-server-side-encryption-customer-algorithm"
						},
						"SSECustomerKey": {
							"shape": "S18",
							"location": "header",
							"locationName": "x-amz-server-side-encryption-customer-key"
						},
						"SSECustomerKeyMD5": {
							"location": "header",
							"locationName": "x-amz-server-side-encryption-customer-key-MD5"
						},
						"CopySourceSSECustomerAlgorithm": {
							"location": "header",
							"locationName": "x-amz-copy-source-server-side-encryption-customer-algorithm"
						},
						"CopySourceSSECustomerKey": {
							"shape": "S1b",
							"location": "header",
							"locationName": "x-amz-copy-source-server-side-encryption-customer-key"
						},
						"CopySourceSSECustomerKeyMD5": {
							"location": "header",
							"locationName": "x-amz-copy-source-server-side-encryption-customer-key-MD5"
						},
						"RequestPayer": {
							"location": "header",
							"locationName": "x-amz-request-payer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"CopySourceVersionId": {
							"location": "header",
							"locationName": "x-amz-copy-source-version-id"
						},
						"CopyPartResult": {
							"type": "structure",
							"members": {
								"ETag": {},
								"LastModified": {
									"type": "timestamp"
								}
							}
						},
						"ServerSideEncryption": {
							"location": "header",
							"locationName": "x-amz-server-side-encryption"
						},
						"SSECustomerAlgorithm": {
							"location": "header",
							"locationName": "x-amz-server-side-encryption-customer-algorithm"
						},
						"SSECustomerKeyMD5": {
							"location": "header",
							"locationName": "x-amz-server-side-encryption-customer-key-MD5"
						},
						"SSEKMSKeyId": {
							"shape": "Sj",
							"location": "header",
							"locationName": "x-amz-server-side-encryption-aws-kms-key-id"
						},
						"RequestCharged": {
							"location": "header",
							"locationName": "x-amz-request-charged"
						}
					},
					"payload": "CopyPartResult"
				}
			}
		},
		"shapes": {
			"Sj": {
				"type": "string",
				"sensitive": true
			},
			"S11": {
				"type": "map",
				"key": {},
				"value": {}
			},
			"S18": {
				"type": "blob",
				"sensitive": true
			},
			"S1b": {
				"type": "blob",
				"sensitive": true
			},
			"S2k": {
				"type": "structure",
				"members": {
					"DisplayName": {},
					"ID": {}
				}
			},
			"S2n": {
				"type": "list",
				"member": {
					"locationName": "Grant",
					"type": "structure",
					"members": {
						"Grantee": {
							"shape": "S2p"
						},
						"Permission": {}
					}
				}
			},
			"S2p": {
				"type": "structure",
				"required": [
					"Type"
				],
				"members": {
					"DisplayName": {},
					"EmailAddress": {},
					"ID": {},
					"Type": {
						"locationName": "xsi:type",
						"xmlAttribute": true
					},
					"URI": {}
				},
				"xmlNamespace": {
					"prefix": "xsi",
					"uri": "http://www.w3.org/2001/XMLSchema-instance"
				}
			},
			"S2w": {
				"type": "list",
				"member": {
					"type": "structure",
					"required": [
						"AllowedMethods",
						"AllowedOrigins"
					],
					"members": {
						"AllowedHeaders": {
							"locationName": "AllowedHeader",
							"type": "list",
							"member": {},
							"flattened": true
						},
						"AllowedMethods": {
							"locationName": "AllowedMethod",
							"type": "list",
							"member": {},
							"flattened": true
						},
						"AllowedOrigins": {
							"locationName": "AllowedOrigin",
							"type": "list",
							"member": {},
							"flattened": true
						},
						"ExposeHeaders": {
							"locationName": "ExposeHeader",
							"type": "list",
							"member": {},
							"flattened": true
						},
						"MaxAgeSeconds": {
							"type": "integer"
						}
					}
				},
				"flattened": true
			},
			"S39": {
				"type": "list",
				"member": {
					"type": "structure",
					"required": [
						"Prefix",
						"Status"
					],
					"members": {
						"Expiration": {
							"shape": "S3b"
						},
						"ID": {},
						"Prefix": {},
						"Status": {},
						"Transition": {
							"shape": "S3h"
						},
						"NoncurrentVersionTransition": {
							"shape": "S3j"
						},
						"NoncurrentVersionExpiration": {
							"shape": "S3k"
						},
						"AbortIncompleteMultipartUpload": {
							"shape": "S3l"
						}
					}
				},
				"flattened": true
			},
			"S3b": {
				"type": "structure",
				"members": {
					"Date": {
						"shape": "S3c"
					},
					"Days": {
						"type": "integer"
					},
					"ExpiredObjectDeleteMarker": {
						"type": "boolean"
					}
				}
			},
			"S3c": {
				"type": "timestamp",
				"timestampFormat": "iso8601"
			},
			"S3h": {
				"type": "structure",
				"members": {
					"Date": {
						"shape": "S3c"
					},
					"Days": {
						"type": "integer"
					},
					"StorageClass": {}
				}
			},
			"S3j": {
				"type": "structure",
				"members": {
					"NoncurrentDays": {
						"type": "integer"
					},
					"StorageClass": {}
				}
			},
			"S3k": {
				"type": "structure",
				"members": {
					"NoncurrentDays": {
						"type": "integer"
					}
				}
			},
			"S3l": {
				"type": "structure",
				"members": {
					"DaysAfterInitiation": {
						"type": "integer"
					}
				}
			},
			"S3p": {
				"type": "list",
				"member": {
					"type": "structure",
					"required": [
						"Prefix",
						"Status"
					],
					"members": {
						"Expiration": {
							"shape": "S3b"
						},
						"ID": {},
						"Prefix": {},
						"Status": {},
						"Transitions": {
							"locationName": "Transition",
							"type": "list",
							"member": {
								"shape": "S3h"
							},
							"flattened": true
						},
						"NoncurrentVersionTransitions": {
							"locationName": "NoncurrentVersionTransition",
							"type": "list",
							"member": {
								"shape": "S3j"
							},
							"flattened": true
						},
						"NoncurrentVersionExpiration": {
							"shape": "S3k"
						},
						"AbortIncompleteMultipartUpload": {
							"shape": "S3l"
						}
					}
				},
				"flattened": true
			},
			"S3x": {
				"type": "structure",
				"members": {
					"TargetBucket": {},
					"TargetGrants": {
						"type": "list",
						"member": {
							"locationName": "Grant",
							"type": "structure",
							"members": {
								"Grantee": {
									"shape": "S2p"
								},
								"Permission": {}
							}
						}
					},
					"TargetPrefix": {}
				}
			},
			"S43": {
				"type": "structure",
				"required": [
					"Bucket"
				],
				"members": {
					"Bucket": {
						"location": "uri",
						"locationName": "Bucket"
					}
				}
			},
			"S44": {
				"type": "structure",
				"members": {
					"TopicConfiguration": {
						"type": "structure",
						"members": {
							"Id": {},
							"Events": {
								"shape": "S47",
								"locationName": "Event"
							},
							"Event": {
								"deprecated": true
							},
							"Topic": {}
						}
					},
					"QueueConfiguration": {
						"type": "structure",
						"members": {
							"Id": {},
							"Event": {
								"deprecated": true
							},
							"Events": {
								"shape": "S47",
								"locationName": "Event"
							},
							"Queue": {}
						}
					},
					"CloudFunctionConfiguration": {
						"type": "structure",
						"members": {
							"Id": {},
							"Event": {
								"deprecated": true
							},
							"Events": {
								"shape": "S47",
								"locationName": "Event"
							},
							"CloudFunction": {},
							"InvocationRole": {}
						}
					}
				}
			},
			"S47": {
				"type": "list",
				"member": {},
				"flattened": true
			},
			"S4f": {
				"type": "structure",
				"members": {
					"TopicConfigurations": {
						"locationName": "TopicConfiguration",
						"type": "list",
						"member": {
							"type": "structure",
							"required": [
								"TopicArn",
								"Events"
							],
							"members": {
								"Id": {},
								"TopicArn": {
									"locationName": "Topic"
								},
								"Events": {
									"shape": "S47",
									"locationName": "Event"
								},
								"Filter": {
									"shape": "S4i"
								}
							}
						},
						"flattened": true
					},
					"QueueConfigurations": {
						"locationName": "QueueConfiguration",
						"type": "list",
						"member": {
							"type": "structure",
							"required": [
								"QueueArn",
								"Events"
							],
							"members": {
								"Id": {},
								"QueueArn": {
									"locationName": "Queue"
								},
								"Events": {
									"shape": "S47",
									"locationName": "Event"
								},
								"Filter": {
									"shape": "S4i"
								}
							}
						},
						"flattened": true
					},
					"LambdaFunctionConfigurations": {
						"locationName": "CloudFunctionConfiguration",
						"type": "list",
						"member": {
							"type": "structure",
							"required": [
								"LambdaFunctionArn",
								"Events"
							],
							"members": {
								"Id": {},
								"LambdaFunctionArn": {
									"locationName": "CloudFunction"
								},
								"Events": {
									"shape": "S47",
									"locationName": "Event"
								},
								"Filter": {
									"shape": "S4i"
								}
							}
						},
						"flattened": true
					}
				}
			},
			"S4i": {
				"type": "structure",
				"members": {
					"Key": {
						"locationName": "S3Key",
						"type": "structure",
						"members": {
							"FilterRules": {
								"locationName": "FilterRule",
								"type": "list",
								"member": {
									"type": "structure",
									"members": {
										"Name": {},
										"Value": {}
									}
								},
								"flattened": true
							}
						}
					}
				}
			},
			"S4y": {
				"type": "structure",
				"required": [
					"Role",
					"Rules"
				],
				"members": {
					"Role": {},
					"Rules": {
						"locationName": "Rule",
						"type": "list",
						"member": {
							"type": "structure",
							"required": [
								"Prefix",
								"Status",
								"Destination"
							],
							"members": {
								"ID": {},
								"Prefix": {},
								"Status": {},
								"Destination": {
									"type": "structure",
									"required": [
										"Bucket"
									],
									"members": {
										"Bucket": {},
										"StorageClass": {}
									}
								}
							}
						},
						"flattened": true
					}
				}
			},
			"S59": {
				"type": "list",
				"member": {
					"locationName": "Tag",
					"type": "structure",
					"required": [
						"Key",
						"Value"
					],
					"members": {
						"Key": {},
						"Value": {}
					}
				}
			},
			"S5i": {
				"type": "structure",
				"required": [
					"HostName"
				],
				"members": {
					"HostName": {},
					"Protocol": {}
				}
			},
			"S5l": {
				"type": "structure",
				"required": [
					"Suffix"
				],
				"members": {
					"Suffix": {}
				}
			},
			"S5n": {
				"type": "structure",
				"required": [
					"Key"
				],
				"members": {
					"Key": {}
				}
			},
			"S5o": {
				"type": "list",
				"member": {
					"locationName": "RoutingRule",
					"type": "structure",
					"required": [
						"Redirect"
					],
					"members": {
						"Condition": {
							"type": "structure",
							"members": {
								"HttpErrorCodeReturnedEquals": {},
								"KeyPrefixEquals": {}
							}
						},
						"Redirect": {
							"type": "structure",
							"members": {
								"HostName": {},
								"HttpRedirectCode": {},
								"Protocol": {},
								"ReplaceKeyPrefixWith": {},
								"ReplaceKeyWith": {}
							}
						}
					}
				}
			},
			"S76": {
				"type": "structure",
				"members": {
					"ID": {},
					"DisplayName": {}
				}
			},
			"S77": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"Prefix": {}
					}
				},
				"flattened": true
			},
			"S7p": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"Key": {},
						"LastModified": {
							"type": "timestamp"
						},
						"ETag": {},
						"Size": {
							"type": "integer"
						},
						"StorageClass": {},
						"Owner": {
							"shape": "S2k"
						}
					}
				},
				"flattened": true
			},
			"S89": {
				"type": "structure",
				"members": {
					"Grants": {
						"shape": "S2n",
						"locationName": "AccessControlList"
					},
					"Owner": {
						"shape": "S2k"
					}
				}
			}
		}
	};

/***/ },
/* 444 */
/***/ function(module, exports) {

	module.exports = {
		"pagination": {
			"ListBuckets": {
				"result_key": "Buckets"
			},
			"ListMultipartUploads": {
				"limit_key": "MaxUploads",
				"more_results": "IsTruncated",
				"output_token": [
					"NextKeyMarker",
					"NextUploadIdMarker"
				],
				"input_token": [
					"KeyMarker",
					"UploadIdMarker"
				],
				"result_key": [
					"Uploads",
					"CommonPrefixes"
				]
			},
			"ListObjectVersions": {
				"more_results": "IsTruncated",
				"limit_key": "MaxKeys",
				"output_token": [
					"NextKeyMarker",
					"NextVersionIdMarker"
				],
				"input_token": [
					"KeyMarker",
					"VersionIdMarker"
				],
				"result_key": [
					"Versions",
					"DeleteMarkers",
					"CommonPrefixes"
				]
			},
			"ListObjects": {
				"more_results": "IsTruncated",
				"limit_key": "MaxKeys",
				"output_token": "NextMarker || Contents[-1].Key",
				"input_token": "Marker",
				"result_key": [
					"Contents",
					"CommonPrefixes"
				]
			},
			"ListObjectsV2": {
				"limit_key": "MaxKeys",
				"output_token": "NextContinuationToken",
				"input_token": "ContinuationToken",
				"result_key": [
					"Contents",
					"CommonPrefixes"
				]
			},
			"ListParts": {
				"more_results": "IsTruncated",
				"limit_key": "MaxParts",
				"output_token": "NextPartNumberMarker",
				"input_token": "PartNumberMarker",
				"result_key": "Parts"
			}
		}
	};

/***/ },
/* 445 */
/***/ function(module, exports) {

	module.exports = {
		"version": 2,
		"waiters": {
			"BucketExists": {
				"delay": 5,
				"operation": "HeadBucket",
				"maxAttempts": 20,
				"acceptors": [
					{
						"expected": 200,
						"matcher": "status",
						"state": "success"
					},
					{
						"expected": 301,
						"matcher": "status",
						"state": "success"
					},
					{
						"expected": 403,
						"matcher": "status",
						"state": "success"
					},
					{
						"expected": 404,
						"matcher": "status",
						"state": "retry"
					}
				]
			},
			"BucketNotExists": {
				"delay": 5,
				"operation": "HeadBucket",
				"maxAttempts": 20,
				"acceptors": [
					{
						"expected": 404,
						"matcher": "status",
						"state": "success"
					}
				]
			},
			"ObjectExists": {
				"delay": 5,
				"operation": "HeadObject",
				"maxAttempts": 20,
				"acceptors": [
					{
						"expected": 200,
						"matcher": "status",
						"state": "success"
					},
					{
						"expected": 404,
						"matcher": "status",
						"state": "retry"
					}
				]
			},
			"ObjectNotExists": {
				"delay": 5,
				"operation": "HeadObject",
				"maxAttempts": 20,
				"acceptors": [
					{
						"expected": 404,
						"matcher": "status",
						"state": "success"
					}
				]
			}
		}
	};

/***/ },
/* 446 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['servicecatalog'] = {};
	AWS.ServiceCatalog = Service.defineService('servicecatalog', ['2015-12-10']);
	Object.defineProperty(apiLoader.services['servicecatalog'], '2015-12-10', {
	  get: function get() {
	    var model = __webpack_require__(447);
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.ServiceCatalog;


/***/ },
/* 447 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2015-12-10",
			"endpointPrefix": "servicecatalog",
			"jsonVersion": "1.1",
			"protocol": "json",
			"serviceFullName": "AWS Service Catalog",
			"signatureVersion": "v4",
			"targetPrefix": "AWS242ServiceCatalogService"
		},
		"operations": {
			"DescribeProduct": {
				"input": {
					"type": "structure",
					"required": [
						"Id"
					],
					"members": {
						"AcceptLanguage": {},
						"Id": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ProductViewSummary": {
							"shape": "S5"
						},
						"ProvisioningArtifacts": {
							"shape": "Sf"
						}
					}
				}
			},
			"DescribeProductView": {
				"input": {
					"type": "structure",
					"required": [
						"Id"
					],
					"members": {
						"AcceptLanguage": {},
						"Id": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ProductViewSummary": {
							"shape": "S5"
						},
						"ProvisioningArtifacts": {
							"shape": "Sf"
						}
					}
				}
			},
			"DescribeProvisioningParameters": {
				"input": {
					"type": "structure",
					"required": [
						"ProductId",
						"ProvisioningArtifactId"
					],
					"members": {
						"AcceptLanguage": {},
						"ProductId": {},
						"ProvisioningArtifactId": {},
						"PathId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ProvisioningArtifactParameters": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"ParameterKey": {},
									"DefaultValue": {},
									"ParameterType": {},
									"IsNoEcho": {
										"type": "boolean"
									},
									"Description": {},
									"ParameterConstraints": {
										"type": "structure",
										"members": {
											"AllowedValues": {
												"type": "list",
												"member": {}
											}
										}
									}
								}
							}
						},
						"ConstraintSummaries": {
							"shape": "Sy"
						},
						"UsageInstructions": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"Type": {},
									"Value": {}
								}
							}
						}
					}
				}
			},
			"DescribeRecord": {
				"input": {
					"type": "structure",
					"required": [
						"Id"
					],
					"members": {
						"AcceptLanguage": {},
						"Id": {},
						"PageToken": {},
						"PageSize": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"RecordDetail": {
							"shape": "S1a"
						},
						"RecordOutputs": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"OutputKey": {},
									"OutputValue": {},
									"Description": {}
								}
							}
						},
						"NextPageToken": {}
					}
				}
			},
			"ListLaunchPaths": {
				"input": {
					"type": "structure",
					"required": [
						"ProductId"
					],
					"members": {
						"AcceptLanguage": {},
						"ProductId": {},
						"PageSize": {
							"type": "integer"
						},
						"PageToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"LaunchPathSummaries": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"Id": {},
									"ConstraintSummaries": {
										"shape": "Sy"
									},
									"Tags": {
										"shape": "S1x"
									},
									"Name": {}
								}
							}
						},
						"NextPageToken": {}
					}
				}
			},
			"ListRecordHistory": {
				"input": {
					"type": "structure",
					"members": {
						"AcceptLanguage": {},
						"AccessLevelFilter": {
							"shape": "S23"
						},
						"SearchFilter": {
							"type": "structure",
							"members": {
								"Key": {},
								"Value": {}
							}
						},
						"PageSize": {
							"type": "integer"
						},
						"PageToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"RecordDetails": {
							"type": "list",
							"member": {
								"shape": "S1a"
							}
						},
						"NextPageToken": {}
					}
				}
			},
			"ProvisionProduct": {
				"input": {
					"type": "structure",
					"required": [
						"ProductId",
						"ProvisioningArtifactId",
						"ProvisionedProductName",
						"ProvisionToken"
					],
					"members": {
						"AcceptLanguage": {},
						"ProductId": {},
						"ProvisioningArtifactId": {},
						"PathId": {},
						"ProvisionedProductName": {},
						"ProvisioningParameters": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"Key": {},
									"Value": {}
								}
							}
						},
						"Tags": {
							"shape": "S1x"
						},
						"NotificationArns": {
							"type": "list",
							"member": {}
						},
						"ProvisionToken": {
							"idempotencyToken": true
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"RecordDetail": {
							"shape": "S1a"
						}
					}
				}
			},
			"ScanProvisionedProducts": {
				"input": {
					"type": "structure",
					"members": {
						"AcceptLanguage": {},
						"AccessLevelFilter": {
							"shape": "S23"
						},
						"PageSize": {
							"type": "integer"
						},
						"PageToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ProvisionedProducts": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"Name": {},
									"Arn": {},
									"Type": {},
									"Id": {},
									"Status": {},
									"StatusMessage": {},
									"CreatedTime": {
										"type": "timestamp"
									},
									"IdempotencyToken": {},
									"LastRecordId": {}
								}
							}
						},
						"NextPageToken": {}
					}
				}
			},
			"SearchProducts": {
				"input": {
					"type": "structure",
					"members": {
						"AcceptLanguage": {},
						"Filters": {
							"type": "map",
							"key": {},
							"value": {
								"type": "list",
								"member": {}
							}
						},
						"PageSize": {
							"type": "integer"
						},
						"SortBy": {},
						"SortOrder": {},
						"PageToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ProductViewSummaries": {
							"type": "list",
							"member": {
								"shape": "S5"
							}
						},
						"ProductViewAggregations": {
							"type": "map",
							"key": {},
							"value": {
								"type": "list",
								"member": {
									"type": "structure",
									"members": {
										"Value": {},
										"ApproximateCount": {
											"type": "integer"
										}
									}
								}
							}
						},
						"NextPageToken": {}
					}
				}
			},
			"TerminateProvisionedProduct": {
				"input": {
					"type": "structure",
					"required": [
						"TerminateToken"
					],
					"members": {
						"ProvisionedProductName": {},
						"ProvisionedProductId": {},
						"TerminateToken": {
							"idempotencyToken": true
						},
						"IgnoreErrors": {
							"type": "boolean"
						},
						"AcceptLanguage": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"RecordDetail": {
							"shape": "S1a"
						}
					}
				}
			},
			"UpdateProvisionedProduct": {
				"input": {
					"type": "structure",
					"required": [
						"UpdateToken"
					],
					"members": {
						"AcceptLanguage": {},
						"ProvisionedProductName": {},
						"ProvisionedProductId": {},
						"ProductId": {},
						"ProvisioningArtifactId": {},
						"PathId": {},
						"ProvisioningParameters": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"Key": {},
									"Value": {},
									"UsePreviousValue": {
										"type": "boolean"
									}
								}
							}
						},
						"UpdateToken": {
							"idempotencyToken": true
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"RecordDetail": {
							"shape": "S1a"
						}
					}
				}
			}
		},
		"shapes": {
			"S5": {
				"type": "structure",
				"members": {
					"Id": {},
					"ProductId": {},
					"Name": {},
					"Owner": {},
					"ShortDescription": {},
					"Type": {},
					"Distributor": {},
					"HasDefaultPath": {
						"type": "boolean"
					},
					"SupportEmail": {},
					"SupportDescription": {},
					"SupportUrl": {}
				}
			},
			"Sf": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"Id": {},
						"Name": {},
						"Description": {},
						"CreatedTime": {
							"type": "timestamp"
						}
					}
				}
			},
			"Sy": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"Type": {},
						"Description": {}
					}
				}
			},
			"S1a": {
				"type": "structure",
				"members": {
					"RecordId": {},
					"ProvisionedProductName": {},
					"Status": {},
					"CreatedTime": {
						"type": "timestamp"
					},
					"UpdatedTime": {
						"type": "timestamp"
					},
					"ProvisionedProductType": {},
					"RecordType": {},
					"ProvisionedProductId": {},
					"ProductId": {},
					"ProvisioningArtifactId": {},
					"PathId": {},
					"RecordErrors": {
						"type": "list",
						"member": {
							"type": "structure",
							"members": {
								"Code": {},
								"Description": {}
							}
						}
					},
					"RecordTags": {
						"type": "list",
						"member": {
							"type": "structure",
							"members": {
								"Key": {},
								"Value": {}
							}
						}
					}
				}
			},
			"S1x": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"Key": {},
						"Value": {}
					}
				}
			},
			"S23": {
				"type": "structure",
				"members": {
					"Key": {},
					"Value": {}
				}
			}
		}
	};

/***/ },
/* 448 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['ses'] = {};
	AWS.SES = Service.defineService('ses', ['2010-12-01']);
	Object.defineProperty(apiLoader.services['ses'], '2010-12-01', {
	  get: function get() {
	    var model = __webpack_require__(449);
	    model.paginators = __webpack_require__(450).pagination;
	    model.waiters = __webpack_require__(451).waiters;
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.SES;


/***/ },
/* 449 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2010-12-01",
			"endpointPrefix": "email",
			"protocol": "query",
			"serviceAbbreviation": "Amazon SES",
			"serviceFullName": "Amazon Simple Email Service",
			"signatureVersion": "v4",
			"signingName": "ses",
			"xmlNamespace": "http://ses.amazonaws.com/doc/2010-12-01/"
		},
		"operations": {
			"CloneReceiptRuleSet": {
				"input": {
					"type": "structure",
					"required": [
						"RuleSetName",
						"OriginalRuleSetName"
					],
					"members": {
						"RuleSetName": {},
						"OriginalRuleSetName": {}
					}
				},
				"output": {
					"resultWrapper": "CloneReceiptRuleSetResult",
					"type": "structure",
					"members": {}
				}
			},
			"CreateConfigurationSet": {
				"input": {
					"type": "structure",
					"required": [
						"ConfigurationSet"
					],
					"members": {
						"ConfigurationSet": {
							"shape": "S5"
						}
					}
				},
				"output": {
					"resultWrapper": "CreateConfigurationSetResult",
					"type": "structure",
					"members": {}
				}
			},
			"CreateConfigurationSetEventDestination": {
				"input": {
					"type": "structure",
					"required": [
						"ConfigurationSetName",
						"EventDestination"
					],
					"members": {
						"ConfigurationSetName": {},
						"EventDestination": {
							"shape": "S9"
						}
					}
				},
				"output": {
					"resultWrapper": "CreateConfigurationSetEventDestinationResult",
					"type": "structure",
					"members": {}
				}
			},
			"CreateReceiptFilter": {
				"input": {
					"type": "structure",
					"required": [
						"Filter"
					],
					"members": {
						"Filter": {
							"shape": "So"
						}
					}
				},
				"output": {
					"resultWrapper": "CreateReceiptFilterResult",
					"type": "structure",
					"members": {}
				}
			},
			"CreateReceiptRule": {
				"input": {
					"type": "structure",
					"required": [
						"RuleSetName",
						"Rule"
					],
					"members": {
						"RuleSetName": {},
						"After": {},
						"Rule": {
							"shape": "Sw"
						}
					}
				},
				"output": {
					"resultWrapper": "CreateReceiptRuleResult",
					"type": "structure",
					"members": {}
				}
			},
			"CreateReceiptRuleSet": {
				"input": {
					"type": "structure",
					"required": [
						"RuleSetName"
					],
					"members": {
						"RuleSetName": {}
					}
				},
				"output": {
					"resultWrapper": "CreateReceiptRuleSetResult",
					"type": "structure",
					"members": {}
				}
			},
			"DeleteConfigurationSet": {
				"input": {
					"type": "structure",
					"required": [
						"ConfigurationSetName"
					],
					"members": {
						"ConfigurationSetName": {}
					}
				},
				"output": {
					"resultWrapper": "DeleteConfigurationSetResult",
					"type": "structure",
					"members": {}
				}
			},
			"DeleteConfigurationSetEventDestination": {
				"input": {
					"type": "structure",
					"required": [
						"ConfigurationSetName",
						"EventDestinationName"
					],
					"members": {
						"ConfigurationSetName": {},
						"EventDestinationName": {}
					}
				},
				"output": {
					"resultWrapper": "DeleteConfigurationSetEventDestinationResult",
					"type": "structure",
					"members": {}
				}
			},
			"DeleteIdentity": {
				"input": {
					"type": "structure",
					"required": [
						"Identity"
					],
					"members": {
						"Identity": {}
					}
				},
				"output": {
					"resultWrapper": "DeleteIdentityResult",
					"type": "structure",
					"members": {}
				}
			},
			"DeleteIdentityPolicy": {
				"input": {
					"type": "structure",
					"required": [
						"Identity",
						"PolicyName"
					],
					"members": {
						"Identity": {},
						"PolicyName": {}
					}
				},
				"output": {
					"resultWrapper": "DeleteIdentityPolicyResult",
					"type": "structure",
					"members": {}
				}
			},
			"DeleteReceiptFilter": {
				"input": {
					"type": "structure",
					"required": [
						"FilterName"
					],
					"members": {
						"FilterName": {}
					}
				},
				"output": {
					"resultWrapper": "DeleteReceiptFilterResult",
					"type": "structure",
					"members": {}
				}
			},
			"DeleteReceiptRule": {
				"input": {
					"type": "structure",
					"required": [
						"RuleSetName",
						"RuleName"
					],
					"members": {
						"RuleSetName": {},
						"RuleName": {}
					}
				},
				"output": {
					"resultWrapper": "DeleteReceiptRuleResult",
					"type": "structure",
					"members": {}
				}
			},
			"DeleteReceiptRuleSet": {
				"input": {
					"type": "structure",
					"required": [
						"RuleSetName"
					],
					"members": {
						"RuleSetName": {}
					}
				},
				"output": {
					"resultWrapper": "DeleteReceiptRuleSetResult",
					"type": "structure",
					"members": {}
				}
			},
			"DeleteVerifiedEmailAddress": {
				"input": {
					"type": "structure",
					"required": [
						"EmailAddress"
					],
					"members": {
						"EmailAddress": {}
					}
				}
			},
			"DescribeActiveReceiptRuleSet": {
				"input": {
					"type": "structure",
					"members": {}
				},
				"output": {
					"resultWrapper": "DescribeActiveReceiptRuleSetResult",
					"type": "structure",
					"members": {
						"Metadata": {
							"shape": "S26"
						},
						"Rules": {
							"shape": "S28"
						}
					}
				}
			},
			"DescribeConfigurationSet": {
				"input": {
					"type": "structure",
					"required": [
						"ConfigurationSetName"
					],
					"members": {
						"ConfigurationSetName": {},
						"ConfigurationSetAttributeNames": {
							"type": "list",
							"member": {}
						}
					}
				},
				"output": {
					"resultWrapper": "DescribeConfigurationSetResult",
					"type": "structure",
					"members": {
						"ConfigurationSet": {
							"shape": "S5"
						},
						"EventDestinations": {
							"type": "list",
							"member": {
								"shape": "S9"
							}
						}
					}
				}
			},
			"DescribeReceiptRule": {
				"input": {
					"type": "structure",
					"required": [
						"RuleSetName",
						"RuleName"
					],
					"members": {
						"RuleSetName": {},
						"RuleName": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeReceiptRuleResult",
					"type": "structure",
					"members": {
						"Rule": {
							"shape": "Sw"
						}
					}
				}
			},
			"DescribeReceiptRuleSet": {
				"input": {
					"type": "structure",
					"required": [
						"RuleSetName"
					],
					"members": {
						"RuleSetName": {}
					}
				},
				"output": {
					"resultWrapper": "DescribeReceiptRuleSetResult",
					"type": "structure",
					"members": {
						"Metadata": {
							"shape": "S26"
						},
						"Rules": {
							"shape": "S28"
						}
					}
				}
			},
			"GetIdentityDkimAttributes": {
				"input": {
					"type": "structure",
					"required": [
						"Identities"
					],
					"members": {
						"Identities": {
							"shape": "S2j"
						}
					}
				},
				"output": {
					"resultWrapper": "GetIdentityDkimAttributesResult",
					"type": "structure",
					"required": [
						"DkimAttributes"
					],
					"members": {
						"DkimAttributes": {
							"type": "map",
							"key": {},
							"value": {
								"type": "structure",
								"required": [
									"DkimEnabled",
									"DkimVerificationStatus"
								],
								"members": {
									"DkimEnabled": {
										"type": "boolean"
									},
									"DkimVerificationStatus": {},
									"DkimTokens": {
										"shape": "S2o"
									}
								}
							}
						}
					}
				}
			},
			"GetIdentityMailFromDomainAttributes": {
				"input": {
					"type": "structure",
					"required": [
						"Identities"
					],
					"members": {
						"Identities": {
							"shape": "S2j"
						}
					}
				},
				"output": {
					"resultWrapper": "GetIdentityMailFromDomainAttributesResult",
					"type": "structure",
					"required": [
						"MailFromDomainAttributes"
					],
					"members": {
						"MailFromDomainAttributes": {
							"type": "map",
							"key": {},
							"value": {
								"type": "structure",
								"required": [
									"MailFromDomain",
									"MailFromDomainStatus",
									"BehaviorOnMXFailure"
								],
								"members": {
									"MailFromDomain": {},
									"MailFromDomainStatus": {},
									"BehaviorOnMXFailure": {}
								}
							}
						}
					}
				}
			},
			"GetIdentityNotificationAttributes": {
				"input": {
					"type": "structure",
					"required": [
						"Identities"
					],
					"members": {
						"Identities": {
							"shape": "S2j"
						}
					}
				},
				"output": {
					"resultWrapper": "GetIdentityNotificationAttributesResult",
					"type": "structure",
					"required": [
						"NotificationAttributes"
					],
					"members": {
						"NotificationAttributes": {
							"type": "map",
							"key": {},
							"value": {
								"type": "structure",
								"required": [
									"BounceTopic",
									"ComplaintTopic",
									"DeliveryTopic",
									"ForwardingEnabled"
								],
								"members": {
									"BounceTopic": {},
									"ComplaintTopic": {},
									"DeliveryTopic": {},
									"ForwardingEnabled": {
										"type": "boolean"
									},
									"HeadersInBounceNotificationsEnabled": {
										"type": "boolean"
									},
									"HeadersInComplaintNotificationsEnabled": {
										"type": "boolean"
									},
									"HeadersInDeliveryNotificationsEnabled": {
										"type": "boolean"
									}
								}
							}
						}
					}
				}
			},
			"GetIdentityPolicies": {
				"input": {
					"type": "structure",
					"required": [
						"Identity",
						"PolicyNames"
					],
					"members": {
						"Identity": {},
						"PolicyNames": {
							"shape": "S33"
						}
					}
				},
				"output": {
					"resultWrapper": "GetIdentityPoliciesResult",
					"type": "structure",
					"required": [
						"Policies"
					],
					"members": {
						"Policies": {
							"type": "map",
							"key": {},
							"value": {}
						}
					}
				}
			},
			"GetIdentityVerificationAttributes": {
				"input": {
					"type": "structure",
					"required": [
						"Identities"
					],
					"members": {
						"Identities": {
							"shape": "S2j"
						}
					}
				},
				"output": {
					"resultWrapper": "GetIdentityVerificationAttributesResult",
					"type": "structure",
					"required": [
						"VerificationAttributes"
					],
					"members": {
						"VerificationAttributes": {
							"type": "map",
							"key": {},
							"value": {
								"type": "structure",
								"required": [
									"VerificationStatus"
								],
								"members": {
									"VerificationStatus": {},
									"VerificationToken": {}
								}
							}
						}
					}
				}
			},
			"GetSendQuota": {
				"output": {
					"resultWrapper": "GetSendQuotaResult",
					"type": "structure",
					"members": {
						"Max24HourSend": {
							"type": "double"
						},
						"MaxSendRate": {
							"type": "double"
						},
						"SentLast24Hours": {
							"type": "double"
						}
					}
				}
			},
			"GetSendStatistics": {
				"output": {
					"resultWrapper": "GetSendStatisticsResult",
					"type": "structure",
					"members": {
						"SendDataPoints": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"Timestamp": {
										"type": "timestamp"
									},
									"DeliveryAttempts": {
										"type": "long"
									},
									"Bounces": {
										"type": "long"
									},
									"Complaints": {
										"type": "long"
									},
									"Rejects": {
										"type": "long"
									}
								}
							}
						}
					}
				}
			},
			"ListConfigurationSets": {
				"input": {
					"type": "structure",
					"members": {
						"NextToken": {},
						"MaxItems": {
							"type": "integer"
						}
					}
				},
				"output": {
					"resultWrapper": "ListConfigurationSetsResult",
					"type": "structure",
					"members": {
						"ConfigurationSets": {
							"type": "list",
							"member": {
								"shape": "S5"
							}
						},
						"NextToken": {}
					}
				}
			},
			"ListIdentities": {
				"input": {
					"type": "structure",
					"members": {
						"IdentityType": {},
						"NextToken": {},
						"MaxItems": {
							"type": "integer"
						}
					}
				},
				"output": {
					"resultWrapper": "ListIdentitiesResult",
					"type": "structure",
					"required": [
						"Identities"
					],
					"members": {
						"Identities": {
							"shape": "S2j"
						},
						"NextToken": {}
					}
				}
			},
			"ListIdentityPolicies": {
				"input": {
					"type": "structure",
					"required": [
						"Identity"
					],
					"members": {
						"Identity": {}
					}
				},
				"output": {
					"resultWrapper": "ListIdentityPoliciesResult",
					"type": "structure",
					"required": [
						"PolicyNames"
					],
					"members": {
						"PolicyNames": {
							"shape": "S33"
						}
					}
				}
			},
			"ListReceiptFilters": {
				"input": {
					"type": "structure",
					"members": {}
				},
				"output": {
					"resultWrapper": "ListReceiptFiltersResult",
					"type": "structure",
					"members": {
						"Filters": {
							"type": "list",
							"member": {
								"shape": "So"
							}
						}
					}
				}
			},
			"ListReceiptRuleSets": {
				"input": {
					"type": "structure",
					"members": {
						"NextToken": {}
					}
				},
				"output": {
					"resultWrapper": "ListReceiptRuleSetsResult",
					"type": "structure",
					"members": {
						"RuleSets": {
							"type": "list",
							"member": {
								"shape": "S26"
							}
						},
						"NextToken": {}
					}
				}
			},
			"ListVerifiedEmailAddresses": {
				"output": {
					"resultWrapper": "ListVerifiedEmailAddressesResult",
					"type": "structure",
					"members": {
						"VerifiedEmailAddresses": {
							"shape": "S40"
						}
					}
				}
			},
			"PutIdentityPolicy": {
				"input": {
					"type": "structure",
					"required": [
						"Identity",
						"PolicyName",
						"Policy"
					],
					"members": {
						"Identity": {},
						"PolicyName": {},
						"Policy": {}
					}
				},
				"output": {
					"resultWrapper": "PutIdentityPolicyResult",
					"type": "structure",
					"members": {}
				}
			},
			"ReorderReceiptRuleSet": {
				"input": {
					"type": "structure",
					"required": [
						"RuleSetName",
						"RuleNames"
					],
					"members": {
						"RuleSetName": {},
						"RuleNames": {
							"type": "list",
							"member": {}
						}
					}
				},
				"output": {
					"resultWrapper": "ReorderReceiptRuleSetResult",
					"type": "structure",
					"members": {}
				}
			},
			"SendBounce": {
				"input": {
					"type": "structure",
					"required": [
						"OriginalMessageId",
						"BounceSender",
						"BouncedRecipientInfoList"
					],
					"members": {
						"OriginalMessageId": {},
						"BounceSender": {},
						"Explanation": {},
						"MessageDsn": {
							"type": "structure",
							"required": [
								"ReportingMta"
							],
							"members": {
								"ReportingMta": {},
								"ArrivalDate": {
									"type": "timestamp"
								},
								"ExtensionFields": {
									"shape": "S4c"
								}
							}
						},
						"BouncedRecipientInfoList": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"Recipient"
								],
								"members": {
									"Recipient": {},
									"RecipientArn": {},
									"BounceType": {},
									"RecipientDsnFields": {
										"type": "structure",
										"required": [
											"Action",
											"Status"
										],
										"members": {
											"FinalRecipient": {},
											"Action": {},
											"RemoteMta": {},
											"Status": {},
											"DiagnosticCode": {},
											"LastAttemptDate": {
												"type": "timestamp"
											},
											"ExtensionFields": {
												"shape": "S4c"
											}
										}
									}
								}
							}
						},
						"BounceSenderArn": {}
					}
				},
				"output": {
					"resultWrapper": "SendBounceResult",
					"type": "structure",
					"members": {
						"MessageId": {}
					}
				}
			},
			"SendEmail": {
				"input": {
					"type": "structure",
					"required": [
						"Source",
						"Destination",
						"Message"
					],
					"members": {
						"Source": {},
						"Destination": {
							"type": "structure",
							"members": {
								"ToAddresses": {
									"shape": "S40"
								},
								"CcAddresses": {
									"shape": "S40"
								},
								"BccAddresses": {
									"shape": "S40"
								}
							}
						},
						"Message": {
							"type": "structure",
							"required": [
								"Subject",
								"Body"
							],
							"members": {
								"Subject": {
									"shape": "S4t"
								},
								"Body": {
									"type": "structure",
									"members": {
										"Text": {
											"shape": "S4t"
										},
										"Html": {
											"shape": "S4t"
										}
									}
								}
							}
						},
						"ReplyToAddresses": {
							"shape": "S40"
						},
						"ReturnPath": {},
						"SourceArn": {},
						"ReturnPathArn": {},
						"Tags": {
							"shape": "S4x"
						},
						"ConfigurationSetName": {}
					}
				},
				"output": {
					"resultWrapper": "SendEmailResult",
					"type": "structure",
					"required": [
						"MessageId"
					],
					"members": {
						"MessageId": {}
					}
				}
			},
			"SendRawEmail": {
				"input": {
					"type": "structure",
					"required": [
						"RawMessage"
					],
					"members": {
						"Source": {},
						"Destinations": {
							"shape": "S40"
						},
						"RawMessage": {
							"type": "structure",
							"required": [
								"Data"
							],
							"members": {
								"Data": {
									"type": "blob"
								}
							}
						},
						"FromArn": {},
						"SourceArn": {},
						"ReturnPathArn": {},
						"Tags": {
							"shape": "S4x"
						},
						"ConfigurationSetName": {}
					}
				},
				"output": {
					"resultWrapper": "SendRawEmailResult",
					"type": "structure",
					"required": [
						"MessageId"
					],
					"members": {
						"MessageId": {}
					}
				}
			},
			"SetActiveReceiptRuleSet": {
				"input": {
					"type": "structure",
					"members": {
						"RuleSetName": {}
					}
				},
				"output": {
					"resultWrapper": "SetActiveReceiptRuleSetResult",
					"type": "structure",
					"members": {}
				}
			},
			"SetIdentityDkimEnabled": {
				"input": {
					"type": "structure",
					"required": [
						"Identity",
						"DkimEnabled"
					],
					"members": {
						"Identity": {},
						"DkimEnabled": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"resultWrapper": "SetIdentityDkimEnabledResult",
					"type": "structure",
					"members": {}
				}
			},
			"SetIdentityFeedbackForwardingEnabled": {
				"input": {
					"type": "structure",
					"required": [
						"Identity",
						"ForwardingEnabled"
					],
					"members": {
						"Identity": {},
						"ForwardingEnabled": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"resultWrapper": "SetIdentityFeedbackForwardingEnabledResult",
					"type": "structure",
					"members": {}
				}
			},
			"SetIdentityHeadersInNotificationsEnabled": {
				"input": {
					"type": "structure",
					"required": [
						"Identity",
						"NotificationType",
						"Enabled"
					],
					"members": {
						"Identity": {},
						"NotificationType": {},
						"Enabled": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"resultWrapper": "SetIdentityHeadersInNotificationsEnabledResult",
					"type": "structure",
					"members": {}
				}
			},
			"SetIdentityMailFromDomain": {
				"input": {
					"type": "structure",
					"required": [
						"Identity"
					],
					"members": {
						"Identity": {},
						"MailFromDomain": {},
						"BehaviorOnMXFailure": {}
					}
				},
				"output": {
					"resultWrapper": "SetIdentityMailFromDomainResult",
					"type": "structure",
					"members": {}
				}
			},
			"SetIdentityNotificationTopic": {
				"input": {
					"type": "structure",
					"required": [
						"Identity",
						"NotificationType"
					],
					"members": {
						"Identity": {},
						"NotificationType": {},
						"SnsTopic": {}
					}
				},
				"output": {
					"resultWrapper": "SetIdentityNotificationTopicResult",
					"type": "structure",
					"members": {}
				}
			},
			"SetReceiptRulePosition": {
				"input": {
					"type": "structure",
					"required": [
						"RuleSetName",
						"RuleName"
					],
					"members": {
						"RuleSetName": {},
						"RuleName": {},
						"After": {}
					}
				},
				"output": {
					"resultWrapper": "SetReceiptRulePositionResult",
					"type": "structure",
					"members": {}
				}
			},
			"UpdateConfigurationSetEventDestination": {
				"input": {
					"type": "structure",
					"required": [
						"ConfigurationSetName",
						"EventDestination"
					],
					"members": {
						"ConfigurationSetName": {},
						"EventDestination": {
							"shape": "S9"
						}
					}
				},
				"output": {
					"resultWrapper": "UpdateConfigurationSetEventDestinationResult",
					"type": "structure",
					"members": {}
				}
			},
			"UpdateReceiptRule": {
				"input": {
					"type": "structure",
					"required": [
						"RuleSetName",
						"Rule"
					],
					"members": {
						"RuleSetName": {},
						"Rule": {
							"shape": "Sw"
						}
					}
				},
				"output": {
					"resultWrapper": "UpdateReceiptRuleResult",
					"type": "structure",
					"members": {}
				}
			},
			"VerifyDomainDkim": {
				"input": {
					"type": "structure",
					"required": [
						"Domain"
					],
					"members": {
						"Domain": {}
					}
				},
				"output": {
					"resultWrapper": "VerifyDomainDkimResult",
					"type": "structure",
					"required": [
						"DkimTokens"
					],
					"members": {
						"DkimTokens": {
							"shape": "S2o"
						}
					}
				}
			},
			"VerifyDomainIdentity": {
				"input": {
					"type": "structure",
					"required": [
						"Domain"
					],
					"members": {
						"Domain": {}
					}
				},
				"output": {
					"resultWrapper": "VerifyDomainIdentityResult",
					"type": "structure",
					"required": [
						"VerificationToken"
					],
					"members": {
						"VerificationToken": {}
					}
				}
			},
			"VerifyEmailAddress": {
				"input": {
					"type": "structure",
					"required": [
						"EmailAddress"
					],
					"members": {
						"EmailAddress": {}
					}
				}
			},
			"VerifyEmailIdentity": {
				"input": {
					"type": "structure",
					"required": [
						"EmailAddress"
					],
					"members": {
						"EmailAddress": {}
					}
				},
				"output": {
					"resultWrapper": "VerifyEmailIdentityResult",
					"type": "structure",
					"members": {}
				}
			}
		},
		"shapes": {
			"S5": {
				"type": "structure",
				"required": [
					"Name"
				],
				"members": {
					"Name": {}
				}
			},
			"S9": {
				"type": "structure",
				"required": [
					"Name",
					"MatchingEventTypes"
				],
				"members": {
					"Name": {},
					"Enabled": {
						"type": "boolean"
					},
					"MatchingEventTypes": {
						"type": "list",
						"member": {}
					},
					"KinesisFirehoseDestination": {
						"type": "structure",
						"required": [
							"IAMRoleARN",
							"DeliveryStreamARN"
						],
						"members": {
							"IAMRoleARN": {},
							"DeliveryStreamARN": {}
						}
					},
					"CloudWatchDestination": {
						"type": "structure",
						"required": [
							"DimensionConfigurations"
						],
						"members": {
							"DimensionConfigurations": {
								"type": "list",
								"member": {
									"type": "structure",
									"required": [
										"DimensionName",
										"DimensionValueSource",
										"DefaultDimensionValue"
									],
									"members": {
										"DimensionName": {},
										"DimensionValueSource": {},
										"DefaultDimensionValue": {}
									}
								}
							}
						}
					}
				}
			},
			"So": {
				"type": "structure",
				"required": [
					"Name",
					"IpFilter"
				],
				"members": {
					"Name": {},
					"IpFilter": {
						"type": "structure",
						"required": [
							"Policy",
							"Cidr"
						],
						"members": {
							"Policy": {},
							"Cidr": {}
						}
					}
				}
			},
			"Sw": {
				"type": "structure",
				"required": [
					"Name"
				],
				"members": {
					"Name": {},
					"Enabled": {
						"type": "boolean"
					},
					"TlsPolicy": {},
					"Recipients": {
						"type": "list",
						"member": {}
					},
					"Actions": {
						"type": "list",
						"member": {
							"type": "structure",
							"members": {
								"S3Action": {
									"type": "structure",
									"required": [
										"BucketName"
									],
									"members": {
										"TopicArn": {},
										"BucketName": {},
										"ObjectKeyPrefix": {},
										"KmsKeyArn": {}
									}
								},
								"BounceAction": {
									"type": "structure",
									"required": [
										"SmtpReplyCode",
										"Message",
										"Sender"
									],
									"members": {
										"TopicArn": {},
										"SmtpReplyCode": {},
										"StatusCode": {},
										"Message": {},
										"Sender": {}
									}
								},
								"WorkmailAction": {
									"type": "structure",
									"required": [
										"OrganizationArn"
									],
									"members": {
										"TopicArn": {},
										"OrganizationArn": {}
									}
								},
								"LambdaAction": {
									"type": "structure",
									"required": [
										"FunctionArn"
									],
									"members": {
										"TopicArn": {},
										"FunctionArn": {},
										"InvocationType": {}
									}
								},
								"StopAction": {
									"type": "structure",
									"required": [
										"Scope"
									],
									"members": {
										"Scope": {},
										"TopicArn": {}
									}
								},
								"AddHeaderAction": {
									"type": "structure",
									"required": [
										"HeaderName",
										"HeaderValue"
									],
									"members": {
										"HeaderName": {},
										"HeaderValue": {}
									}
								},
								"SNSAction": {
									"type": "structure",
									"required": [
										"TopicArn"
									],
									"members": {
										"TopicArn": {},
										"Encoding": {}
									}
								}
							}
						}
					},
					"ScanEnabled": {
						"type": "boolean"
					}
				}
			},
			"S26": {
				"type": "structure",
				"members": {
					"Name": {},
					"CreatedTimestamp": {
						"type": "timestamp"
					}
				}
			},
			"S28": {
				"type": "list",
				"member": {
					"shape": "Sw"
				}
			},
			"S2j": {
				"type": "list",
				"member": {}
			},
			"S2o": {
				"type": "list",
				"member": {}
			},
			"S33": {
				"type": "list",
				"member": {}
			},
			"S40": {
				"type": "list",
				"member": {}
			},
			"S4c": {
				"type": "list",
				"member": {
					"type": "structure",
					"required": [
						"Name",
						"Value"
					],
					"members": {
						"Name": {},
						"Value": {}
					}
				}
			},
			"S4t": {
				"type": "structure",
				"required": [
					"Data"
				],
				"members": {
					"Data": {},
					"Charset": {}
				}
			},
			"S4x": {
				"type": "list",
				"member": {
					"type": "structure",
					"required": [
						"Name",
						"Value"
					],
					"members": {
						"Name": {},
						"Value": {}
					}
				}
			}
		}
	};

/***/ },
/* 450 */
/***/ function(module, exports) {

	module.exports = {
		"pagination": {
			"ListIdentities": {
				"input_token": "NextToken",
				"output_token": "NextToken",
				"limit_key": "MaxItems",
				"result_key": "Identities"
			},
			"ListVerifiedEmailAddresses": {
				"result_key": "VerifiedEmailAddresses"
			}
		}
	};

/***/ },
/* 451 */
/***/ function(module, exports) {

	module.exports = {
		"version": 2,
		"waiters": {
			"IdentityExists": {
				"delay": 3,
				"operation": "GetIdentityVerificationAttributes",
				"maxAttempts": 20,
				"acceptors": [
					{
						"expected": "Success",
						"matcher": "pathAll",
						"state": "success",
						"argument": "VerificationAttributes.*.VerificationStatus"
					}
				]
			}
		}
	};

/***/ },
/* 452 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['simpledb'] = {};
	AWS.SimpleDB = Service.defineService('simpledb', ['2009-04-15']);
	Object.defineProperty(apiLoader.services['simpledb'], '2009-04-15', {
	  get: function get() {
	    var model = __webpack_require__(453);
	    model.paginators = __webpack_require__(454).pagination;
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.SimpleDB;


/***/ },
/* 453 */
/***/ function(module, exports) {

	module.exports = {
		"metadata": {
			"apiVersion": "2009-04-15",
			"endpointPrefix": "sdb",
			"serviceFullName": "Amazon SimpleDB",
			"signatureVersion": "v2",
			"xmlNamespace": "http://sdb.amazonaws.com/doc/2009-04-15/",
			"protocol": "query"
		},
		"operations": {
			"BatchDeleteAttributes": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName",
						"Items"
					],
					"members": {
						"DomainName": {},
						"Items": {
							"type": "list",
							"member": {
								"locationName": "Item",
								"type": "structure",
								"required": [
									"Name"
								],
								"members": {
									"Name": {
										"locationName": "ItemName"
									},
									"Attributes": {
										"shape": "S5"
									}
								}
							},
							"flattened": true
						}
					}
				}
			},
			"BatchPutAttributes": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName",
						"Items"
					],
					"members": {
						"DomainName": {},
						"Items": {
							"type": "list",
							"member": {
								"locationName": "Item",
								"type": "structure",
								"required": [
									"Name",
									"Attributes"
								],
								"members": {
									"Name": {
										"locationName": "ItemName"
									},
									"Attributes": {
										"shape": "Sa"
									}
								}
							},
							"flattened": true
						}
					}
				}
			},
			"CreateDomain": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName"
					],
					"members": {
						"DomainName": {}
					}
				}
			},
			"DeleteAttributes": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName",
						"ItemName"
					],
					"members": {
						"DomainName": {},
						"ItemName": {},
						"Attributes": {
							"shape": "S5"
						},
						"Expected": {
							"shape": "Sf"
						}
					}
				}
			},
			"DeleteDomain": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName"
					],
					"members": {
						"DomainName": {}
					}
				}
			},
			"DomainMetadata": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName"
					],
					"members": {
						"DomainName": {}
					}
				},
				"output": {
					"resultWrapper": "DomainMetadataResult",
					"type": "structure",
					"members": {
						"ItemCount": {
							"type": "integer"
						},
						"ItemNamesSizeBytes": {
							"type": "long"
						},
						"AttributeNameCount": {
							"type": "integer"
						},
						"AttributeNamesSizeBytes": {
							"type": "long"
						},
						"AttributeValueCount": {
							"type": "integer"
						},
						"AttributeValuesSizeBytes": {
							"type": "long"
						},
						"Timestamp": {
							"type": "integer"
						}
					}
				}
			},
			"GetAttributes": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName",
						"ItemName"
					],
					"members": {
						"DomainName": {},
						"ItemName": {},
						"AttributeNames": {
							"type": "list",
							"member": {
								"locationName": "AttributeName"
							},
							"flattened": true
						},
						"ConsistentRead": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"resultWrapper": "GetAttributesResult",
					"type": "structure",
					"members": {
						"Attributes": {
							"shape": "So"
						}
					}
				}
			},
			"ListDomains": {
				"input": {
					"type": "structure",
					"members": {
						"MaxNumberOfDomains": {
							"type": "integer"
						},
						"NextToken": {}
					}
				},
				"output": {
					"resultWrapper": "ListDomainsResult",
					"type": "structure",
					"members": {
						"DomainNames": {
							"type": "list",
							"member": {
								"locationName": "DomainName"
							},
							"flattened": true
						},
						"NextToken": {}
					}
				}
			},
			"PutAttributes": {
				"input": {
					"type": "structure",
					"required": [
						"DomainName",
						"ItemName",
						"Attributes"
					],
					"members": {
						"DomainName": {},
						"ItemName": {},
						"Attributes": {
							"shape": "Sa"
						},
						"Expected": {
							"shape": "Sf"
						}
					}
				}
			},
			"Select": {
				"input": {
					"type": "structure",
					"required": [
						"SelectExpression"
					],
					"members": {
						"SelectExpression": {},
						"NextToken": {},
						"ConsistentRead": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"resultWrapper": "SelectResult",
					"type": "structure",
					"members": {
						"Items": {
							"type": "list",
							"member": {
								"locationName": "Item",
								"type": "structure",
								"required": [
									"Name",
									"Attributes"
								],
								"members": {
									"Name": {},
									"AlternateNameEncoding": {},
									"Attributes": {
										"shape": "So"
									}
								}
							},
							"flattened": true
						},
						"NextToken": {}
					}
				}
			}
		},
		"shapes": {
			"S5": {
				"type": "list",
				"member": {
					"locationName": "Attribute",
					"type": "structure",
					"required": [
						"Name"
					],
					"members": {
						"Name": {},
						"Value": {}
					}
				},
				"flattened": true
			},
			"Sa": {
				"type": "list",
				"member": {
					"locationName": "Attribute",
					"type": "structure",
					"required": [
						"Name",
						"Value"
					],
					"members": {
						"Name": {},
						"Value": {},
						"Replace": {
							"type": "boolean"
						}
					}
				},
				"flattened": true
			},
			"Sf": {
				"type": "structure",
				"members": {
					"Name": {},
					"Value": {},
					"Exists": {
						"type": "boolean"
					}
				}
			},
			"So": {
				"type": "list",
				"member": {
					"locationName": "Attribute",
					"type": "structure",
					"required": [
						"Name",
						"Value"
					],
					"members": {
						"Name": {},
						"AlternateNameEncoding": {},
						"Value": {},
						"AlternateValueEncoding": {}
					}
				},
				"flattened": true
			}
		}
	};

/***/ },
/* 454 */
/***/ function(module, exports) {

	module.exports = {
		"pagination": {
			"ListDomains": {
				"input_token": "NextToken",
				"output_token": "NextToken",
				"limit_key": "MaxNumberOfDomains",
				"result_key": "DomainNames"
			},
			"Select": {
				"input_token": "NextToken",
				"output_token": "NextToken",
				"result_key": "Items"
			}
		}
	};

/***/ },
/* 455 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['sms'] = {};
	AWS.SMS = Service.defineService('sms', ['2016-10-24']);
	Object.defineProperty(apiLoader.services['sms'], '2016-10-24', {
	  get: function get() {
	    var model = __webpack_require__(456);
	    model.paginators = __webpack_require__(457).pagination;
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.SMS;


/***/ },
/* 456 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2016-10-24",
			"endpointPrefix": "sms",
			"jsonVersion": "1.1",
			"protocol": "json",
			"serviceAbbreviation": "SMS",
			"serviceFullName": "AWS Server Migration Service",
			"signatureVersion": "v4",
			"targetPrefix": "AWSServerMigrationService_V2016_10_24"
		},
		"operations": {
			"CreateReplicationJob": {
				"input": {
					"type": "structure",
					"required": [
						"serverId",
						"seedReplicationTime",
						"frequency"
					],
					"members": {
						"serverId": {},
						"seedReplicationTime": {
							"type": "timestamp"
						},
						"frequency": {
							"type": "integer"
						},
						"licenseType": {},
						"roleName": {},
						"description": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"replicationJobId": {}
					}
				}
			},
			"DeleteReplicationJob": {
				"input": {
					"type": "structure",
					"required": [
						"replicationJobId"
					],
					"members": {
						"replicationJobId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"DeleteServerCatalog": {
				"input": {
					"type": "structure",
					"members": {}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"DisassociateConnector": {
				"input": {
					"type": "structure",
					"required": [
						"connectorId"
					],
					"members": {
						"connectorId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"GetConnectors": {
				"input": {
					"type": "structure",
					"members": {
						"nextToken": {},
						"maxResults": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"connectorList": {
							"type": "list",
							"member": {
								"locationName": "item",
								"type": "structure",
								"members": {
									"connectorId": {},
									"version": {},
									"status": {},
									"capabilityList": {
										"type": "list",
										"member": {
											"locationName": "item"
										}
									},
									"vmManagerName": {},
									"vmManagerType": {},
									"vmManagerId": {},
									"ipAddress": {},
									"macAddress": {},
									"associatedOn": {
										"type": "timestamp"
									}
								}
							}
						},
						"nextToken": {}
					}
				}
			},
			"GetReplicationJobs": {
				"input": {
					"type": "structure",
					"members": {
						"replicationJobId": {},
						"nextToken": {},
						"maxResults": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"replicationJobList": {
							"type": "list",
							"member": {
								"shape": "Sz",
								"locationName": "item"
							}
						},
						"nextToken": {}
					}
				}
			},
			"GetReplicationRuns": {
				"input": {
					"type": "structure",
					"required": [
						"replicationJobId"
					],
					"members": {
						"replicationJobId": {},
						"nextToken": {},
						"maxResults": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"replicationJob": {
							"shape": "Sz"
						},
						"replicationRunList": {
							"shape": "S19"
						},
						"nextToken": {}
					}
				}
			},
			"GetServers": {
				"input": {
					"type": "structure",
					"members": {
						"nextToken": {},
						"maxResults": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"lastModifiedOn": {
							"type": "timestamp"
						},
						"serverCatalogStatus": {},
						"serverList": {
							"type": "list",
							"member": {
								"locationName": "item",
								"type": "structure",
								"members": {
									"serverId": {},
									"serverType": {},
									"vmServer": {
										"shape": "S11"
									},
									"replicationJobId": {},
									"replicationJobTerminated": {
										"type": "boolean"
									}
								}
							}
						},
						"nextToken": {}
					}
				}
			},
			"ImportServerCatalog": {
				"input": {
					"type": "structure",
					"members": {}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"StartOnDemandReplicationRun": {
				"input": {
					"type": "structure",
					"required": [
						"replicationJobId"
					],
					"members": {
						"replicationJobId": {},
						"description": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"replicationRunId": {}
					}
				}
			},
			"UpdateReplicationJob": {
				"input": {
					"type": "structure",
					"required": [
						"replicationJobId"
					],
					"members": {
						"replicationJobId": {},
						"frequency": {
							"type": "integer"
						},
						"nextReplicationRunStartTime": {
							"type": "timestamp"
						},
						"licenseType": {},
						"roleName": {},
						"description": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			}
		},
		"shapes": {
			"Sz": {
				"type": "structure",
				"members": {
					"replicationJobId": {},
					"serverId": {},
					"serverType": {},
					"vmServer": {
						"shape": "S11"
					},
					"seedReplicationTime": {
						"type": "timestamp"
					},
					"frequency": {
						"type": "integer"
					},
					"nextReplicationRunStartTime": {
						"type": "timestamp"
					},
					"licenseType": {},
					"roleName": {},
					"latestAmiId": {},
					"state": {},
					"statusMessage": {},
					"description": {},
					"replicationRunList": {
						"shape": "S19"
					}
				}
			},
			"S11": {
				"type": "structure",
				"members": {
					"vmServerAddress": {
						"type": "structure",
						"members": {
							"vmManagerId": {},
							"vmId": {}
						}
					},
					"vmName": {},
					"vmManagerName": {},
					"vmManagerType": {},
					"vmPath": {}
				}
			},
			"S19": {
				"type": "list",
				"member": {
					"locationName": "item",
					"type": "structure",
					"members": {
						"replicationRunId": {},
						"state": {},
						"type": {},
						"statusMessage": {},
						"amiId": {},
						"scheduledStartTime": {
							"type": "timestamp"
						},
						"completedTime": {
							"type": "timestamp"
						},
						"description": {}
					}
				}
			}
		}
	};

/***/ },
/* 457 */
/***/ function(module, exports) {

	module.exports = {
		"pagination": {
			"GetReplicationJobs": {
				"input_token": "nextToken",
				"output_token": "nextToken",
				"limit_key": "maxResults",
				"result_key": "replicationJobList"
			},
			"GetReplicationRuns": {
				"input_token": "nextToken",
				"output_token": "nextToken",
				"limit_key": "maxResults",
				"result_key": "replicationRunList"
			},
			"GetConnectors": {
				"input_token": "nextToken",
				"output_token": "nextToken",
				"limit_key": "maxResults",
				"result_key": "connectorList"
			},
			"GetServers": {
				"input_token": "nextToken",
				"output_token": "nextToken",
				"limit_key": "maxResults",
				"result_key": "serverList"
			}
		}
	};

/***/ },
/* 458 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['snowball'] = {};
	AWS.Snowball = Service.defineService('snowball', ['2016-06-30']);
	Object.defineProperty(apiLoader.services['snowball'], '2016-06-30', {
	  get: function get() {
	    var model = __webpack_require__(459);
	    model.paginators = __webpack_require__(460).pagination;
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.Snowball;


/***/ },
/* 459 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2016-06-30",
			"endpointPrefix": "snowball",
			"jsonVersion": "1.1",
			"protocol": "json",
			"serviceAbbreviation": "Amazon Snowball",
			"serviceFullName": "Amazon Import/Export Snowball",
			"signatureVersion": "v4",
			"targetPrefix": "AWSIESnowballJobManagementService"
		},
		"operations": {
			"CancelJob": {
				"input": {
					"type": "structure",
					"required": [
						"JobId"
					],
					"members": {
						"JobId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"CreateAddress": {
				"input": {
					"type": "structure",
					"required": [
						"Address"
					],
					"members": {
						"Address": {
							"shape": "S5"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"AddressId": {}
					}
				}
			},
			"CreateJob": {
				"input": {
					"type": "structure",
					"required": [
						"JobType",
						"Resources",
						"AddressId",
						"RoleARN",
						"ShippingOption"
					],
					"members": {
						"JobType": {},
						"Resources": {
							"shape": "Sb"
						},
						"Description": {},
						"AddressId": {},
						"KmsKeyARN": {},
						"RoleARN": {},
						"SnowballCapacityPreference": {},
						"ShippingOption": {},
						"Notification": {
							"shape": "Sk"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"JobId": {}
					}
				}
			},
			"DescribeAddress": {
				"input": {
					"type": "structure",
					"required": [
						"AddressId"
					],
					"members": {
						"AddressId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Address": {
							"shape": "S5"
						}
					}
				}
			},
			"DescribeAddresses": {
				"input": {
					"type": "structure",
					"members": {
						"MaxResults": {
							"type": "integer"
						},
						"NextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Addresses": {
							"type": "list",
							"member": {
								"shape": "S5"
							}
						},
						"NextToken": {}
					}
				}
			},
			"DescribeJob": {
				"input": {
					"type": "structure",
					"required": [
						"JobId"
					],
					"members": {
						"JobId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"JobMetadata": {
							"shape": "Sy"
						},
						"SubJobMetadata": {
							"type": "list",
							"member": {
								"shape": "Sy"
							}
						}
					}
				}
			},
			"GetJobManifest": {
				"input": {
					"type": "structure",
					"required": [
						"JobId"
					],
					"members": {
						"JobId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ManifestURI": {}
					}
				}
			},
			"GetJobUnlockCode": {
				"input": {
					"type": "structure",
					"required": [
						"JobId"
					],
					"members": {
						"JobId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"UnlockCode": {}
					}
				}
			},
			"GetSnowballUsage": {
				"input": {
					"type": "structure",
					"members": {}
				},
				"output": {
					"type": "structure",
					"members": {
						"SnowballLimit": {
							"type": "integer"
						},
						"SnowballsInUse": {
							"type": "integer"
						}
					}
				}
			},
			"ListJobs": {
				"input": {
					"type": "structure",
					"members": {
						"MaxResults": {
							"type": "integer"
						},
						"NextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"JobListEntries": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"JobId": {},
									"JobState": {},
									"IsMaster": {
										"type": "boolean"
									}
								}
							}
						},
						"NextToken": {}
					}
				}
			},
			"UpdateJob": {
				"input": {
					"type": "structure",
					"required": [
						"JobId"
					],
					"members": {
						"JobId": {},
						"RoleARN": {},
						"Notification": {
							"shape": "Sk"
						},
						"Resources": {
							"shape": "Sb"
						},
						"AddressId": {},
						"ShippingOption": {},
						"Description": {},
						"SnowballCapacityPreference": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			}
		},
		"shapes": {
			"S5": {
				"type": "structure",
				"members": {
					"AddressId": {},
					"Name": {},
					"Company": {},
					"Street1": {},
					"Street2": {},
					"Street3": {},
					"City": {},
					"StateOrProvince": {},
					"PrefectureOrDistrict": {},
					"Landmark": {},
					"Country": {},
					"PostalCode": {},
					"PhoneNumber": {}
				}
			},
			"Sb": {
				"type": "structure",
				"members": {
					"S3Resources": {
						"type": "list",
						"member": {
							"type": "structure",
							"members": {
								"BucketArn": {},
								"KeyRange": {
									"type": "structure",
									"members": {
										"BeginMarker": {},
										"EndMarker": {}
									}
								}
							}
						}
					}
				}
			},
			"Sk": {
				"type": "structure",
				"members": {
					"SnsTopicARN": {},
					"JobStatesToNotify": {
						"type": "list",
						"member": {}
					},
					"NotifyAll": {
						"type": "boolean"
					}
				}
			},
			"Sy": {
				"type": "structure",
				"members": {
					"JobId": {},
					"JobState": {},
					"JobType": {},
					"CreationDate": {
						"type": "timestamp"
					},
					"Resources": {
						"shape": "Sb"
					},
					"Description": {},
					"KmsKeyARN": {},
					"RoleARN": {},
					"AddressId": {},
					"ShippingDetails": {
						"type": "structure",
						"members": {
							"ShippingOption": {},
							"InboundShipment": {
								"shape": "S11"
							},
							"OutboundShipment": {
								"shape": "S11"
							}
						}
					},
					"SnowballCapacityPreference": {},
					"Notification": {
						"shape": "Sk"
					},
					"DataTransferProgress": {
						"type": "structure",
						"members": {
							"BytesTransferred": {
								"type": "long"
							},
							"ObjectsTransferred": {
								"type": "long"
							},
							"TotalBytes": {
								"type": "long"
							},
							"TotalObjects": {
								"type": "long"
							}
						}
					},
					"JobLogInfo": {
						"type": "structure",
						"members": {
							"JobCompletionReportURI": {},
							"JobSuccessLogURI": {},
							"JobFailureLogURI": {}
						}
					}
				}
			},
			"S11": {
				"type": "structure",
				"members": {
					"Status": {},
					"TrackingNumber": {}
				}
			}
		}
	};

/***/ },
/* 460 */
/***/ function(module, exports) {

	module.exports = {
		"pagination": {
			"ListJobs": {
				"limit_key": "MaxResults",
				"output_token": "NextToken",
				"input_token": "NextToken",
				"result_key": "JobListEntries"
			},
			"DescribeAddresses": {
				"limit_key": "MaxResults",
				"output_token": "NextToken",
				"input_token": "NextToken",
				"result_key": "Addresses"
			}
		}
	};

/***/ },
/* 461 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['sns'] = {};
	AWS.SNS = Service.defineService('sns', ['2010-03-31']);
	Object.defineProperty(apiLoader.services['sns'], '2010-03-31', {
	  get: function get() {
	    var model = __webpack_require__(462);
	    model.paginators = __webpack_require__(463).pagination;
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.SNS;


/***/ },
/* 462 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2010-03-31",
			"endpointPrefix": "sns",
			"protocol": "query",
			"serviceAbbreviation": "Amazon SNS",
			"serviceFullName": "Amazon Simple Notification Service",
			"signatureVersion": "v4",
			"xmlNamespace": "http://sns.amazonaws.com/doc/2010-03-31/"
		},
		"operations": {
			"AddPermission": {
				"input": {
					"type": "structure",
					"required": [
						"TopicArn",
						"Label",
						"AWSAccountId",
						"ActionName"
					],
					"members": {
						"TopicArn": {},
						"Label": {},
						"AWSAccountId": {
							"type": "list",
							"member": {}
						},
						"ActionName": {
							"type": "list",
							"member": {}
						}
					}
				}
			},
			"CheckIfPhoneNumberIsOptedOut": {
				"input": {
					"type": "structure",
					"required": [
						"phoneNumber"
					],
					"members": {
						"phoneNumber": {}
					}
				},
				"output": {
					"resultWrapper": "CheckIfPhoneNumberIsOptedOutResult",
					"type": "structure",
					"members": {
						"isOptedOut": {
							"type": "boolean"
						}
					}
				}
			},
			"ConfirmSubscription": {
				"input": {
					"type": "structure",
					"required": [
						"TopicArn",
						"Token"
					],
					"members": {
						"TopicArn": {},
						"Token": {},
						"AuthenticateOnUnsubscribe": {}
					}
				},
				"output": {
					"resultWrapper": "ConfirmSubscriptionResult",
					"type": "structure",
					"members": {
						"SubscriptionArn": {}
					}
				}
			},
			"CreatePlatformApplication": {
				"input": {
					"type": "structure",
					"required": [
						"Name",
						"Platform",
						"Attributes"
					],
					"members": {
						"Name": {},
						"Platform": {},
						"Attributes": {
							"shape": "Sj"
						}
					}
				},
				"output": {
					"resultWrapper": "CreatePlatformApplicationResult",
					"type": "structure",
					"members": {
						"PlatformApplicationArn": {}
					}
				}
			},
			"CreatePlatformEndpoint": {
				"input": {
					"type": "structure",
					"required": [
						"PlatformApplicationArn",
						"Token"
					],
					"members": {
						"PlatformApplicationArn": {},
						"Token": {},
						"CustomUserData": {},
						"Attributes": {
							"shape": "Sj"
						}
					}
				},
				"output": {
					"resultWrapper": "CreatePlatformEndpointResult",
					"type": "structure",
					"members": {
						"EndpointArn": {}
					}
				}
			},
			"CreateTopic": {
				"input": {
					"type": "structure",
					"required": [
						"Name"
					],
					"members": {
						"Name": {}
					}
				},
				"output": {
					"resultWrapper": "CreateTopicResult",
					"type": "structure",
					"members": {
						"TopicArn": {}
					}
				}
			},
			"DeleteEndpoint": {
				"input": {
					"type": "structure",
					"required": [
						"EndpointArn"
					],
					"members": {
						"EndpointArn": {}
					}
				}
			},
			"DeletePlatformApplication": {
				"input": {
					"type": "structure",
					"required": [
						"PlatformApplicationArn"
					],
					"members": {
						"PlatformApplicationArn": {}
					}
				}
			},
			"DeleteTopic": {
				"input": {
					"type": "structure",
					"required": [
						"TopicArn"
					],
					"members": {
						"TopicArn": {}
					}
				}
			},
			"GetEndpointAttributes": {
				"input": {
					"type": "structure",
					"required": [
						"EndpointArn"
					],
					"members": {
						"EndpointArn": {}
					}
				},
				"output": {
					"resultWrapper": "GetEndpointAttributesResult",
					"type": "structure",
					"members": {
						"Attributes": {
							"shape": "Sj"
						}
					}
				}
			},
			"GetPlatformApplicationAttributes": {
				"input": {
					"type": "structure",
					"required": [
						"PlatformApplicationArn"
					],
					"members": {
						"PlatformApplicationArn": {}
					}
				},
				"output": {
					"resultWrapper": "GetPlatformApplicationAttributesResult",
					"type": "structure",
					"members": {
						"Attributes": {
							"shape": "Sj"
						}
					}
				}
			},
			"GetSMSAttributes": {
				"input": {
					"type": "structure",
					"members": {
						"attributes": {
							"type": "list",
							"member": {}
						}
					}
				},
				"output": {
					"resultWrapper": "GetSMSAttributesResult",
					"type": "structure",
					"members": {
						"attributes": {
							"shape": "Sj"
						}
					}
				}
			},
			"GetSubscriptionAttributes": {
				"input": {
					"type": "structure",
					"required": [
						"SubscriptionArn"
					],
					"members": {
						"SubscriptionArn": {}
					}
				},
				"output": {
					"resultWrapper": "GetSubscriptionAttributesResult",
					"type": "structure",
					"members": {
						"Attributes": {
							"type": "map",
							"key": {},
							"value": {}
						}
					}
				}
			},
			"GetTopicAttributes": {
				"input": {
					"type": "structure",
					"required": [
						"TopicArn"
					],
					"members": {
						"TopicArn": {}
					}
				},
				"output": {
					"resultWrapper": "GetTopicAttributesResult",
					"type": "structure",
					"members": {
						"Attributes": {
							"type": "map",
							"key": {},
							"value": {}
						}
					}
				}
			},
			"ListEndpointsByPlatformApplication": {
				"input": {
					"type": "structure",
					"required": [
						"PlatformApplicationArn"
					],
					"members": {
						"PlatformApplicationArn": {},
						"NextToken": {}
					}
				},
				"output": {
					"resultWrapper": "ListEndpointsByPlatformApplicationResult",
					"type": "structure",
					"members": {
						"Endpoints": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"EndpointArn": {},
									"Attributes": {
										"shape": "Sj"
									}
								}
							}
						},
						"NextToken": {}
					}
				}
			},
			"ListPhoneNumbersOptedOut": {
				"input": {
					"type": "structure",
					"members": {
						"nextToken": {}
					}
				},
				"output": {
					"resultWrapper": "ListPhoneNumbersOptedOutResult",
					"type": "structure",
					"members": {
						"phoneNumbers": {
							"type": "list",
							"member": {}
						},
						"nextToken": {}
					}
				}
			},
			"ListPlatformApplications": {
				"input": {
					"type": "structure",
					"members": {
						"NextToken": {}
					}
				},
				"output": {
					"resultWrapper": "ListPlatformApplicationsResult",
					"type": "structure",
					"members": {
						"PlatformApplications": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"PlatformApplicationArn": {},
									"Attributes": {
										"shape": "Sj"
									}
								}
							}
						},
						"NextToken": {}
					}
				}
			},
			"ListSubscriptions": {
				"input": {
					"type": "structure",
					"members": {
						"NextToken": {}
					}
				},
				"output": {
					"resultWrapper": "ListSubscriptionsResult",
					"type": "structure",
					"members": {
						"Subscriptions": {
							"shape": "S1n"
						},
						"NextToken": {}
					}
				}
			},
			"ListSubscriptionsByTopic": {
				"input": {
					"type": "structure",
					"required": [
						"TopicArn"
					],
					"members": {
						"TopicArn": {},
						"NextToken": {}
					}
				},
				"output": {
					"resultWrapper": "ListSubscriptionsByTopicResult",
					"type": "structure",
					"members": {
						"Subscriptions": {
							"shape": "S1n"
						},
						"NextToken": {}
					}
				}
			},
			"ListTopics": {
				"input": {
					"type": "structure",
					"members": {
						"NextToken": {}
					}
				},
				"output": {
					"resultWrapper": "ListTopicsResult",
					"type": "structure",
					"members": {
						"Topics": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"TopicArn": {}
								}
							}
						},
						"NextToken": {}
					}
				}
			},
			"OptInPhoneNumber": {
				"input": {
					"type": "structure",
					"required": [
						"phoneNumber"
					],
					"members": {
						"phoneNumber": {}
					}
				},
				"output": {
					"resultWrapper": "OptInPhoneNumberResult",
					"type": "structure",
					"members": {}
				}
			},
			"Publish": {
				"input": {
					"type": "structure",
					"required": [
						"Message"
					],
					"members": {
						"TopicArn": {},
						"TargetArn": {},
						"PhoneNumber": {},
						"Message": {},
						"Subject": {},
						"MessageStructure": {},
						"MessageAttributes": {
							"type": "map",
							"key": {
								"locationName": "Name"
							},
							"value": {
								"locationName": "Value",
								"type": "structure",
								"required": [
									"DataType"
								],
								"members": {
									"DataType": {},
									"StringValue": {},
									"BinaryValue": {
										"type": "blob"
									}
								}
							}
						}
					}
				},
				"output": {
					"resultWrapper": "PublishResult",
					"type": "structure",
					"members": {
						"MessageId": {}
					}
				}
			},
			"RemovePermission": {
				"input": {
					"type": "structure",
					"required": [
						"TopicArn",
						"Label"
					],
					"members": {
						"TopicArn": {},
						"Label": {}
					}
				}
			},
			"SetEndpointAttributes": {
				"input": {
					"type": "structure",
					"required": [
						"EndpointArn",
						"Attributes"
					],
					"members": {
						"EndpointArn": {},
						"Attributes": {
							"shape": "Sj"
						}
					}
				}
			},
			"SetPlatformApplicationAttributes": {
				"input": {
					"type": "structure",
					"required": [
						"PlatformApplicationArn",
						"Attributes"
					],
					"members": {
						"PlatformApplicationArn": {},
						"Attributes": {
							"shape": "Sj"
						}
					}
				}
			},
			"SetSMSAttributes": {
				"input": {
					"type": "structure",
					"required": [
						"attributes"
					],
					"members": {
						"attributes": {
							"shape": "Sj"
						}
					}
				},
				"output": {
					"resultWrapper": "SetSMSAttributesResult",
					"type": "structure",
					"members": {}
				}
			},
			"SetSubscriptionAttributes": {
				"input": {
					"type": "structure",
					"required": [
						"SubscriptionArn",
						"AttributeName"
					],
					"members": {
						"SubscriptionArn": {},
						"AttributeName": {},
						"AttributeValue": {}
					}
				}
			},
			"SetTopicAttributes": {
				"input": {
					"type": "structure",
					"required": [
						"TopicArn",
						"AttributeName"
					],
					"members": {
						"TopicArn": {},
						"AttributeName": {},
						"AttributeValue": {}
					}
				}
			},
			"Subscribe": {
				"input": {
					"type": "structure",
					"required": [
						"TopicArn",
						"Protocol"
					],
					"members": {
						"TopicArn": {},
						"Protocol": {},
						"Endpoint": {}
					}
				},
				"output": {
					"resultWrapper": "SubscribeResult",
					"type": "structure",
					"members": {
						"SubscriptionArn": {}
					}
				}
			},
			"Unsubscribe": {
				"input": {
					"type": "structure",
					"required": [
						"SubscriptionArn"
					],
					"members": {
						"SubscriptionArn": {}
					}
				}
			}
		},
		"shapes": {
			"Sj": {
				"type": "map",
				"key": {},
				"value": {}
			},
			"S1n": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"SubscriptionArn": {},
						"Owner": {},
						"Protocol": {},
						"Endpoint": {},
						"TopicArn": {}
					}
				}
			}
		}
	};

/***/ },
/* 463 */
/***/ function(module, exports) {

	module.exports = {
		"pagination": {
			"ListEndpointsByPlatformApplication": {
				"input_token": "NextToken",
				"output_token": "NextToken",
				"result_key": "Endpoints"
			},
			"ListPlatformApplications": {
				"input_token": "NextToken",
				"output_token": "NextToken",
				"result_key": "PlatformApplications"
			},
			"ListSubscriptions": {
				"input_token": "NextToken",
				"output_token": "NextToken",
				"result_key": "Subscriptions"
			},
			"ListSubscriptionsByTopic": {
				"input_token": "NextToken",
				"output_token": "NextToken",
				"result_key": "Subscriptions"
			},
			"ListTopics": {
				"input_token": "NextToken",
				"output_token": "NextToken",
				"result_key": "Topics"
			}
		}
	};

/***/ },
/* 464 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['sqs'] = {};
	AWS.SQS = Service.defineService('sqs', ['2012-11-05']);
	__webpack_require__(465);
	Object.defineProperty(apiLoader.services['sqs'], '2012-11-05', {
	  get: function get() {
	    var model = __webpack_require__(466);
	    model.paginators = __webpack_require__(467).pagination;
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.SQS;


/***/ },
/* 465 */
/***/ function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(93);

	AWS.util.update(AWS.SQS.prototype, {
	  /**
	   * @api private
	   */
	  setupRequestListeners: function setupRequestListeners(request) {
	    request.addListener('build', this.buildEndpoint);

	    if (request.service.config.computeChecksums) {
	      if (request.operation === 'sendMessage') {
	        request.addListener('extractData', this.verifySendMessageChecksum);
	      } else if (request.operation === 'sendMessageBatch') {
	        request.addListener('extractData', this.verifySendMessageBatchChecksum);
	      } else if (request.operation === 'receiveMessage') {
	        request.addListener('extractData', this.verifyReceiveMessageChecksum);
	      }
	    }
	  },

	  /**
	   * @api private
	   */
	  verifySendMessageChecksum: function verifySendMessageChecksum(response) {
	    if (!response.data) return;

	    var md5 = response.data.MD5OfMessageBody;
	    var body = this.params.MessageBody;
	    var calculatedMd5 = this.service.calculateChecksum(body);
	    if (calculatedMd5 !== md5) {
	      var msg = 'Got "' + response.data.MD5OfMessageBody +
	        '", expecting "' + calculatedMd5 + '".';
	      this.service.throwInvalidChecksumError(response,
	        [response.data.MessageId], msg);
	    }
	  },

	  /**
	   * @api private
	   */
	  verifySendMessageBatchChecksum: function verifySendMessageBatchChecksum(response) {
	    if (!response.data) return;

	    var service = this.service;
	    var entries = {};
	    var errors = [];
	    var messageIds = [];
	    AWS.util.arrayEach(response.data.Successful, function (entry) {
	      entries[entry.Id] = entry;
	    });
	    AWS.util.arrayEach(this.params.Entries, function (entry) {
	      if (entries[entry.Id]) {
	        var md5 = entries[entry.Id].MD5OfMessageBody;
	        var body = entry.MessageBody;
	        if (!service.isChecksumValid(md5, body)) {
	          errors.push(entry.Id);
	          messageIds.push(entries[entry.Id].MessageId);
	        }
	      }
	    });

	    if (errors.length > 0) {
	      service.throwInvalidChecksumError(response, messageIds,
	        'Invalid messages: ' + errors.join(', '));
	    }
	  },

	  /**
	   * @api private
	   */
	  verifyReceiveMessageChecksum: function verifyReceiveMessageChecksum(response) {
	    if (!response.data) return;

	    var service = this.service;
	    var messageIds = [];
	    AWS.util.arrayEach(response.data.Messages, function(message) {
	      var md5 = message.MD5OfBody;
	      var body = message.Body;
	      if (!service.isChecksumValid(md5, body)) {
	        messageIds.push(message.MessageId);
	      }
	    });

	    if (messageIds.length > 0) {
	      service.throwInvalidChecksumError(response, messageIds,
	        'Invalid messages: ' + messageIds.join(', '));
	    }
	  },

	  /**
	   * @api private
	   */
	  throwInvalidChecksumError: function throwInvalidChecksumError(response, ids, message) {
	    response.error = AWS.util.error(new Error(), {
	      retryable: true,
	      code: 'InvalidChecksum',
	      messageIds: ids,
	      message: response.request.operation +
	               ' returned an invalid MD5 response. ' + message
	    });
	  },

	  /**
	   * @api private
	   */
	  isChecksumValid: function isChecksumValid(checksum, data) {
	    return this.calculateChecksum(data) === checksum;
	  },

	  /**
	   * @api private
	   */
	  calculateChecksum: function calculateChecksum(data) {
	    return AWS.util.crypto.md5(data, 'hex');
	  },

	  /**
	   * @api private
	   */
	  buildEndpoint: function buildEndpoint(request) {
	    var url = request.httpRequest.params.QueueUrl;
	    if (url) {
	      request.httpRequest.endpoint = new AWS.Endpoint(url);

	      // signature version 4 requires the region name to be set,
	      // sqs queue urls contain the region name
	      var matches = request.httpRequest.endpoint.host.match(/^sqs\.(.+?)\./);
	      if (matches) request.httpRequest.region = matches[1];
	    }
	  }
	});


/***/ },
/* 466 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2012-11-05",
			"endpointPrefix": "sqs",
			"protocol": "query",
			"serviceAbbreviation": "Amazon SQS",
			"serviceFullName": "Amazon Simple Queue Service",
			"signatureVersion": "v4",
			"xmlNamespace": "http://queue.amazonaws.com/doc/2012-11-05/"
		},
		"operations": {
			"AddPermission": {
				"input": {
					"type": "structure",
					"required": [
						"QueueUrl",
						"Label",
						"AWSAccountIds",
						"Actions"
					],
					"members": {
						"QueueUrl": {},
						"Label": {},
						"AWSAccountIds": {
							"type": "list",
							"member": {
								"locationName": "AWSAccountId"
							},
							"flattened": true
						},
						"Actions": {
							"type": "list",
							"member": {
								"locationName": "ActionName"
							},
							"flattened": true
						}
					}
				}
			},
			"ChangeMessageVisibility": {
				"input": {
					"type": "structure",
					"required": [
						"QueueUrl",
						"ReceiptHandle",
						"VisibilityTimeout"
					],
					"members": {
						"QueueUrl": {},
						"ReceiptHandle": {},
						"VisibilityTimeout": {
							"type": "integer"
						}
					}
				}
			},
			"ChangeMessageVisibilityBatch": {
				"input": {
					"type": "structure",
					"required": [
						"QueueUrl",
						"Entries"
					],
					"members": {
						"QueueUrl": {},
						"Entries": {
							"type": "list",
							"member": {
								"locationName": "ChangeMessageVisibilityBatchRequestEntry",
								"type": "structure",
								"required": [
									"Id",
									"ReceiptHandle"
								],
								"members": {
									"Id": {},
									"ReceiptHandle": {},
									"VisibilityTimeout": {
										"type": "integer"
									}
								}
							},
							"flattened": true
						}
					}
				},
				"output": {
					"resultWrapper": "ChangeMessageVisibilityBatchResult",
					"type": "structure",
					"required": [
						"Successful",
						"Failed"
					],
					"members": {
						"Successful": {
							"type": "list",
							"member": {
								"locationName": "ChangeMessageVisibilityBatchResultEntry",
								"type": "structure",
								"required": [
									"Id"
								],
								"members": {
									"Id": {}
								}
							},
							"flattened": true
						},
						"Failed": {
							"shape": "Sd"
						}
					}
				}
			},
			"CreateQueue": {
				"input": {
					"type": "structure",
					"required": [
						"QueueName"
					],
					"members": {
						"QueueName": {},
						"Attributes": {
							"shape": "Sh",
							"locationName": "Attribute"
						}
					}
				},
				"output": {
					"resultWrapper": "CreateQueueResult",
					"type": "structure",
					"members": {
						"QueueUrl": {}
					}
				}
			},
			"DeleteMessage": {
				"input": {
					"type": "structure",
					"required": [
						"QueueUrl",
						"ReceiptHandle"
					],
					"members": {
						"QueueUrl": {},
						"ReceiptHandle": {}
					}
				}
			},
			"DeleteMessageBatch": {
				"input": {
					"type": "structure",
					"required": [
						"QueueUrl",
						"Entries"
					],
					"members": {
						"QueueUrl": {},
						"Entries": {
							"type": "list",
							"member": {
								"locationName": "DeleteMessageBatchRequestEntry",
								"type": "structure",
								"required": [
									"Id",
									"ReceiptHandle"
								],
								"members": {
									"Id": {},
									"ReceiptHandle": {}
								}
							},
							"flattened": true
						}
					}
				},
				"output": {
					"resultWrapper": "DeleteMessageBatchResult",
					"type": "structure",
					"required": [
						"Successful",
						"Failed"
					],
					"members": {
						"Successful": {
							"type": "list",
							"member": {
								"locationName": "DeleteMessageBatchResultEntry",
								"type": "structure",
								"required": [
									"Id"
								],
								"members": {
									"Id": {}
								}
							},
							"flattened": true
						},
						"Failed": {
							"shape": "Sd"
						}
					}
				}
			},
			"DeleteQueue": {
				"input": {
					"type": "structure",
					"required": [
						"QueueUrl"
					],
					"members": {
						"QueueUrl": {}
					}
				}
			},
			"GetQueueAttributes": {
				"input": {
					"type": "structure",
					"required": [
						"QueueUrl"
					],
					"members": {
						"QueueUrl": {},
						"AttributeNames": {
							"shape": "St"
						}
					}
				},
				"output": {
					"resultWrapper": "GetQueueAttributesResult",
					"type": "structure",
					"members": {
						"Attributes": {
							"shape": "Sh",
							"locationName": "Attribute"
						}
					}
				}
			},
			"GetQueueUrl": {
				"input": {
					"type": "structure",
					"required": [
						"QueueName"
					],
					"members": {
						"QueueName": {},
						"QueueOwnerAWSAccountId": {}
					}
				},
				"output": {
					"resultWrapper": "GetQueueUrlResult",
					"type": "structure",
					"members": {
						"QueueUrl": {}
					}
				}
			},
			"ListDeadLetterSourceQueues": {
				"input": {
					"type": "structure",
					"required": [
						"QueueUrl"
					],
					"members": {
						"QueueUrl": {}
					}
				},
				"output": {
					"resultWrapper": "ListDeadLetterSourceQueuesResult",
					"type": "structure",
					"required": [
						"queueUrls"
					],
					"members": {
						"queueUrls": {
							"shape": "Sz"
						}
					}
				}
			},
			"ListQueues": {
				"input": {
					"type": "structure",
					"members": {
						"QueueNamePrefix": {}
					}
				},
				"output": {
					"resultWrapper": "ListQueuesResult",
					"type": "structure",
					"members": {
						"QueueUrls": {
							"shape": "Sz"
						}
					}
				}
			},
			"PurgeQueue": {
				"input": {
					"type": "structure",
					"required": [
						"QueueUrl"
					],
					"members": {
						"QueueUrl": {}
					}
				}
			},
			"ReceiveMessage": {
				"input": {
					"type": "structure",
					"required": [
						"QueueUrl"
					],
					"members": {
						"QueueUrl": {},
						"AttributeNames": {
							"shape": "St"
						},
						"MessageAttributeNames": {
							"type": "list",
							"member": {
								"locationName": "MessageAttributeName"
							},
							"flattened": true
						},
						"MaxNumberOfMessages": {
							"type": "integer"
						},
						"VisibilityTimeout": {
							"type": "integer"
						},
						"WaitTimeSeconds": {
							"type": "integer"
						}
					}
				},
				"output": {
					"resultWrapper": "ReceiveMessageResult",
					"type": "structure",
					"members": {
						"Messages": {
							"type": "list",
							"member": {
								"locationName": "Message",
								"type": "structure",
								"members": {
									"MessageId": {},
									"ReceiptHandle": {},
									"MD5OfBody": {},
									"Body": {},
									"Attributes": {
										"shape": "Sh",
										"locationName": "Attribute"
									},
									"MD5OfMessageAttributes": {},
									"MessageAttributes": {
										"shape": "S19",
										"locationName": "MessageAttribute"
									}
								}
							},
							"flattened": true
						}
					}
				}
			},
			"RemovePermission": {
				"input": {
					"type": "structure",
					"required": [
						"QueueUrl",
						"Label"
					],
					"members": {
						"QueueUrl": {},
						"Label": {}
					}
				}
			},
			"SendMessage": {
				"input": {
					"type": "structure",
					"required": [
						"QueueUrl",
						"MessageBody"
					],
					"members": {
						"QueueUrl": {},
						"MessageBody": {},
						"DelaySeconds": {
							"type": "integer"
						},
						"MessageAttributes": {
							"shape": "S19",
							"locationName": "MessageAttribute"
						}
					}
				},
				"output": {
					"resultWrapper": "SendMessageResult",
					"type": "structure",
					"members": {
						"MD5OfMessageBody": {},
						"MD5OfMessageAttributes": {},
						"MessageId": {}
					}
				}
			},
			"SendMessageBatch": {
				"input": {
					"type": "structure",
					"required": [
						"QueueUrl",
						"Entries"
					],
					"members": {
						"QueueUrl": {},
						"Entries": {
							"type": "list",
							"member": {
								"locationName": "SendMessageBatchRequestEntry",
								"type": "structure",
								"required": [
									"Id",
									"MessageBody"
								],
								"members": {
									"Id": {},
									"MessageBody": {},
									"DelaySeconds": {
										"type": "integer"
									},
									"MessageAttributes": {
										"shape": "S19",
										"locationName": "MessageAttribute"
									}
								}
							},
							"flattened": true
						}
					}
				},
				"output": {
					"resultWrapper": "SendMessageBatchResult",
					"type": "structure",
					"required": [
						"Successful",
						"Failed"
					],
					"members": {
						"Successful": {
							"type": "list",
							"member": {
								"locationName": "SendMessageBatchResultEntry",
								"type": "structure",
								"required": [
									"Id",
									"MessageId",
									"MD5OfMessageBody"
								],
								"members": {
									"Id": {},
									"MessageId": {},
									"MD5OfMessageBody": {},
									"MD5OfMessageAttributes": {}
								}
							},
							"flattened": true
						},
						"Failed": {
							"shape": "Sd"
						}
					}
				}
			},
			"SetQueueAttributes": {
				"input": {
					"type": "structure",
					"required": [
						"QueueUrl",
						"Attributes"
					],
					"members": {
						"QueueUrl": {},
						"Attributes": {
							"shape": "Sh",
							"locationName": "Attribute"
						}
					}
				}
			}
		},
		"shapes": {
			"Sd": {
				"type": "list",
				"member": {
					"locationName": "BatchResultErrorEntry",
					"type": "structure",
					"required": [
						"Id",
						"SenderFault",
						"Code"
					],
					"members": {
						"Id": {},
						"SenderFault": {
							"type": "boolean"
						},
						"Code": {},
						"Message": {}
					}
				},
				"flattened": true
			},
			"Sh": {
				"type": "map",
				"key": {
					"locationName": "Name"
				},
				"value": {
					"locationName": "Value"
				},
				"flattened": true,
				"locationName": "Attribute"
			},
			"St": {
				"type": "list",
				"member": {
					"locationName": "AttributeName"
				},
				"flattened": true
			},
			"Sz": {
				"type": "list",
				"member": {
					"locationName": "QueueUrl"
				},
				"flattened": true
			},
			"S19": {
				"type": "map",
				"key": {
					"locationName": "Name"
				},
				"value": {
					"locationName": "Value",
					"type": "structure",
					"required": [
						"DataType"
					],
					"members": {
						"StringValue": {},
						"BinaryValue": {
							"type": "blob"
						},
						"StringListValues": {
							"flattened": true,
							"locationName": "StringListValue",
							"type": "list",
							"member": {
								"locationName": "StringListValue"
							}
						},
						"BinaryListValues": {
							"flattened": true,
							"locationName": "BinaryListValue",
							"type": "list",
							"member": {
								"locationName": "BinaryListValue",
								"type": "blob"
							}
						},
						"DataType": {}
					}
				},
				"flattened": true
			}
		}
	};

/***/ },
/* 467 */
/***/ function(module, exports) {

	module.exports = {
		"pagination": {
			"ListQueues": {
				"result_key": "QueueUrls"
			}
		}
	};

/***/ },
/* 468 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['ssm'] = {};
	AWS.SSM = Service.defineService('ssm', ['2014-11-06']);
	Object.defineProperty(apiLoader.services['ssm'], '2014-11-06', {
	  get: function get() {
	    var model = __webpack_require__(469);
	    model.paginators = __webpack_require__(470).pagination;
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.SSM;


/***/ },
/* 469 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2014-11-06",
			"endpointPrefix": "ssm",
			"jsonVersion": "1.1",
			"protocol": "json",
			"serviceAbbreviation": "Amazon SSM",
			"serviceFullName": "Amazon Simple Systems Management Service",
			"signatureVersion": "v4",
			"targetPrefix": "AmazonSSM"
		},
		"operations": {
			"AddTagsToResource": {
				"input": {
					"type": "structure",
					"required": [
						"ResourceType",
						"ResourceId",
						"Tags"
					],
					"members": {
						"ResourceType": {},
						"ResourceId": {},
						"Tags": {
							"shape": "S4"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"CancelCommand": {
				"input": {
					"type": "structure",
					"required": [
						"CommandId"
					],
					"members": {
						"CommandId": {},
						"InstanceIds": {
							"shape": "Sb"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"CreateActivation": {
				"input": {
					"type": "structure",
					"required": [
						"IamRole"
					],
					"members": {
						"Description": {},
						"DefaultInstanceName": {},
						"IamRole": {},
						"RegistrationLimit": {
							"type": "integer"
						},
						"ExpirationDate": {
							"type": "timestamp"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ActivationId": {},
						"ActivationCode": {}
					}
				}
			},
			"CreateAssociation": {
				"input": {
					"type": "structure",
					"required": [
						"Name",
						"InstanceId"
					],
					"members": {
						"Name": {},
						"InstanceId": {},
						"Parameters": {
							"shape": "Sp"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"AssociationDescription": {
							"shape": "Su"
						}
					}
				}
			},
			"CreateAssociationBatch": {
				"input": {
					"type": "structure",
					"required": [
						"Entries"
					],
					"members": {
						"Entries": {
							"type": "list",
							"member": {
								"shape": "S12",
								"locationName": "entries"
							}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Successful": {
							"type": "list",
							"member": {
								"shape": "Su",
								"locationName": "AssociationDescription"
							}
						},
						"Failed": {
							"type": "list",
							"member": {
								"locationName": "FailedCreateAssociationEntry",
								"type": "structure",
								"members": {
									"Entry": {
										"shape": "S12"
									},
									"Message": {},
									"Fault": {}
								}
							}
						}
					}
				}
			},
			"CreateDocument": {
				"input": {
					"type": "structure",
					"required": [
						"Content",
						"Name"
					],
					"members": {
						"Content": {},
						"Name": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"DocumentDescription": {
							"shape": "S1c"
						}
					}
				}
			},
			"DeleteActivation": {
				"input": {
					"type": "structure",
					"required": [
						"ActivationId"
					],
					"members": {
						"ActivationId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"DeleteAssociation": {
				"input": {
					"type": "structure",
					"required": [
						"Name",
						"InstanceId"
					],
					"members": {
						"Name": {},
						"InstanceId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"DeleteDocument": {
				"input": {
					"type": "structure",
					"required": [
						"Name"
					],
					"members": {
						"Name": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"DeregisterManagedInstance": {
				"input": {
					"type": "structure",
					"required": [
						"InstanceId"
					],
					"members": {
						"InstanceId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"DescribeActivations": {
				"input": {
					"type": "structure",
					"members": {
						"Filters": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"FilterKey": {},
									"FilterValues": {
										"type": "list",
										"member": {}
									}
								}
							}
						},
						"MaxResults": {
							"type": "integer"
						},
						"NextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ActivationList": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"ActivationId": {},
									"Description": {},
									"DefaultInstanceName": {},
									"IamRole": {},
									"RegistrationLimit": {
										"type": "integer"
									},
									"RegistrationsCount": {
										"type": "integer"
									},
									"ExpirationDate": {
										"type": "timestamp"
									},
									"Expired": {
										"type": "boolean"
									},
									"CreatedDate": {
										"type": "timestamp"
									}
								}
							}
						},
						"NextToken": {}
					}
				}
			},
			"DescribeAssociation": {
				"input": {
					"type": "structure",
					"required": [
						"Name",
						"InstanceId"
					],
					"members": {
						"Name": {},
						"InstanceId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"AssociationDescription": {
							"shape": "Su"
						}
					}
				}
			},
			"DescribeDocument": {
				"input": {
					"type": "structure",
					"required": [
						"Name"
					],
					"members": {
						"Name": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Document": {
							"shape": "S1c"
						}
					}
				}
			},
			"DescribeDocumentPermission": {
				"input": {
					"type": "structure",
					"required": [
						"Name",
						"PermissionType"
					],
					"members": {
						"Name": {},
						"PermissionType": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"AccountIds": {
							"shape": "S2m"
						}
					}
				}
			},
			"DescribeInstanceInformation": {
				"input": {
					"type": "structure",
					"members": {
						"InstanceInformationFilterList": {
							"type": "list",
							"member": {
								"locationName": "InstanceInformationFilter",
								"type": "structure",
								"required": [
									"key",
									"valueSet"
								],
								"members": {
									"key": {},
									"valueSet": {
										"type": "list",
										"member": {
											"locationName": "InstanceInformationFilterValue"
										}
									}
								}
							}
						},
						"MaxResults": {
							"type": "integer"
						},
						"NextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"InstanceInformationList": {
							"type": "list",
							"member": {
								"locationName": "InstanceInformation",
								"type": "structure",
								"members": {
									"InstanceId": {},
									"PingStatus": {},
									"LastPingDateTime": {
										"type": "timestamp"
									},
									"AgentVersion": {},
									"IsLatestVersion": {
										"type": "boolean"
									},
									"PlatformType": {},
									"PlatformName": {},
									"PlatformVersion": {},
									"ActivationId": {},
									"IamRole": {},
									"RegistrationDate": {
										"type": "timestamp"
									},
									"ResourceType": {},
									"Name": {},
									"IPAddress": {},
									"ComputerName": {}
								}
							}
						},
						"NextToken": {}
					}
				}
			},
			"GetDocument": {
				"input": {
					"type": "structure",
					"required": [
						"Name"
					],
					"members": {
						"Name": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Name": {},
						"Content": {}
					}
				}
			},
			"ListAssociations": {
				"input": {
					"type": "structure",
					"required": [
						"AssociationFilterList"
					],
					"members": {
						"AssociationFilterList": {
							"type": "list",
							"member": {
								"locationName": "AssociationFilter",
								"type": "structure",
								"required": [
									"key",
									"value"
								],
								"members": {
									"key": {},
									"value": {}
								}
							}
						},
						"MaxResults": {
							"type": "integer"
						},
						"NextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Associations": {
							"type": "list",
							"member": {
								"locationName": "Association",
								"type": "structure",
								"members": {
									"Name": {},
									"InstanceId": {}
								}
							}
						},
						"NextToken": {}
					}
				}
			},
			"ListCommandInvocations": {
				"input": {
					"type": "structure",
					"members": {
						"CommandId": {},
						"InstanceId": {},
						"MaxResults": {
							"type": "integer"
						},
						"NextToken": {},
						"Filters": {
							"shape": "S3f"
						},
						"Details": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"CommandInvocations": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"CommandId": {},
									"InstanceId": {},
									"Comment": {},
									"DocumentName": {},
									"RequestedDateTime": {
										"type": "timestamp"
									},
									"Status": {},
									"TraceOutput": {},
									"CommandPlugins": {
										"type": "list",
										"member": {
											"type": "structure",
											"members": {
												"Name": {},
												"Status": {},
												"ResponseCode": {
													"type": "integer"
												},
												"ResponseStartDateTime": {
													"type": "timestamp"
												},
												"ResponseFinishDateTime": {
													"type": "timestamp"
												},
												"Output": {},
												"OutputS3BucketName": {},
												"OutputS3KeyPrefix": {}
											}
										}
									},
									"ServiceRole": {},
									"NotificationConfig": {
										"shape": "S3y"
									}
								}
							}
						},
						"NextToken": {}
					}
				}
			},
			"ListCommands": {
				"input": {
					"type": "structure",
					"members": {
						"CommandId": {},
						"InstanceId": {},
						"MaxResults": {
							"type": "integer"
						},
						"NextToken": {},
						"Filters": {
							"shape": "S3f"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Commands": {
							"type": "list",
							"member": {
								"shape": "S46"
							}
						},
						"NextToken": {}
					}
				}
			},
			"ListDocuments": {
				"input": {
					"type": "structure",
					"members": {
						"DocumentFilterList": {
							"type": "list",
							"member": {
								"locationName": "DocumentFilter",
								"type": "structure",
								"required": [
									"key",
									"value"
								],
								"members": {
									"key": {},
									"value": {}
								}
							}
						},
						"MaxResults": {
							"type": "integer"
						},
						"NextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"DocumentIdentifiers": {
							"type": "list",
							"member": {
								"locationName": "DocumentIdentifier",
								"type": "structure",
								"members": {
									"Name": {},
									"Owner": {},
									"PlatformTypes": {
										"shape": "S1q"
									}
								}
							}
						},
						"NextToken": {}
					}
				}
			},
			"ListTagsForResource": {
				"input": {
					"type": "structure",
					"required": [
						"ResourceType",
						"ResourceId"
					],
					"members": {
						"ResourceType": {},
						"ResourceId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"TagList": {
							"shape": "S4"
						}
					}
				}
			},
			"ModifyDocumentPermission": {
				"input": {
					"type": "structure",
					"required": [
						"Name",
						"PermissionType"
					],
					"members": {
						"Name": {},
						"PermissionType": {},
						"AccountIdsToAdd": {
							"shape": "S2m"
						},
						"AccountIdsToRemove": {
							"shape": "S2m"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"RemoveTagsFromResource": {
				"input": {
					"type": "structure",
					"required": [
						"ResourceType",
						"ResourceId",
						"TagKeys"
					],
					"members": {
						"ResourceType": {},
						"ResourceId": {},
						"TagKeys": {
							"type": "list",
							"member": {}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"SendCommand": {
				"input": {
					"type": "structure",
					"required": [
						"InstanceIds",
						"DocumentName"
					],
					"members": {
						"InstanceIds": {
							"shape": "Sb"
						},
						"DocumentName": {},
						"DocumentHash": {},
						"DocumentHashType": {},
						"TimeoutSeconds": {
							"type": "integer"
						},
						"Comment": {},
						"Parameters": {
							"shape": "Sp"
						},
						"OutputS3BucketName": {},
						"OutputS3KeyPrefix": {},
						"ServiceRoleArn": {},
						"NotificationConfig": {
							"shape": "S3y"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Command": {
							"shape": "S46"
						}
					}
				}
			},
			"UpdateAssociationStatus": {
				"input": {
					"type": "structure",
					"required": [
						"Name",
						"InstanceId",
						"AssociationStatus"
					],
					"members": {
						"Name": {},
						"InstanceId": {},
						"AssociationStatus": {
							"shape": "Sw"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"AssociationDescription": {
							"shape": "Su"
						}
					}
				}
			},
			"UpdateManagedInstanceRole": {
				"input": {
					"type": "structure",
					"required": [
						"InstanceId",
						"IamRole"
					],
					"members": {
						"InstanceId": {},
						"IamRole": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			}
		},
		"shapes": {
			"S4": {
				"type": "list",
				"member": {
					"type": "structure",
					"required": [
						"Key",
						"Value"
					],
					"members": {
						"Key": {},
						"Value": {}
					}
				}
			},
			"Sb": {
				"type": "list",
				"member": {}
			},
			"Sp": {
				"type": "map",
				"key": {},
				"value": {
					"type": "list",
					"member": {}
				}
			},
			"Su": {
				"type": "structure",
				"members": {
					"Name": {},
					"InstanceId": {},
					"Date": {
						"type": "timestamp"
					},
					"Status": {
						"shape": "Sw"
					},
					"Parameters": {
						"shape": "Sp"
					}
				}
			},
			"Sw": {
				"type": "structure",
				"required": [
					"Date",
					"Name",
					"Message"
				],
				"members": {
					"Date": {
						"type": "timestamp"
					},
					"Name": {},
					"Message": {},
					"AdditionalInfo": {}
				}
			},
			"S12": {
				"type": "structure",
				"members": {
					"Name": {},
					"InstanceId": {},
					"Parameters": {
						"shape": "Sp"
					}
				}
			},
			"S1c": {
				"type": "structure",
				"members": {
					"Sha1": {},
					"Hash": {},
					"HashType": {},
					"Name": {},
					"Owner": {},
					"CreatedDate": {
						"type": "timestamp"
					},
					"Status": {},
					"Description": {},
					"Parameters": {
						"type": "list",
						"member": {
							"locationName": "DocumentParameter",
							"type": "structure",
							"members": {
								"Name": {},
								"Type": {},
								"Description": {},
								"DefaultValue": {}
							}
						}
					},
					"PlatformTypes": {
						"shape": "S1q"
					}
				}
			},
			"S1q": {
				"type": "list",
				"member": {
					"locationName": "PlatformType"
				}
			},
			"S2m": {
				"type": "list",
				"member": {
					"locationName": "AccountId"
				}
			},
			"S3f": {
				"type": "list",
				"member": {
					"type": "structure",
					"required": [
						"key",
						"value"
					],
					"members": {
						"key": {},
						"value": {}
					}
				}
			},
			"S3y": {
				"type": "structure",
				"members": {
					"NotificationArn": {},
					"NotificationEvents": {
						"type": "list",
						"member": {}
					},
					"NotificationType": {}
				}
			},
			"S46": {
				"type": "structure",
				"members": {
					"CommandId": {},
					"DocumentName": {},
					"Comment": {},
					"ExpiresAfter": {
						"type": "timestamp"
					},
					"Parameters": {
						"shape": "Sp"
					},
					"InstanceIds": {
						"shape": "Sb"
					},
					"RequestedDateTime": {
						"type": "timestamp"
					},
					"Status": {},
					"OutputS3BucketName": {},
					"OutputS3KeyPrefix": {},
					"ServiceRole": {},
					"NotificationConfig": {
						"shape": "S3y"
					}
				}
			}
		}
	};

/***/ },
/* 470 */
/***/ function(module, exports) {

	module.exports = {
		"pagination": {
			"DescribeInstanceInformation": {
				"input_token": "NextToken",
				"output_token": "NextToken",
				"limit_key": "MaxResults",
				"result_key": "InstanceInformationList"
			},
			"ListAssociations": {
				"input_token": "NextToken",
				"output_token": "NextToken",
				"limit_key": "MaxResults",
				"result_key": "Associations"
			},
			"ListCommandInvocations": {
				"input_token": "NextToken",
				"output_token": "NextToken",
				"limit_key": "MaxResults",
				"result_key": "CommandInvocations"
			},
			"ListCommands": {
				"input_token": "NextToken",
				"output_token": "NextToken",
				"limit_key": "MaxResults",
				"result_key": "Commands"
			},
			"ListDocuments": {
				"input_token": "NextToken",
				"output_token": "NextToken",
				"limit_key": "MaxResults",
				"result_key": "DocumentIdentifiers"
			},
			"DescribeActivations": {
				"input_token": "NextToken",
				"output_token": "NextToken",
				"limit_key": "MaxResults",
				"result_key": "ActivationList"
			}
		}
	};

/***/ },
/* 471 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['storagegateway'] = {};
	AWS.StorageGateway = Service.defineService('storagegateway', ['2013-06-30']);
	Object.defineProperty(apiLoader.services['storagegateway'], '2013-06-30', {
	  get: function get() {
	    var model = __webpack_require__(472);
	    model.paginators = __webpack_require__(473).pagination;
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.StorageGateway;


/***/ },
/* 472 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2013-06-30",
			"endpointPrefix": "storagegateway",
			"jsonVersion": "1.1",
			"protocol": "json",
			"serviceFullName": "AWS Storage Gateway",
			"signatureVersion": "v4",
			"targetPrefix": "StorageGateway_20130630"
		},
		"operations": {
			"ActivateGateway": {
				"input": {
					"type": "structure",
					"required": [
						"ActivationKey",
						"GatewayName",
						"GatewayTimezone",
						"GatewayRegion"
					],
					"members": {
						"ActivationKey": {},
						"GatewayName": {},
						"GatewayTimezone": {},
						"GatewayRegion": {},
						"GatewayType": {},
						"TapeDriveType": {},
						"MediumChangerType": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"GatewayARN": {}
					}
				}
			},
			"AddCache": {
				"input": {
					"type": "structure",
					"required": [
						"GatewayARN",
						"DiskIds"
					],
					"members": {
						"GatewayARN": {},
						"DiskIds": {
							"shape": "Sc"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"GatewayARN": {}
					}
				}
			},
			"AddTagsToResource": {
				"input": {
					"type": "structure",
					"required": [
						"ResourceARN",
						"Tags"
					],
					"members": {
						"ResourceARN": {},
						"Tags": {
							"shape": "Sh"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ResourceARN": {}
					}
				}
			},
			"AddUploadBuffer": {
				"input": {
					"type": "structure",
					"required": [
						"GatewayARN",
						"DiskIds"
					],
					"members": {
						"GatewayARN": {},
						"DiskIds": {
							"shape": "Sc"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"GatewayARN": {}
					}
				}
			},
			"AddWorkingStorage": {
				"input": {
					"type": "structure",
					"required": [
						"GatewayARN",
						"DiskIds"
					],
					"members": {
						"GatewayARN": {},
						"DiskIds": {
							"shape": "Sc"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"GatewayARN": {}
					}
				}
			},
			"CancelArchival": {
				"input": {
					"type": "structure",
					"required": [
						"GatewayARN",
						"TapeARN"
					],
					"members": {
						"GatewayARN": {},
						"TapeARN": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"TapeARN": {}
					}
				}
			},
			"CancelRetrieval": {
				"input": {
					"type": "structure",
					"required": [
						"GatewayARN",
						"TapeARN"
					],
					"members": {
						"GatewayARN": {},
						"TapeARN": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"TapeARN": {}
					}
				}
			},
			"CreateCachediSCSIVolume": {
				"input": {
					"type": "structure",
					"required": [
						"GatewayARN",
						"VolumeSizeInBytes",
						"TargetName",
						"NetworkInterfaceId",
						"ClientToken"
					],
					"members": {
						"GatewayARN": {},
						"VolumeSizeInBytes": {
							"type": "long"
						},
						"SnapshotId": {},
						"TargetName": {},
						"NetworkInterfaceId": {},
						"ClientToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"VolumeARN": {},
						"TargetARN": {}
					}
				}
			},
			"CreateSnapshot": {
				"input": {
					"type": "structure",
					"required": [
						"VolumeARN",
						"SnapshotDescription"
					],
					"members": {
						"VolumeARN": {},
						"SnapshotDescription": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"VolumeARN": {},
						"SnapshotId": {}
					}
				}
			},
			"CreateSnapshotFromVolumeRecoveryPoint": {
				"input": {
					"type": "structure",
					"required": [
						"VolumeARN",
						"SnapshotDescription"
					],
					"members": {
						"VolumeARN": {},
						"SnapshotDescription": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"SnapshotId": {},
						"VolumeARN": {},
						"VolumeRecoveryPointTime": {}
					}
				}
			},
			"CreateStorediSCSIVolume": {
				"input": {
					"type": "structure",
					"required": [
						"GatewayARN",
						"DiskId",
						"PreserveExistingData",
						"TargetName",
						"NetworkInterfaceId"
					],
					"members": {
						"GatewayARN": {},
						"DiskId": {},
						"SnapshotId": {},
						"PreserveExistingData": {
							"type": "boolean"
						},
						"TargetName": {},
						"NetworkInterfaceId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"VolumeARN": {},
						"VolumeSizeInBytes": {
							"type": "long"
						},
						"TargetARN": {}
					}
				}
			},
			"CreateTapeWithBarcode": {
				"input": {
					"type": "structure",
					"required": [
						"GatewayARN",
						"TapeSizeInBytes",
						"TapeBarcode"
					],
					"members": {
						"GatewayARN": {},
						"TapeSizeInBytes": {
							"type": "long"
						},
						"TapeBarcode": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"TapeARN": {}
					}
				}
			},
			"CreateTapes": {
				"input": {
					"type": "structure",
					"required": [
						"GatewayARN",
						"TapeSizeInBytes",
						"ClientToken",
						"NumTapesToCreate",
						"TapeBarcodePrefix"
					],
					"members": {
						"GatewayARN": {},
						"TapeSizeInBytes": {
							"type": "long"
						},
						"ClientToken": {},
						"NumTapesToCreate": {
							"type": "integer"
						},
						"TapeBarcodePrefix": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"TapeARNs": {
							"shape": "S1l"
						}
					}
				}
			},
			"DeleteBandwidthRateLimit": {
				"input": {
					"type": "structure",
					"required": [
						"GatewayARN",
						"BandwidthType"
					],
					"members": {
						"GatewayARN": {},
						"BandwidthType": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"GatewayARN": {}
					}
				}
			},
			"DeleteChapCredentials": {
				"input": {
					"type": "structure",
					"required": [
						"TargetARN",
						"InitiatorName"
					],
					"members": {
						"TargetARN": {},
						"InitiatorName": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"TargetARN": {},
						"InitiatorName": {}
					}
				}
			},
			"DeleteGateway": {
				"input": {
					"type": "structure",
					"required": [
						"GatewayARN"
					],
					"members": {
						"GatewayARN": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"GatewayARN": {}
					}
				}
			},
			"DeleteSnapshotSchedule": {
				"input": {
					"type": "structure",
					"required": [
						"VolumeARN"
					],
					"members": {
						"VolumeARN": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"VolumeARN": {}
					}
				}
			},
			"DeleteTape": {
				"input": {
					"type": "structure",
					"required": [
						"GatewayARN",
						"TapeARN"
					],
					"members": {
						"GatewayARN": {},
						"TapeARN": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"TapeARN": {}
					}
				}
			},
			"DeleteTapeArchive": {
				"input": {
					"type": "structure",
					"required": [
						"TapeARN"
					],
					"members": {
						"TapeARN": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"TapeARN": {}
					}
				}
			},
			"DeleteVolume": {
				"input": {
					"type": "structure",
					"required": [
						"VolumeARN"
					],
					"members": {
						"VolumeARN": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"VolumeARN": {}
					}
				}
			},
			"DescribeBandwidthRateLimit": {
				"input": {
					"type": "structure",
					"required": [
						"GatewayARN"
					],
					"members": {
						"GatewayARN": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"GatewayARN": {},
						"AverageUploadRateLimitInBitsPerSec": {
							"type": "long"
						},
						"AverageDownloadRateLimitInBitsPerSec": {
							"type": "long"
						}
					}
				}
			},
			"DescribeCache": {
				"input": {
					"type": "structure",
					"required": [
						"GatewayARN"
					],
					"members": {
						"GatewayARN": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"GatewayARN": {},
						"DiskIds": {
							"shape": "Sc"
						},
						"CacheAllocatedInBytes": {
							"type": "long"
						},
						"CacheUsedPercentage": {
							"type": "double"
						},
						"CacheDirtyPercentage": {
							"type": "double"
						},
						"CacheHitPercentage": {
							"type": "double"
						},
						"CacheMissPercentage": {
							"type": "double"
						}
					}
				}
			},
			"DescribeCachediSCSIVolumes": {
				"input": {
					"type": "structure",
					"required": [
						"VolumeARNs"
					],
					"members": {
						"VolumeARNs": {
							"shape": "S2a"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"CachediSCSIVolumes": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"VolumeARN": {},
									"VolumeId": {},
									"VolumeType": {},
									"VolumeStatus": {},
									"VolumeSizeInBytes": {
										"type": "long"
									},
									"VolumeProgress": {
										"type": "double"
									},
									"SourceSnapshotId": {},
									"VolumeiSCSIAttributes": {
										"shape": "S2i"
									}
								}
							}
						}
					}
				}
			},
			"DescribeChapCredentials": {
				"input": {
					"type": "structure",
					"required": [
						"TargetARN"
					],
					"members": {
						"TargetARN": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ChapCredentials": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"TargetARN": {},
									"SecretToAuthenticateInitiator": {},
									"InitiatorName": {},
									"SecretToAuthenticateTarget": {}
								}
							}
						}
					}
				}
			},
			"DescribeGatewayInformation": {
				"input": {
					"type": "structure",
					"required": [
						"GatewayARN"
					],
					"members": {
						"GatewayARN": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"GatewayARN": {},
						"GatewayId": {},
						"GatewayName": {},
						"GatewayTimezone": {},
						"GatewayState": {},
						"GatewayNetworkInterfaces": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"Ipv4Address": {},
									"MacAddress": {},
									"Ipv6Address": {}
								}
							}
						},
						"GatewayType": {},
						"NextUpdateAvailabilityDate": {},
						"LastSoftwareUpdate": {}
					}
				}
			},
			"DescribeMaintenanceStartTime": {
				"input": {
					"type": "structure",
					"required": [
						"GatewayARN"
					],
					"members": {
						"GatewayARN": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"GatewayARN": {},
						"HourOfDay": {
							"type": "integer"
						},
						"MinuteOfHour": {
							"type": "integer"
						},
						"DayOfWeek": {
							"type": "integer"
						},
						"Timezone": {}
					}
				}
			},
			"DescribeSnapshotSchedule": {
				"input": {
					"type": "structure",
					"required": [
						"VolumeARN"
					],
					"members": {
						"VolumeARN": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"VolumeARN": {},
						"StartAt": {
							"type": "integer"
						},
						"RecurrenceInHours": {
							"type": "integer"
						},
						"Description": {},
						"Timezone": {}
					}
				}
			},
			"DescribeStorediSCSIVolumes": {
				"input": {
					"type": "structure",
					"required": [
						"VolumeARNs"
					],
					"members": {
						"VolumeARNs": {
							"shape": "S2a"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"StorediSCSIVolumes": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"VolumeARN": {},
									"VolumeId": {},
									"VolumeType": {},
									"VolumeStatus": {},
									"VolumeSizeInBytes": {
										"type": "long"
									},
									"VolumeProgress": {
										"type": "double"
									},
									"VolumeDiskId": {},
									"SourceSnapshotId": {},
									"PreservedExistingData": {
										"type": "boolean"
									},
									"VolumeiSCSIAttributes": {
										"shape": "S2i"
									}
								}
							}
						}
					}
				}
			},
			"DescribeTapeArchives": {
				"input": {
					"type": "structure",
					"members": {
						"TapeARNs": {
							"shape": "S1l"
						},
						"Marker": {},
						"Limit": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"TapeArchives": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"TapeARN": {},
									"TapeBarcode": {},
									"TapeSizeInBytes": {
										"type": "long"
									},
									"CompletionTime": {
										"type": "timestamp"
									},
									"RetrievedTo": {},
									"TapeStatus": {}
								}
							}
						},
						"Marker": {}
					}
				}
			},
			"DescribeTapeRecoveryPoints": {
				"input": {
					"type": "structure",
					"required": [
						"GatewayARN"
					],
					"members": {
						"GatewayARN": {},
						"Marker": {},
						"Limit": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"GatewayARN": {},
						"TapeRecoveryPointInfos": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"TapeARN": {},
									"TapeRecoveryPointTime": {
										"type": "timestamp"
									},
									"TapeSizeInBytes": {
										"type": "long"
									},
									"TapeStatus": {}
								}
							}
						},
						"Marker": {}
					}
				}
			},
			"DescribeTapes": {
				"input": {
					"type": "structure",
					"required": [
						"GatewayARN"
					],
					"members": {
						"GatewayARN": {},
						"TapeARNs": {
							"shape": "S1l"
						},
						"Marker": {},
						"Limit": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Tapes": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"TapeARN": {},
									"TapeBarcode": {},
									"TapeSizeInBytes": {
										"type": "long"
									},
									"TapeStatus": {},
									"VTLDevice": {},
									"Progress": {
										"type": "double"
									}
								}
							}
						},
						"Marker": {}
					}
				}
			},
			"DescribeUploadBuffer": {
				"input": {
					"type": "structure",
					"required": [
						"GatewayARN"
					],
					"members": {
						"GatewayARN": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"GatewayARN": {},
						"DiskIds": {
							"shape": "Sc"
						},
						"UploadBufferUsedInBytes": {
							"type": "long"
						},
						"UploadBufferAllocatedInBytes": {
							"type": "long"
						}
					}
				}
			},
			"DescribeVTLDevices": {
				"input": {
					"type": "structure",
					"required": [
						"GatewayARN"
					],
					"members": {
						"GatewayARN": {},
						"VTLDeviceARNs": {
							"type": "list",
							"member": {}
						},
						"Marker": {},
						"Limit": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"GatewayARN": {},
						"VTLDevices": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"VTLDeviceARN": {},
									"VTLDeviceType": {},
									"VTLDeviceVendor": {},
									"VTLDeviceProductIdentifier": {},
									"DeviceiSCSIAttributes": {
										"type": "structure",
										"members": {
											"TargetARN": {},
											"NetworkInterfaceId": {},
											"NetworkInterfacePort": {
												"type": "integer"
											},
											"ChapEnabled": {
												"type": "boolean"
											}
										}
									}
								}
							}
						},
						"Marker": {}
					}
				}
			},
			"DescribeWorkingStorage": {
				"input": {
					"type": "structure",
					"required": [
						"GatewayARN"
					],
					"members": {
						"GatewayARN": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"GatewayARN": {},
						"DiskIds": {
							"shape": "Sc"
						},
						"WorkingStorageUsedInBytes": {
							"type": "long"
						},
						"WorkingStorageAllocatedInBytes": {
							"type": "long"
						}
					}
				}
			},
			"DisableGateway": {
				"input": {
					"type": "structure",
					"required": [
						"GatewayARN"
					],
					"members": {
						"GatewayARN": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"GatewayARN": {}
					}
				}
			},
			"ListGateways": {
				"input": {
					"type": "structure",
					"members": {
						"Marker": {},
						"Limit": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Gateways": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"GatewayId": {},
									"GatewayARN": {},
									"GatewayType": {},
									"GatewayOperationalState": {},
									"GatewayName": {}
								}
							}
						},
						"Marker": {}
					}
				}
			},
			"ListLocalDisks": {
				"input": {
					"type": "structure",
					"required": [
						"GatewayARN"
					],
					"members": {
						"GatewayARN": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"GatewayARN": {},
						"Disks": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"DiskId": {},
									"DiskPath": {},
									"DiskNode": {},
									"DiskStatus": {},
									"DiskSizeInBytes": {
										"type": "long"
									},
									"DiskAllocationType": {},
									"DiskAllocationResource": {}
								}
							}
						}
					}
				}
			},
			"ListTagsForResource": {
				"input": {
					"type": "structure",
					"required": [
						"ResourceARN"
					],
					"members": {
						"ResourceARN": {},
						"Marker": {},
						"Limit": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ResourceARN": {},
						"Marker": {},
						"Tags": {
							"shape": "Sh"
						}
					}
				}
			},
			"ListTapes": {
				"input": {
					"type": "structure",
					"members": {
						"TapeARNs": {
							"shape": "S1l"
						},
						"Marker": {},
						"Limit": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"TapeInfos": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"TapeARN": {},
									"TapeBarcode": {},
									"TapeSizeInBytes": {
										"type": "long"
									},
									"TapeStatus": {},
									"GatewayARN": {}
								}
							}
						},
						"Marker": {}
					}
				}
			},
			"ListVolumeInitiators": {
				"input": {
					"type": "structure",
					"required": [
						"VolumeARN"
					],
					"members": {
						"VolumeARN": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Initiators": {
							"type": "list",
							"member": {}
						}
					}
				}
			},
			"ListVolumeRecoveryPoints": {
				"input": {
					"type": "structure",
					"required": [
						"GatewayARN"
					],
					"members": {
						"GatewayARN": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"GatewayARN": {},
						"VolumeRecoveryPointInfos": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"VolumeARN": {},
									"VolumeSizeInBytes": {
										"type": "long"
									},
									"VolumeUsageInBytes": {
										"type": "long"
									},
									"VolumeRecoveryPointTime": {}
								}
							}
						}
					}
				}
			},
			"ListVolumes": {
				"input": {
					"type": "structure",
					"members": {
						"GatewayARN": {},
						"Marker": {},
						"Limit": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"GatewayARN": {},
						"Marker": {},
						"VolumeInfos": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"VolumeARN": {},
									"VolumeId": {},
									"GatewayARN": {},
									"GatewayId": {},
									"VolumeType": {},
									"VolumeSizeInBytes": {
										"type": "long"
									}
								}
							}
						}
					}
				}
			},
			"RemoveTagsFromResource": {
				"input": {
					"type": "structure",
					"required": [
						"ResourceARN",
						"TagKeys"
					],
					"members": {
						"ResourceARN": {},
						"TagKeys": {
							"type": "list",
							"member": {}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ResourceARN": {}
					}
				}
			},
			"ResetCache": {
				"input": {
					"type": "structure",
					"required": [
						"GatewayARN"
					],
					"members": {
						"GatewayARN": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"GatewayARN": {}
					}
				}
			},
			"RetrieveTapeArchive": {
				"input": {
					"type": "structure",
					"required": [
						"TapeARN",
						"GatewayARN"
					],
					"members": {
						"TapeARN": {},
						"GatewayARN": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"TapeARN": {}
					}
				}
			},
			"RetrieveTapeRecoveryPoint": {
				"input": {
					"type": "structure",
					"required": [
						"TapeARN",
						"GatewayARN"
					],
					"members": {
						"TapeARN": {},
						"GatewayARN": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"TapeARN": {}
					}
				}
			},
			"SetLocalConsolePassword": {
				"input": {
					"type": "structure",
					"required": [
						"GatewayARN",
						"LocalConsolePassword"
					],
					"members": {
						"GatewayARN": {},
						"LocalConsolePassword": {
							"type": "string",
							"sensitive": true
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"GatewayARN": {}
					}
				}
			},
			"ShutdownGateway": {
				"input": {
					"type": "structure",
					"required": [
						"GatewayARN"
					],
					"members": {
						"GatewayARN": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"GatewayARN": {}
					}
				}
			},
			"StartGateway": {
				"input": {
					"type": "structure",
					"required": [
						"GatewayARN"
					],
					"members": {
						"GatewayARN": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"GatewayARN": {}
					}
				}
			},
			"UpdateBandwidthRateLimit": {
				"input": {
					"type": "structure",
					"required": [
						"GatewayARN"
					],
					"members": {
						"GatewayARN": {},
						"AverageUploadRateLimitInBitsPerSec": {
							"type": "long"
						},
						"AverageDownloadRateLimitInBitsPerSec": {
							"type": "long"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"GatewayARN": {}
					}
				}
			},
			"UpdateChapCredentials": {
				"input": {
					"type": "structure",
					"required": [
						"TargetARN",
						"SecretToAuthenticateInitiator",
						"InitiatorName"
					],
					"members": {
						"TargetARN": {},
						"SecretToAuthenticateInitiator": {},
						"InitiatorName": {},
						"SecretToAuthenticateTarget": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"TargetARN": {},
						"InitiatorName": {}
					}
				}
			},
			"UpdateGatewayInformation": {
				"input": {
					"type": "structure",
					"required": [
						"GatewayARN"
					],
					"members": {
						"GatewayARN": {},
						"GatewayName": {},
						"GatewayTimezone": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"GatewayARN": {},
						"GatewayName": {}
					}
				}
			},
			"UpdateGatewaySoftwareNow": {
				"input": {
					"type": "structure",
					"required": [
						"GatewayARN"
					],
					"members": {
						"GatewayARN": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"GatewayARN": {}
					}
				}
			},
			"UpdateMaintenanceStartTime": {
				"input": {
					"type": "structure",
					"required": [
						"GatewayARN",
						"HourOfDay",
						"MinuteOfHour",
						"DayOfWeek"
					],
					"members": {
						"GatewayARN": {},
						"HourOfDay": {
							"type": "integer"
						},
						"MinuteOfHour": {
							"type": "integer"
						},
						"DayOfWeek": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"GatewayARN": {}
					}
				}
			},
			"UpdateSnapshotSchedule": {
				"input": {
					"type": "structure",
					"required": [
						"VolumeARN",
						"StartAt",
						"RecurrenceInHours"
					],
					"members": {
						"VolumeARN": {},
						"StartAt": {
							"type": "integer"
						},
						"RecurrenceInHours": {
							"type": "integer"
						},
						"Description": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"VolumeARN": {}
					}
				}
			},
			"UpdateVTLDeviceType": {
				"input": {
					"type": "structure",
					"required": [
						"VTLDeviceARN",
						"DeviceType"
					],
					"members": {
						"VTLDeviceARN": {},
						"DeviceType": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"VTLDeviceARN": {}
					}
				}
			}
		},
		"shapes": {
			"Sc": {
				"type": "list",
				"member": {}
			},
			"Sh": {
				"type": "list",
				"member": {
					"type": "structure",
					"required": [
						"Key",
						"Value"
					],
					"members": {
						"Key": {},
						"Value": {}
					}
				}
			},
			"S1l": {
				"type": "list",
				"member": {}
			},
			"S2a": {
				"type": "list",
				"member": {}
			},
			"S2i": {
				"type": "structure",
				"members": {
					"TargetARN": {},
					"NetworkInterfaceId": {},
					"NetworkInterfacePort": {
						"type": "integer"
					},
					"LunNumber": {
						"type": "integer"
					},
					"ChapEnabled": {
						"type": "boolean"
					}
				}
			}
		}
	};

/***/ },
/* 473 */
/***/ function(module, exports) {

	module.exports = {
		"pagination": {
			"DescribeCachediSCSIVolumes": {
				"result_key": "CachediSCSIVolumes"
			},
			"DescribeStorediSCSIVolumes": {
				"result_key": "StorediSCSIVolumes"
			},
			"DescribeTapeArchives": {
				"input_token": "Marker",
				"limit_key": "Limit",
				"output_token": "Marker",
				"result_key": "TapeArchives"
			},
			"DescribeTapeRecoveryPoints": {
				"input_token": "Marker",
				"limit_key": "Limit",
				"output_token": "Marker",
				"result_key": "TapeRecoveryPointInfos"
			},
			"DescribeTapes": {
				"input_token": "Marker",
				"limit_key": "Limit",
				"output_token": "Marker",
				"result_key": "Tapes"
			},
			"DescribeVTLDevices": {
				"input_token": "Marker",
				"limit_key": "Limit",
				"output_token": "Marker",
				"result_key": "VTLDevices"
			},
			"ListGateways": {
				"input_token": "Marker",
				"limit_key": "Limit",
				"output_token": "Marker",
				"result_key": "Gateways"
			},
			"ListLocalDisks": {
				"result_key": "Disks"
			},
			"ListVolumeRecoveryPoints": {
				"result_key": "VolumeRecoveryPointInfos"
			},
			"ListVolumes": {
				"input_token": "Marker",
				"limit_key": "Limit",
				"output_token": "Marker",
				"result_key": "VolumeInfos"
			}
		}
	};

/***/ },
/* 474 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['support'] = {};
	AWS.Support = Service.defineService('support', ['2013-04-15']);
	Object.defineProperty(apiLoader.services['support'], '2013-04-15', {
	  get: function get() {
	    var model = __webpack_require__(475);
	    model.paginators = __webpack_require__(476).pagination;
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.Support;


/***/ },
/* 475 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2013-04-15",
			"endpointPrefix": "support",
			"jsonVersion": "1.1",
			"protocol": "json",
			"serviceFullName": "AWS Support",
			"signatureVersion": "v4",
			"targetPrefix": "AWSSupport_20130415"
		},
		"operations": {
			"AddAttachmentsToSet": {
				"input": {
					"type": "structure",
					"required": [
						"attachments"
					],
					"members": {
						"attachmentSetId": {},
						"attachments": {
							"type": "list",
							"member": {
								"shape": "S4"
							}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"attachmentSetId": {},
						"expiryTime": {}
					}
				}
			},
			"AddCommunicationToCase": {
				"input": {
					"type": "structure",
					"required": [
						"communicationBody"
					],
					"members": {
						"caseId": {},
						"communicationBody": {},
						"ccEmailAddresses": {
							"shape": "Sc"
						},
						"attachmentSetId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"result": {
							"type": "boolean"
						}
					}
				}
			},
			"CreateCase": {
				"input": {
					"type": "structure",
					"required": [
						"subject",
						"communicationBody"
					],
					"members": {
						"subject": {},
						"serviceCode": {},
						"severityCode": {},
						"categoryCode": {},
						"communicationBody": {},
						"ccEmailAddresses": {
							"shape": "Sc"
						},
						"language": {},
						"issueType": {},
						"attachmentSetId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"caseId": {}
					}
				}
			},
			"DescribeAttachment": {
				"input": {
					"type": "structure",
					"required": [
						"attachmentId"
					],
					"members": {
						"attachmentId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"attachment": {
							"shape": "S4"
						}
					}
				}
			},
			"DescribeCases": {
				"input": {
					"type": "structure",
					"members": {
						"caseIdList": {
							"type": "list",
							"member": {}
						},
						"displayId": {},
						"afterTime": {},
						"beforeTime": {},
						"includeResolvedCases": {
							"type": "boolean"
						},
						"nextToken": {},
						"maxResults": {
							"type": "integer"
						},
						"language": {},
						"includeCommunications": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"cases": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"caseId": {},
									"displayId": {},
									"subject": {},
									"status": {},
									"serviceCode": {},
									"categoryCode": {},
									"severityCode": {},
									"submittedBy": {},
									"timeCreated": {},
									"recentCommunications": {
										"type": "structure",
										"members": {
											"communications": {
												"shape": "S17"
											},
											"nextToken": {}
										}
									},
									"ccEmailAddresses": {
										"shape": "Sc"
									},
									"language": {}
								}
							}
						},
						"nextToken": {}
					}
				}
			},
			"DescribeCommunications": {
				"input": {
					"type": "structure",
					"required": [
						"caseId"
					],
					"members": {
						"caseId": {},
						"beforeTime": {},
						"afterTime": {},
						"nextToken": {},
						"maxResults": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"communications": {
							"shape": "S17"
						},
						"nextToken": {}
					}
				}
			},
			"DescribeServices": {
				"input": {
					"type": "structure",
					"members": {
						"serviceCodeList": {
							"type": "list",
							"member": {}
						},
						"language": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"services": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"code": {},
									"name": {},
									"categories": {
										"type": "list",
										"member": {
											"type": "structure",
											"members": {
												"code": {},
												"name": {}
											}
										}
									}
								}
							}
						}
					}
				}
			},
			"DescribeSeverityLevels": {
				"input": {
					"type": "structure",
					"members": {
						"language": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"severityLevels": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"code": {},
									"name": {}
								}
							}
						}
					}
				}
			},
			"DescribeTrustedAdvisorCheckRefreshStatuses": {
				"input": {
					"type": "structure",
					"required": [
						"checkIds"
					],
					"members": {
						"checkIds": {
							"shape": "S1t"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"statuses"
					],
					"members": {
						"statuses": {
							"type": "list",
							"member": {
								"shape": "S1x"
							}
						}
					}
				}
			},
			"DescribeTrustedAdvisorCheckResult": {
				"input": {
					"type": "structure",
					"required": [
						"checkId"
					],
					"members": {
						"checkId": {},
						"language": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"result": {
							"type": "structure",
							"required": [
								"checkId",
								"timestamp",
								"status",
								"resourcesSummary",
								"categorySpecificSummary",
								"flaggedResources"
							],
							"members": {
								"checkId": {},
								"timestamp": {},
								"status": {},
								"resourcesSummary": {
									"shape": "S22"
								},
								"categorySpecificSummary": {
									"shape": "S23"
								},
								"flaggedResources": {
									"type": "list",
									"member": {
										"type": "structure",
										"required": [
											"status",
											"resourceId",
											"metadata"
										],
										"members": {
											"status": {},
											"region": {},
											"resourceId": {},
											"isSuppressed": {
												"type": "boolean"
											},
											"metadata": {
												"shape": "S1t"
											}
										}
									}
								}
							}
						}
					}
				}
			},
			"DescribeTrustedAdvisorCheckSummaries": {
				"input": {
					"type": "structure",
					"required": [
						"checkIds"
					],
					"members": {
						"checkIds": {
							"shape": "S1t"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"summaries"
					],
					"members": {
						"summaries": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"checkId",
									"timestamp",
									"status",
									"resourcesSummary",
									"categorySpecificSummary"
								],
								"members": {
									"checkId": {},
									"timestamp": {},
									"status": {},
									"hasFlaggedResources": {
										"type": "boolean"
									},
									"resourcesSummary": {
										"shape": "S22"
									},
									"categorySpecificSummary": {
										"shape": "S23"
									}
								}
							}
						}
					}
				}
			},
			"DescribeTrustedAdvisorChecks": {
				"input": {
					"type": "structure",
					"required": [
						"language"
					],
					"members": {
						"language": {}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"checks"
					],
					"members": {
						"checks": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"id",
									"name",
									"description",
									"category",
									"metadata"
								],
								"members": {
									"id": {},
									"name": {},
									"description": {},
									"category": {},
									"metadata": {
										"shape": "S1t"
									}
								}
							}
						}
					}
				}
			},
			"RefreshTrustedAdvisorCheck": {
				"input": {
					"type": "structure",
					"required": [
						"checkId"
					],
					"members": {
						"checkId": {}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"status"
					],
					"members": {
						"status": {
							"shape": "S1x"
						}
					}
				}
			},
			"ResolveCase": {
				"input": {
					"type": "structure",
					"members": {
						"caseId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"initialCaseStatus": {},
						"finalCaseStatus": {}
					}
				}
			}
		},
		"shapes": {
			"S4": {
				"type": "structure",
				"members": {
					"fileName": {},
					"data": {
						"type": "blob"
					}
				}
			},
			"Sc": {
				"type": "list",
				"member": {}
			},
			"S17": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"caseId": {},
						"body": {},
						"submittedBy": {},
						"timeCreated": {},
						"attachmentSet": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"attachmentId": {},
									"fileName": {}
								}
							}
						}
					}
				}
			},
			"S1t": {
				"type": "list",
				"member": {}
			},
			"S1x": {
				"type": "structure",
				"required": [
					"checkId",
					"status",
					"millisUntilNextRefreshable"
				],
				"members": {
					"checkId": {},
					"status": {},
					"millisUntilNextRefreshable": {
						"type": "long"
					}
				}
			},
			"S22": {
				"type": "structure",
				"required": [
					"resourcesProcessed",
					"resourcesFlagged",
					"resourcesIgnored",
					"resourcesSuppressed"
				],
				"members": {
					"resourcesProcessed": {
						"type": "long"
					},
					"resourcesFlagged": {
						"type": "long"
					},
					"resourcesIgnored": {
						"type": "long"
					},
					"resourcesSuppressed": {
						"type": "long"
					}
				}
			},
			"S23": {
				"type": "structure",
				"members": {
					"costOptimizing": {
						"type": "structure",
						"required": [
							"estimatedMonthlySavings",
							"estimatedPercentMonthlySavings"
						],
						"members": {
							"estimatedMonthlySavings": {
								"type": "double"
							},
							"estimatedPercentMonthlySavings": {
								"type": "double"
							}
						}
					}
				}
			}
		}
	};

/***/ },
/* 476 */
/***/ function(module, exports) {

	module.exports = {
		"pagination": {
			"DescribeCases": {
				"input_token": "nextToken",
				"output_token": "nextToken",
				"limit_key": "maxResults",
				"result_key": "cases"
			},
			"DescribeCommunications": {
				"input_token": "nextToken",
				"output_token": "nextToken",
				"limit_key": "maxResults",
				"result_key": "communications"
			},
			"DescribeServices": {
				"result_key": "services"
			},
			"DescribeTrustedAdvisorCheckRefreshStatuses": {
				"result_key": "statuses"
			},
			"DescribeTrustedAdvisorCheckSummaries": {
				"result_key": "summaries"
			}
		}
	};

/***/ },
/* 477 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['swf'] = {};
	AWS.SWF = Service.defineService('swf', ['2012-01-25']);
	__webpack_require__(478);
	Object.defineProperty(apiLoader.services['swf'], '2012-01-25', {
	  get: function get() {
	    var model = __webpack_require__(479);
	    model.paginators = __webpack_require__(480).pagination;
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.SWF;


/***/ },
/* 478 */
/***/ function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(93);

	AWS.util.hideProperties(AWS, ['SimpleWorkflow']);

	/**
	 * @constant
	 * @readonly
	 * Backwards compatibility for access to the {AWS.SWF} service class.
	 */
	AWS.SimpleWorkflow = AWS.SWF;


/***/ },
/* 479 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2012-01-25",
			"endpointPrefix": "swf",
			"jsonVersion": "1.0",
			"serviceAbbreviation": "Amazon SWF",
			"serviceFullName": "Amazon Simple Workflow Service",
			"signatureVersion": "v4",
			"targetPrefix": "SimpleWorkflowService",
			"timestampFormat": "unixTimestamp",
			"protocol": "json"
		},
		"operations": {
			"CountClosedWorkflowExecutions": {
				"input": {
					"type": "structure",
					"required": [
						"domain"
					],
					"members": {
						"domain": {},
						"startTimeFilter": {
							"shape": "S3"
						},
						"closeTimeFilter": {
							"shape": "S3"
						},
						"executionFilter": {
							"shape": "S5"
						},
						"typeFilter": {
							"shape": "S7"
						},
						"tagFilter": {
							"shape": "Sa"
						},
						"closeStatusFilter": {
							"shape": "Sc"
						}
					}
				},
				"output": {
					"shape": "Se"
				}
			},
			"CountOpenWorkflowExecutions": {
				"input": {
					"type": "structure",
					"required": [
						"domain",
						"startTimeFilter"
					],
					"members": {
						"domain": {},
						"startTimeFilter": {
							"shape": "S3"
						},
						"typeFilter": {
							"shape": "S7"
						},
						"tagFilter": {
							"shape": "Sa"
						},
						"executionFilter": {
							"shape": "S5"
						}
					}
				},
				"output": {
					"shape": "Se"
				}
			},
			"CountPendingActivityTasks": {
				"input": {
					"type": "structure",
					"required": [
						"domain",
						"taskList"
					],
					"members": {
						"domain": {},
						"taskList": {
							"shape": "Sj"
						}
					}
				},
				"output": {
					"shape": "Sk"
				}
			},
			"CountPendingDecisionTasks": {
				"input": {
					"type": "structure",
					"required": [
						"domain",
						"taskList"
					],
					"members": {
						"domain": {},
						"taskList": {
							"shape": "Sj"
						}
					}
				},
				"output": {
					"shape": "Sk"
				}
			},
			"DeprecateActivityType": {
				"input": {
					"type": "structure",
					"required": [
						"domain",
						"activityType"
					],
					"members": {
						"domain": {},
						"activityType": {
							"shape": "Sn"
						}
					}
				}
			},
			"DeprecateDomain": {
				"input": {
					"type": "structure",
					"required": [
						"name"
					],
					"members": {
						"name": {}
					}
				}
			},
			"DeprecateWorkflowType": {
				"input": {
					"type": "structure",
					"required": [
						"domain",
						"workflowType"
					],
					"members": {
						"domain": {},
						"workflowType": {
							"shape": "Sr"
						}
					}
				}
			},
			"DescribeActivityType": {
				"input": {
					"type": "structure",
					"required": [
						"domain",
						"activityType"
					],
					"members": {
						"domain": {},
						"activityType": {
							"shape": "Sn"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"typeInfo",
						"configuration"
					],
					"members": {
						"typeInfo": {
							"shape": "Su"
						},
						"configuration": {
							"type": "structure",
							"members": {
								"defaultTaskStartToCloseTimeout": {},
								"defaultTaskHeartbeatTimeout": {},
								"defaultTaskList": {
									"shape": "Sj"
								},
								"defaultTaskPriority": {},
								"defaultTaskScheduleToStartTimeout": {},
								"defaultTaskScheduleToCloseTimeout": {}
							}
						}
					}
				}
			},
			"DescribeDomain": {
				"input": {
					"type": "structure",
					"required": [
						"name"
					],
					"members": {
						"name": {}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"domainInfo",
						"configuration"
					],
					"members": {
						"domainInfo": {
							"shape": "S12"
						},
						"configuration": {
							"type": "structure",
							"required": [
								"workflowExecutionRetentionPeriodInDays"
							],
							"members": {
								"workflowExecutionRetentionPeriodInDays": {}
							}
						}
					}
				}
			},
			"DescribeWorkflowExecution": {
				"input": {
					"type": "structure",
					"required": [
						"domain",
						"execution"
					],
					"members": {
						"domain": {},
						"execution": {
							"shape": "S16"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"executionInfo",
						"executionConfiguration",
						"openCounts"
					],
					"members": {
						"executionInfo": {
							"shape": "S19"
						},
						"executionConfiguration": {
							"type": "structure",
							"required": [
								"taskStartToCloseTimeout",
								"executionStartToCloseTimeout",
								"taskList",
								"childPolicy"
							],
							"members": {
								"taskStartToCloseTimeout": {},
								"executionStartToCloseTimeout": {},
								"taskList": {
									"shape": "Sj"
								},
								"taskPriority": {},
								"childPolicy": {},
								"lambdaRole": {}
							}
						},
						"openCounts": {
							"type": "structure",
							"required": [
								"openActivityTasks",
								"openDecisionTasks",
								"openTimers",
								"openChildWorkflowExecutions"
							],
							"members": {
								"openActivityTasks": {
									"type": "integer"
								},
								"openDecisionTasks": {
									"type": "integer"
								},
								"openTimers": {
									"type": "integer"
								},
								"openChildWorkflowExecutions": {
									"type": "integer"
								},
								"openLambdaFunctions": {
									"type": "integer"
								}
							}
						},
						"latestActivityTaskTimestamp": {
							"type": "timestamp"
						},
						"latestExecutionContext": {}
					}
				}
			},
			"DescribeWorkflowType": {
				"input": {
					"type": "structure",
					"required": [
						"domain",
						"workflowType"
					],
					"members": {
						"domain": {},
						"workflowType": {
							"shape": "Sr"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"typeInfo",
						"configuration"
					],
					"members": {
						"typeInfo": {
							"shape": "S1m"
						},
						"configuration": {
							"type": "structure",
							"members": {
								"defaultTaskStartToCloseTimeout": {},
								"defaultExecutionStartToCloseTimeout": {},
								"defaultTaskList": {
									"shape": "Sj"
								},
								"defaultTaskPriority": {},
								"defaultChildPolicy": {},
								"defaultLambdaRole": {}
							}
						}
					}
				}
			},
			"GetWorkflowExecutionHistory": {
				"input": {
					"type": "structure",
					"required": [
						"domain",
						"execution"
					],
					"members": {
						"domain": {},
						"execution": {
							"shape": "S16"
						},
						"nextPageToken": {},
						"maximumPageSize": {
							"type": "integer"
						},
						"reverseOrder": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"events"
					],
					"members": {
						"events": {
							"shape": "S1t"
						},
						"nextPageToken": {}
					}
				}
			},
			"ListActivityTypes": {
				"input": {
					"type": "structure",
					"required": [
						"domain",
						"registrationStatus"
					],
					"members": {
						"domain": {},
						"name": {},
						"registrationStatus": {},
						"nextPageToken": {},
						"maximumPageSize": {
							"type": "integer"
						},
						"reverseOrder": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"typeInfos"
					],
					"members": {
						"typeInfos": {
							"type": "list",
							"member": {
								"shape": "Su"
							}
						},
						"nextPageToken": {}
					}
				}
			},
			"ListClosedWorkflowExecutions": {
				"input": {
					"type": "structure",
					"required": [
						"domain"
					],
					"members": {
						"domain": {},
						"startTimeFilter": {
							"shape": "S3"
						},
						"closeTimeFilter": {
							"shape": "S3"
						},
						"executionFilter": {
							"shape": "S5"
						},
						"closeStatusFilter": {
							"shape": "Sc"
						},
						"typeFilter": {
							"shape": "S7"
						},
						"tagFilter": {
							"shape": "Sa"
						},
						"nextPageToken": {},
						"maximumPageSize": {
							"type": "integer"
						},
						"reverseOrder": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"shape": "S4g"
				}
			},
			"ListDomains": {
				"input": {
					"type": "structure",
					"required": [
						"registrationStatus"
					],
					"members": {
						"nextPageToken": {},
						"registrationStatus": {},
						"maximumPageSize": {
							"type": "integer"
						},
						"reverseOrder": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"domainInfos"
					],
					"members": {
						"domainInfos": {
							"type": "list",
							"member": {
								"shape": "S12"
							}
						},
						"nextPageToken": {}
					}
				}
			},
			"ListOpenWorkflowExecutions": {
				"input": {
					"type": "structure",
					"required": [
						"domain",
						"startTimeFilter"
					],
					"members": {
						"domain": {},
						"startTimeFilter": {
							"shape": "S3"
						},
						"typeFilter": {
							"shape": "S7"
						},
						"tagFilter": {
							"shape": "Sa"
						},
						"nextPageToken": {},
						"maximumPageSize": {
							"type": "integer"
						},
						"reverseOrder": {
							"type": "boolean"
						},
						"executionFilter": {
							"shape": "S5"
						}
					}
				},
				"output": {
					"shape": "S4g"
				}
			},
			"ListWorkflowTypes": {
				"input": {
					"type": "structure",
					"required": [
						"domain",
						"registrationStatus"
					],
					"members": {
						"domain": {},
						"name": {},
						"registrationStatus": {},
						"nextPageToken": {},
						"maximumPageSize": {
							"type": "integer"
						},
						"reverseOrder": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"typeInfos"
					],
					"members": {
						"typeInfos": {
							"type": "list",
							"member": {
								"shape": "S1m"
							}
						},
						"nextPageToken": {}
					}
				}
			},
			"PollForActivityTask": {
				"input": {
					"type": "structure",
					"required": [
						"domain",
						"taskList"
					],
					"members": {
						"domain": {},
						"taskList": {
							"shape": "Sj"
						},
						"identity": {}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"taskToken",
						"activityId",
						"startedEventId",
						"workflowExecution",
						"activityType"
					],
					"members": {
						"taskToken": {},
						"activityId": {},
						"startedEventId": {
							"type": "long"
						},
						"workflowExecution": {
							"shape": "S16"
						},
						"activityType": {
							"shape": "Sn"
						},
						"input": {}
					}
				}
			},
			"PollForDecisionTask": {
				"input": {
					"type": "structure",
					"required": [
						"domain",
						"taskList"
					],
					"members": {
						"domain": {},
						"taskList": {
							"shape": "Sj"
						},
						"identity": {},
						"nextPageToken": {},
						"maximumPageSize": {
							"type": "integer"
						},
						"reverseOrder": {
							"type": "boolean"
						}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"taskToken",
						"startedEventId",
						"workflowExecution",
						"workflowType",
						"events"
					],
					"members": {
						"taskToken": {},
						"startedEventId": {
							"type": "long"
						},
						"workflowExecution": {
							"shape": "S16"
						},
						"workflowType": {
							"shape": "Sr"
						},
						"events": {
							"shape": "S1t"
						},
						"nextPageToken": {},
						"previousStartedEventId": {
							"type": "long"
						}
					}
				}
			},
			"RecordActivityTaskHeartbeat": {
				"input": {
					"type": "structure",
					"required": [
						"taskToken"
					],
					"members": {
						"taskToken": {},
						"details": {}
					}
				},
				"output": {
					"type": "structure",
					"required": [
						"cancelRequested"
					],
					"members": {
						"cancelRequested": {
							"type": "boolean"
						}
					}
				}
			},
			"RegisterActivityType": {
				"input": {
					"type": "structure",
					"required": [
						"domain",
						"name",
						"version"
					],
					"members": {
						"domain": {},
						"name": {},
						"version": {},
						"description": {},
						"defaultTaskStartToCloseTimeout": {},
						"defaultTaskHeartbeatTimeout": {},
						"defaultTaskList": {
							"shape": "Sj"
						},
						"defaultTaskPriority": {},
						"defaultTaskScheduleToStartTimeout": {},
						"defaultTaskScheduleToCloseTimeout": {}
					}
				}
			},
			"RegisterDomain": {
				"input": {
					"type": "structure",
					"required": [
						"name",
						"workflowExecutionRetentionPeriodInDays"
					],
					"members": {
						"name": {},
						"description": {},
						"workflowExecutionRetentionPeriodInDays": {}
					}
				}
			},
			"RegisterWorkflowType": {
				"input": {
					"type": "structure",
					"required": [
						"domain",
						"name",
						"version"
					],
					"members": {
						"domain": {},
						"name": {},
						"version": {},
						"description": {},
						"defaultTaskStartToCloseTimeout": {},
						"defaultExecutionStartToCloseTimeout": {},
						"defaultTaskList": {
							"shape": "Sj"
						},
						"defaultTaskPriority": {},
						"defaultChildPolicy": {},
						"defaultLambdaRole": {}
					}
				}
			},
			"RequestCancelWorkflowExecution": {
				"input": {
					"type": "structure",
					"required": [
						"domain",
						"workflowId"
					],
					"members": {
						"domain": {},
						"workflowId": {},
						"runId": {}
					}
				}
			},
			"RespondActivityTaskCanceled": {
				"input": {
					"type": "structure",
					"required": [
						"taskToken"
					],
					"members": {
						"taskToken": {},
						"details": {}
					}
				}
			},
			"RespondActivityTaskCompleted": {
				"input": {
					"type": "structure",
					"required": [
						"taskToken"
					],
					"members": {
						"taskToken": {},
						"result": {}
					}
				}
			},
			"RespondActivityTaskFailed": {
				"input": {
					"type": "structure",
					"required": [
						"taskToken"
					],
					"members": {
						"taskToken": {},
						"reason": {},
						"details": {}
					}
				}
			},
			"RespondDecisionTaskCompleted": {
				"input": {
					"type": "structure",
					"required": [
						"taskToken"
					],
					"members": {
						"taskToken": {},
						"decisions": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"decisionType"
								],
								"members": {
									"decisionType": {},
									"scheduleActivityTaskDecisionAttributes": {
										"type": "structure",
										"required": [
											"activityType",
											"activityId"
										],
										"members": {
											"activityType": {
												"shape": "Sn"
											},
											"activityId": {},
											"control": {},
											"input": {},
											"scheduleToCloseTimeout": {},
											"taskList": {
												"shape": "Sj"
											},
											"taskPriority": {},
											"scheduleToStartTimeout": {},
											"startToCloseTimeout": {},
											"heartbeatTimeout": {}
										}
									},
									"requestCancelActivityTaskDecisionAttributes": {
										"type": "structure",
										"required": [
											"activityId"
										],
										"members": {
											"activityId": {}
										}
									},
									"completeWorkflowExecutionDecisionAttributes": {
										"type": "structure",
										"members": {
											"result": {}
										}
									},
									"failWorkflowExecutionDecisionAttributes": {
										"type": "structure",
										"members": {
											"reason": {},
											"details": {}
										}
									},
									"cancelWorkflowExecutionDecisionAttributes": {
										"type": "structure",
										"members": {
											"details": {}
										}
									},
									"continueAsNewWorkflowExecutionDecisionAttributes": {
										"type": "structure",
										"members": {
											"input": {},
											"executionStartToCloseTimeout": {},
											"taskList": {
												"shape": "Sj"
											},
											"taskPriority": {},
											"taskStartToCloseTimeout": {},
											"childPolicy": {},
											"tagList": {
												"shape": "S1b"
											},
											"workflowTypeVersion": {},
											"lambdaRole": {}
										}
									},
									"recordMarkerDecisionAttributes": {
										"type": "structure",
										"required": [
											"markerName"
										],
										"members": {
											"markerName": {},
											"details": {}
										}
									},
									"startTimerDecisionAttributes": {
										"type": "structure",
										"required": [
											"timerId",
											"startToFireTimeout"
										],
										"members": {
											"timerId": {},
											"control": {},
											"startToFireTimeout": {}
										}
									},
									"cancelTimerDecisionAttributes": {
										"type": "structure",
										"required": [
											"timerId"
										],
										"members": {
											"timerId": {}
										}
									},
									"signalExternalWorkflowExecutionDecisionAttributes": {
										"type": "structure",
										"required": [
											"workflowId",
											"signalName"
										],
										"members": {
											"workflowId": {},
											"runId": {},
											"signalName": {},
											"input": {},
											"control": {}
										}
									},
									"requestCancelExternalWorkflowExecutionDecisionAttributes": {
										"type": "structure",
										"required": [
											"workflowId"
										],
										"members": {
											"workflowId": {},
											"runId": {},
											"control": {}
										}
									},
									"startChildWorkflowExecutionDecisionAttributes": {
										"type": "structure",
										"required": [
											"workflowType",
											"workflowId"
										],
										"members": {
											"workflowType": {
												"shape": "Sr"
											},
											"workflowId": {},
											"control": {},
											"input": {},
											"executionStartToCloseTimeout": {},
											"taskList": {
												"shape": "Sj"
											},
											"taskPriority": {},
											"taskStartToCloseTimeout": {},
											"childPolicy": {},
											"tagList": {
												"shape": "S1b"
											},
											"lambdaRole": {}
										}
									},
									"scheduleLambdaFunctionDecisionAttributes": {
										"type": "structure",
										"required": [
											"id",
											"name"
										],
										"members": {
											"id": {},
											"name": {},
											"input": {},
											"startToCloseTimeout": {}
										}
									}
								}
							}
						},
						"executionContext": {}
					}
				}
			},
			"SignalWorkflowExecution": {
				"input": {
					"type": "structure",
					"required": [
						"domain",
						"workflowId",
						"signalName"
					],
					"members": {
						"domain": {},
						"workflowId": {},
						"runId": {},
						"signalName": {},
						"input": {}
					}
				}
			},
			"StartWorkflowExecution": {
				"input": {
					"type": "structure",
					"required": [
						"domain",
						"workflowId",
						"workflowType"
					],
					"members": {
						"domain": {},
						"workflowId": {},
						"workflowType": {
							"shape": "Sr"
						},
						"taskList": {
							"shape": "Sj"
						},
						"taskPriority": {},
						"input": {},
						"executionStartToCloseTimeout": {},
						"tagList": {
							"shape": "S1b"
						},
						"taskStartToCloseTimeout": {},
						"childPolicy": {},
						"lambdaRole": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"runId": {}
					}
				}
			},
			"TerminateWorkflowExecution": {
				"input": {
					"type": "structure",
					"required": [
						"domain",
						"workflowId"
					],
					"members": {
						"domain": {},
						"workflowId": {},
						"runId": {},
						"reason": {},
						"details": {},
						"childPolicy": {}
					}
				}
			}
		},
		"shapes": {
			"S3": {
				"type": "structure",
				"required": [
					"oldestDate"
				],
				"members": {
					"oldestDate": {
						"type": "timestamp"
					},
					"latestDate": {
						"type": "timestamp"
					}
				}
			},
			"S5": {
				"type": "structure",
				"required": [
					"workflowId"
				],
				"members": {
					"workflowId": {}
				}
			},
			"S7": {
				"type": "structure",
				"required": [
					"name"
				],
				"members": {
					"name": {},
					"version": {}
				}
			},
			"Sa": {
				"type": "structure",
				"required": [
					"tag"
				],
				"members": {
					"tag": {}
				}
			},
			"Sc": {
				"type": "structure",
				"required": [
					"status"
				],
				"members": {
					"status": {}
				}
			},
			"Se": {
				"type": "structure",
				"required": [
					"count"
				],
				"members": {
					"count": {
						"type": "integer"
					},
					"truncated": {
						"type": "boolean"
					}
				}
			},
			"Sj": {
				"type": "structure",
				"required": [
					"name"
				],
				"members": {
					"name": {}
				}
			},
			"Sk": {
				"type": "structure",
				"required": [
					"count"
				],
				"members": {
					"count": {
						"type": "integer"
					},
					"truncated": {
						"type": "boolean"
					}
				}
			},
			"Sn": {
				"type": "structure",
				"required": [
					"name",
					"version"
				],
				"members": {
					"name": {},
					"version": {}
				}
			},
			"Sr": {
				"type": "structure",
				"required": [
					"name",
					"version"
				],
				"members": {
					"name": {},
					"version": {}
				}
			},
			"Su": {
				"type": "structure",
				"required": [
					"activityType",
					"status",
					"creationDate"
				],
				"members": {
					"activityType": {
						"shape": "Sn"
					},
					"status": {},
					"description": {},
					"creationDate": {
						"type": "timestamp"
					},
					"deprecationDate": {
						"type": "timestamp"
					}
				}
			},
			"S12": {
				"type": "structure",
				"required": [
					"name",
					"status"
				],
				"members": {
					"name": {},
					"status": {},
					"description": {}
				}
			},
			"S16": {
				"type": "structure",
				"required": [
					"workflowId",
					"runId"
				],
				"members": {
					"workflowId": {},
					"runId": {}
				}
			},
			"S19": {
				"type": "structure",
				"required": [
					"execution",
					"workflowType",
					"startTimestamp",
					"executionStatus"
				],
				"members": {
					"execution": {
						"shape": "S16"
					},
					"workflowType": {
						"shape": "Sr"
					},
					"startTimestamp": {
						"type": "timestamp"
					},
					"closeTimestamp": {
						"type": "timestamp"
					},
					"executionStatus": {},
					"closeStatus": {},
					"parent": {
						"shape": "S16"
					},
					"tagList": {
						"shape": "S1b"
					},
					"cancelRequested": {
						"type": "boolean"
					}
				}
			},
			"S1b": {
				"type": "list",
				"member": {}
			},
			"S1m": {
				"type": "structure",
				"required": [
					"workflowType",
					"status",
					"creationDate"
				],
				"members": {
					"workflowType": {
						"shape": "Sr"
					},
					"status": {},
					"description": {},
					"creationDate": {
						"type": "timestamp"
					},
					"deprecationDate": {
						"type": "timestamp"
					}
				}
			},
			"S1t": {
				"type": "list",
				"member": {
					"type": "structure",
					"required": [
						"eventTimestamp",
						"eventType",
						"eventId"
					],
					"members": {
						"eventTimestamp": {
							"type": "timestamp"
						},
						"eventType": {},
						"eventId": {
							"type": "long"
						},
						"workflowExecutionStartedEventAttributes": {
							"type": "structure",
							"required": [
								"childPolicy",
								"taskList",
								"workflowType"
							],
							"members": {
								"input": {},
								"executionStartToCloseTimeout": {},
								"taskStartToCloseTimeout": {},
								"childPolicy": {},
								"taskList": {
									"shape": "Sj"
								},
								"workflowType": {
									"shape": "Sr"
								},
								"tagList": {
									"shape": "S1b"
								},
								"taskPriority": {},
								"continuedExecutionRunId": {},
								"parentWorkflowExecution": {
									"shape": "S16"
								},
								"parentInitiatedEventId": {
									"type": "long"
								},
								"lambdaRole": {}
							}
						},
						"workflowExecutionCompletedEventAttributes": {
							"type": "structure",
							"required": [
								"decisionTaskCompletedEventId"
							],
							"members": {
								"result": {},
								"decisionTaskCompletedEventId": {
									"type": "long"
								}
							}
						},
						"completeWorkflowExecutionFailedEventAttributes": {
							"type": "structure",
							"required": [
								"cause",
								"decisionTaskCompletedEventId"
							],
							"members": {
								"cause": {},
								"decisionTaskCompletedEventId": {
									"type": "long"
								}
							}
						},
						"workflowExecutionFailedEventAttributes": {
							"type": "structure",
							"required": [
								"decisionTaskCompletedEventId"
							],
							"members": {
								"reason": {},
								"details": {},
								"decisionTaskCompletedEventId": {
									"type": "long"
								}
							}
						},
						"failWorkflowExecutionFailedEventAttributes": {
							"type": "structure",
							"required": [
								"cause",
								"decisionTaskCompletedEventId"
							],
							"members": {
								"cause": {},
								"decisionTaskCompletedEventId": {
									"type": "long"
								}
							}
						},
						"workflowExecutionTimedOutEventAttributes": {
							"type": "structure",
							"required": [
								"timeoutType",
								"childPolicy"
							],
							"members": {
								"timeoutType": {},
								"childPolicy": {}
							}
						},
						"workflowExecutionCanceledEventAttributes": {
							"type": "structure",
							"required": [
								"decisionTaskCompletedEventId"
							],
							"members": {
								"details": {},
								"decisionTaskCompletedEventId": {
									"type": "long"
								}
							}
						},
						"cancelWorkflowExecutionFailedEventAttributes": {
							"type": "structure",
							"required": [
								"cause",
								"decisionTaskCompletedEventId"
							],
							"members": {
								"cause": {},
								"decisionTaskCompletedEventId": {
									"type": "long"
								}
							}
						},
						"workflowExecutionContinuedAsNewEventAttributes": {
							"type": "structure",
							"required": [
								"decisionTaskCompletedEventId",
								"newExecutionRunId",
								"taskList",
								"childPolicy",
								"workflowType"
							],
							"members": {
								"input": {},
								"decisionTaskCompletedEventId": {
									"type": "long"
								},
								"newExecutionRunId": {},
								"executionStartToCloseTimeout": {},
								"taskList": {
									"shape": "Sj"
								},
								"taskPriority": {},
								"taskStartToCloseTimeout": {},
								"childPolicy": {},
								"tagList": {
									"shape": "S1b"
								},
								"workflowType": {
									"shape": "Sr"
								},
								"lambdaRole": {}
							}
						},
						"continueAsNewWorkflowExecutionFailedEventAttributes": {
							"type": "structure",
							"required": [
								"cause",
								"decisionTaskCompletedEventId"
							],
							"members": {
								"cause": {},
								"decisionTaskCompletedEventId": {
									"type": "long"
								}
							}
						},
						"workflowExecutionTerminatedEventAttributes": {
							"type": "structure",
							"required": [
								"childPolicy"
							],
							"members": {
								"reason": {},
								"details": {},
								"childPolicy": {},
								"cause": {}
							}
						},
						"workflowExecutionCancelRequestedEventAttributes": {
							"type": "structure",
							"members": {
								"externalWorkflowExecution": {
									"shape": "S16"
								},
								"externalInitiatedEventId": {
									"type": "long"
								},
								"cause": {}
							}
						},
						"decisionTaskScheduledEventAttributes": {
							"type": "structure",
							"required": [
								"taskList"
							],
							"members": {
								"taskList": {
									"shape": "Sj"
								},
								"taskPriority": {},
								"startToCloseTimeout": {}
							}
						},
						"decisionTaskStartedEventAttributes": {
							"type": "structure",
							"required": [
								"scheduledEventId"
							],
							"members": {
								"identity": {},
								"scheduledEventId": {
									"type": "long"
								}
							}
						},
						"decisionTaskCompletedEventAttributes": {
							"type": "structure",
							"required": [
								"scheduledEventId",
								"startedEventId"
							],
							"members": {
								"executionContext": {},
								"scheduledEventId": {
									"type": "long"
								},
								"startedEventId": {
									"type": "long"
								}
							}
						},
						"decisionTaskTimedOutEventAttributes": {
							"type": "structure",
							"required": [
								"timeoutType",
								"scheduledEventId",
								"startedEventId"
							],
							"members": {
								"timeoutType": {},
								"scheduledEventId": {
									"type": "long"
								},
								"startedEventId": {
									"type": "long"
								}
							}
						},
						"activityTaskScheduledEventAttributes": {
							"type": "structure",
							"required": [
								"activityType",
								"activityId",
								"taskList",
								"decisionTaskCompletedEventId"
							],
							"members": {
								"activityType": {
									"shape": "Sn"
								},
								"activityId": {},
								"input": {},
								"control": {},
								"scheduleToStartTimeout": {},
								"scheduleToCloseTimeout": {},
								"startToCloseTimeout": {},
								"taskList": {
									"shape": "Sj"
								},
								"taskPriority": {},
								"decisionTaskCompletedEventId": {
									"type": "long"
								},
								"heartbeatTimeout": {}
							}
						},
						"activityTaskStartedEventAttributes": {
							"type": "structure",
							"required": [
								"scheduledEventId"
							],
							"members": {
								"identity": {},
								"scheduledEventId": {
									"type": "long"
								}
							}
						},
						"activityTaskCompletedEventAttributes": {
							"type": "structure",
							"required": [
								"scheduledEventId",
								"startedEventId"
							],
							"members": {
								"result": {},
								"scheduledEventId": {
									"type": "long"
								},
								"startedEventId": {
									"type": "long"
								}
							}
						},
						"activityTaskFailedEventAttributes": {
							"type": "structure",
							"required": [
								"scheduledEventId",
								"startedEventId"
							],
							"members": {
								"reason": {},
								"details": {},
								"scheduledEventId": {
									"type": "long"
								},
								"startedEventId": {
									"type": "long"
								}
							}
						},
						"activityTaskTimedOutEventAttributes": {
							"type": "structure",
							"required": [
								"timeoutType",
								"scheduledEventId",
								"startedEventId"
							],
							"members": {
								"timeoutType": {},
								"scheduledEventId": {
									"type": "long"
								},
								"startedEventId": {
									"type": "long"
								},
								"details": {}
							}
						},
						"activityTaskCanceledEventAttributes": {
							"type": "structure",
							"required": [
								"scheduledEventId",
								"startedEventId"
							],
							"members": {
								"details": {},
								"scheduledEventId": {
									"type": "long"
								},
								"startedEventId": {
									"type": "long"
								},
								"latestCancelRequestedEventId": {
									"type": "long"
								}
							}
						},
						"activityTaskCancelRequestedEventAttributes": {
							"type": "structure",
							"required": [
								"decisionTaskCompletedEventId",
								"activityId"
							],
							"members": {
								"decisionTaskCompletedEventId": {
									"type": "long"
								},
								"activityId": {}
							}
						},
						"workflowExecutionSignaledEventAttributes": {
							"type": "structure",
							"required": [
								"signalName"
							],
							"members": {
								"signalName": {},
								"input": {},
								"externalWorkflowExecution": {
									"shape": "S16"
								},
								"externalInitiatedEventId": {
									"type": "long"
								}
							}
						},
						"markerRecordedEventAttributes": {
							"type": "structure",
							"required": [
								"markerName",
								"decisionTaskCompletedEventId"
							],
							"members": {
								"markerName": {},
								"details": {},
								"decisionTaskCompletedEventId": {
									"type": "long"
								}
							}
						},
						"recordMarkerFailedEventAttributes": {
							"type": "structure",
							"required": [
								"markerName",
								"cause",
								"decisionTaskCompletedEventId"
							],
							"members": {
								"markerName": {},
								"cause": {},
								"decisionTaskCompletedEventId": {
									"type": "long"
								}
							}
						},
						"timerStartedEventAttributes": {
							"type": "structure",
							"required": [
								"timerId",
								"startToFireTimeout",
								"decisionTaskCompletedEventId"
							],
							"members": {
								"timerId": {},
								"control": {},
								"startToFireTimeout": {},
								"decisionTaskCompletedEventId": {
									"type": "long"
								}
							}
						},
						"timerFiredEventAttributes": {
							"type": "structure",
							"required": [
								"timerId",
								"startedEventId"
							],
							"members": {
								"timerId": {},
								"startedEventId": {
									"type": "long"
								}
							}
						},
						"timerCanceledEventAttributes": {
							"type": "structure",
							"required": [
								"timerId",
								"startedEventId",
								"decisionTaskCompletedEventId"
							],
							"members": {
								"timerId": {},
								"startedEventId": {
									"type": "long"
								},
								"decisionTaskCompletedEventId": {
									"type": "long"
								}
							}
						},
						"startChildWorkflowExecutionInitiatedEventAttributes": {
							"type": "structure",
							"required": [
								"workflowId",
								"workflowType",
								"taskList",
								"decisionTaskCompletedEventId",
								"childPolicy"
							],
							"members": {
								"workflowId": {},
								"workflowType": {
									"shape": "Sr"
								},
								"control": {},
								"input": {},
								"executionStartToCloseTimeout": {},
								"taskList": {
									"shape": "Sj"
								},
								"taskPriority": {},
								"decisionTaskCompletedEventId": {
									"type": "long"
								},
								"childPolicy": {},
								"taskStartToCloseTimeout": {},
								"tagList": {
									"shape": "S1b"
								},
								"lambdaRole": {}
							}
						},
						"childWorkflowExecutionStartedEventAttributes": {
							"type": "structure",
							"required": [
								"workflowExecution",
								"workflowType",
								"initiatedEventId"
							],
							"members": {
								"workflowExecution": {
									"shape": "S16"
								},
								"workflowType": {
									"shape": "Sr"
								},
								"initiatedEventId": {
									"type": "long"
								}
							}
						},
						"childWorkflowExecutionCompletedEventAttributes": {
							"type": "structure",
							"required": [
								"workflowExecution",
								"workflowType",
								"initiatedEventId",
								"startedEventId"
							],
							"members": {
								"workflowExecution": {
									"shape": "S16"
								},
								"workflowType": {
									"shape": "Sr"
								},
								"result": {},
								"initiatedEventId": {
									"type": "long"
								},
								"startedEventId": {
									"type": "long"
								}
							}
						},
						"childWorkflowExecutionFailedEventAttributes": {
							"type": "structure",
							"required": [
								"workflowExecution",
								"workflowType",
								"initiatedEventId",
								"startedEventId"
							],
							"members": {
								"workflowExecution": {
									"shape": "S16"
								},
								"workflowType": {
									"shape": "Sr"
								},
								"reason": {},
								"details": {},
								"initiatedEventId": {
									"type": "long"
								},
								"startedEventId": {
									"type": "long"
								}
							}
						},
						"childWorkflowExecutionTimedOutEventAttributes": {
							"type": "structure",
							"required": [
								"workflowExecution",
								"workflowType",
								"timeoutType",
								"initiatedEventId",
								"startedEventId"
							],
							"members": {
								"workflowExecution": {
									"shape": "S16"
								},
								"workflowType": {
									"shape": "Sr"
								},
								"timeoutType": {},
								"initiatedEventId": {
									"type": "long"
								},
								"startedEventId": {
									"type": "long"
								}
							}
						},
						"childWorkflowExecutionCanceledEventAttributes": {
							"type": "structure",
							"required": [
								"workflowExecution",
								"workflowType",
								"initiatedEventId",
								"startedEventId"
							],
							"members": {
								"workflowExecution": {
									"shape": "S16"
								},
								"workflowType": {
									"shape": "Sr"
								},
								"details": {},
								"initiatedEventId": {
									"type": "long"
								},
								"startedEventId": {
									"type": "long"
								}
							}
						},
						"childWorkflowExecutionTerminatedEventAttributes": {
							"type": "structure",
							"required": [
								"workflowExecution",
								"workflowType",
								"initiatedEventId",
								"startedEventId"
							],
							"members": {
								"workflowExecution": {
									"shape": "S16"
								},
								"workflowType": {
									"shape": "Sr"
								},
								"initiatedEventId": {
									"type": "long"
								},
								"startedEventId": {
									"type": "long"
								}
							}
						},
						"signalExternalWorkflowExecutionInitiatedEventAttributes": {
							"type": "structure",
							"required": [
								"workflowId",
								"signalName",
								"decisionTaskCompletedEventId"
							],
							"members": {
								"workflowId": {},
								"runId": {},
								"signalName": {},
								"input": {},
								"decisionTaskCompletedEventId": {
									"type": "long"
								},
								"control": {}
							}
						},
						"externalWorkflowExecutionSignaledEventAttributes": {
							"type": "structure",
							"required": [
								"workflowExecution",
								"initiatedEventId"
							],
							"members": {
								"workflowExecution": {
									"shape": "S16"
								},
								"initiatedEventId": {
									"type": "long"
								}
							}
						},
						"signalExternalWorkflowExecutionFailedEventAttributes": {
							"type": "structure",
							"required": [
								"workflowId",
								"cause",
								"initiatedEventId",
								"decisionTaskCompletedEventId"
							],
							"members": {
								"workflowId": {},
								"runId": {},
								"cause": {},
								"initiatedEventId": {
									"type": "long"
								},
								"decisionTaskCompletedEventId": {
									"type": "long"
								},
								"control": {}
							}
						},
						"externalWorkflowExecutionCancelRequestedEventAttributes": {
							"type": "structure",
							"required": [
								"workflowExecution",
								"initiatedEventId"
							],
							"members": {
								"workflowExecution": {
									"shape": "S16"
								},
								"initiatedEventId": {
									"type": "long"
								}
							}
						},
						"requestCancelExternalWorkflowExecutionInitiatedEventAttributes": {
							"type": "structure",
							"required": [
								"workflowId",
								"decisionTaskCompletedEventId"
							],
							"members": {
								"workflowId": {},
								"runId": {},
								"decisionTaskCompletedEventId": {
									"type": "long"
								},
								"control": {}
							}
						},
						"requestCancelExternalWorkflowExecutionFailedEventAttributes": {
							"type": "structure",
							"required": [
								"workflowId",
								"cause",
								"initiatedEventId",
								"decisionTaskCompletedEventId"
							],
							"members": {
								"workflowId": {},
								"runId": {},
								"cause": {},
								"initiatedEventId": {
									"type": "long"
								},
								"decisionTaskCompletedEventId": {
									"type": "long"
								},
								"control": {}
							}
						},
						"scheduleActivityTaskFailedEventAttributes": {
							"type": "structure",
							"required": [
								"activityType",
								"activityId",
								"cause",
								"decisionTaskCompletedEventId"
							],
							"members": {
								"activityType": {
									"shape": "Sn"
								},
								"activityId": {},
								"cause": {},
								"decisionTaskCompletedEventId": {
									"type": "long"
								}
							}
						},
						"requestCancelActivityTaskFailedEventAttributes": {
							"type": "structure",
							"required": [
								"activityId",
								"cause",
								"decisionTaskCompletedEventId"
							],
							"members": {
								"activityId": {},
								"cause": {},
								"decisionTaskCompletedEventId": {
									"type": "long"
								}
							}
						},
						"startTimerFailedEventAttributes": {
							"type": "structure",
							"required": [
								"timerId",
								"cause",
								"decisionTaskCompletedEventId"
							],
							"members": {
								"timerId": {},
								"cause": {},
								"decisionTaskCompletedEventId": {
									"type": "long"
								}
							}
						},
						"cancelTimerFailedEventAttributes": {
							"type": "structure",
							"required": [
								"timerId",
								"cause",
								"decisionTaskCompletedEventId"
							],
							"members": {
								"timerId": {},
								"cause": {},
								"decisionTaskCompletedEventId": {
									"type": "long"
								}
							}
						},
						"startChildWorkflowExecutionFailedEventAttributes": {
							"type": "structure",
							"required": [
								"workflowType",
								"cause",
								"workflowId",
								"initiatedEventId",
								"decisionTaskCompletedEventId"
							],
							"members": {
								"workflowType": {
									"shape": "Sr"
								},
								"cause": {},
								"workflowId": {},
								"initiatedEventId": {
									"type": "long"
								},
								"decisionTaskCompletedEventId": {
									"type": "long"
								},
								"control": {}
							}
						},
						"lambdaFunctionScheduledEventAttributes": {
							"type": "structure",
							"required": [
								"id",
								"name",
								"decisionTaskCompletedEventId"
							],
							"members": {
								"id": {},
								"name": {},
								"input": {},
								"startToCloseTimeout": {},
								"decisionTaskCompletedEventId": {
									"type": "long"
								}
							}
						},
						"lambdaFunctionStartedEventAttributes": {
							"type": "structure",
							"required": [
								"scheduledEventId"
							],
							"members": {
								"scheduledEventId": {
									"type": "long"
								}
							}
						},
						"lambdaFunctionCompletedEventAttributes": {
							"type": "structure",
							"required": [
								"scheduledEventId",
								"startedEventId"
							],
							"members": {
								"scheduledEventId": {
									"type": "long"
								},
								"startedEventId": {
									"type": "long"
								},
								"result": {}
							}
						},
						"lambdaFunctionFailedEventAttributes": {
							"type": "structure",
							"required": [
								"scheduledEventId",
								"startedEventId"
							],
							"members": {
								"scheduledEventId": {
									"type": "long"
								},
								"startedEventId": {
									"type": "long"
								},
								"reason": {},
								"details": {}
							}
						},
						"lambdaFunctionTimedOutEventAttributes": {
							"type": "structure",
							"required": [
								"scheduledEventId",
								"startedEventId"
							],
							"members": {
								"scheduledEventId": {
									"type": "long"
								},
								"startedEventId": {
									"type": "long"
								},
								"timeoutType": {}
							}
						},
						"scheduleLambdaFunctionFailedEventAttributes": {
							"type": "structure",
							"required": [
								"id",
								"name",
								"cause",
								"decisionTaskCompletedEventId"
							],
							"members": {
								"id": {},
								"name": {},
								"cause": {},
								"decisionTaskCompletedEventId": {
									"type": "long"
								}
							}
						},
						"startLambdaFunctionFailedEventAttributes": {
							"type": "structure",
							"members": {
								"scheduledEventId": {
									"type": "long"
								},
								"cause": {},
								"message": {}
							}
						}
					}
				}
			},
			"S4g": {
				"type": "structure",
				"required": [
					"executionInfos"
				],
				"members": {
					"executionInfos": {
						"type": "list",
						"member": {
							"shape": "S19"
						}
					},
					"nextPageToken": {}
				}
			}
		},
		"examples": {}
	};

/***/ },
/* 480 */
/***/ function(module, exports) {

	module.exports = {
		"pagination": {
			"GetWorkflowExecutionHistory": {
				"limit_key": "maximumPageSize",
				"input_token": "nextPageToken",
				"output_token": "nextPageToken",
				"result_key": "events"
			},
			"ListActivityTypes": {
				"limit_key": "maximumPageSize",
				"input_token": "nextPageToken",
				"output_token": "nextPageToken",
				"result_key": "typeInfos"
			},
			"ListClosedWorkflowExecutions": {
				"limit_key": "maximumPageSize",
				"input_token": "nextPageToken",
				"output_token": "nextPageToken",
				"result_key": "executionInfos"
			},
			"ListDomains": {
				"limit_key": "maximumPageSize",
				"input_token": "nextPageToken",
				"output_token": "nextPageToken",
				"result_key": "domainInfos"
			},
			"ListOpenWorkflowExecutions": {
				"limit_key": "maximumPageSize",
				"input_token": "nextPageToken",
				"output_token": "nextPageToken",
				"result_key": "executionInfos"
			},
			"ListWorkflowTypes": {
				"limit_key": "maximumPageSize",
				"input_token": "nextPageToken",
				"output_token": "nextPageToken",
				"result_key": "typeInfos"
			},
			"PollForDecisionTask": {
				"limit_key": "maximumPageSize",
				"input_token": "nextPageToken",
				"output_token": "nextPageToken",
				"result_key": "events"
			}
		}
	};

/***/ },
/* 481 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['waf'] = {};
	AWS.WAF = Service.defineService('waf', ['2015-08-24']);
	Object.defineProperty(apiLoader.services['waf'], '2015-08-24', {
	  get: function get() {
	    var model = __webpack_require__(482);
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.WAF;


/***/ },
/* 482 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2015-08-24",
			"endpointPrefix": "waf",
			"jsonVersion": "1.1",
			"protocol": "json",
			"serviceAbbreviation": "WAF",
			"serviceFullName": "AWS WAF",
			"signatureVersion": "v4",
			"targetPrefix": "AWSWAF_20150824"
		},
		"operations": {
			"CreateByteMatchSet": {
				"input": {
					"type": "structure",
					"required": [
						"Name",
						"ChangeToken"
					],
					"members": {
						"Name": {},
						"ChangeToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ByteMatchSet": {
							"shape": "S5"
						},
						"ChangeToken": {}
					}
				}
			},
			"CreateIPSet": {
				"input": {
					"type": "structure",
					"required": [
						"Name",
						"ChangeToken"
					],
					"members": {
						"Name": {},
						"ChangeToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"IPSet": {
							"shape": "Sh"
						},
						"ChangeToken": {}
					}
				}
			},
			"CreateRule": {
				"input": {
					"type": "structure",
					"required": [
						"Name",
						"MetricName",
						"ChangeToken"
					],
					"members": {
						"Name": {},
						"MetricName": {},
						"ChangeToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Rule": {
							"shape": "Sp"
						},
						"ChangeToken": {}
					}
				}
			},
			"CreateSizeConstraintSet": {
				"input": {
					"type": "structure",
					"required": [
						"Name",
						"ChangeToken"
					],
					"members": {
						"Name": {},
						"ChangeToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"SizeConstraintSet": {
							"shape": "Sw"
						},
						"ChangeToken": {}
					}
				}
			},
			"CreateSqlInjectionMatchSet": {
				"input": {
					"type": "structure",
					"required": [
						"Name",
						"ChangeToken"
					],
					"members": {
						"Name": {},
						"ChangeToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"SqlInjectionMatchSet": {
							"shape": "S13"
						},
						"ChangeToken": {}
					}
				}
			},
			"CreateWebACL": {
				"input": {
					"type": "structure",
					"required": [
						"Name",
						"MetricName",
						"DefaultAction",
						"ChangeToken"
					],
					"members": {
						"Name": {},
						"MetricName": {},
						"DefaultAction": {
							"shape": "S17"
						},
						"ChangeToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"WebACL": {
							"shape": "S1a"
						},
						"ChangeToken": {}
					}
				}
			},
			"CreateXssMatchSet": {
				"input": {
					"type": "structure",
					"required": [
						"Name",
						"ChangeToken"
					],
					"members": {
						"Name": {},
						"ChangeToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"XssMatchSet": {
							"shape": "S1g"
						},
						"ChangeToken": {}
					}
				}
			},
			"DeleteByteMatchSet": {
				"input": {
					"type": "structure",
					"required": [
						"ByteMatchSetId",
						"ChangeToken"
					],
					"members": {
						"ByteMatchSetId": {},
						"ChangeToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ChangeToken": {}
					}
				}
			},
			"DeleteIPSet": {
				"input": {
					"type": "structure",
					"required": [
						"IPSetId",
						"ChangeToken"
					],
					"members": {
						"IPSetId": {},
						"ChangeToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ChangeToken": {}
					}
				}
			},
			"DeleteRule": {
				"input": {
					"type": "structure",
					"required": [
						"RuleId",
						"ChangeToken"
					],
					"members": {
						"RuleId": {},
						"ChangeToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ChangeToken": {}
					}
				}
			},
			"DeleteSizeConstraintSet": {
				"input": {
					"type": "structure",
					"required": [
						"SizeConstraintSetId",
						"ChangeToken"
					],
					"members": {
						"SizeConstraintSetId": {},
						"ChangeToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ChangeToken": {}
					}
				}
			},
			"DeleteSqlInjectionMatchSet": {
				"input": {
					"type": "structure",
					"required": [
						"SqlInjectionMatchSetId",
						"ChangeToken"
					],
					"members": {
						"SqlInjectionMatchSetId": {},
						"ChangeToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ChangeToken": {}
					}
				}
			},
			"DeleteWebACL": {
				"input": {
					"type": "structure",
					"required": [
						"WebACLId",
						"ChangeToken"
					],
					"members": {
						"WebACLId": {},
						"ChangeToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ChangeToken": {}
					}
				}
			},
			"DeleteXssMatchSet": {
				"input": {
					"type": "structure",
					"required": [
						"XssMatchSetId",
						"ChangeToken"
					],
					"members": {
						"XssMatchSetId": {},
						"ChangeToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ChangeToken": {}
					}
				}
			},
			"GetByteMatchSet": {
				"input": {
					"type": "structure",
					"required": [
						"ByteMatchSetId"
					],
					"members": {
						"ByteMatchSetId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ByteMatchSet": {
							"shape": "S5"
						}
					}
				}
			},
			"GetChangeToken": {
				"input": {
					"type": "structure",
					"members": {}
				},
				"output": {
					"type": "structure",
					"members": {
						"ChangeToken": {}
					}
				}
			},
			"GetChangeTokenStatus": {
				"input": {
					"type": "structure",
					"required": [
						"ChangeToken"
					],
					"members": {
						"ChangeToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ChangeTokenStatus": {}
					}
				}
			},
			"GetIPSet": {
				"input": {
					"type": "structure",
					"required": [
						"IPSetId"
					],
					"members": {
						"IPSetId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"IPSet": {
							"shape": "Sh"
						}
					}
				}
			},
			"GetRule": {
				"input": {
					"type": "structure",
					"required": [
						"RuleId"
					],
					"members": {
						"RuleId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Rule": {
							"shape": "Sp"
						}
					}
				}
			},
			"GetSampledRequests": {
				"input": {
					"type": "structure",
					"required": [
						"WebAclId",
						"RuleId",
						"TimeWindow",
						"MaxItems"
					],
					"members": {
						"WebAclId": {},
						"RuleId": {},
						"TimeWindow": {
							"shape": "S29"
						},
						"MaxItems": {
							"type": "long"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"SampledRequests": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"Request",
									"Weight"
								],
								"members": {
									"Request": {
										"type": "structure",
										"members": {
											"ClientIP": {},
											"Country": {},
											"URI": {},
											"Method": {},
											"HTTPVersion": {},
											"Headers": {
												"type": "list",
												"member": {
													"type": "structure",
													"members": {
														"Name": {},
														"Value": {}
													}
												}
											}
										}
									},
									"Weight": {
										"type": "long"
									},
									"Timestamp": {
										"type": "timestamp"
									},
									"Action": {}
								}
							}
						},
						"PopulationSize": {
							"type": "long"
						},
						"TimeWindow": {
							"shape": "S29"
						}
					}
				}
			},
			"GetSizeConstraintSet": {
				"input": {
					"type": "structure",
					"required": [
						"SizeConstraintSetId"
					],
					"members": {
						"SizeConstraintSetId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"SizeConstraintSet": {
							"shape": "Sw"
						}
					}
				}
			},
			"GetSqlInjectionMatchSet": {
				"input": {
					"type": "structure",
					"required": [
						"SqlInjectionMatchSetId"
					],
					"members": {
						"SqlInjectionMatchSetId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"SqlInjectionMatchSet": {
							"shape": "S13"
						}
					}
				}
			},
			"GetWebACL": {
				"input": {
					"type": "structure",
					"required": [
						"WebACLId"
					],
					"members": {
						"WebACLId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"WebACL": {
							"shape": "S1a"
						}
					}
				}
			},
			"GetXssMatchSet": {
				"input": {
					"type": "structure",
					"required": [
						"XssMatchSetId"
					],
					"members": {
						"XssMatchSetId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"XssMatchSet": {
							"shape": "S1g"
						}
					}
				}
			},
			"ListByteMatchSets": {
				"input": {
					"type": "structure",
					"members": {
						"NextMarker": {},
						"Limit": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"NextMarker": {},
						"ByteMatchSets": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"ByteMatchSetId",
									"Name"
								],
								"members": {
									"ByteMatchSetId": {},
									"Name": {}
								}
							}
						}
					}
				}
			},
			"ListIPSets": {
				"input": {
					"type": "structure",
					"members": {
						"NextMarker": {},
						"Limit": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"NextMarker": {},
						"IPSets": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"IPSetId",
									"Name"
								],
								"members": {
									"IPSetId": {},
									"Name": {}
								}
							}
						}
					}
				}
			},
			"ListRules": {
				"input": {
					"type": "structure",
					"members": {
						"NextMarker": {},
						"Limit": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"NextMarker": {},
						"Rules": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"RuleId",
									"Name"
								],
								"members": {
									"RuleId": {},
									"Name": {}
								}
							}
						}
					}
				}
			},
			"ListSizeConstraintSets": {
				"input": {
					"type": "structure",
					"members": {
						"NextMarker": {},
						"Limit": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"NextMarker": {},
						"SizeConstraintSets": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"SizeConstraintSetId",
									"Name"
								],
								"members": {
									"SizeConstraintSetId": {},
									"Name": {}
								}
							}
						}
					}
				}
			},
			"ListSqlInjectionMatchSets": {
				"input": {
					"type": "structure",
					"members": {
						"NextMarker": {},
						"Limit": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"NextMarker": {},
						"SqlInjectionMatchSets": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"SqlInjectionMatchSetId",
									"Name"
								],
								"members": {
									"SqlInjectionMatchSetId": {},
									"Name": {}
								}
							}
						}
					}
				}
			},
			"ListWebACLs": {
				"input": {
					"type": "structure",
					"members": {
						"NextMarker": {},
						"Limit": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"NextMarker": {},
						"WebACLs": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"WebACLId",
									"Name"
								],
								"members": {
									"WebACLId": {},
									"Name": {}
								}
							}
						}
					}
				}
			},
			"ListXssMatchSets": {
				"input": {
					"type": "structure",
					"members": {
						"NextMarker": {},
						"Limit": {
							"type": "integer"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"NextMarker": {},
						"XssMatchSets": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"XssMatchSetId",
									"Name"
								],
								"members": {
									"XssMatchSetId": {},
									"Name": {}
								}
							}
						}
					}
				}
			},
			"UpdateByteMatchSet": {
				"input": {
					"type": "structure",
					"required": [
						"ByteMatchSetId",
						"ChangeToken",
						"Updates"
					],
					"members": {
						"ByteMatchSetId": {},
						"ChangeToken": {},
						"Updates": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"Action",
									"ByteMatchTuple"
								],
								"members": {
									"Action": {},
									"ByteMatchTuple": {
										"shape": "S8"
									}
								}
							}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ChangeToken": {}
					}
				}
			},
			"UpdateIPSet": {
				"input": {
					"type": "structure",
					"required": [
						"IPSetId",
						"ChangeToken",
						"Updates"
					],
					"members": {
						"IPSetId": {},
						"ChangeToken": {},
						"Updates": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"Action",
									"IPSetDescriptor"
								],
								"members": {
									"Action": {},
									"IPSetDescriptor": {
										"shape": "Sj"
									}
								}
							}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ChangeToken": {}
					}
				}
			},
			"UpdateRule": {
				"input": {
					"type": "structure",
					"required": [
						"RuleId",
						"ChangeToken",
						"Updates"
					],
					"members": {
						"RuleId": {},
						"ChangeToken": {},
						"Updates": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"Action",
									"Predicate"
								],
								"members": {
									"Action": {},
									"Predicate": {
										"shape": "Sr"
									}
								}
							}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ChangeToken": {}
					}
				}
			},
			"UpdateSizeConstraintSet": {
				"input": {
					"type": "structure",
					"required": [
						"SizeConstraintSetId",
						"ChangeToken",
						"Updates"
					],
					"members": {
						"SizeConstraintSetId": {},
						"ChangeToken": {},
						"Updates": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"Action",
									"SizeConstraint"
								],
								"members": {
									"Action": {},
									"SizeConstraint": {
										"shape": "Sy"
									}
								}
							}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ChangeToken": {}
					}
				}
			},
			"UpdateSqlInjectionMatchSet": {
				"input": {
					"type": "structure",
					"required": [
						"SqlInjectionMatchSetId",
						"ChangeToken",
						"Updates"
					],
					"members": {
						"SqlInjectionMatchSetId": {},
						"ChangeToken": {},
						"Updates": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"Action",
									"SqlInjectionMatchTuple"
								],
								"members": {
									"Action": {},
									"SqlInjectionMatchTuple": {
										"shape": "S15"
									}
								}
							}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ChangeToken": {}
					}
				}
			},
			"UpdateWebACL": {
				"input": {
					"type": "structure",
					"required": [
						"WebACLId",
						"ChangeToken"
					],
					"members": {
						"WebACLId": {},
						"ChangeToken": {},
						"Updates": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"Action",
									"ActivatedRule"
								],
								"members": {
									"Action": {},
									"ActivatedRule": {
										"shape": "S1c"
									}
								}
							}
						},
						"DefaultAction": {
							"shape": "S17"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ChangeToken": {}
					}
				}
			},
			"UpdateXssMatchSet": {
				"input": {
					"type": "structure",
					"required": [
						"XssMatchSetId",
						"ChangeToken",
						"Updates"
					],
					"members": {
						"XssMatchSetId": {},
						"ChangeToken": {},
						"Updates": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"Action",
									"XssMatchTuple"
								],
								"members": {
									"Action": {},
									"XssMatchTuple": {
										"shape": "S1i"
									}
								}
							}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"ChangeToken": {}
					}
				}
			}
		},
		"shapes": {
			"S5": {
				"type": "structure",
				"required": [
					"ByteMatchSetId",
					"ByteMatchTuples"
				],
				"members": {
					"ByteMatchSetId": {},
					"Name": {},
					"ByteMatchTuples": {
						"type": "list",
						"member": {
							"shape": "S8"
						}
					}
				}
			},
			"S8": {
				"type": "structure",
				"required": [
					"FieldToMatch",
					"TargetString",
					"TextTransformation",
					"PositionalConstraint"
				],
				"members": {
					"FieldToMatch": {
						"shape": "S9"
					},
					"TargetString": {
						"type": "blob"
					},
					"TextTransformation": {},
					"PositionalConstraint": {}
				}
			},
			"S9": {
				"type": "structure",
				"required": [
					"Type"
				],
				"members": {
					"Type": {},
					"Data": {}
				}
			},
			"Sh": {
				"type": "structure",
				"required": [
					"IPSetId",
					"IPSetDescriptors"
				],
				"members": {
					"IPSetId": {},
					"Name": {},
					"IPSetDescriptors": {
						"type": "list",
						"member": {
							"shape": "Sj"
						}
					}
				}
			},
			"Sj": {
				"type": "structure",
				"required": [
					"Type",
					"Value"
				],
				"members": {
					"Type": {},
					"Value": {}
				}
			},
			"Sp": {
				"type": "structure",
				"required": [
					"RuleId",
					"Predicates"
				],
				"members": {
					"RuleId": {},
					"Name": {},
					"MetricName": {},
					"Predicates": {
						"type": "list",
						"member": {
							"shape": "Sr"
						}
					}
				}
			},
			"Sr": {
				"type": "structure",
				"required": [
					"Negated",
					"Type",
					"DataId"
				],
				"members": {
					"Negated": {
						"type": "boolean"
					},
					"Type": {},
					"DataId": {}
				}
			},
			"Sw": {
				"type": "structure",
				"required": [
					"SizeConstraintSetId",
					"SizeConstraints"
				],
				"members": {
					"SizeConstraintSetId": {},
					"Name": {},
					"SizeConstraints": {
						"type": "list",
						"member": {
							"shape": "Sy"
						}
					}
				}
			},
			"Sy": {
				"type": "structure",
				"required": [
					"FieldToMatch",
					"TextTransformation",
					"ComparisonOperator",
					"Size"
				],
				"members": {
					"FieldToMatch": {
						"shape": "S9"
					},
					"TextTransformation": {},
					"ComparisonOperator": {},
					"Size": {
						"type": "long"
					}
				}
			},
			"S13": {
				"type": "structure",
				"required": [
					"SqlInjectionMatchSetId",
					"SqlInjectionMatchTuples"
				],
				"members": {
					"SqlInjectionMatchSetId": {},
					"Name": {},
					"SqlInjectionMatchTuples": {
						"type": "list",
						"member": {
							"shape": "S15"
						}
					}
				}
			},
			"S15": {
				"type": "structure",
				"required": [
					"FieldToMatch",
					"TextTransformation"
				],
				"members": {
					"FieldToMatch": {
						"shape": "S9"
					},
					"TextTransformation": {}
				}
			},
			"S17": {
				"type": "structure",
				"required": [
					"Type"
				],
				"members": {
					"Type": {}
				}
			},
			"S1a": {
				"type": "structure",
				"required": [
					"WebACLId",
					"DefaultAction",
					"Rules"
				],
				"members": {
					"WebACLId": {},
					"Name": {},
					"MetricName": {},
					"DefaultAction": {
						"shape": "S17"
					},
					"Rules": {
						"type": "list",
						"member": {
							"shape": "S1c"
						}
					}
				}
			},
			"S1c": {
				"type": "structure",
				"required": [
					"Priority",
					"RuleId",
					"Action"
				],
				"members": {
					"Priority": {
						"type": "integer"
					},
					"RuleId": {},
					"Action": {
						"shape": "S17"
					}
				}
			},
			"S1g": {
				"type": "structure",
				"required": [
					"XssMatchSetId",
					"XssMatchTuples"
				],
				"members": {
					"XssMatchSetId": {},
					"Name": {},
					"XssMatchTuples": {
						"type": "list",
						"member": {
							"shape": "S1i"
						}
					}
				}
			},
			"S1i": {
				"type": "structure",
				"required": [
					"FieldToMatch",
					"TextTransformation"
				],
				"members": {
					"FieldToMatch": {
						"shape": "S9"
					},
					"TextTransformation": {}
				}
			},
			"S29": {
				"type": "structure",
				"required": [
					"StartTime",
					"EndTime"
				],
				"members": {
					"StartTime": {
						"type": "timestamp"
					},
					"EndTime": {
						"type": "timestamp"
					}
				}
			}
		}
	};

/***/ },
/* 483 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var AWS = __webpack_require__(93);
	var Service = __webpack_require__(174);
	var apiLoader = __webpack_require__(181);

	apiLoader.services['workspaces'] = {};
	AWS.WorkSpaces = Service.defineService('workspaces', ['2015-04-08']);
	Object.defineProperty(apiLoader.services['workspaces'], '2015-04-08', {
	  get: function get() {
	    var model = __webpack_require__(484);
	    model.paginators = __webpack_require__(485).pagination;
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.WorkSpaces;


/***/ },
/* 484 */
/***/ function(module, exports) {

	module.exports = {
		"version": "2.0",
		"metadata": {
			"apiVersion": "2015-04-08",
			"endpointPrefix": "workspaces",
			"jsonVersion": "1.1",
			"protocol": "json",
			"serviceFullName": "Amazon WorkSpaces",
			"signatureVersion": "v4",
			"targetPrefix": "WorkspacesService"
		},
		"operations": {
			"CreateTags": {
				"input": {
					"type": "structure",
					"required": [
						"ResourceId",
						"Tags"
					],
					"members": {
						"ResourceId": {},
						"Tags": {
							"shape": "S3"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"CreateWorkspaces": {
				"input": {
					"type": "structure",
					"required": [
						"Workspaces"
					],
					"members": {
						"Workspaces": {
							"type": "list",
							"member": {
								"shape": "Sa"
							}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"FailedRequests": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"WorkspaceRequest": {
										"shape": "Sa"
									},
									"ErrorCode": {},
									"ErrorMessage": {}
								}
							}
						},
						"PendingRequests": {
							"shape": "So"
						}
					}
				}
			},
			"DeleteTags": {
				"input": {
					"type": "structure",
					"required": [
						"ResourceId",
						"TagKeys"
					],
					"members": {
						"ResourceId": {},
						"TagKeys": {
							"type": "list",
							"member": {}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"DescribeTags": {
				"input": {
					"type": "structure",
					"required": [
						"ResourceId"
					],
					"members": {
						"ResourceId": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"TagList": {
							"shape": "S3"
						}
					}
				}
			},
			"DescribeWorkspaceBundles": {
				"input": {
					"type": "structure",
					"members": {
						"BundleIds": {
							"type": "list",
							"member": {}
						},
						"Owner": {},
						"NextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Bundles": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"BundleId": {},
									"Name": {},
									"Owner": {},
									"Description": {},
									"UserStorage": {
										"type": "structure",
										"members": {
											"Capacity": {}
										}
									},
									"ComputeType": {
										"type": "structure",
										"members": {
											"Name": {}
										}
									}
								}
							}
						},
						"NextToken": {}
					}
				}
			},
			"DescribeWorkspaceDirectories": {
				"input": {
					"type": "structure",
					"members": {
						"DirectoryIds": {
							"type": "list",
							"member": {}
						},
						"NextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Directories": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"DirectoryId": {},
									"Alias": {},
									"DirectoryName": {},
									"RegistrationCode": {},
									"SubnetIds": {
										"type": "list",
										"member": {}
									},
									"DnsIpAddresses": {
										"type": "list",
										"member": {}
									},
									"CustomerUserName": {},
									"IamRoleId": {},
									"DirectoryType": {},
									"WorkspaceSecurityGroupId": {},
									"State": {},
									"WorkspaceCreationProperties": {
										"type": "structure",
										"members": {
											"EnableWorkDocs": {
												"type": "boolean"
											},
											"EnableInternetAccess": {
												"type": "boolean"
											},
											"DefaultOu": {},
											"CustomSecurityGroupId": {},
											"UserEnabledAsLocalAdministrator": {
												"type": "boolean"
											}
										}
									}
								}
							}
						},
						"NextToken": {}
					}
				}
			},
			"DescribeWorkspaces": {
				"input": {
					"type": "structure",
					"members": {
						"WorkspaceIds": {
							"shape": "S1s"
						},
						"DirectoryId": {},
						"UserName": {},
						"BundleId": {},
						"Limit": {
							"type": "integer"
						},
						"NextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"Workspaces": {
							"shape": "So"
						},
						"NextToken": {}
					}
				}
			},
			"DescribeWorkspacesConnectionStatus": {
				"input": {
					"type": "structure",
					"members": {
						"WorkspaceIds": {
							"shape": "S1s"
						},
						"NextToken": {}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"WorkspacesConnectionStatus": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"WorkspaceId": {},
									"ConnectionState": {},
									"ConnectionStateCheckTimestamp": {
										"type": "timestamp"
									},
									"LastKnownUserConnectionTimestamp": {
										"type": "timestamp"
									}
								}
							}
						},
						"NextToken": {}
					}
				}
			},
			"ModifyWorkspaceProperties": {
				"input": {
					"type": "structure",
					"required": [
						"WorkspaceId",
						"WorkspaceProperties"
					],
					"members": {
						"WorkspaceId": {},
						"WorkspaceProperties": {
							"shape": "Sg"
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {}
				}
			},
			"RebootWorkspaces": {
				"input": {
					"type": "structure",
					"required": [
						"RebootWorkspaceRequests"
					],
					"members": {
						"RebootWorkspaceRequests": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"WorkspaceId"
								],
								"members": {
									"WorkspaceId": {}
								}
							}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"FailedRequests": {
							"type": "list",
							"member": {
								"shape": "S28"
							}
						}
					}
				}
			},
			"RebuildWorkspaces": {
				"input": {
					"type": "structure",
					"required": [
						"RebuildWorkspaceRequests"
					],
					"members": {
						"RebuildWorkspaceRequests": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"WorkspaceId"
								],
								"members": {
									"WorkspaceId": {}
								}
							}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"FailedRequests": {
							"type": "list",
							"member": {
								"shape": "S28"
							}
						}
					}
				}
			},
			"StartWorkspaces": {
				"input": {
					"type": "structure",
					"required": [
						"StartWorkspaceRequests"
					],
					"members": {
						"StartWorkspaceRequests": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"WorkspaceId": {}
								}
							}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"FailedRequests": {
							"type": "list",
							"member": {
								"shape": "S28"
							}
						}
					}
				}
			},
			"StopWorkspaces": {
				"input": {
					"type": "structure",
					"required": [
						"StopWorkspaceRequests"
					],
					"members": {
						"StopWorkspaceRequests": {
							"type": "list",
							"member": {
								"type": "structure",
								"members": {
									"WorkspaceId": {}
								}
							}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"FailedRequests": {
							"type": "list",
							"member": {
								"shape": "S28"
							}
						}
					}
				}
			},
			"TerminateWorkspaces": {
				"input": {
					"type": "structure",
					"required": [
						"TerminateWorkspaceRequests"
					],
					"members": {
						"TerminateWorkspaceRequests": {
							"type": "list",
							"member": {
								"type": "structure",
								"required": [
									"WorkspaceId"
								],
								"members": {
									"WorkspaceId": {}
								}
							}
						}
					}
				},
				"output": {
					"type": "structure",
					"members": {
						"FailedRequests": {
							"type": "list",
							"member": {
								"shape": "S28"
							}
						}
					}
				}
			}
		},
		"shapes": {
			"S3": {
				"type": "list",
				"member": {
					"type": "structure",
					"required": [
						"Key"
					],
					"members": {
						"Key": {},
						"Value": {}
					}
				}
			},
			"Sa": {
				"type": "structure",
				"required": [
					"DirectoryId",
					"UserName",
					"BundleId"
				],
				"members": {
					"DirectoryId": {},
					"UserName": {},
					"BundleId": {},
					"VolumeEncryptionKey": {},
					"UserVolumeEncryptionEnabled": {
						"type": "boolean"
					},
					"RootVolumeEncryptionEnabled": {
						"type": "boolean"
					},
					"WorkspaceProperties": {
						"shape": "Sg"
					},
					"Tags": {
						"shape": "S3"
					}
				}
			},
			"Sg": {
				"type": "structure",
				"members": {
					"RunningMode": {},
					"RunningModeAutoStopTimeoutInMinutes": {
						"type": "integer"
					}
				}
			},
			"So": {
				"type": "list",
				"member": {
					"type": "structure",
					"members": {
						"WorkspaceId": {},
						"DirectoryId": {},
						"UserName": {},
						"IpAddress": {},
						"State": {},
						"BundleId": {},
						"SubnetId": {},
						"ErrorMessage": {},
						"ErrorCode": {},
						"ComputerName": {},
						"VolumeEncryptionKey": {},
						"UserVolumeEncryptionEnabled": {
							"type": "boolean"
						},
						"RootVolumeEncryptionEnabled": {
							"type": "boolean"
						},
						"WorkspaceProperties": {
							"shape": "Sg"
						}
					}
				}
			},
			"S1s": {
				"type": "list",
				"member": {}
			},
			"S28": {
				"type": "structure",
				"members": {
					"WorkspaceId": {},
					"ErrorCode": {},
					"ErrorMessage": {}
				}
			}
		}
	};

/***/ },
/* 485 */
/***/ function(module, exports) {

	module.exports = {
		"pagination": {
			"DescribeWorkspaceBundles": {
				"input_token": "NextToken",
				"output_token": "NextToken",
				"result_key": "Bundles"
			},
			"DescribeWorkspaceDirectories": {
				"input_token": "NextToken",
				"output_token": "NextToken",
				"result_key": "Directories"
			},
			"DescribeWorkspaces": {
				"limit_key": "Limit",
				"input_token": "NextToken",
				"output_token": "NextToken",
				"result_key": "Workspaces"
			}
		}
	};

/***/ },
/* 486 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//     Underscore.js 1.8.3
	//     http://underscorejs.org
	//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	//     Underscore may be freely distributed under the MIT license.

	(function() {

	  // Baseline setup
	  // --------------

	  // Establish the root object, `window` in the browser, or `exports` on the server.
	  var root = this;

	  // Save the previous value of the `_` variable.
	  var previousUnderscore = root._;

	  // Save bytes in the minified (but not gzipped) version:
	  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

	  // Create quick reference variables for speed access to core prototypes.
	  var
	    push             = ArrayProto.push,
	    slice            = ArrayProto.slice,
	    toString         = ObjProto.toString,
	    hasOwnProperty   = ObjProto.hasOwnProperty;

	  // All **ECMAScript 5** native function implementations that we hope to use
	  // are declared here.
	  var
	    nativeIsArray      = Array.isArray,
	    nativeKeys         = Object.keys,
	    nativeBind         = FuncProto.bind,
	    nativeCreate       = Object.create;

	  // Naked function reference for surrogate-prototype-swapping.
	  var Ctor = function(){};

	  // Create a safe reference to the Underscore object for use below.
	  var _ = function(obj) {
	    if (obj instanceof _) return obj;
	    if (!(this instanceof _)) return new _(obj);
	    this._wrapped = obj;
	  };

	  // Export the Underscore object for **Node.js**, with
	  // backwards-compatibility for the old `require()` API. If we're in
	  // the browser, add `_` as a global object.
	  if (true) {
	    if (typeof module !== 'undefined' && module.exports) {
	      exports = module.exports = _;
	    }
	    exports._ = _;
	  } else {
	    root._ = _;
	  }

	  // Current version.
	  _.VERSION = '1.8.3';

	  // Internal function that returns an efficient (for current engines) version
	  // of the passed-in callback, to be repeatedly applied in other Underscore
	  // functions.
	  var optimizeCb = function(func, context, argCount) {
	    if (context === void 0) return func;
	    switch (argCount == null ? 3 : argCount) {
	      case 1: return function(value) {
	        return func.call(context, value);
	      };
	      case 2: return function(value, other) {
	        return func.call(context, value, other);
	      };
	      case 3: return function(value, index, collection) {
	        return func.call(context, value, index, collection);
	      };
	      case 4: return function(accumulator, value, index, collection) {
	        return func.call(context, accumulator, value, index, collection);
	      };
	    }
	    return function() {
	      return func.apply(context, arguments);
	    };
	  };

	  // A mostly-internal function to generate callbacks that can be applied
	  // to each element in a collection, returning the desired result  either
	  // identity, an arbitrary callback, a property matcher, or a property accessor.
	  var cb = function(value, context, argCount) {
	    if (value == null) return _.identity;
	    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
	    if (_.isObject(value)) return _.matcher(value);
	    return _.property(value);
	  };
	  _.iteratee = function(value, context) {
	    return cb(value, context, Infinity);
	  };

	  // An internal function for creating assigner functions.
	  var createAssigner = function(keysFunc, undefinedOnly) {
	    return function(obj) {
	      var length = arguments.length;
	      if (length < 2 || obj == null) return obj;
	      for (var index = 1; index < length; index++) {
	        var source = arguments[index],
	            keys = keysFunc(source),
	            l = keys.length;
	        for (var i = 0; i < l; i++) {
	          var key = keys[i];
	          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
	        }
	      }
	      return obj;
	    };
	  };

	  // An internal function for creating a new object that inherits from another.
	  var baseCreate = function(prototype) {
	    if (!_.isObject(prototype)) return {};
	    if (nativeCreate) return nativeCreate(prototype);
	    Ctor.prototype = prototype;
	    var result = new Ctor;
	    Ctor.prototype = null;
	    return result;
	  };

	  var property = function(key) {
	    return function(obj) {
	      return obj == null ? void 0 : obj[key];
	    };
	  };

	  // Helper for collection methods to determine whether a collection
	  // should be iterated as an array or as an object
	  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
	  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
	  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
	  var getLength = property('length');
	  var isArrayLike = function(collection) {
	    var length = getLength(collection);
	    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
	  };

	  // Collection Functions
	  // --------------------

	  // The cornerstone, an `each` implementation, aka `forEach`.
	  // Handles raw objects in addition to array-likes. Treats all
	  // sparse array-likes as if they were dense.
	  _.each = _.forEach = function(obj, iteratee, context) {
	    iteratee = optimizeCb(iteratee, context);
	    var i, length;
	    if (isArrayLike(obj)) {
	      for (i = 0, length = obj.length; i < length; i++) {
	        iteratee(obj[i], i, obj);
	      }
	    } else {
	      var keys = _.keys(obj);
	      for (i = 0, length = keys.length; i < length; i++) {
	        iteratee(obj[keys[i]], keys[i], obj);
	      }
	    }
	    return obj;
	  };

	  // Return the results of applying the iteratee to each element.
	  _.map = _.collect = function(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length,
	        results = Array(length);
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      results[index] = iteratee(obj[currentKey], currentKey, obj);
	    }
	    return results;
	  };

	  // Create a reducing function iterating left or right.
	  function createReduce(dir) {
	    // Optimized iterator function as using arguments.length
	    // in the main function will deoptimize the, see #1991.
	    function iterator(obj, iteratee, memo, keys, index, length) {
	      for (; index >= 0 && index < length; index += dir) {
	        var currentKey = keys ? keys[index] : index;
	        memo = iteratee(memo, obj[currentKey], currentKey, obj);
	      }
	      return memo;
	    }

	    return function(obj, iteratee, memo, context) {
	      iteratee = optimizeCb(iteratee, context, 4);
	      var keys = !isArrayLike(obj) && _.keys(obj),
	          length = (keys || obj).length,
	          index = dir > 0 ? 0 : length - 1;
	      // Determine the initial value if none is provided.
	      if (arguments.length < 3) {
	        memo = obj[keys ? keys[index] : index];
	        index += dir;
	      }
	      return iterator(obj, iteratee, memo, keys, index, length);
	    };
	  }

	  // **Reduce** builds up a single result from a list of values, aka `inject`,
	  // or `foldl`.
	  _.reduce = _.foldl = _.inject = createReduce(1);

	  // The right-associative version of reduce, also known as `foldr`.
	  _.reduceRight = _.foldr = createReduce(-1);

	  // Return the first value which passes a truth test. Aliased as `detect`.
	  _.find = _.detect = function(obj, predicate, context) {
	    var key;
	    if (isArrayLike(obj)) {
	      key = _.findIndex(obj, predicate, context);
	    } else {
	      key = _.findKey(obj, predicate, context);
	    }
	    if (key !== void 0 && key !== -1) return obj[key];
	  };

	  // Return all the elements that pass a truth test.
	  // Aliased as `select`.
	  _.filter = _.select = function(obj, predicate, context) {
	    var results = [];
	    predicate = cb(predicate, context);
	    _.each(obj, function(value, index, list) {
	      if (predicate(value, index, list)) results.push(value);
	    });
	    return results;
	  };

	  // Return all the elements for which a truth test fails.
	  _.reject = function(obj, predicate, context) {
	    return _.filter(obj, _.negate(cb(predicate)), context);
	  };

	  // Determine whether all of the elements match a truth test.
	  // Aliased as `all`.
	  _.every = _.all = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length;
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      if (!predicate(obj[currentKey], currentKey, obj)) return false;
	    }
	    return true;
	  };

	  // Determine if at least one element in the object matches a truth test.
	  // Aliased as `any`.
	  _.some = _.any = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length;
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      if (predicate(obj[currentKey], currentKey, obj)) return true;
	    }
	    return false;
	  };

	  // Determine if the array or object contains a given item (using `===`).
	  // Aliased as `includes` and `include`.
	  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
	    if (!isArrayLike(obj)) obj = _.values(obj);
	    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
	    return _.indexOf(obj, item, fromIndex) >= 0;
	  };

	  // Invoke a method (with arguments) on every item in a collection.
	  _.invoke = function(obj, method) {
	    var args = slice.call(arguments, 2);
	    var isFunc = _.isFunction(method);
	    return _.map(obj, function(value) {
	      var func = isFunc ? method : value[method];
	      return func == null ? func : func.apply(value, args);
	    });
	  };

	  // Convenience version of a common use case of `map`: fetching a property.
	  _.pluck = function(obj, key) {
	    return _.map(obj, _.property(key));
	  };

	  // Convenience version of a common use case of `filter`: selecting only objects
	  // containing specific `key:value` pairs.
	  _.where = function(obj, attrs) {
	    return _.filter(obj, _.matcher(attrs));
	  };

	  // Convenience version of a common use case of `find`: getting the first object
	  // containing specific `key:value` pairs.
	  _.findWhere = function(obj, attrs) {
	    return _.find(obj, _.matcher(attrs));
	  };

	  // Return the maximum element (or element-based computation).
	  _.max = function(obj, iteratee, context) {
	    var result = -Infinity, lastComputed = -Infinity,
	        value, computed;
	    if (iteratee == null && obj != null) {
	      obj = isArrayLike(obj) ? obj : _.values(obj);
	      for (var i = 0, length = obj.length; i < length; i++) {
	        value = obj[i];
	        if (value > result) {
	          result = value;
	        }
	      }
	    } else {
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(value, index, list) {
	        computed = iteratee(value, index, list);
	        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
	          result = value;
	          lastComputed = computed;
	        }
	      });
	    }
	    return result;
	  };

	  // Return the minimum element (or element-based computation).
	  _.min = function(obj, iteratee, context) {
	    var result = Infinity, lastComputed = Infinity,
	        value, computed;
	    if (iteratee == null && obj != null) {
	      obj = isArrayLike(obj) ? obj : _.values(obj);
	      for (var i = 0, length = obj.length; i < length; i++) {
	        value = obj[i];
	        if (value < result) {
	          result = value;
	        }
	      }
	    } else {
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(value, index, list) {
	        computed = iteratee(value, index, list);
	        if (computed < lastComputed || computed === Infinity && result === Infinity) {
	          result = value;
	          lastComputed = computed;
	        }
	      });
	    }
	    return result;
	  };

	  // Shuffle a collection, using the modern version of the
	  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).
	  _.shuffle = function(obj) {
	    var set = isArrayLike(obj) ? obj : _.values(obj);
	    var length = set.length;
	    var shuffled = Array(length);
	    for (var index = 0, rand; index < length; index++) {
	      rand = _.random(0, index);
	      if (rand !== index) shuffled[index] = shuffled[rand];
	      shuffled[rand] = set[index];
	    }
	    return shuffled;
	  };

	  // Sample **n** random values from a collection.
	  // If **n** is not specified, returns a single random element.
	  // The internal `guard` argument allows it to work with `map`.
	  _.sample = function(obj, n, guard) {
	    if (n == null || guard) {
	      if (!isArrayLike(obj)) obj = _.values(obj);
	      return obj[_.random(obj.length - 1)];
	    }
	    return _.shuffle(obj).slice(0, Math.max(0, n));
	  };

	  // Sort the object's values by a criterion produced by an iteratee.
	  _.sortBy = function(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    return _.pluck(_.map(obj, function(value, index, list) {
	      return {
	        value: value,
	        index: index,
	        criteria: iteratee(value, index, list)
	      };
	    }).sort(function(left, right) {
	      var a = left.criteria;
	      var b = right.criteria;
	      if (a !== b) {
	        if (a > b || a === void 0) return 1;
	        if (a < b || b === void 0) return -1;
	      }
	      return left.index - right.index;
	    }), 'value');
	  };

	  // An internal function used for aggregate "group by" operations.
	  var group = function(behavior) {
	    return function(obj, iteratee, context) {
	      var result = {};
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(value, index) {
	        var key = iteratee(value, index, obj);
	        behavior(result, value, key);
	      });
	      return result;
	    };
	  };

	  // Groups the object's values by a criterion. Pass either a string attribute
	  // to group by, or a function that returns the criterion.
	  _.groupBy = group(function(result, value, key) {
	    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
	  });

	  // Indexes the object's values by a criterion, similar to `groupBy`, but for
	  // when you know that your index values will be unique.
	  _.indexBy = group(function(result, value, key) {
	    result[key] = value;
	  });

	  // Counts instances of an object that group by a certain criterion. Pass
	  // either a string attribute to count by, or a function that returns the
	  // criterion.
	  _.countBy = group(function(result, value, key) {
	    if (_.has(result, key)) result[key]++; else result[key] = 1;
	  });

	  // Safely create a real, live array from anything iterable.
	  _.toArray = function(obj) {
	    if (!obj) return [];
	    if (_.isArray(obj)) return slice.call(obj);
	    if (isArrayLike(obj)) return _.map(obj, _.identity);
	    return _.values(obj);
	  };

	  // Return the number of elements in an object.
	  _.size = function(obj) {
	    if (obj == null) return 0;
	    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
	  };

	  // Split a collection into two arrays: one whose elements all satisfy the given
	  // predicate, and one whose elements all do not satisfy the predicate.
	  _.partition = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var pass = [], fail = [];
	    _.each(obj, function(value, key, obj) {
	      (predicate(value, key, obj) ? pass : fail).push(value);
	    });
	    return [pass, fail];
	  };

	  // Array Functions
	  // ---------------

	  // Get the first element of an array. Passing **n** will return the first N
	  // values in the array. Aliased as `head` and `take`. The **guard** check
	  // allows it to work with `_.map`.
	  _.first = _.head = _.take = function(array, n, guard) {
	    if (array == null) return void 0;
	    if (n == null || guard) return array[0];
	    return _.initial(array, array.length - n);
	  };

	  // Returns everything but the last entry of the array. Especially useful on
	  // the arguments object. Passing **n** will return all the values in
	  // the array, excluding the last N.
	  _.initial = function(array, n, guard) {
	    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
	  };

	  // Get the last element of an array. Passing **n** will return the last N
	  // values in the array.
	  _.last = function(array, n, guard) {
	    if (array == null) return void 0;
	    if (n == null || guard) return array[array.length - 1];
	    return _.rest(array, Math.max(0, array.length - n));
	  };

	  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
	  // Especially useful on the arguments object. Passing an **n** will return
	  // the rest N values in the array.
	  _.rest = _.tail = _.drop = function(array, n, guard) {
	    return slice.call(array, n == null || guard ? 1 : n);
	  };

	  // Trim out all falsy values from an array.
	  _.compact = function(array) {
	    return _.filter(array, _.identity);
	  };

	  // Internal implementation of a recursive `flatten` function.
	  var flatten = function(input, shallow, strict, startIndex) {
	    var output = [], idx = 0;
	    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
	      var value = input[i];
	      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
	        //flatten current level of array or arguments object
	        if (!shallow) value = flatten(value, shallow, strict);
	        var j = 0, len = value.length;
	        output.length += len;
	        while (j < len) {
	          output[idx++] = value[j++];
	        }
	      } else if (!strict) {
	        output[idx++] = value;
	      }
	    }
	    return output;
	  };

	  // Flatten out an array, either recursively (by default), or just one level.
	  _.flatten = function(array, shallow) {
	    return flatten(array, shallow, false);
	  };

	  // Return a version of the array that does not contain the specified value(s).
	  _.without = function(array) {
	    return _.difference(array, slice.call(arguments, 1));
	  };

	  // Produce a duplicate-free version of the array. If the array has already
	  // been sorted, you have the option of using a faster algorithm.
	  // Aliased as `unique`.
	  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
	    if (!_.isBoolean(isSorted)) {
	      context = iteratee;
	      iteratee = isSorted;
	      isSorted = false;
	    }
	    if (iteratee != null) iteratee = cb(iteratee, context);
	    var result = [];
	    var seen = [];
	    for (var i = 0, length = getLength(array); i < length; i++) {
	      var value = array[i],
	          computed = iteratee ? iteratee(value, i, array) : value;
	      if (isSorted) {
	        if (!i || seen !== computed) result.push(value);
	        seen = computed;
	      } else if (iteratee) {
	        if (!_.contains(seen, computed)) {
	          seen.push(computed);
	          result.push(value);
	        }
	      } else if (!_.contains(result, value)) {
	        result.push(value);
	      }
	    }
	    return result;
	  };

	  // Produce an array that contains the union: each distinct element from all of
	  // the passed-in arrays.
	  _.union = function() {
	    return _.uniq(flatten(arguments, true, true));
	  };

	  // Produce an array that contains every item shared between all the
	  // passed-in arrays.
	  _.intersection = function(array) {
	    var result = [];
	    var argsLength = arguments.length;
	    for (var i = 0, length = getLength(array); i < length; i++) {
	      var item = array[i];
	      if (_.contains(result, item)) continue;
	      for (var j = 1; j < argsLength; j++) {
	        if (!_.contains(arguments[j], item)) break;
	      }
	      if (j === argsLength) result.push(item);
	    }
	    return result;
	  };

	  // Take the difference between one array and a number of other arrays.
	  // Only the elements present in just the first array will remain.
	  _.difference = function(array) {
	    var rest = flatten(arguments, true, true, 1);
	    return _.filter(array, function(value){
	      return !_.contains(rest, value);
	    });
	  };

	  // Zip together multiple lists into a single array -- elements that share
	  // an index go together.
	  _.zip = function() {
	    return _.unzip(arguments);
	  };

	  // Complement of _.zip. Unzip accepts an array of arrays and groups
	  // each array's elements on shared indices
	  _.unzip = function(array) {
	    var length = array && _.max(array, getLength).length || 0;
	    var result = Array(length);

	    for (var index = 0; index < length; index++) {
	      result[index] = _.pluck(array, index);
	    }
	    return result;
	  };

	  // Converts lists into objects. Pass either a single array of `[key, value]`
	  // pairs, or two parallel arrays of the same length -- one of keys, and one of
	  // the corresponding values.
	  _.object = function(list, values) {
	    var result = {};
	    for (var i = 0, length = getLength(list); i < length; i++) {
	      if (values) {
	        result[list[i]] = values[i];
	      } else {
	        result[list[i][0]] = list[i][1];
	      }
	    }
	    return result;
	  };

	  // Generator function to create the findIndex and findLastIndex functions
	  function createPredicateIndexFinder(dir) {
	    return function(array, predicate, context) {
	      predicate = cb(predicate, context);
	      var length = getLength(array);
	      var index = dir > 0 ? 0 : length - 1;
	      for (; index >= 0 && index < length; index += dir) {
	        if (predicate(array[index], index, array)) return index;
	      }
	      return -1;
	    };
	  }

	  // Returns the first index on an array-like that passes a predicate test
	  _.findIndex = createPredicateIndexFinder(1);
	  _.findLastIndex = createPredicateIndexFinder(-1);

	  // Use a comparator function to figure out the smallest index at which
	  // an object should be inserted so as to maintain order. Uses binary search.
	  _.sortedIndex = function(array, obj, iteratee, context) {
	    iteratee = cb(iteratee, context, 1);
	    var value = iteratee(obj);
	    var low = 0, high = getLength(array);
	    while (low < high) {
	      var mid = Math.floor((low + high) / 2);
	      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
	    }
	    return low;
	  };

	  // Generator function to create the indexOf and lastIndexOf functions
	  function createIndexFinder(dir, predicateFind, sortedIndex) {
	    return function(array, item, idx) {
	      var i = 0, length = getLength(array);
	      if (typeof idx == 'number') {
	        if (dir > 0) {
	            i = idx >= 0 ? idx : Math.max(idx + length, i);
	        } else {
	            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
	        }
	      } else if (sortedIndex && idx && length) {
	        idx = sortedIndex(array, item);
	        return array[idx] === item ? idx : -1;
	      }
	      if (item !== item) {
	        idx = predicateFind(slice.call(array, i, length), _.isNaN);
	        return idx >= 0 ? idx + i : -1;
	      }
	      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
	        if (array[idx] === item) return idx;
	      }
	      return -1;
	    };
	  }

	  // Return the position of the first occurrence of an item in an array,
	  // or -1 if the item is not included in the array.
	  // If the array is large and already in sort order, pass `true`
	  // for **isSorted** to use binary search.
	  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
	  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

	  // Generate an integer Array containing an arithmetic progression. A port of
	  // the native Python `range()` function. See
	  // [the Python documentation](http://docs.python.org/library/functions.html#range).
	  _.range = function(start, stop, step) {
	    if (stop == null) {
	      stop = start || 0;
	      start = 0;
	    }
	    step = step || 1;

	    var length = Math.max(Math.ceil((stop - start) / step), 0);
	    var range = Array(length);

	    for (var idx = 0; idx < length; idx++, start += step) {
	      range[idx] = start;
	    }

	    return range;
	  };

	  // Function (ahem) Functions
	  // ------------------

	  // Determines whether to execute a function as a constructor
	  // or a normal function with the provided arguments
	  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
	    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
	    var self = baseCreate(sourceFunc.prototype);
	    var result = sourceFunc.apply(self, args);
	    if (_.isObject(result)) return result;
	    return self;
	  };

	  // Create a function bound to a given object (assigning `this`, and arguments,
	  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
	  // available.
	  _.bind = function(func, context) {
	    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
	    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
	    var args = slice.call(arguments, 2);
	    var bound = function() {
	      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
	    };
	    return bound;
	  };

	  // Partially apply a function by creating a version that has had some of its
	  // arguments pre-filled, without changing its dynamic `this` context. _ acts
	  // as a placeholder, allowing any combination of arguments to be pre-filled.
	  _.partial = function(func) {
	    var boundArgs = slice.call(arguments, 1);
	    var bound = function() {
	      var position = 0, length = boundArgs.length;
	      var args = Array(length);
	      for (var i = 0; i < length; i++) {
	        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
	      }
	      while (position < arguments.length) args.push(arguments[position++]);
	      return executeBound(func, bound, this, this, args);
	    };
	    return bound;
	  };

	  // Bind a number of an object's methods to that object. Remaining arguments
	  // are the method names to be bound. Useful for ensuring that all callbacks
	  // defined on an object belong to it.
	  _.bindAll = function(obj) {
	    var i, length = arguments.length, key;
	    if (length <= 1) throw new Error('bindAll must be passed function names');
	    for (i = 1; i < length; i++) {
	      key = arguments[i];
	      obj[key] = _.bind(obj[key], obj);
	    }
	    return obj;
	  };

	  // Memoize an expensive function by storing its results.
	  _.memoize = function(func, hasher) {
	    var memoize = function(key) {
	      var cache = memoize.cache;
	      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
	      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
	      return cache[address];
	    };
	    memoize.cache = {};
	    return memoize;
	  };

	  // Delays a function for the given number of milliseconds, and then calls
	  // it with the arguments supplied.
	  _.delay = function(func, wait) {
	    var args = slice.call(arguments, 2);
	    return setTimeout(function(){
	      return func.apply(null, args);
	    }, wait);
	  };

	  // Defers a function, scheduling it to run after the current call stack has
	  // cleared.
	  _.defer = _.partial(_.delay, _, 1);

	  // Returns a function, that, when invoked, will only be triggered at most once
	  // during a given window of time. Normally, the throttled function will run
	  // as much as it can, without ever going more than once per `wait` duration;
	  // but if you'd like to disable the execution on the leading edge, pass
	  // `{leading: false}`. To disable execution on the trailing edge, ditto.
	  _.throttle = function(func, wait, options) {
	    var context, args, result;
	    var timeout = null;
	    var previous = 0;
	    if (!options) options = {};
	    var later = function() {
	      previous = options.leading === false ? 0 : _.now();
	      timeout = null;
	      result = func.apply(context, args);
	      if (!timeout) context = args = null;
	    };
	    return function() {
	      var now = _.now();
	      if (!previous && options.leading === false) previous = now;
	      var remaining = wait - (now - previous);
	      context = this;
	      args = arguments;
	      if (remaining <= 0 || remaining > wait) {
	        if (timeout) {
	          clearTimeout(timeout);
	          timeout = null;
	        }
	        previous = now;
	        result = func.apply(context, args);
	        if (!timeout) context = args = null;
	      } else if (!timeout && options.trailing !== false) {
	        timeout = setTimeout(later, remaining);
	      }
	      return result;
	    };
	  };

	  // Returns a function, that, as long as it continues to be invoked, will not
	  // be triggered. The function will be called after it stops being called for
	  // N milliseconds. If `immediate` is passed, trigger the function on the
	  // leading edge, instead of the trailing.
	  _.debounce = function(func, wait, immediate) {
	    var timeout, args, context, timestamp, result;

	    var later = function() {
	      var last = _.now() - timestamp;

	      if (last < wait && last >= 0) {
	        timeout = setTimeout(later, wait - last);
	      } else {
	        timeout = null;
	        if (!immediate) {
	          result = func.apply(context, args);
	          if (!timeout) context = args = null;
	        }
	      }
	    };

	    return function() {
	      context = this;
	      args = arguments;
	      timestamp = _.now();
	      var callNow = immediate && !timeout;
	      if (!timeout) timeout = setTimeout(later, wait);
	      if (callNow) {
	        result = func.apply(context, args);
	        context = args = null;
	      }

	      return result;
	    };
	  };

	  // Returns the first function passed as an argument to the second,
	  // allowing you to adjust arguments, run code before and after, and
	  // conditionally execute the original function.
	  _.wrap = function(func, wrapper) {
	    return _.partial(wrapper, func);
	  };

	  // Returns a negated version of the passed-in predicate.
	  _.negate = function(predicate) {
	    return function() {
	      return !predicate.apply(this, arguments);
	    };
	  };

	  // Returns a function that is the composition of a list of functions, each
	  // consuming the return value of the function that follows.
	  _.compose = function() {
	    var args = arguments;
	    var start = args.length - 1;
	    return function() {
	      var i = start;
	      var result = args[start].apply(this, arguments);
	      while (i--) result = args[i].call(this, result);
	      return result;
	    };
	  };

	  // Returns a function that will only be executed on and after the Nth call.
	  _.after = function(times, func) {
	    return function() {
	      if (--times < 1) {
	        return func.apply(this, arguments);
	      }
	    };
	  };

	  // Returns a function that will only be executed up to (but not including) the Nth call.
	  _.before = function(times, func) {
	    var memo;
	    return function() {
	      if (--times > 0) {
	        memo = func.apply(this, arguments);
	      }
	      if (times <= 1) func = null;
	      return memo;
	    };
	  };

	  // Returns a function that will be executed at most one time, no matter how
	  // often you call it. Useful for lazy initialization.
	  _.once = _.partial(_.before, 2);

	  // Object Functions
	  // ----------------

	  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
	  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
	  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
	                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

	  function collectNonEnumProps(obj, keys) {
	    var nonEnumIdx = nonEnumerableProps.length;
	    var constructor = obj.constructor;
	    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

	    // Constructor is a special case.
	    var prop = 'constructor';
	    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

	    while (nonEnumIdx--) {
	      prop = nonEnumerableProps[nonEnumIdx];
	      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
	        keys.push(prop);
	      }
	    }
	  }

	  // Retrieve the names of an object's own properties.
	  // Delegates to **ECMAScript 5**'s native `Object.keys`
	  _.keys = function(obj) {
	    if (!_.isObject(obj)) return [];
	    if (nativeKeys) return nativeKeys(obj);
	    var keys = [];
	    for (var key in obj) if (_.has(obj, key)) keys.push(key);
	    // Ahem, IE < 9.
	    if (hasEnumBug) collectNonEnumProps(obj, keys);
	    return keys;
	  };

	  // Retrieve all the property names of an object.
	  _.allKeys = function(obj) {
	    if (!_.isObject(obj)) return [];
	    var keys = [];
	    for (var key in obj) keys.push(key);
	    // Ahem, IE < 9.
	    if (hasEnumBug) collectNonEnumProps(obj, keys);
	    return keys;
	  };

	  // Retrieve the values of an object's properties.
	  _.values = function(obj) {
	    var keys = _.keys(obj);
	    var length = keys.length;
	    var values = Array(length);
	    for (var i = 0; i < length; i++) {
	      values[i] = obj[keys[i]];
	    }
	    return values;
	  };

	  // Returns the results of applying the iteratee to each element of the object
	  // In contrast to _.map it returns an object
	  _.mapObject = function(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    var keys =  _.keys(obj),
	          length = keys.length,
	          results = {},
	          currentKey;
	      for (var index = 0; index < length; index++) {
	        currentKey = keys[index];
	        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
	      }
	      return results;
	  };

	  // Convert an object into a list of `[key, value]` pairs.
	  _.pairs = function(obj) {
	    var keys = _.keys(obj);
	    var length = keys.length;
	    var pairs = Array(length);
	    for (var i = 0; i < length; i++) {
	      pairs[i] = [keys[i], obj[keys[i]]];
	    }
	    return pairs;
	  };

	  // Invert the keys and values of an object. The values must be serializable.
	  _.invert = function(obj) {
	    var result = {};
	    var keys = _.keys(obj);
	    for (var i = 0, length = keys.length; i < length; i++) {
	      result[obj[keys[i]]] = keys[i];
	    }
	    return result;
	  };

	  // Return a sorted list of the function names available on the object.
	  // Aliased as `methods`
	  _.functions = _.methods = function(obj) {
	    var names = [];
	    for (var key in obj) {
	      if (_.isFunction(obj[key])) names.push(key);
	    }
	    return names.sort();
	  };

	  // Extend a given object with all the properties in passed-in object(s).
	  _.extend = createAssigner(_.allKeys);

	  // Assigns a given object with all the own properties in the passed-in object(s)
	  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
	  _.extendOwn = _.assign = createAssigner(_.keys);

	  // Returns the first key on an object that passes a predicate test
	  _.findKey = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = _.keys(obj), key;
	    for (var i = 0, length = keys.length; i < length; i++) {
	      key = keys[i];
	      if (predicate(obj[key], key, obj)) return key;
	    }
	  };

	  // Return a copy of the object only containing the whitelisted properties.
	  _.pick = function(object, oiteratee, context) {
	    var result = {}, obj = object, iteratee, keys;
	    if (obj == null) return result;
	    if (_.isFunction(oiteratee)) {
	      keys = _.allKeys(obj);
	      iteratee = optimizeCb(oiteratee, context);
	    } else {
	      keys = flatten(arguments, false, false, 1);
	      iteratee = function(value, key, obj) { return key in obj; };
	      obj = Object(obj);
	    }
	    for (var i = 0, length = keys.length; i < length; i++) {
	      var key = keys[i];
	      var value = obj[key];
	      if (iteratee(value, key, obj)) result[key] = value;
	    }
	    return result;
	  };

	   // Return a copy of the object without the blacklisted properties.
	  _.omit = function(obj, iteratee, context) {
	    if (_.isFunction(iteratee)) {
	      iteratee = _.negate(iteratee);
	    } else {
	      var keys = _.map(flatten(arguments, false, false, 1), String);
	      iteratee = function(value, key) {
	        return !_.contains(keys, key);
	      };
	    }
	    return _.pick(obj, iteratee, context);
	  };

	  // Fill in a given object with default properties.
	  _.defaults = createAssigner(_.allKeys, true);

	  // Creates an object that inherits from the given prototype object.
	  // If additional properties are provided then they will be added to the
	  // created object.
	  _.create = function(prototype, props) {
	    var result = baseCreate(prototype);
	    if (props) _.extendOwn(result, props);
	    return result;
	  };

	  // Create a (shallow-cloned) duplicate of an object.
	  _.clone = function(obj) {
	    if (!_.isObject(obj)) return obj;
	    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
	  };

	  // Invokes interceptor with the obj, and then returns obj.
	  // The primary purpose of this method is to "tap into" a method chain, in
	  // order to perform operations on intermediate results within the chain.
	  _.tap = function(obj, interceptor) {
	    interceptor(obj);
	    return obj;
	  };

	  // Returns whether an object has a given set of `key:value` pairs.
	  _.isMatch = function(object, attrs) {
	    var keys = _.keys(attrs), length = keys.length;
	    if (object == null) return !length;
	    var obj = Object(object);
	    for (var i = 0; i < length; i++) {
	      var key = keys[i];
	      if (attrs[key] !== obj[key] || !(key in obj)) return false;
	    }
	    return true;
	  };


	  // Internal recursive comparison function for `isEqual`.
	  var eq = function(a, b, aStack, bStack) {
	    // Identical objects are equal. `0 === -0`, but they aren't identical.
	    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
	    if (a === b) return a !== 0 || 1 / a === 1 / b;
	    // A strict comparison is necessary because `null == undefined`.
	    if (a == null || b == null) return a === b;
	    // Unwrap any wrapped objects.
	    if (a instanceof _) a = a._wrapped;
	    if (b instanceof _) b = b._wrapped;
	    // Compare `[[Class]]` names.
	    var className = toString.call(a);
	    if (className !== toString.call(b)) return false;
	    switch (className) {
	      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
	      case '[object RegExp]':
	      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
	      case '[object String]':
	        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
	        // equivalent to `new String("5")`.
	        return '' + a === '' + b;
	      case '[object Number]':
	        // `NaN`s are equivalent, but non-reflexive.
	        // Object(NaN) is equivalent to NaN
	        if (+a !== +a) return +b !== +b;
	        // An `egal` comparison is performed for other numeric values.
	        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
	      case '[object Date]':
	      case '[object Boolean]':
	        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
	        // millisecond representations. Note that invalid dates with millisecond representations
	        // of `NaN` are not equivalent.
	        return +a === +b;
	    }

	    var areArrays = className === '[object Array]';
	    if (!areArrays) {
	      if (typeof a != 'object' || typeof b != 'object') return false;

	      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
	      // from different frames are.
	      var aCtor = a.constructor, bCtor = b.constructor;
	      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
	                               _.isFunction(bCtor) && bCtor instanceof bCtor)
	                          && ('constructor' in a && 'constructor' in b)) {
	        return false;
	      }
	    }
	    // Assume equality for cyclic structures. The algorithm for detecting cyclic
	    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

	    // Initializing stack of traversed objects.
	    // It's done here since we only need them for objects and arrays comparison.
	    aStack = aStack || [];
	    bStack = bStack || [];
	    var length = aStack.length;
	    while (length--) {
	      // Linear search. Performance is inversely proportional to the number of
	      // unique nested structures.
	      if (aStack[length] === a) return bStack[length] === b;
	    }

	    // Add the first object to the stack of traversed objects.
	    aStack.push(a);
	    bStack.push(b);

	    // Recursively compare objects and arrays.
	    if (areArrays) {
	      // Compare array lengths to determine if a deep comparison is necessary.
	      length = a.length;
	      if (length !== b.length) return false;
	      // Deep compare the contents, ignoring non-numeric properties.
	      while (length--) {
	        if (!eq(a[length], b[length], aStack, bStack)) return false;
	      }
	    } else {
	      // Deep compare objects.
	      var keys = _.keys(a), key;
	      length = keys.length;
	      // Ensure that both objects contain the same number of properties before comparing deep equality.
	      if (_.keys(b).length !== length) return false;
	      while (length--) {
	        // Deep compare each member
	        key = keys[length];
	        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
	      }
	    }
	    // Remove the first object from the stack of traversed objects.
	    aStack.pop();
	    bStack.pop();
	    return true;
	  };

	  // Perform a deep comparison to check if two objects are equal.
	  _.isEqual = function(a, b) {
	    return eq(a, b);
	  };

	  // Is a given array, string, or object empty?
	  // An "empty" object has no enumerable own-properties.
	  _.isEmpty = function(obj) {
	    if (obj == null) return true;
	    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
	    return _.keys(obj).length === 0;
	  };

	  // Is a given value a DOM element?
	  _.isElement = function(obj) {
	    return !!(obj && obj.nodeType === 1);
	  };

	  // Is a given value an array?
	  // Delegates to ECMA5's native Array.isArray
	  _.isArray = nativeIsArray || function(obj) {
	    return toString.call(obj) === '[object Array]';
	  };

	  // Is a given variable an object?
	  _.isObject = function(obj) {
	    var type = typeof obj;
	    return type === 'function' || type === 'object' && !!obj;
	  };

	  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
	  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
	    _['is' + name] = function(obj) {
	      return toString.call(obj) === '[object ' + name + ']';
	    };
	  });

	  // Define a fallback version of the method in browsers (ahem, IE < 9), where
	  // there isn't any inspectable "Arguments" type.
	  if (!_.isArguments(arguments)) {
	    _.isArguments = function(obj) {
	      return _.has(obj, 'callee');
	    };
	  }

	  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
	  // IE 11 (#1621), and in Safari 8 (#1929).
	  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
	    _.isFunction = function(obj) {
	      return typeof obj == 'function' || false;
	    };
	  }

	  // Is a given object a finite number?
	  _.isFinite = function(obj) {
	    return isFinite(obj) && !isNaN(parseFloat(obj));
	  };

	  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
	  _.isNaN = function(obj) {
	    return _.isNumber(obj) && obj !== +obj;
	  };

	  // Is a given value a boolean?
	  _.isBoolean = function(obj) {
	    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
	  };

	  // Is a given value equal to null?
	  _.isNull = function(obj) {
	    return obj === null;
	  };

	  // Is a given variable undefined?
	  _.isUndefined = function(obj) {
	    return obj === void 0;
	  };

	  // Shortcut function for checking if an object has a given property directly
	  // on itself (in other words, not on a prototype).
	  _.has = function(obj, key) {
	    return obj != null && hasOwnProperty.call(obj, key);
	  };

	  // Utility Functions
	  // -----------------

	  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
	  // previous owner. Returns a reference to the Underscore object.
	  _.noConflict = function() {
	    root._ = previousUnderscore;
	    return this;
	  };

	  // Keep the identity function around for default iteratees.
	  _.identity = function(value) {
	    return value;
	  };

	  // Predicate-generating functions. Often useful outside of Underscore.
	  _.constant = function(value) {
	    return function() {
	      return value;
	    };
	  };

	  _.noop = function(){};

	  _.property = property;

	  // Generates a function for a given object that returns a given property.
	  _.propertyOf = function(obj) {
	    return obj == null ? function(){} : function(key) {
	      return obj[key];
	    };
	  };

	  // Returns a predicate for checking whether an object has a given set of
	  // `key:value` pairs.
	  _.matcher = _.matches = function(attrs) {
	    attrs = _.extendOwn({}, attrs);
	    return function(obj) {
	      return _.isMatch(obj, attrs);
	    };
	  };

	  // Run a function **n** times.
	  _.times = function(n, iteratee, context) {
	    var accum = Array(Math.max(0, n));
	    iteratee = optimizeCb(iteratee, context, 1);
	    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
	    return accum;
	  };

	  // Return a random integer between min and max (inclusive).
	  _.random = function(min, max) {
	    if (max == null) {
	      max = min;
	      min = 0;
	    }
	    return min + Math.floor(Math.random() * (max - min + 1));
	  };

	  // A (possibly faster) way to get the current timestamp as an integer.
	  _.now = Date.now || function() {
	    return new Date().getTime();
	  };

	   // List of HTML entities for escaping.
	  var escapeMap = {
	    '&': '&amp;',
	    '<': '&lt;',
	    '>': '&gt;',
	    '"': '&quot;',
	    "'": '&#x27;',
	    '`': '&#x60;'
	  };
	  var unescapeMap = _.invert(escapeMap);

	  // Functions for escaping and unescaping strings to/from HTML interpolation.
	  var createEscaper = function(map) {
	    var escaper = function(match) {
	      return map[match];
	    };
	    // Regexes for identifying a key that needs to be escaped
	    var source = '(?:' + _.keys(map).join('|') + ')';
	    var testRegexp = RegExp(source);
	    var replaceRegexp = RegExp(source, 'g');
	    return function(string) {
	      string = string == null ? '' : '' + string;
	      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
	    };
	  };
	  _.escape = createEscaper(escapeMap);
	  _.unescape = createEscaper(unescapeMap);

	  // If the value of the named `property` is a function then invoke it with the
	  // `object` as context; otherwise, return it.
	  _.result = function(object, property, fallback) {
	    var value = object == null ? void 0 : object[property];
	    if (value === void 0) {
	      value = fallback;
	    }
	    return _.isFunction(value) ? value.call(object) : value;
	  };

	  // Generate a unique integer id (unique within the entire client session).
	  // Useful for temporary DOM ids.
	  var idCounter = 0;
	  _.uniqueId = function(prefix) {
	    var id = ++idCounter + '';
	    return prefix ? prefix + id : id;
	  };

	  // By default, Underscore uses ERB-style template delimiters, change the
	  // following template settings to use alternative delimiters.
	  _.templateSettings = {
	    evaluate    : /<%([\s\S]+?)%>/g,
	    interpolate : /<%=([\s\S]+?)%>/g,
	    escape      : /<%-([\s\S]+?)%>/g
	  };

	  // When customizing `templateSettings`, if you don't want to define an
	  // interpolation, evaluation or escaping regex, we need one that is
	  // guaranteed not to match.
	  var noMatch = /(.)^/;

	  // Certain characters need to be escaped so that they can be put into a
	  // string literal.
	  var escapes = {
	    "'":      "'",
	    '\\':     '\\',
	    '\r':     'r',
	    '\n':     'n',
	    '\u2028': 'u2028',
	    '\u2029': 'u2029'
	  };

	  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

	  var escapeChar = function(match) {
	    return '\\' + escapes[match];
	  };

	  // JavaScript micro-templating, similar to John Resig's implementation.
	  // Underscore templating handles arbitrary delimiters, preserves whitespace,
	  // and correctly escapes quotes within interpolated code.
	  // NB: `oldSettings` only exists for backwards compatibility.
	  _.template = function(text, settings, oldSettings) {
	    if (!settings && oldSettings) settings = oldSettings;
	    settings = _.defaults({}, settings, _.templateSettings);

	    // Combine delimiters into one regular expression via alternation.
	    var matcher = RegExp([
	      (settings.escape || noMatch).source,
	      (settings.interpolate || noMatch).source,
	      (settings.evaluate || noMatch).source
	    ].join('|') + '|$', 'g');

	    // Compile the template source, escaping string literals appropriately.
	    var index = 0;
	    var source = "__p+='";
	    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
	      source += text.slice(index, offset).replace(escaper, escapeChar);
	      index = offset + match.length;

	      if (escape) {
	        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
	      } else if (interpolate) {
	        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
	      } else if (evaluate) {
	        source += "';\n" + evaluate + "\n__p+='";
	      }

	      // Adobe VMs need the match returned to produce the correct offest.
	      return match;
	    });
	    source += "';\n";

	    // If a variable is not specified, place data values in local scope.
	    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

	    source = "var __t,__p='',__j=Array.prototype.join," +
	      "print=function(){__p+=__j.call(arguments,'');};\n" +
	      source + 'return __p;\n';

	    try {
	      var render = new Function(settings.variable || 'obj', '_', source);
	    } catch (e) {
	      e.source = source;
	      throw e;
	    }

	    var template = function(data) {
	      return render.call(this, data, _);
	    };

	    // Provide the compiled source as a convenience for precompilation.
	    var argument = settings.variable || 'obj';
	    template.source = 'function(' + argument + '){\n' + source + '}';

	    return template;
	  };

	  // Add a "chain" function. Start chaining a wrapped Underscore object.
	  _.chain = function(obj) {
	    var instance = _(obj);
	    instance._chain = true;
	    return instance;
	  };

	  // OOP
	  // ---------------
	  // If Underscore is called as a function, it returns a wrapped object that
	  // can be used OO-style. This wrapper holds altered versions of all the
	  // underscore functions. Wrapped objects may be chained.

	  // Helper function to continue chaining intermediate results.
	  var result = function(instance, obj) {
	    return instance._chain ? _(obj).chain() : obj;
	  };

	  // Add your own custom functions to the Underscore object.
	  _.mixin = function(obj) {
	    _.each(_.functions(obj), function(name) {
	      var func = _[name] = obj[name];
	      _.prototype[name] = function() {
	        var args = [this._wrapped];
	        push.apply(args, arguments);
	        return result(this, func.apply(_, args));
	      };
	    });
	  };

	  // Add all of the Underscore functions to the wrapper object.
	  _.mixin(_);

	  // Add all mutator Array functions to the wrapper.
	  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
	    var method = ArrayProto[name];
	    _.prototype[name] = function() {
	      var obj = this._wrapped;
	      method.apply(obj, arguments);
	      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
	      return result(this, obj);
	    };
	  });

	  // Add all accessor Array functions to the wrapper.
	  _.each(['concat', 'join', 'slice'], function(name) {
	    var method = ArrayProto[name];
	    _.prototype[name] = function() {
	      return result(this, method.apply(this._wrapped, arguments));
	    };
	  });

	  // Extracts the result from a wrapped and chained object.
	  _.prototype.value = function() {
	    return this._wrapped;
	  };

	  // Provide unwrapping proxy for some methods used in engine operations
	  // such as arithmetic and JSON stringification.
	  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

	  _.prototype.toString = function() {
	    return '' + this._wrapped;
	  };

	  // AMD registration happens at the end for compatibility with AMD loaders
	  // that may not enforce next-turn semantics on modules. Even though general
	  // practice for AMD registration is to be anonymous, underscore registers
	  // as a named module because, like jQuery, it is a base library that is
	  // popular enough to be bundled in a third party lib, but not be part of
	  // an AMD load request. Those cases could generate an error when an
	  // anonymous define() is called outside of a loader request.
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
	      return _;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	}.call(this));


/***/ }
/******/ ])));